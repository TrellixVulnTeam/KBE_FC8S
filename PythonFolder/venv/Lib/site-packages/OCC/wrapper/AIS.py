# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_AIS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_AIS')
    _AIS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_AIS', [dirname(__file__)])
        except ImportError:
            import _AIS
            return _AIS
        try:
            _mod = imp.load_module('_AIS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _AIS = swig_import_helper()
    del swig_import_helper
else:
    import _AIS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _AIS.delete_SwigPyIterator

    def value(self):
        return _AIS.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _AIS.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _AIS.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _AIS.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _AIS.SwigPyIterator_equal(self, x)

    def copy(self):
        return _AIS.SwigPyIterator_copy(self)

    def next(self):
        return _AIS.SwigPyIterator_next(self)

    def __next__(self):
        return _AIS.SwigPyIterator___next__(self)

    def previous(self):
        return _AIS.SwigPyIterator_previous(self)

    def advance(self, n):
        return _AIS.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _AIS.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _AIS.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _AIS.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _AIS.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _AIS.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _AIS.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _AIS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _AIS.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_AIS.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _AIS.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _AIS.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _AIS.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _AIS.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _AIS.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _AIS.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_AIS.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _AIS.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _AIS.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _AIS.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _AIS.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _AIS.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _AIS.ptr_to_number(item)
ptr_to_number = _AIS.ptr_to_number

def HashCode(*args):
    return _AIS.HashCode(*args)
HashCode = _AIS.HashCode

def ptr_equal(a, b):
    return _AIS.ptr_equal(a, b)
ptr_equal = _AIS.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PrsMgr
else:
    import PrsMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import V3d
else:
    import V3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Prs3d
else:
    import Prs3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import DsgPrs
else:
    import DsgPrs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Select3D
else:
    import Select3D
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectBasics
else:
    import SelectBasics
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectMgr
else:
    import SelectMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StdSelect
else:
    import StdSelect
del _swig_python_version_info
AIS_KOS_Plane = _AIS.AIS_KOS_Plane
AIS_KOS_Cylinder = _AIS.AIS_KOS_Cylinder
AIS_KOS_Cone = _AIS.AIS_KOS_Cone
AIS_KOS_Sphere = _AIS.AIS_KOS_Sphere
AIS_KOS_Torus = _AIS.AIS_KOS_Torus
AIS_KOS_Revolution = _AIS.AIS_KOS_Revolution
AIS_KOS_Extrusion = _AIS.AIS_KOS_Extrusion
AIS_KOS_OtherSurface = _AIS.AIS_KOS_OtherSurface
AIS_KOI_None = _AIS.AIS_KOI_None
AIS_KOI_Datum = _AIS.AIS_KOI_Datum
AIS_KOI_Shape = _AIS.AIS_KOI_Shape
AIS_KOI_Object = _AIS.AIS_KOI_Object
AIS_KOI_Relation = _AIS.AIS_KOI_Relation
AIS_KOI_Dimension = _AIS.AIS_KOI_Dimension
AIS_SelectionModesConcurrency_Single = _AIS.AIS_SelectionModesConcurrency_Single
AIS_SelectionModesConcurrency_GlobalOrLocal = _AIS.AIS_SelectionModesConcurrency_GlobalOrLocal
AIS_SelectionModesConcurrency_Multiple = _AIS.AIS_SelectionModesConcurrency_Multiple
AIS_CM_All = _AIS.AIS_CM_All
AIS_CM_Interactive = _AIS.AIS_CM_Interactive
AIS_CM_Filters = _AIS.AIS_CM_Filters
AIS_CM_StandardModes = _AIS.AIS_CM_StandardModes
AIS_CM_TemporaryShapePrs = _AIS.AIS_CM_TemporaryShapePrs
AIS_SOD_Error = _AIS.AIS_SOD_Error
AIS_SOD_Nothing = _AIS.AIS_SOD_Nothing
AIS_SOD_AllBad = _AIS.AIS_SOD_AllBad
AIS_SOD_Selected = _AIS.AIS_SOD_Selected
AIS_SOD_OnlyOneDetected = _AIS.AIS_SOD_OnlyOneDetected
AIS_SOD_OnlyOneGood = _AIS.AIS_SOD_OnlyOneGood
AIS_SOD_SeveralGood = _AIS.AIS_SOD_SeveralGood
AIS_SOP_Error = _AIS.AIS_SOP_Error
AIS_SOP_NothingSelected = _AIS.AIS_SOP_NothingSelected
AIS_SOP_Removed = _AIS.AIS_SOP_Removed
AIS_SOP_OneSelected = _AIS.AIS_SOP_OneSelected
AIS_SOP_SeveralSelected = _AIS.AIS_SOP_SeveralSelected
AIS_SS_Added = _AIS.AIS_SS_Added
AIS_SS_Removed = _AIS.AIS_SS_Removed
AIS_SS_NotDone = _AIS.AIS_SS_NotDone
AIS_DS_Displayed = _AIS.AIS_DS_Displayed
AIS_DS_Erased = _AIS.AIS_DS_Erased
AIS_DS_Temporary = _AIS.AIS_DS_Temporary
AIS_DS_None = _AIS.AIS_DS_None
AIS_WireFrame = _AIS.AIS_WireFrame
AIS_Shaded = _AIS.AIS_Shaded
AIS_TOI_IsoU = _AIS.AIS_TOI_IsoU
AIS_TOI_IsoV = _AIS.AIS_TOI_IsoV
AIS_TOI_Both = _AIS.AIS_TOI_Both
AIS_DSM_All = _AIS.AIS_DSM_All
AIS_DSM_Line = _AIS.AIS_DSM_Line
AIS_DSM_Text = _AIS.AIS_DSM_Text
AIS_DSS_No = _AIS.AIS_DSS_No
AIS_DSS_Before = _AIS.AIS_DSS_Before
AIS_DSS_After = _AIS.AIS_DSS_After
AIS_KOD_NONE = _AIS.AIS_KOD_NONE
AIS_KOD_LENGTH = _AIS.AIS_KOD_LENGTH
AIS_KOD_PLANEANGLE = _AIS.AIS_KOD_PLANEANGLE
AIS_KOD_SOLIDANGLE = _AIS.AIS_KOD_SOLIDANGLE
AIS_KOD_AREA = _AIS.AIS_KOD_AREA
AIS_KOD_VOLUME = _AIS.AIS_KOD_VOLUME
AIS_KOD_MASS = _AIS.AIS_KOD_MASS
AIS_KOD_TIME = _AIS.AIS_KOD_TIME
AIS_KOD_RADIUS = _AIS.AIS_KOD_RADIUS
AIS_KOD_DIAMETER = _AIS.AIS_KOD_DIAMETER
AIS_KOD_CHAMF2D = _AIS.AIS_KOD_CHAMF2D
AIS_KOD_CHAMF3D = _AIS.AIS_KOD_CHAMF3D
AIS_KOD_OFFSET = _AIS.AIS_KOD_OFFSET
AIS_KOD_ELLIPSERADIUS = _AIS.AIS_KOD_ELLIPSERADIUS
AIS_TOA_Interior = _AIS.AIS_TOA_Interior
AIS_TOA_Exterior = _AIS.AIS_TOA_Exterior
AIS_TOAV_Both = _AIS.AIS_TOAV_Both
AIS_TOAV_First = _AIS.AIS_TOAV_First
AIS_TOAV_Second = _AIS.AIS_TOAV_Second
AIS_TOAV_None = _AIS.AIS_TOAV_None
AIS_TOAX_Unknown = _AIS.AIS_TOAX_Unknown
AIS_TOAX_XAxis = _AIS.AIS_TOAX_XAxis
AIS_TOAX_YAxis = _AIS.AIS_TOAX_YAxis
AIS_TOAX_ZAxis = _AIS.AIS_TOAX_ZAxis
AIS_CS_None = _AIS.AIS_CS_None
AIS_CS_Connection = _AIS.AIS_CS_Connection
AIS_CS_Transform = _AIS.AIS_CS_Transform
AIS_CS_Both = _AIS.AIS_CS_Both
AIS_TOD_Unknown = _AIS.AIS_TOD_Unknown
AIS_TOD_Horizontal = _AIS.AIS_TOD_Horizontal
AIS_TOD_Vertical = _AIS.AIS_TOD_Vertical
AIS_TOA_Line = _AIS.AIS_TOA_Line
AIS_TOA_Dimension = _AIS.AIS_TOA_Dimension
AIS_TOA_Wire = _AIS.AIS_TOA_Wire
AIS_TOA_Plane = _AIS.AIS_TOA_Plane
AIS_TOA_Vector = _AIS.AIS_TOA_Vector
AIS_TOA_UIso = _AIS.AIS_TOA_UIso
AIS_TOA_VIso = _AIS.AIS_TOA_VIso
AIS_TOA_Free = _AIS.AIS_TOA_Free
AIS_TOA_UnFree = _AIS.AIS_TOA_UnFree
AIS_TOA_Section = _AIS.AIS_TOA_Section
AIS_TOA_Hidden = _AIS.AIS_TOA_Hidden
AIS_TOA_Seen = _AIS.AIS_TOA_Seen
AIS_TOA_FirstAxis = _AIS.AIS_TOA_FirstAxis
AIS_TOA_SecondAxis = _AIS.AIS_TOA_SecondAxis
AIS_TOA_ThirdAxis = _AIS.AIS_TOA_ThirdAxis
AIS_KOR_NONE = _AIS.AIS_KOR_NONE
AIS_KOR_CONCENTRIC = _AIS.AIS_KOR_CONCENTRIC
AIS_KOR_EQUALDISTANCE = _AIS.AIS_KOR_EQUALDISTANCE
AIS_KOR_EQUALRADIUS = _AIS.AIS_KOR_EQUALRADIUS
AIS_KOR_FIX = _AIS.AIS_KOR_FIX
AIS_KOR_IDENTIC = _AIS.AIS_KOR_IDENTIC
AIS_KOR_OFFSET = _AIS.AIS_KOR_OFFSET
AIS_KOR_PARALLEL = _AIS.AIS_KOR_PARALLEL
AIS_KOR_PERPENDICULAR = _AIS.AIS_KOR_PERPENDICULAR
AIS_KOR_TANGENT = _AIS.AIS_KOR_TANGENT
AIS_KOR_SYMMETRIC = _AIS.AIS_KOR_SYMMETRIC
AIS_TOU_LENGTH = _AIS.AIS_TOU_LENGTH
AIS_TOU_SURFACE = _AIS.AIS_TOU_SURFACE
AIS_TOU_VOLUME = _AIS.AIS_TOU_VOLUME
AIS_TOU_PLANE_ANGLE = _AIS.AIS_TOU_PLANE_ANGLE
AIS_TOU_SOLID_ANGLE = _AIS.AIS_TOU_SOLID_ANGLE
AIS_TOU_MASS = _AIS.AIS_TOU_MASS
AIS_TOU_FORCE = _AIS.AIS_TOU_FORCE
AIS_TOU_TIME = _AIS.AIS_TOU_TIME
AIS_MM_None = _AIS.AIS_MM_None
AIS_MM_Translation = _AIS.AIS_MM_Translation
AIS_MM_Rotation = _AIS.AIS_MM_Rotation
AIS_MM_Scaling = _AIS.AIS_MM_Scaling
AIS_TOPL_Unknown = _AIS.AIS_TOPL_Unknown
AIS_TOPL_XYPlane = _AIS.AIS_TOPL_XYPlane
AIS_TOPL_XZPlane = _AIS.AIS_TOPL_XZPlane
AIS_TOPL_YZPlane = _AIS.AIS_TOPL_YZPlane
AIS_SD_None = _AIS.AIS_SD_None
AIS_SD_Point = _AIS.AIS_SD_Point
AIS_SD_Axis = _AIS.AIS_SD_Axis
AIS_SD_Trihedron = _AIS.AIS_SD_Trihedron
AIS_SD_PlaneTrihedron = _AIS.AIS_SD_PlaneTrihedron
AIS_SD_Line = _AIS.AIS_SD_Line
AIS_SD_Circle = _AIS.AIS_SD_Circle
AIS_SD_Plane = _AIS.AIS_SD_Plane
AIS_TrihedronSelectionMode_EntireObject = _AIS.AIS_TrihedronSelectionMode_EntireObject
AIS_TrihedronSelectionMode_Origin = _AIS.AIS_TrihedronSelectionMode_Origin
AIS_TrihedronSelectionMode_Axes = _AIS.AIS_TrihedronSelectionMode_Axes
AIS_TrihedronSelectionMode_MainPlanes = _AIS.AIS_TrihedronSelectionMode_MainPlanes
class AIS_InteractiveObject(SelectMgr.SelectMgr_SelectableObject):
    """
    Defines a class of objects with display and selection services.
    Entities which are visualized and selected are
    Interactive Objects. You can make use of classes of
    standard Interactive Objects for which all necessary
    methods have already been programmed, or you can
    implement your own classes of Interactive Objects.
    Specific attributes of entities such as arrow aspect for
    dimensions must be loaded in a Drawer. This Drawer
    is then applied to the Interactive Object in view.
    There are four types of Interactive Object in AIS: the
    construction element or Datum, the Relation, which
    includes both dimensions and constraints, the Object,
    and finally, when the object is of an unknown type, the None type.
    Inside these categories, a signature, or index,
    provides the possibility of additional characterization.
    By default, the Interactive Object has a None type
    and a signature of 0. If you want to give a particular
    type and signature to your interactive object, you must
    redefine the methods, Signature and Type.
    Warning
    In the case of attribute methods, methods for
    standard attributes are virtual. They must be
    redefined   by the inheriting classes. Setcolor for a
    point and Setcolor for a plane, for example, do not
    affect the same attributes in the Drawer.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_InteractiveObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_InteractiveObject(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_InteractiveObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_InteractiveObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_InteractiveObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(AIS_InteractiveObject self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_InteractiveObject_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_InteractiveObject self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveObject_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(AIS_InteractiveObject self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(AIS_InteractiveObject self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.AIS_InteractiveObject_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(AIS_InteractiveObject self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.AIS_InteractiveObject_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_InteractiveObject self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_InteractiveObject_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_InteractiveObject self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.AIS_InteractiveObject_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_InteractiveObject self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.AIS_InteractiveObject_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(AIS_InteractiveObject self)"""
        return _AIS.AIS_InteractiveObject_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_InteractiveObject self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(AIS_InteractiveObject self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveObject_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(AIS_InteractiveObject self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.AIS_InteractiveObject_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(AIS_InteractiveObject self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.AIS_InteractiveObject_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(AIS_InteractiveObject self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(AIS_InteractiveObject self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.AIS_InteractiveObject_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(AIS_InteractiveObject self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.AIS_InteractiveObject_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.AIS_InteractiveObject_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(AIS_InteractiveObject self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.AIS_InteractiveObject_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(AIS_InteractiveObject self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.AIS_InteractiveObject_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(AIS_InteractiveObject self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.AIS_InteractiveObject_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(AIS_InteractiveObject self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.AIS_InteractiveObject_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(AIS_InteractiveObject self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveObject_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(AIS_InteractiveObject self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveObject_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(AIS_InteractiveObject self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.AIS_InteractiveObject_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(AIS_InteractiveObject self)

        Unsets highlight display mode.


        """
        return _AIS.AIS_InteractiveObject_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(AIS_InteractiveObject self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_InteractiveObject_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(AIS_InteractiveObject self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveObject_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(AIS_InteractiveObject self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.AIS_InteractiveObject_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(AIS_InteractiveObject self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.AIS_InteractiveObject_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(AIS_InteractiveObject self)

        Removes the setting for material.


        """
        return _AIS.AIS_InteractiveObject_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(AIS_InteractiveObject self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.AIS_InteractiveObject_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(AIS_InteractiveObject self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveObject_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(AIS_InteractiveObject self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.AIS_InteractiveObject_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(AIS_InteractiveObject self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.AIS_InteractiveObject_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(AIS_InteractiveObject self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(AIS_InteractiveObject self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_InteractiveObject_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(AIS_InteractiveObject self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.AIS_InteractiveObject_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(AIS_InteractiveObject self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.AIS_InteractiveObject_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(AIS_InteractiveObject self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveObject_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(AIS_InteractiveObject self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.AIS_InteractiveObject_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(AIS_InteractiveObject self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.AIS_InteractiveObject_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(AIS_InteractiveObject self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.AIS_InteractiveObject_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(AIS_InteractiveObject self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.AIS_InteractiveObject_SynchronizeAspects(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_InteractiveObject
AIS_InteractiveObject_swigregister = _AIS.AIS_InteractiveObject_swigregister
AIS_InteractiveObject_swigregister(AIS_InteractiveObject)

def AIS_InteractiveObject_get_type_name(*args):
    """
    AIS_InteractiveObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_InteractiveObject_get_type_name(*args)

def AIS_InteractiveObject_get_type_descriptor(*args):
    """
    AIS_InteractiveObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_InteractiveObject_get_type_descriptor(*args)

class AIS_TypeFilter(SelectMgr.SelectMgr_Filter):
    """
    Selects Interactive Objects through their types. The
    filter questions each Interactive Object in local context
    to determine whether it has an non-null owner, and if
    so, whether it is of the desired type. If the object
    returns true in each case, it is kept. If not, it is rejected.
    By default, the   interactive object has a None   type
    and a signature of 0. A filter for type specifies a
    choice of type out of a range at any level enumerated
    for type or kind. The choice could be for kind of
    interactive object, of dimension, of unit, or type of axis,
    plane or attribute.
    If you want to give a particular type and signature to
    your Interactive Object, you must redefine two virtual
    methods:   Type and Signature.
    This filter is used in both Neutral Point and open local contexts.
    In the Collector viewer, you can only locate
    Interactive Objects which answer positively to the
    positioned filters when a local context is open.
    Warning
    When you close a local context, all temporary
    interactive objects are deleted, all selection modes
    concerning the context are cancelled, and all content
    filters are emptied.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_TypeFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_TypeFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_TypeFilter self, AIS_KindOfInteractive const aGivenKind) -> AIS_TypeFilter

        Initializes filter for type, aGivenKind.

        :type aGivenKind: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        this = _AIS.new_AIS_TypeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsOk(self, *args):
        """
        IsOk(AIS_TypeFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        Returns False if the transient is not an Interactive
        Object, or if the type of the Interactive Object is not
        the same as that stored in the filter.

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TypeFilter_IsOk(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_TypeFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_TypeFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_TypeFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_TypeFilter
AIS_TypeFilter_swigregister = _AIS.AIS_TypeFilter_swigregister
AIS_TypeFilter_swigregister(AIS_TypeFilter)

def AIS_TypeFilter_get_type_name(*args):
    """
    AIS_TypeFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_TypeFilter_get_type_name(*args)

def AIS_TypeFilter_get_type_descriptor(*args):
    """
    AIS_TypeFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_TypeFilter_get_type_descriptor(*args)

class AIS_Relation(AIS_InteractiveObject):
    """
    One of the four types of interactive object in
    AIS,comprising dimensions and constraints. Serves
    as the abstract class for the seven relation classes as
    well as the seven dimension classes.
    The statuses available for relations between shapes are as follows:
    -   0 - there is no connection to a shape;
    -   1 - there is a connection to the first shape;
    -   2 - there is a connection to the second shape.
    The connection takes the form of an edge between the two shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Relation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Relation(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Relation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Relation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Relation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(AIS_Relation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Relation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Relation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.AIS_Relation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Relation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Relation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(AIS_Relation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.AIS_Relation_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(AIS_Relation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Relation_IsMovable(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_Relation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(AIS_Relation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_Relation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_Relation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(AIS_Relation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_Relation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(AIS_Relation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.AIS_Relation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(AIS_Relation self)"""
        return _AIS.AIS_Relation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.AIS_Relation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(AIS_Relation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.AIS_Relation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(AIS_Relation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Relation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(AIS_Relation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.AIS_Relation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_Relation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(AIS_Relation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_Relation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.AIS_Relation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(AIS_Relation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.AIS_Relation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(AIS_Relation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Relation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(AIS_Relation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.AIS_Relation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(AIS_Relation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.AIS_Relation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(AIS_Relation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.AIS_Relation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(AIS_Relation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.AIS_Relation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(AIS_Relation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Relation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_Relation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Relation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(AIS_Relation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.AIS_Relation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(AIS_Relation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Relation_AutomaticPosition(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Relation
AIS_Relation_swigregister = _AIS.AIS_Relation_swigregister
AIS_Relation_swigregister(AIS_Relation)

def AIS_Relation_get_type_name(*args):
    """
    AIS_Relation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Relation_get_type_name(*args)

def AIS_Relation_get_type_descriptor(*args):
    """
    AIS_Relation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Relation_get_type_descriptor(*args)

class AIS_Shape(AIS_InteractiveObject):
    """
    A framework to manage presentation and selection of shapes.
    AIS_Shape is the interactive object which is used the
    most by   applications. There are standard functions
    available which allow you to prepare selection
    operations on the constituent elements of shapes -
    vertices, edges, faces etc - in an open local context.
    The selection modes specific to "Shape" type objects
    are referred to as Standard Activation Mode. These
    modes are only taken into account in open local
    context and only act on Interactive Objects which
    have redefined the virtual method
    AcceptShapeDecomposition so that it returns true.
    Several advanced functions are also available. These
    include functions to manage deviation angle and
    deviation coefficient - both HLR and non-HLR - of
    an inheriting shape class. These services allow you to
    select one type of shape interactive object for higher
    precision drawing. When you do this, the
    Prs3d_Drawer::IsOwn... functions corresponding to the
    above deviation angle and coefficient functions return
    true indicating that there is a local setting available
    for the specific object.

    This class allows to map textures on shapes using native UV parametric space of underlying surface of each Face
    (this means that texture will be visually duplicated on all Faces).
    To generate texture coordinates, appropriate shading attribute should be set before computing presentation in AIS_Shaded display mode:
    @code
    Handle(AIS_Shape) aPrs = new AIS_Shape();
    aPrs->Attributes()->SetShadingAspect (new Prs3d_ShadingAspect());
    aPrs->Attributes()->ShadingAspect()->Aspect()->SetTextureMapOn();
    aPrs->Attributes()->ShadingAspect()->Aspect()->SetTextureMap (new Graphic3d_Texture2Dmanual (Graphic3d_NOT_2D_ALUMINUM));
    @endcode
    The texture itself is parametrized in (0,1)x(0,1).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Shape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Shape(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Shape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Shape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Shape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Shape self, TopoDS_Shape shap) -> AIS_Shape

        Initializes construction of the shape shap from wires,
        edges and vertices.

        :type shap: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _AIS.new_AIS_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Signature(self, *args):
        """
        Signature(AIS_Shape self) -> Standard_Integer

        Returns index 0. This value refers to SHAPE from TopAbs_ShapeEnum

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Shape_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Shape self) -> AIS_KindOfInteractive

        Returns Object as the type of Interactive Object.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Shape_Type(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(AIS_Shape self) -> Standard_Boolean

        Returns true if the Interactive Object accepts shape decomposition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Shape_AcceptShapeDecomposition(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_Shape self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if specified display mode is supported.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Shape_AcceptDisplayMode(self, *args)


    def Shape(self, *args):
        """
        Returns this shape object.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_Shape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape(self, *args):
        """
        SetShape(AIS_Shape self, TopoDS_Shape theShape)

        Constructs an instance of the shape object theShape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_Shape_SetShape(self, *args)


    def Set(self, *args):
        """
        Set(AIS_Shape self, TopoDS_Shape theShape)

        Alias for ::SetShape().

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_Shape_Set(self, *args)


    def SetOwnDeviationCoefficient(self, *args):
        """
        SetOwnDeviationCoefficient(AIS_Shape self) -> Standard_Boolean
        SetOwnDeviationCoefficient(AIS_Shape self, Standard_Real const aCoefficient)

        Sets a local value for deviation coefficient for this specific shape.

        :type aCoefficient: float

        """
        return _AIS.AIS_Shape_SetOwnDeviationCoefficient(self, *args)


    def SetOwnHLRDeviationCoefficient(self, *args):
        """
        SetOwnHLRDeviationCoefficient(AIS_Shape self) -> Standard_Boolean
        SetOwnHLRDeviationCoefficient(AIS_Shape self, Standard_Real const aCoefficient)

        sets myOwnHLRDeviationCoefficient field in Prs3d_Drawer &
        recomputes presentation

        :type aCoefficient: float

        """
        return _AIS.AIS_Shape_SetOwnHLRDeviationCoefficient(self, *args)


    def SetAngleAndDeviation(self, *args):
        """
        SetAngleAndDeviation(AIS_Shape self, Standard_Real const anAngle)

        this compute a new angle and Deviation from the value anAngle
        and set the values stored in myDrawer with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.AIS_Shape_SetAngleAndDeviation(self, *args)


    def UserAngle(self, *args):
        """
        UserAngle(AIS_Shape self) -> Standard_Real

        gives back the angle initial value put by the User.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Shape_UserAngle(self, *args)


    def SetOwnDeviationAngle(self, *args):
        """
        SetOwnDeviationAngle(AIS_Shape self) -> Standard_Boolean
        SetOwnDeviationAngle(AIS_Shape self, Standard_Real const anAngle)

        sets myOwnDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.AIS_Shape_SetOwnDeviationAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args):
        """
        SetHLRAngleAndDeviation(AIS_Shape self, Standard_Real const anAngle)

        this compute a new Angle and Deviation from the value anAngle for HLR
        and set the values stored in myDrawer for with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.AIS_Shape_SetHLRAngleAndDeviation(self, *args)


    def SetOwnHLRDeviationAngle(self, *args):
        """
        SetOwnHLRDeviationAngle(AIS_Shape self) -> Standard_Boolean
        SetOwnHLRDeviationAngle(AIS_Shape self, Standard_Real const anAngle)

        sets myOwnHLRDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.AIS_Shape_SetOwnHLRDeviationAngle(self, *args)


    def OwnDeviationCoefficient(self, *args):
        """
        OwnDeviationCoefficient(AIS_Shape self) -> Standard_Boolean

        Returns true and the values of the deviation
        coefficient aCoefficient and the previous deviation
        coefficient aPreviousCoefficient. If these values are
        not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Shape_OwnDeviationCoefficient(self, *args)


    def OwnHLRDeviationCoefficient(self, *args):
        """
        OwnHLRDeviationCoefficient(AIS_Shape self) -> Standard_Boolean

        Returns   true and the values of the HLR deviation
        coefficient aCoefficient and the previous HLR
        deviation coefficient aPreviousCoefficient. If these
        values are not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Shape_OwnHLRDeviationCoefficient(self, *args)


    def OwnDeviationAngle(self, *args):
        """
        OwnDeviationAngle(AIS_Shape self) -> Standard_Boolean

        Returns true and the values of the deviation angle
        anAngle and the previous deviation angle aPreviousAngle.
        If these values are not already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Shape_OwnDeviationAngle(self, *args)


    def OwnHLRDeviationAngle(self, *args):
        """
        OwnHLRDeviationAngle(AIS_Shape self) -> Standard_Boolean

        Returns true and the values   of the HLR deviation
        angle anAngle and of the previous HLR deviation
        angle aPreviousAngle. If these values are not
        already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Shape_OwnHLRDeviationAngle(self, *args)


    def SetTypeOfHLR(self, *args):
        """
        SetTypeOfHLR(AIS_Shape self, Prs3d_TypeOfHLR const theTypeOfHLR)

        Sets the type of HLR algorithm used by the shape

        :type theTypeOfHLR: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.AIS_Shape_SetTypeOfHLR(self, *args)


    def TypeOfHLR(self, *args):
        """
        TypeOfHLR(AIS_Shape self) -> Prs3d_TypeOfHLR

        Gets the type of HLR algorithm

        :rtype: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.AIS_Shape_TypeOfHLR(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_Shape self, Quantity_Color theColor)

        Sets the color aColor in the reconstructed
        compound shape. Acts via the Drawer methods below on the appearance of:
        -   free boundaries:
        Prs3d_Drawer_FreeBoundaryAspect,
        -   isos: Prs3d_Drawer_UIsoAspect,
        Prs3dDrawer_VIsoAspect,
        -   shared boundaries:
        Prs3d_Drawer_UnFreeBoundaryAspect,
        -   shading: Prs3d_Drawer_ShadingAspect,
        -   visible line color in hidden line mode:
        Prs3d_Drawer_SeenLineAspect
        -   hidden line color in hidden line mode:
        Prs3d_Drawer_HiddenLineAspect.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Shape_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Shape self)

        Removes settings for color in the reconstructed compound shape.


        """
        return _AIS.AIS_Shape_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_Shape self, Standard_Real const aValue)

        Sets the value aValue for line width in the reconstructed compound shape.
        Changes line aspects for lines-only presentation modes like Wireframe and Bounding Box.
        Doesn't change face boundary line aspect.

        :type aValue: float

        """
        return _AIS.AIS_Shape_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(AIS_Shape self)

        Removes the setting for line width in the reconstructed compound shape.


        """
        return _AIS.AIS_Shape_UnsetWidth(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(AIS_Shape self, Graphic3d_MaterialAspect aName)

        Allows you to provide settings for the material aName
        in the reconstructed compound shape.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.AIS_Shape_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(AIS_Shape self)

        Removes settings for material in the reconstructed compound shape.


        """
        return _AIS.AIS_Shape_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(AIS_Shape self, Standard_Real const aValue=0.6)

        Sets the value aValue for transparency in the reconstructed compound shape.

        :type aValue: float

        """
        return _AIS.AIS_Shape_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(AIS_Shape self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _AIS.AIS_Shape_UnsetTransparency(self, *args)


    def Color(self, *args):
        """
        Color(AIS_Shape self, Quantity_Color aColor)

        Returns the Color attributes of the shape accordingly to
        the current facing model;

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Shape_Color(self, *args)


    def Material(self, *args):
        """
        Material(AIS_Shape self) -> Graphic3d_NameOfMaterial

        Returns the NameOfMaterial attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.AIS_Shape_Material(self, *args)


    def Transparency(self, *args):
        """
        Transparency(AIS_Shape self) -> Standard_Real

        Returns the transparency attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Shape_Transparency(self, *args)


    def SelectionType(*args):
        """
        SelectionType(Standard_Integer const theSelMode) -> TopAbs_ShapeEnum

        Return shape type for specified selection mode.

        :type theSelMode: int
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.AIS_Shape_SelectionType(*args)

    SelectionType = staticmethod(SelectionType)

    def SelectionMode(*args):
        """
        SelectionMode(TopAbs_ShapeEnum const theShapeType) -> Standard_Integer

        Return selection mode for specified shape type.

        :type theShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Shape_SelectionMode(*args)

    SelectionMode = staticmethod(SelectionMode)

    def TextureRepeatUV(self, *args):
        """
        Return texture repeat UV values; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.AIS_Shape_TextureRepeatUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureRepeatUV(self, *args):
        """
        SetTextureRepeatUV(AIS_Shape self, gp_Pnt2d theRepeatUV)

        Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1).
        Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax).

        :type theRepeatUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.AIS_Shape_SetTextureRepeatUV(self, *args)


    def TextureOriginUV(self, *args):
        """
        Return texture origin UV position; (0, 0) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.AIS_Shape_TextureOriginUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureOriginUV(self, *args):
        """
        SetTextureOriginUV(AIS_Shape self, gp_Pnt2d theOriginUV)

        Use this method to change the origin of the texture.
        The texel (0,0) will be mapped to the surface (myUVOrigin.X(), myUVOrigin.Y()).

        :type theOriginUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.AIS_Shape_SetTextureOriginUV(self, *args)


    def TextureScaleUV(self, *args):
        """
        Return scale factor for UV coordinates; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.AIS_Shape_TextureScaleUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureScaleUV(self, *args):
        """
        SetTextureScaleUV(AIS_Shape self, gp_Pnt2d theScaleUV)

        Use this method to scale the texture (percent of the face).
        You can specify a scale factor for both U and V.
        Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat,
        the texture will appear twice on the face in each direction.

        :type theScaleUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.AIS_Shape_SetTextureScaleUV(self, *args)


    def computeHlrPresentation(*args):
        """
        computeHlrPresentation(Handle_Prs3d_Projector theProjector, Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

        Compute HLR presentation for specified shape.

        :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.AIS_Shape_computeHlrPresentation(*args)

    computeHlrPresentation = staticmethod(computeHlrPresentation)

    def BoundingBox(self, *args):
        """
        Constructs a bounding box with which to reconstruct
        compound topological shapes for presentation.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _AIS.AIS_Shape_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_Shape
AIS_Shape_swigregister = _AIS.AIS_Shape_swigregister
AIS_Shape_swigregister(AIS_Shape)

def AIS_Shape_get_type_name(*args):
    """
    AIS_Shape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Shape_get_type_name(*args)

def AIS_Shape_get_type_descriptor(*args):
    """
    AIS_Shape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Shape_get_type_descriptor(*args)

def AIS_Shape_SelectionType(*args):
    """
    AIS_Shape_SelectionType(Standard_Integer const theSelMode) -> TopAbs_ShapeEnum

    Return shape type for specified selection mode.

    :type theSelMode: int
    :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

    """
    return _AIS.AIS_Shape_SelectionType(*args)

def AIS_Shape_SelectionMode(*args):
    """
    AIS_Shape_SelectionMode(TopAbs_ShapeEnum const theShapeType) -> Standard_Integer

    Return selection mode for specified shape type.

    :type theShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _AIS.AIS_Shape_SelectionMode(*args)

def AIS_Shape_computeHlrPresentation(*args):
    """
    AIS_Shape_computeHlrPresentation(Handle_Prs3d_Projector theProjector, Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

    Compute HLR presentation for specified shape.

    :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
    :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _AIS.AIS_Shape_computeHlrPresentation(*args)

class AIS_Point(AIS_InteractiveObject):
    """
    Constructs point datums to be used in construction of
    composite shapes. The datum is displayed as the plus marker +.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Point
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Point(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Point_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Point_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Point_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Point self, Handle_Geom_Point aComponent) -> AIS_Point

        Initializes the point aComponent from which the point
        datum will be built.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Point

        """
        this = _AIS.new_AIS_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Signature(self, *args):
        """
        Signature(AIS_Point self) -> Standard_Integer

        Returns index 1, the default index for a point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Point_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Point self) -> AIS_KindOfInteractive

        Indicates that a point is a datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Point_Type(self, *args)


    def Component(self, *args):
        """
        Component(AIS_Point self) -> Handle_Geom_Point

        Returns the component specified in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.AIS_Point_Component(self, *args)


    def SetComponent(self, *args):
        """
        SetComponent(AIS_Point self, Handle_Geom_Point aComponent)

        Constructs an instance of the point aComponent.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.AIS_Point_SetComponent(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_Point self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode selected is valid for point datums.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Point_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_Point self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_Point_Compute(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_Point self, Quantity_Color theColor)

        Allows you to provide settings for the Color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Point_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Point self)

        Allows you to remove color settings.


        """
        return _AIS.AIS_Point_UnsetColor(self, *args)


    def SetMarker(self, *args):
        """
        SetMarker(AIS_Point self, Aspect_TypeOfMarker const aType)

        Allows you to provide settings for a marker. These include
        -   type of marker,
        -   marker color,
        -   scale factor.

        :type aType: OCC.wrapper.Aspect.Aspect_TypeOfMarker

        """
        return _AIS.AIS_Point_SetMarker(self, *args)


    def UnsetMarker(self, *args):
        """
        UnsetMarker(AIS_Point self)

        Removes the marker settings.


        """
        return _AIS.AIS_Point_UnsetMarker(self, *args)


    def HasMarker(self, *args):
        """
        HasMarker(AIS_Point self) -> Standard_Boolean

        Returns true if the point datum has a marker.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Point_HasMarker(self, *args)


    def Vertex(self, *args):
        """
        Vertex(AIS_Point self) -> TopoDS_Vertex

        Converts a point into a vertex.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _AIS.AIS_Point_Vertex(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Point
AIS_Point_swigregister = _AIS.AIS_Point_swigregister
AIS_Point_swigregister(AIS_Point)

def AIS_Point_get_type_name(*args):
    """
    AIS_Point_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Point_get_type_name(*args)

def AIS_Point_get_type_descriptor(*args):
    """
    AIS_Point_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Point_get_type_descriptor(*args)

class AIS_EllipseRadiusDimension(AIS_Relation):
    """
    Computes  geometry  (  basis  curve  and  plane  of  dimension)
    for  input  shape  aShape  from  TopoDS
    Root  class  for MinRadiusDimension  and  MaxRadiusDimension
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_EllipseRadiusDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_EllipseRadiusDimension(self) 
            return h


    def KindOfDimension(self, *args):
        """
        KindOfDimension(AIS_EllipseRadiusDimension self) -> AIS_KindOfDimension

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.AIS_EllipseRadiusDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(AIS_EllipseRadiusDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_EllipseRadiusDimension_IsMovable(self, *args)


    def ComputeGeometry(self, *args):
        """ComputeGeometry(AIS_EllipseRadiusDimension self)"""
        return _AIS.AIS_EllipseRadiusDimension_ComputeGeometry(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_EllipseRadiusDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_EllipseRadiusDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_EllipseRadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_EllipseRadiusDimension
AIS_EllipseRadiusDimension_swigregister = _AIS.AIS_EllipseRadiusDimension_swigregister
AIS_EllipseRadiusDimension_swigregister(AIS_EllipseRadiusDimension)

def AIS_EllipseRadiusDimension_get_type_name(*args):
    """
    AIS_EllipseRadiusDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_EllipseRadiusDimension_get_type_name(*args)

def AIS_EllipseRadiusDimension_get_type_descriptor(*args):
    """
    AIS_EllipseRadiusDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_EllipseRadiusDimension_get_type_descriptor(*args)

class AIS_MultipleConnectedInteractive(AIS_InteractiveObject):
    """
    Defines an Interactive Object by gathering together
    several object presentations. This is done through a
    list of interactive objects. These can also be
    Connected objects. That way memory-costly
    calculations of presentation are avoided.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_MultipleConnectedInteractive
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_MultipleConnectedInteractive(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_MultipleConnectedInteractive_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_MultipleConnectedInteractive_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_MultipleConnectedInteractive_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_MultipleConnectedInteractive self) -> AIS_MultipleConnectedInteractive

        Initializes the Interactive Object with multiple
        connections to AIS_Interactive objects.


        """
        this = _AIS.new_AIS_MultipleConnectedInteractive(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Type(self, *args):
        """
        Type(AIS_MultipleConnectedInteractive self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_MultipleConnectedInteractive_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_MultipleConnectedInteractive self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_MultipleConnectedInteractive_Signature(self, *args)


    def HasConnection(self, *args):
        """
        HasConnection(AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the object is connected to others.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_MultipleConnectedInteractive_HasConnection(self, *args)


    def Disconnect(self, *args):
        """
        Disconnect(AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theInteractive)

        Removes the connection with theInteractive.

        :type theInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_MultipleConnectedInteractive_Disconnect(self, *args)


    def DisconnectAll(self, *args):
        """
        DisconnectAll(AIS_MultipleConnectedInteractive self)

        Clears all the connections to objects.


        """
        return _AIS.AIS_MultipleConnectedInteractive_DisconnectAll(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_MultipleConnectedInteractive self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)
        Compute(AIS_MultipleConnectedInteractive self, Handle_Prs3d_Projector aProjector, Handle_Prs3d_Presentation aPresentation)

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_MultipleConnectedInteractive_Compute(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_MultipleConnectedInteractive_AcceptShapeDecomposition(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.AIS_MultipleConnectedInteractive_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(AIS_MultipleConnectedInteractive self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_MultipleConnectedInteractive_GlobalSelOwner(self, *args)


    def SetContext(self, *args):
        """
        SetContext(AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveContext theCtx)

        Assigns interactive context.

        :type theCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.AIS_MultipleConnectedInteractive_SetContext(self, *args)


    def Connect(self, *args):
        """
        Connect(AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, Handle_Geom_Transformation theLocation, Handle_Graphic3d_TransformPers theTrsfPers) -> Handle_AIS_InteractiveObject
        Connect(AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj) -> Handle_AIS_InteractiveObject
        Connect(AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, gp_Trsf theLocation) -> Handle_AIS_InteractiveObject
        Connect(AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, gp_Trsf theLocation, Handle_Graphic3d_TransformPers theTrsfPers) -> Handle_AIS_InteractiveObject
        Connect(AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theInteractive, gp_Trsf theLocation, Graphic3d_TransModeFlags const & theTrsfPersFlag, gp_Pnt theTrsfPersPoint) -> Handle_AIS_InteractiveObject

        :type theInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLocation: OCC.wrapper.gp.gp_Trsf
        :type theTrsfPersFlag: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type theTrsfPersPoint: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_MultipleConnectedInteractive_Connect(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_MultipleConnectedInteractive
AIS_MultipleConnectedInteractive_swigregister = _AIS.AIS_MultipleConnectedInteractive_swigregister
AIS_MultipleConnectedInteractive_swigregister(AIS_MultipleConnectedInteractive)

def AIS_MultipleConnectedInteractive_get_type_name(*args):
    """
    AIS_MultipleConnectedInteractive_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_MultipleConnectedInteractive_get_type_name(*args)

def AIS_MultipleConnectedInteractive_get_type_descriptor(*args):
    """
    AIS_MultipleConnectedInteractive_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_MultipleConnectedInteractive_get_type_descriptor(*args)

class AIS_Dimension(AIS_InteractiveObject):
    """
    AIS_Dimension is a base class for 2D presentations of linear (length, diameter, radius)
    and angular dimensions.

    The dimensions provide measurement of quantities, such as lengths or plane angles.
    The measurement of dimension "value" is done in model space "as is".
    These "value" are said to be represented in "model units", which can be specified by user.
    During the display the measured value converted from "model units" to "display units".
    The display and model units are stored in common Prs3d_Drawer (drawer of the context)
    to share it between all dimensions.
    The specified by user units are stored in the dimension's drawer.

    As a drawing, the dimension is composed from the following components:
    - Attachment (binding) points. The points where the dimension lines attaches to, for
    length dimensions the distances are measured between these points.
    - Main dimension line. The which extends from the attachment points in "up" direction,
    and which contains text label on it with value string.
    - Flyouts. The lines connecting the attachment points with main dimension line.
    - Extension. The lines used to extend the main dimension line in the cases when text
    or arrows do not fit into the main dimension line due to their size.
    - Arrows.

    <pre>
    Linear dimensions:

    extension
    line                                     arrow
    -->|------- main dimension line -------|<--
    |                                   |
    |flyout                       flyout|
    |                                   |
    +-----------------------------------+
    attachment                                attachment
    point                                       point

    Angular dimensions:

    extension
    line
    -->|+++++
    arrow |     +++
    |        90(deg) - main dimension line
    flyout |         +++
    |           +
    o---flyout---
    center         ^ 
    point          | extension
    line
    </pre>

    Being a 2D drawings, the dimensions are created on imaginary plane, called "dimension plane",
    which can be thought of as reference system of axes (X,Y,N) for constructing the presentation.

    The role of axes of the dimension plane is to guide you through the encapsualted automations
    of presentation building to help you understand how is the presentation will look and how it
    will be oriented in model space during construction.

    Orientation of dimension line in model space relatively to the base shapes is defined 
    with the flyouts. Flyouts specify length of flyout lines and their orientation relatively
    to the attachment points on the working plane.
    For linear dimensions: 
    Direction of flyouts is specified with direction of main dimension line
    (vector from the first attachment to the second attachment) and the normal of the dimension plane.
    Positive direction of flyouts is defined by vector multiplication: AttachVector * PlaneNormal.
    For angular dimensions:
    Flyouts are defined by vectors from the center point to the attachment points.
    These vectors directions are supposed to be the positive directions of flyouts.
    Negative flyouts directions means that these vectors should be reversed
    (and dimension will be built out of the angle constructed with center and two attach points).

    The dimension plane can be constructed automatically by application (where possible,
    it depends on the measured geometry).
    It can be also set by user. However, if the user-defined plane does not fit the
    geometry of the dimension (attach points do not belong to it), the dimension could not
    be built.
    If it is not possible to compute automatic plane (for example, in case of length between 
    two points) the user is supposed to specify the custom plane.

    Since the dimensions feature automated construction procedures from an arbitrary shapes,
    the interfaces to check the validness are also implemented. Once the measured geometry is
    specified, the one can inquire the validness status by calling "IsValid()" method. If the result
    is TRUE, then all of public parameters should be pre-computed and ready. The presentation
    should be also computable. Otherwise, the parameters may return invalid values. In this case,
    the presentation will not be computed and displayed.

    The dimension support two local selection modes: main dimension line selection and text label
    selection. These modes can be used to develop interactive modification of dimension presentations.
    The component highlighting in these selection modes is provided by AIS_DimensionOwner class.
    Please note that selection is unavailable until the presentation is computed.

    The specific drawing attributes are controlled through Prs3d_DimensionAspect. The one can change
    color, arrows, text and arrow style and specify positioning of value label by setting corresponding
    values to the aspect.

    Such set of parameters that consists of:
    - flyout size and direction,
    - user-defined  dimension plane,
    - horizontal and vertical text alignment
    can be uniquely replaced with text position in 3d space. Therefore, there are methods to convert
    this set of parameters to the text position and vice versa:

    - If the fixed text position is defined by user, called SetTextPosition (theTextPos) method converts
    this 3d point to the set of parameters including adjusting of the dimension plane (this plane will be
    automatic plane, NOT user-defined one).
    If the fixed text position is set, the flag myIsFixedTextPosition is set to TRUE.
    ATTENSION! myIsFixedTextPosition fixes all parameters of the set from recomputing inside
    SetMeasureGeometry() methods. Parameters in dimension aspect (they are horizontal text position
    and extension size) are adjusted on presentation computing step, user-defined values in
    dimension aspect are not changed.
    But plane and flyout as dimension position parameters are changed by SetTextPosition() method
    according with user-defined text position.
    If parameters from the set are changed by user with calls of setters, it leads to disabling of
    fixed text position (myIsFixedTextPosition is set to FALSE).
    If the fixed text position is set and geometry is changed by user (SetMeasureGeometry() method
    is called) and the geometry doesn't satisfy computed dimension plane, the dimension is not valid.

    - If the set of parameters was set by user (may be without the user-defined plane or with it),
    it can be converted to the text position by calling the method GetTextPosition(). In this case
    the text position is NOT fixed, and SetMeasureGeometry() without user-defined plane adjusts
    the automatic plane according input geometry (if it is possible).

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Dimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Dimension(self) 
            return h

    ComputeMode_All = _AIS.AIS_Dimension_ComputeMode_All
    ComputeMode_Line = _AIS.AIS_Dimension_ComputeMode_Line
    ComputeMode_Text = _AIS.AIS_Dimension_ComputeMode_Text

    def __init__(self, *args):
        """
        __init__(AIS_Dimension self, AIS_KindOfDimension const theType) -> AIS_Dimension

        Constructor with default parameters values.
        @param theType [in] the type of dimension.

        :type theType: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        this = _AIS.new_AIS_Dimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetValue(self, *args):
        """
        GetValue(AIS_Dimension self) -> Standard_Real

        Gets dimension measurement value. If the value to display is not
        specified by user, then the dimension object is responsible to
        compute it on its own in model space coordinates.
        @return the dimension value (in model units) which is used
        during display of the presentation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Dimension_GetValue(self, *args)


    def SetComputedValue(self, *args):
        """
        SetComputedValue(AIS_Dimension self)

        Sets computed dimension value. Resets custom value mode if it was set.


        """
        return _AIS.AIS_Dimension_SetComputedValue(self, *args)


    def SetCustomValue(self, *args):
        """
        SetCustomValue(AIS_Dimension self, Standard_Real const theValue)
        SetCustomValue(AIS_Dimension self, TCollection_ExtendedString theValue)

        Sets user-defined dimension value.
        Unit conversion during the display is not applyed.
        @param theValue [in] the user-defined value to display.

        :type theValue: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.AIS_Dimension_SetCustomValue(self, *args)


    def GetCustomValue(self, *args):
        """
        Gets user-defined dimension value.
        @return dimension value string.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.AIS_Dimension_GetCustomValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPlane(self, *args):
        """
        Get the dimension plane in which the 2D dimension presentation is computed.
        By default, if plane is not defined by user, it is computed automatically
        after dimension geometry is computed.
        If computed dimension geometry (points) can't be placed on the user-defined
        plane, dimension geometry was set as invalid (validity flag is set to false)
        and dimension presentation will not be computed.
        If user-defined plane allow geometry placement on it, it will be used for
        computing of the dimension presentation.
        @return dimension plane used for presentation computing.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _AIS.AIS_Dimension_GetPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetGeometryType(self, *args):
        """
        GetGeometryType(AIS_Dimension self) -> Standard_Integer

        Geometry type defines type of shapes on which the dimension is to be built. 
        @return type of geometry on which the dimension will be built.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Dimension_GetGeometryType(self, *args)


    def SetCustomPlane(self, *args):
        """
        SetCustomPlane(AIS_Dimension self, gp_Pln thePlane)

        Sets user-defined plane where the 2D dimension presentation will be placed.
        Checks validity of this plane if geometry has been set already.
        Validity of the plane is checked according to the geometry set
        and has different criteria for different kinds of dimensions.

        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        return _AIS.AIS_Dimension_SetCustomPlane(self, *args)


    def UnsetCustomPlane(self, *args):
        """
        UnsetCustomPlane(AIS_Dimension self)

        Unsets user-defined plane. Therefore the plane for dimension will be
        computed automatically.


        """
        return _AIS.AIS_Dimension_UnsetCustomPlane(self, *args)


    def IsTextPositionCustom(self, *args):
        """
        IsTextPositionCustom(AIS_Dimension self) -> Standard_Boolean

        @return TRUE if text position is set by user with method SetTextPosition().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Dimension_IsTextPositionCustom(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(AIS_Dimension self, gp_Pnt arg2)

        Fixes the absolute text position and adjusts flyout, plane and text alignment
        according to it. Updates presentation if the text position is valid.
        ATTENTION! It does not change vertical text alignment.
        @param theTextPos [in] the point of text position.

        :type : OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_Dimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(AIS_Dimension self) -> gp_Pnt

        Computes absolute text position from dimension parameters
        (flyout, plane and text alignment).

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_Dimension_GetTextPosition(self, *args)


    def DimensionAspect(self, *args):
        """
        DimensionAspect(AIS_Dimension self) -> Handle_Prs3d_DimensionAspect

        Gets the dimension aspect from AIS object drawer.
        Dimension aspect contains aspects of line, text and arrows for dimension presentation.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.AIS_Dimension_DimensionAspect(self, *args)


    def SetDimensionAspect(self, *args):
        """
        SetDimensionAspect(AIS_Dimension self, Handle_Prs3d_DimensionAspect theDimensionAspect)

        Sets new dimension aspect for the interactive object drawer.
        The dimension aspect provides dynamic properties which are generally
        used during computation of dimension presentations.

        :type theDimensionAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.AIS_Dimension_SetDimensionAspect(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(AIS_Dimension self) -> AIS_KindOfDimension

        @return the kind of dimension.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.AIS_Dimension_KindOfDimension(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Dimension self) -> AIS_KindOfInteractive

        @return the kind of interactive.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Dimension_Type(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_Dimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode theMode.
        The interactive context can have a default mode of representation for
        the set of Interactive Objects. This mode may not be accepted by object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Dimension_AcceptDisplayMode(self, *args)


    def DisplaySpecialSymbol(self, *args):
        """
        DisplaySpecialSymbol(AIS_Dimension self) -> AIS_DisplaySpecialSymbol

        @return dimension special symbol display options.

        :rtype: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.AIS_Dimension_DisplaySpecialSymbol(self, *args)


    def SetDisplaySpecialSymbol(self, *args):
        """
        SetDisplaySpecialSymbol(AIS_Dimension self, AIS_DisplaySpecialSymbol const theDisplaySpecSymbol)

        Specifies whether to display special symbol or not.

        :type theDisplaySpecSymbol: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.AIS_Dimension_SetDisplaySpecialSymbol(self, *args)


    def SpecialSymbol(self, *args):
        """
        SpecialSymbol(AIS_Dimension self) -> Standard_ExtCharacter

        @return special symbol.

        :rtype: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.AIS_Dimension_SpecialSymbol(self, *args)


    def SetSpecialSymbol(self, *args):
        """
        SetSpecialSymbol(AIS_Dimension self, Standard_ExtCharacter const theSpecialSymbol)

        Specifies special symbol.

        :type theSpecialSymbol: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.AIS_Dimension_SetSpecialSymbol(self, *args)


    def GetDisplayUnits(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_Dimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_Dimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(AIS_Dimension self, TCollection_AsciiString arg2)

        :type : OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_Dimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(AIS_Dimension self, TCollection_AsciiString arg2)

        :type : OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_Dimension_SetModelUnits(self, *args)


    def UnsetFixedTextPosition(self, *args):
        """
        UnsetFixedTextPosition(AIS_Dimension self)

        Unsets user defined text positioning and enables text positioning
        by other parameters: text alignment, extension size, flyout and custom plane.


        """
        return _AIS.AIS_Dimension_UnsetFixedTextPosition(self, *args)


    def SelToleranceForText2d(self, *args):
        """
        SelToleranceForText2d(AIS_Dimension self) -> Standard_Real

        Returns selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        Important! Only for 2d text.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Dimension_SelToleranceForText2d(self, *args)


    def SetSelToleranceForText2d(self, *args):
        """
        SetSelToleranceForText2d(AIS_Dimension self, Standard_Real const theTol)

        Sets selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        to change this tolerance use this method
        Important! Only for 2d text.

        :type theTol: float

        """
        return _AIS.AIS_Dimension_SetSelToleranceForText2d(self, *args)


    def GetFlyout(self, *args):
        """
        GetFlyout(AIS_Dimension self) -> Standard_Real

        @return flyout value for dimension.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Dimension_GetFlyout(self, *args)


    def SetFlyout(self, *args):
        """
        SetFlyout(AIS_Dimension self, Standard_Real const theFlyout)

        Sets flyout value for dimension.

        :type theFlyout: float

        """
        return _AIS.AIS_Dimension_SetFlyout(self, *args)


    def IsValid(self, *args):
        """
        IsValid(AIS_Dimension self) -> Standard_Boolean

        Check that the input geometry for dimension is valid and the
        presentation can be successfully computed.
        @return TRUE if dimension geometry is ok.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Dimension_IsValid(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Dimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Dimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Dimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_Dimension
AIS_Dimension_swigregister = _AIS.AIS_Dimension_swigregister
AIS_Dimension_swigregister(AIS_Dimension)

def AIS_Dimension_get_type_name(*args):
    """
    AIS_Dimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Dimension_get_type_name(*args)

def AIS_Dimension_get_type_descriptor(*args):
    """
    AIS_Dimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Dimension_get_type_descriptor(*args)

class AIS_Animation(Standard.Standard_Transient):
    """
    Class represents single animation.
    It is defined with:
    - Start time on the timeline started from 0, in seconds
    - Duration, in seconds
    - virtual method Update() for handling an update
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Animation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Animation(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Animation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Animation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Animation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Animation self, TCollection_AsciiString theAnimationName) -> AIS_Animation

        Creates empty animation.

        :type theAnimationName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _AIS.new_AIS_Animation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        Animation name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_Animation_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPts(self, *args):
        """
        StartPts(AIS_Animation self) -> Standard_Real

        @return start time of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Animation_StartPts(self, *args)


    def SetStartPts(self, *args):
        """
        SetStartPts(AIS_Animation self, Standard_Real const thePtsStart)

        Sets time limits for animation in the animation timeline

        :type thePtsStart: float

        """
        return _AIS.AIS_Animation_SetStartPts(self, *args)


    def Duration(self, *args):
        """
        Duration(AIS_Animation self) -> Standard_Real

        @return duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Animation_Duration(self, *args)


    def UpdateTotalDuration(self, *args):
        """
        UpdateTotalDuration(AIS_Animation self)

        Update total duration considering all animations on timeline.


        """
        return _AIS.AIS_Animation_UpdateTotalDuration(self, *args)


    def HasOwnDuration(self, *args):
        """
        HasOwnDuration(AIS_Animation self) -> Standard_Boolean

        Return true if duration is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Animation_HasOwnDuration(self, *args)


    def OwnDuration(self, *args):
        """
        OwnDuration(AIS_Animation self) -> Standard_Real

        @return own duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Animation_OwnDuration(self, *args)


    def SetOwnDuration(self, *args):
        """
        SetOwnDuration(AIS_Animation self, Standard_Real const theDuration)

        Defines duration of the animation.

        :type theDuration: float

        """
        return _AIS.AIS_Animation_SetOwnDuration(self, *args)


    def Add(self, *args):
        """
        Add(AIS_Animation self, Handle_AIS_Animation theAnimation)

        Add single animation to the timeline.
        @param theAnimation input animation

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.AIS_Animation_Add(self, *args)


    def Clear(self, *args):
        """
        Clear(AIS_Animation self)

        Clear animation timeline - remove all animations from it.


        """
        return _AIS.AIS_Animation_Clear(self, *args)


    def Find(self, *args):
        """
        Find(AIS_Animation self, TCollection_AsciiString theAnimationName) -> Handle_AIS_Animation

        Return the child animation with the given name.

        :type theAnimationName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.AIS_Animation_Find(self, *args)


    def Remove(self, *args):
        """
        Remove(AIS_Animation self, Handle_AIS_Animation theAnimation) -> Standard_Boolean

        Remove the child animation.

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Animation_Remove(self, *args)


    def Replace(self, *args):
        """
        Replace(AIS_Animation self, Handle_AIS_Animation theAnimationOld, Handle_AIS_Animation theAnimationNew) -> Standard_Boolean

        Replace the child animation.

        :type theAnimationOld: OCC.wrapper.AIS.Handle_AIS_Animation
        :type theAnimationNew: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Animation_Replace(self, *args)


    def CopyFrom(self, *args):
        """
        CopyFrom(AIS_Animation self, Handle_AIS_Animation theOther)

        Clears own children and then copy child animations from another object.
        Copy also Start Time and Duration values.

        :type theOther: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.AIS_Animation_CopyFrom(self, *args)


    def Children(self, *args):
        """
        Return sequence of child animations.

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_Animation

        """
        res = _AIS.AIS_Animation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartTimer(self, *args):
        """
        StartTimer(AIS_Animation self, Standard_Real const theStartPts, Standard_Real const thePlaySpeed, Standard_Boolean const theToUpdate, Standard_Boolean const theToStopTimer)

        Start animation with internally defined timer instance.
        Calls ::Start() internally.
        @param theStartPts    starting timer position (presentation timestamp)
        @param thePlaySpeed   playback speed (1.0 means normal speed)
        @param theToUpdate    flag to update defined animations to specified start position
        @param theToStopTimer flag to pause timer at the starting position

        :type theStartPts: float
        :type thePlaySpeed: float
        :type theToUpdate: bool
        :type theToStopTimer: bool

        """
        return _AIS.AIS_Animation_StartTimer(self, *args)


    def UpdateTimer(self, *args):
        """
        UpdateTimer(AIS_Animation self) -> Standard_Real

        Update single frame of animation, update timer state
        @return current time of timeline progress.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Animation_UpdateTimer(self, *args)


    def ElapsedTime(self, *args):
        """
        ElapsedTime(AIS_Animation self) -> Standard_Real

        Return elapsed time.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Animation_ElapsedTime(self, *args)


    def Start(self, *args):
        """
        Start(AIS_Animation self, Standard_Boolean const theToUpdate)

        Start animation. This method changes status of the animation to Started.
        This status defines whether animation is to be performed in the timeline or not.
        @param theToUpdate call Update() method

        :type theToUpdate: bool

        """
        return _AIS.AIS_Animation_Start(self, *args)


    def Pause(self, *args):
        """
        Pause(AIS_Animation self)

        Pause the process timeline.


        """
        return _AIS.AIS_Animation_Pause(self, *args)


    def Stop(self, *args):
        """
        Stop(AIS_Animation self)

        Stop animation. This method changed status of the animation to Stopped.
        This status shows that animation will not be performed in the timeline or it is finished.


        """
        return _AIS.AIS_Animation_Stop(self, *args)


    def IsStopped(self, *args):
        """
        IsStopped(AIS_Animation self) -> bool

        Check if animation is to be performed in the animation timeline.
        @return True if it is stopped of finished.

        :rtype: bool

        """
        return _AIS.AIS_Animation_IsStopped(self, *args)


    def Update(self, *args):
        """
        Update(AIS_Animation self, Standard_Real const thePts) -> Standard_Boolean

        Update single frame of animation, update timer state
        @param thePts [in] the time moment within [0; Duration()]
        @return True if timeline is in progress

        :type thePts: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Animation_Update(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Animation
AIS_Animation_swigregister = _AIS.AIS_Animation_swigregister
AIS_Animation_swigregister(AIS_Animation)

def AIS_Animation_get_type_name(*args):
    """
    AIS_Animation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Animation_get_type_name(*args)

def AIS_Animation_get_type_descriptor(*args):
    """
    AIS_Animation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Animation_get_type_descriptor(*args)

class AIS_AnimationCamera(AIS_Animation):
    """Camera animation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_AnimationCamera
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_AnimationCamera(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_AnimationCamera_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_AnimationCamera_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_AnimationCamera_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_AnimationCamera self, TCollection_AsciiString theAnimationName, Handle_V3d_View theView) -> AIS_AnimationCamera

        Main constructor.

        :type theAnimationName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        this = _AIS.new_AIS_AnimationCamera(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def View(self, *args):
        """
        Return the target view.

        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        res = _AIS.AIS_AnimationCamera_View(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CameraStart(self, *args):
        """
        Return camera start position.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _AIS.AIS_AnimationCamera_CameraStart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCameraStart(self, *args):
        """
        SetCameraStart(AIS_AnimationCamera self, Handle_Graphic3d_Camera theCameraStart)

        Define camera start position.

        :type theCameraStart: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _AIS.AIS_AnimationCamera_SetCameraStart(self, *args)


    def CameraEnd(self, *args):
        """
        Return camera end position.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _AIS.AIS_AnimationCamera_CameraEnd(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCameraEnd(self, *args):
        """
        SetCameraEnd(AIS_AnimationCamera self, Handle_Graphic3d_Camera theCameraEnd)

        Define camera end position.

        :type theCameraEnd: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _AIS.AIS_AnimationCamera_SetCameraEnd(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_AnimationCamera
AIS_AnimationCamera_swigregister = _AIS.AIS_AnimationCamera_swigregister
AIS_AnimationCamera_swigregister(AIS_AnimationCamera)

def AIS_AnimationCamera_get_type_name(*args):
    """
    AIS_AnimationCamera_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_AnimationCamera_get_type_name(*args)

def AIS_AnimationCamera_get_type_descriptor(*args):
    """
    AIS_AnimationCamera_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_AnimationCamera_get_type_descriptor(*args)

class AIS_ParallelRelation(AIS_Relation):
    """
    A framework to display constraints of parallelism
    between two or more Interactive Objects. These
    entities can be faces or edges.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ParallelRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ParallelRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_ParallelRelation self, TopoDS_Shape aFShape, TopoDS_Shape aSShape, Handle_Geom_Plane aPlane) -> AIS_ParallelRelation
        __init__(AIS_ParallelRelation self, TopoDS_Shape aFShape, TopoDS_Shape aSShape, Handle_Geom_Plane aPlane, gp_Pnt aPosition, DsgPrs_ArrowSide const aSymbolPrs, Standard_Real const anArrowSize=0.01) -> AIS_ParallelRelation

        Constructs an object to display parallel constraints.
        This object is defined by the first shape aFShape and
        the second shape aSShape the plane aPlane, the
        position aPosition, the type of arrow, aSymbolPrs and
        its size anArrowSize.

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type aPosition: OCC.wrapper.gp.gp_Pnt
        :type aSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide
        :type anArrowSize: float

        """
        this = _AIS.new_AIS_ParallelRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsMovable(self, *args):
        """
        IsMovable(AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the parallelism is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ParallelRelation_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_ParallelRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_ParallelRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ParallelRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ParallelRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ParallelRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_ParallelRelation
AIS_ParallelRelation_swigregister = _AIS.AIS_ParallelRelation_swigregister
AIS_ParallelRelation_swigregister(AIS_ParallelRelation)

def AIS_ParallelRelation_get_type_name(*args):
    """
    AIS_ParallelRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ParallelRelation_get_type_name(*args)

def AIS_ParallelRelation_get_type_descriptor(*args):
    """
    AIS_ParallelRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ParallelRelation_get_type_descriptor(*args)

class AIS_AngleDimension(AIS_Dimension):
    """
    Angle dimension. Can be constructed:
    - on two intersected edges.
    - on three points or vertices.
    - on conical face.
    - between two intersected faces.

    In case of three points or two intersected edges the dimension plane
    (on which dimension presentation is built) can be computed uniquely
    as through three defined points can be built only one plane.
    Therefore, if user-defined plane differs from this one, the dimension can't be built.

    In cases of two planes automatic plane by default is built on point of the
    origin of parametric space of the first face (the basis surface) so, that
    the working plane and two faces intersection forms minimal angle between the faces.
    User can define the other point which the dimension plane should pass through
    using the appropriate constructor. This point can lay on the one of the faces or not.
    Also user can define his own plane but it should pass through the three points
    computed on the geometry initialization step (when the constructor or SetMeasuredGeometry() method
    is called). 

    In case of the conical face the center point of the angle is the apex of the conical surface.
    The attachment points are points of the first and the last parameter of the basis circle of the cone.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_AngleDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_AngleDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_AngleDimension self, TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge) -> AIS_AngleDimension
        __init__(AIS_AngleDimension self, gp_Pnt theFirstPoint, gp_Pnt theSecondPoint, gp_Pnt theThirdPoint) -> AIS_AngleDimension
        __init__(AIS_AngleDimension self, TopoDS_Vertex theFirstVertex, TopoDS_Vertex theSecondVertex, TopoDS_Vertex theThirdVertex) -> AIS_AngleDimension
        __init__(AIS_AngleDimension self, TopoDS_Face theCone) -> AIS_AngleDimension
        __init__(AIS_AngleDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace) -> AIS_AngleDimension
        __init__(AIS_AngleDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, gp_Pnt thePoint) -> AIS_AngleDimension

        Constructs angle dimension between two planar faces.
        @param theFirstFace [in] the first face.
        @param theSecondFace [in] the second face.
        @param thePoint [in] the point which the dimension plane should pass through.
        This point can lay on the one of the faces or not.

        :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        this = _AIS.new_AIS_AngleDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FirstPoint(self, *args):
        """
        @return first point forming the angle.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_AngleDimension_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondPoint(self, *args):
        """
        @return second point forming the angle.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_AngleDimension_SecondPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CenterPoint(self, *args):
        """
        @return center point forming the angle.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_AngleDimension_CenterPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstShape(self, *args):
        """
        @return first argument shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_AngleDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondShape(self, *args):
        """
        @return second argument shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_AngleDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ThirdShape(self, *args):
        """
        @return third argument shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_AngleDimension_ThirdShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(AIS_AngleDimension self, TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge)
        SetMeasuredGeometry(AIS_AngleDimension self, gp_Pnt theFirstPoint, gp_Pnt theSecondPoint, gp_Pnt theThridPoint)
        SetMeasuredGeometry(AIS_AngleDimension self, TopoDS_Vertex theFirstVertex, TopoDS_Vertex theSecondVertex, TopoDS_Vertex theThirdVertex)
        SetMeasuredGeometry(AIS_AngleDimension self, TopoDS_Face theCone)
        SetMeasuredGeometry(AIS_AngleDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace)
        SetMeasuredGeometry(AIS_AngleDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, gp_Pnt thePoint)

        Measures angle between two planar faces.
        @param theFirstFace [in] the first face.
        @param theSecondFace [in] the second face.
        @param thePoint [in] the point which the dimension plane should pass through.
        This point can lay on the one of the faces or not.

        :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_AngleDimension_SetMeasuredGeometry(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_AngleDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_AngleDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(AIS_AngleDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_AngleDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(AIS_AngleDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_AngleDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(AIS_AngleDimension self, gp_Pnt theTextPos)

        Principle of horizontal text alignment settings:
        - divide circle into two halves according to attachment points
        - if aTextPos is between attach points -> Center + positive flyout
        - if aTextPos is not between attach points but in this half -> Left or Right + positive flyout
        - if aTextPos is between reflections of attach points -> Center + negative flyout
        - if aTextPos is not between reflections of attach points -> Left or Right + negative flyout

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_AngleDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(AIS_AngleDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_AngleDimension_GetTextPosition(self, *args)


    def SetType(self, *args):
        """
        SetType(AIS_AngleDimension self, AIS_TypeOfAngle const theType)

        Sets angle type.
        @param theType [in] the type value.

        :type theType: OCC.wrapper.AIS.AIS_TypeOfAngle

        """
        return _AIS.AIS_AngleDimension_SetType(self, *args)


    def GetType(self, *args):
        """
        GetType(AIS_AngleDimension self) -> AIS_TypeOfAngle

        @return the current angle type.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfAngle

        """
        return _AIS.AIS_AngleDimension_GetType(self, *args)


    def SetArrowsVisibility(self, *args):
        """
        SetArrowsVisibility(AIS_AngleDimension self, AIS_TypeOfAngleArrowVisibility const & theType)

        Sets visible arrows type
        @param theType [in] the type of visibility of arrows.

        :type theType: OCC.wrapper.AIS.AIS_TypeOfAngleArrowVisibility

        """
        return _AIS.AIS_AngleDimension_SetArrowsVisibility(self, *args)


    def GetArrowsVisibility(self, *args):
        """
        GetArrowsVisibility(AIS_AngleDimension self) -> AIS_TypeOfAngleArrowVisibility

        @return the type of visibility of arrows.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfAngleArrowVisibility

        """
        return _AIS.AIS_AngleDimension_GetArrowsVisibility(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_AngleDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_AngleDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_AngleDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_AngleDimension
AIS_AngleDimension_swigregister = _AIS.AIS_AngleDimension_swigregister
AIS_AngleDimension_swigregister(AIS_AngleDimension)

def AIS_AngleDimension_get_type_name(*args):
    """
    AIS_AngleDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_AngleDimension_get_type_name(*args)

def AIS_AngleDimension_get_type_descriptor(*args):
    """
    AIS_AngleDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_AngleDimension_get_type_descriptor(*args)

class AIS_SignatureFilter(AIS_TypeFilter):
    """
    Selects Interactive Objects through their signatures
    and types. The signature provides an
    additional   characterization of an object's type, and
    takes the form of an index. The filter questions each
    Interactive Object in local context to determine
    whether it has an non-null owner, and if so, whether
    it has the desired signature. If the object returns true
    in each case, it is kept. If not, it is rejected.
    By default, the   interactive object has a None   type
    and a signature of 0. If you want to give a particular
    type and signature to your Interactive Object, you
    must redefine two virtual methods:   Type and Signature.
    This filter is only used in an open local contexts.
    In the Collector viewer, you can only locate
    Interactive Objects which answer positively to the
    positioned filters when a local context is open.
    Warning
    Some signatures have already been used by standard
    objects delivered in AIS. These include:
    -   signature 0 - Shape
    -   signature 1 - Point
    -   signature 2 - Axis
    -   signature 3 - Trihedron
    -   signature 4 - PlaneTrihedron
    -   signature 5 - Line
    -   signature 6 - Circle
    -   signature 7 - Plane
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_SignatureFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_SignatureFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_SignatureFilter self, AIS_KindOfInteractive const aGivenKind, Standard_Integer const aGivenSignature) -> AIS_SignatureFilter

        Initializes the signature filter, adding the signature
        specification, aGivenSignature, to that for type,
        aGivenKind, in AIS_TypeFilter.

        :type aGivenKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type aGivenSignature: int

        """
        this = _AIS.new_AIS_SignatureFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsOk(self, *args):
        """
        IsOk(AIS_SignatureFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        Returns False if the transient is not an AIS_InteractiveObject.
        Returns False if the signature of InteractiveObject
        is not the same as the stored one in the filter...

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_SignatureFilter_IsOk(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_SignatureFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_SignatureFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_SignatureFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_SignatureFilter
AIS_SignatureFilter_swigregister = _AIS.AIS_SignatureFilter_swigregister
AIS_SignatureFilter_swigregister(AIS_SignatureFilter)

def AIS_SignatureFilter_get_type_name(*args):
    """
    AIS_SignatureFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_SignatureFilter_get_type_name(*args)

def AIS_SignatureFilter_get_type_descriptor(*args):
    """
    AIS_SignatureFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_SignatureFilter_get_type_descriptor(*args)

class AIS_Axis(AIS_InteractiveObject):
    """
    Locates the x, y and z axes in an Interactive Object.
    These are used to orient it correctly in presentations
    from different viewpoints, or to construct a revolved
    shape, for example, from one of the axes. Conversely,
    an axis can be created to build a revolved shape and
    then situated relative to one of the axes of the view.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Axis
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Axis(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Axis_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Axis_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Axis_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Axis self, Handle_Geom_Line aComponent) -> AIS_Axis
        __init__(AIS_Axis self, Handle_Geom_Axis2Placement aComponent, AIS_TypeOfAxis const anAxisType) -> AIS_Axis
        __init__(AIS_Axis self, Handle_Geom_Axis1Placement anAxis) -> AIS_Axis

        Initializes the axis1 position anAxis.

        :type anAxis: OCC.wrapper.Geom.Handle_Geom_Axis1Placement

        """
        this = _AIS.new_AIS_Axis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Component(self, *args):
        """
        Returns the axis entity aComponent and identifies it
        as a component of a shape.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Line

        """
        res = _AIS.AIS_Axis_Component(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetComponent(self, *args):
        """
        SetComponent(AIS_Axis self, Handle_Geom_Line aComponent)

        Sets the coordinates of the lin aComponent.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Line

        """
        return _AIS.AIS_Axis_SetComponent(self, *args)


    def Axis2Placement(self, *args):
        """
        Returns the position of axis2 and   positions it by
        identifying it as the x, y, or z axis and giving its
        direction in 3D space. The coordinate system used is right-handed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        res = _AIS.AIS_Axis_Axis2Placement(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis2Placement(self, *args):
        """
        SetAxis2Placement(AIS_Axis self, Handle_Geom_Axis2Placement aComponent, AIS_TypeOfAxis const anAxisType)

        Allows you to provide settings for aComponent:the
        position and direction of an axis in 3D space. The
        coordinate system used is right-handed.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement
        :type anAxisType: OCC.wrapper.AIS.AIS_TypeOfAxis

        """
        return _AIS.AIS_Axis_SetAxis2Placement(self, *args)


    def SetAxis1Placement(self, *args):
        """
        SetAxis1Placement(AIS_Axis self, Handle_Geom_Axis1Placement anAxis)

        Constructs a new line to serve as the axis anAxis in 3D space.

        :type anAxis: OCC.wrapper.Geom.Handle_Geom_Axis1Placement

        """
        return _AIS.AIS_Axis_SetAxis1Placement(self, *args)


    def TypeOfAxis(self, *args):
        """
        TypeOfAxis(AIS_Axis self) -> AIS_TypeOfAxis

        Returns the type of axis.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfAxis

        """
        return _AIS.AIS_Axis_TypeOfAxis(self, *args)


    def SetTypeOfAxis(self, *args):
        """
        SetTypeOfAxis(AIS_Axis self, AIS_TypeOfAxis const theTypeAxis)

        Constructs the entity theTypeAxis to stock information
        concerning type of axis.

        :type theTypeAxis: OCC.wrapper.AIS.AIS_TypeOfAxis

        """
        return _AIS.AIS_Axis_SetTypeOfAxis(self, *args)


    def IsXYZAxis(self, *args):
        """
        IsXYZAxis(AIS_Axis self) -> Standard_Boolean

        Returns a signature of 2 for axis datums. When you
        activate mode 2 by a signature, you pick AIS objects
        of type AIS_Axis.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Axis_IsXYZAxis(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_Axis self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the interactive object accepts the display mode aMode.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Axis_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_Axis self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_Axis_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_Axis self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Axis_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Axis self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Axis_Type(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_Axis self, Quantity_Color aColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Axis_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_Axis self, Standard_Real const aValue)

        :type aValue: float

        """
        return _AIS.AIS_Axis_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Axis self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.AIS_Axis_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(AIS_Axis self)"""
        return _AIS.AIS_Axis_UnsetWidth(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Axis
AIS_Axis_swigregister = _AIS.AIS_Axis_swigregister
AIS_Axis_swigregister(AIS_Axis)

def AIS_Axis_get_type_name(*args):
    """
    AIS_Axis_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Axis_get_type_name(*args)

def AIS_Axis_get_type_descriptor(*args):
    """
    AIS_Axis_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Axis_get_type_descriptor(*args)

class AIS_BadEdgeFilter(SelectMgr.SelectMgr_Filter):
    """A Class"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_BadEdgeFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_BadEdgeFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_BadEdgeFilter self) -> AIS_BadEdgeFilter

        Constructs an empty filter object for bad edges.


        """
        this = _AIS.new_AIS_BadEdgeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ActsOn(self, *args):
        """
        ActsOn(AIS_BadEdgeFilter self, TopAbs_ShapeEnum const aType) -> Standard_Boolean

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_BadEdgeFilter_ActsOn(self, *args)


    def IsOk(self, *args):
        """
        IsOk(AIS_BadEdgeFilter self, Handle_SelectMgr_EntityOwner EO) -> Standard_Boolean

        :type EO: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_BadEdgeFilter_IsOk(self, *args)


    def SetContour(self, *args):
        """
        SetContour(AIS_BadEdgeFilter self, Standard_Integer const Index)

        sets  <myContour> with  current  contour. used  by
        IsOk.

        :type Index: int

        """
        return _AIS.AIS_BadEdgeFilter_SetContour(self, *args)


    def AddEdge(self, *args):
        """
        AddEdge(AIS_BadEdgeFilter self, TopoDS_Edge anEdge, Standard_Integer const Index)

        Adds an  edge  to the list  of non-selectionnable
        edges.

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Index: int

        """
        return _AIS.AIS_BadEdgeFilter_AddEdge(self, *args)


    def RemoveEdges(self, *args):
        """
        RemoveEdges(AIS_BadEdgeFilter self, Standard_Integer const Index)

        removes from the  list of non-selectionnable edges
        all edges in the contour <Index>.

        :type Index: int

        """
        return _AIS.AIS_BadEdgeFilter_RemoveEdges(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_BadEdgeFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_BadEdgeFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_BadEdgeFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_BadEdgeFilter
AIS_BadEdgeFilter_swigregister = _AIS.AIS_BadEdgeFilter_swigregister
AIS_BadEdgeFilter_swigregister(AIS_BadEdgeFilter)

def AIS_BadEdgeFilter_get_type_name(*args):
    """
    AIS_BadEdgeFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_BadEdgeFilter_get_type_name(*args)

def AIS_BadEdgeFilter_get_type_descriptor(*args):
    """
    AIS_BadEdgeFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_BadEdgeFilter_get_type_descriptor(*args)

class AIS_DiameterDimension(AIS_Dimension):
    """
    Diameter dimension. Can be constructued:
    - On generic circle.
    - On generic circle with user-defined anchor point on that circle
    (dimension plane is oriented to follow the anchor point).
    - On generic circle in the specified plane.
    - On generic shape containing geometry that can be measured
    by diameter dimension: circle wire, circular face, etc.
    The anchor point is the location of the left attachement point of
    dimension on the circle.
    The anchor point computation is processed after dimension plane setting
    so that positive flyout direction stands with normal of the circle and
    the normal of the plane.
    If the plane is user-defined the anchor point was computed as intersection
    of the plane and the basis circle. Among two intersection points
    the one is selected so that positive flyout direction vector and
    the circle normal on the one side form the circle plane.
    (corner between positive flyout directio nand the circle normal is acute.)
    If the plane is computed automatically (by default it is the circle plane),
    the anchor point is the zero parameter point of the circle.

    The dimension is considered as invalid if the user-defined plane
    does not include th enachor point and th ecircle center,
    if the diameter of the circle is less than Precision::Confusion().
    In case if the dimension is built on the arbitrary shape, it can be considered
    as invalid if the shape does not contain circle geometry.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_DiameterDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_DiameterDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_DiameterDimension self, gp_Circ theCircle) -> AIS_DiameterDimension
        __init__(AIS_DiameterDimension self, gp_Circ theCircle, gp_Pln thePlane) -> AIS_DiameterDimension
        __init__(AIS_DiameterDimension self, TopoDS_Shape theShape) -> AIS_DiameterDimension
        __init__(AIS_DiameterDimension self, TopoDS_Shape theShape, gp_Pln thePlane) -> AIS_DiameterDimension

        Construct diameter on the passed shape, if applicable - and
        define the preferred plane to orient the dimension.
        @param theShape [in] the shape to measure.
        @param thePlane [in] the plane defining preferred orientation
        for dimension.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        this = _AIS.new_AIS_DiameterDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Circle(self, *args):
        """
        @return measured geometry circle.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        res = _AIS.AIS_DiameterDimension_Circle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AnchorPoint(self, *args):
        """
        AnchorPoint(AIS_DiameterDimension self) -> gp_Pnt

        @return anchor point on circle for diameter dimension.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_DiameterDimension_AnchorPoint(self, *args)


    def Shape(self, *args):
        """
        @return the measured shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_DiameterDimension_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(AIS_DiameterDimension self, gp_Circ theCircle)
        SetMeasuredGeometry(AIS_DiameterDimension self, TopoDS_Shape theShape)

        Measure diameter on the passed shape, if applicable.
        The dimension will become invalid if the passed shape is not
        measurable or if measured diameter value is less than Precision::Confusion().
        @param theShape [in] the shape to measure.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_DiameterDimension_SetMeasuredGeometry(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_DiameterDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_DiameterDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(AIS_DiameterDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_DiameterDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(AIS_DiameterDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_DiameterDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(AIS_DiameterDimension self, gp_Pnt theTextPos)

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_DiameterDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(AIS_DiameterDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_DiameterDimension_GetTextPosition(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_DiameterDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_DiameterDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_DiameterDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_DiameterDimension
AIS_DiameterDimension_swigregister = _AIS.AIS_DiameterDimension_swigregister
AIS_DiameterDimension_swigregister(AIS_DiameterDimension)

def AIS_DiameterDimension_get_type_name(*args):
    """
    AIS_DiameterDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_DiameterDimension_get_type_name(*args)

def AIS_DiameterDimension_get_type_descriptor(*args):
    """
    AIS_DiameterDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_DiameterDimension_get_type_descriptor(*args)

class AIS_SymmetricRelation(AIS_Relation):
    """
    A framework to display constraints of symmetricity
    between two or more datum Interactive Objects.
    A plane serves as the axis of symmetry between the
    shapes of which the datums are parts.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_SymmetricRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_SymmetricRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_SymmetricRelation self, TopoDS_Shape aSymmTool, TopoDS_Shape FirstShape, TopoDS_Shape SecondShape, Handle_Geom_Plane aPlane) -> AIS_SymmetricRelation

        Constructs an object to display constraints of symmetricity.
        This object is defined by a tool aSymmTool, a first
        shape FirstShape, a second shape SecondShape, and a plane aPlane.
        aPlane serves as the axis of symmetry.
        aSymmTool is the shape composed of FirstShape
        SecondShape and aPlane. It may be queried and
        edited using the functions GetTool and SetTool.
        The two shapes are typically two edges, two vertices or two points.

        :type aSymmTool: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SecondShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        this = _AIS.new_AIS_SymmetricRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsMovable(self, *args):
        """
        IsMovable(AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the symmetric constraint display is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_SymmetricRelation_IsMovable(self, *args)


    def SetTool(self, *args):
        """
        SetTool(AIS_SymmetricRelation self, TopoDS_Shape aSymmetricTool)

        Sets the tool aSymmetricTool composed of a first
        shape, a second shape, and a plane.
        This tool is initially created at construction time.

        :type aSymmetricTool: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_SymmetricRelation_SetTool(self, *args)


    def GetTool(self, *args):
        """
        Returns the tool composed of a first shape, a second
        shape, and a plane. This tool is created at construction time.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_SymmetricRelation_GetTool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(AIS_SymmetricRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_SymmetricRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_SymmetricRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_SymmetricRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_SymmetricRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_SymmetricRelation
AIS_SymmetricRelation_swigregister = _AIS.AIS_SymmetricRelation_swigregister
AIS_SymmetricRelation_swigregister(AIS_SymmetricRelation)

def AIS_SymmetricRelation_get_type_name(*args):
    """
    AIS_SymmetricRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_SymmetricRelation_get_type_name(*args)

def AIS_SymmetricRelation_get_type_descriptor(*args):
    """
    AIS_SymmetricRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_SymmetricRelation_get_type_descriptor(*args)

class AIS_ExclusionFilter(SelectMgr.SelectMgr_Filter):
    """
    A framework to reject or to accept only objects of
    given types and/or signatures.
    Objects are stored, and the stored objects - along
    with the flag settings - are used to define the filter.
    Objects to be filtered are compared with the stored
    objects added to the filter, and are accepted or
    rejected according to the exclusion flag setting.
    -   Exclusion flag on
    -   the function IsOk answers true for all objects,
    except those of the types and signatures stored
    in the filter framework
    -   Exclusion flag off
    -   the funciton IsOk answers true for all objects
    which have the same type and signature as the stored ones.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ExclusionFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ExclusionFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_ExclusionFilter self, Standard_Boolean const ExclusionFlagOn) -> AIS_ExclusionFilter
        __init__(AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude, Standard_Boolean const ExclusionFlagOn) -> AIS_ExclusionFilter
        __init__(AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude, Standard_Integer const SignatureInType, Standard_Boolean const ExclusionFlagOn) -> AIS_ExclusionFilter

        Constructs an exclusion filter object defined by the
        enumeration value TypeToExclude, the signature
        SignatureInType, and the flag setting ExclusionFlagOn.
        By default, the flag is set to true.

        :type TypeToExclude: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type SignatureInType: int
        :type ExclusionFlagOn: bool

        """
        this = _AIS.new_AIS_ExclusionFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsOk(self, *args):
        """
        IsOk(AIS_ExclusionFilter self, Handle_SelectMgr_EntityOwner anObj) -> Standard_Boolean

        :type anObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ExclusionFilter_IsOk(self, *args)


    def Add(self, *args):
        """
        Add(AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude) -> Standard_Boolean
        Add(AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude, Standard_Integer const SignatureInType) -> Standard_Boolean

        :type TypeToExclude: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type SignatureInType: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ExclusionFilter_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude) -> Standard_Boolean
        Remove(AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude, Standard_Integer const SignatureInType) -> Standard_Boolean

        :type TypeToExclude: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type SignatureInType: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ExclusionFilter_Remove(self, *args)


    def Clear(self, *args):
        """Clear(AIS_ExclusionFilter self)"""
        return _AIS.AIS_ExclusionFilter_Clear(self, *args)


    def IsExclusionFlagOn(self, *args):
        """
        IsExclusionFlagOn(AIS_ExclusionFilter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ExclusionFilter_IsExclusionFlagOn(self, *args)


    def SetExclusionFlag(self, *args):
        """
        SetExclusionFlag(AIS_ExclusionFilter self, Standard_Boolean const Status)

        :type Status: bool

        """
        return _AIS.AIS_ExclusionFilter_SetExclusionFlag(self, *args)


    def IsStored(self, *args):
        """
        IsStored(AIS_ExclusionFilter self, AIS_KindOfInteractive const aType) -> Standard_Boolean

        :type aType: OCC.wrapper.AIS.AIS_KindOfInteractive
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ExclusionFilter_IsStored(self, *args)


    def ListOfStoredTypes(self, *args):
        """
        ListOfStoredTypes(AIS_ExclusionFilter self, NCollection_List_Standard_Integer TheList)

        :type TheList: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.AIS_ExclusionFilter_ListOfStoredTypes(self, *args)


    def ListOfSignature(self, *args):
        """
        ListOfSignature(AIS_ExclusionFilter self, AIS_KindOfInteractive const aType, NCollection_List_Standard_Integer TheStoredList)

        :type aType: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type TheStoredList: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.AIS_ExclusionFilter_ListOfSignature(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ExclusionFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ExclusionFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ExclusionFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_ExclusionFilter
AIS_ExclusionFilter_swigregister = _AIS.AIS_ExclusionFilter_swigregister
AIS_ExclusionFilter_swigregister(AIS_ExclusionFilter)

def AIS_ExclusionFilter_get_type_name(*args):
    """
    AIS_ExclusionFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ExclusionFilter_get_type_name(*args)

def AIS_ExclusionFilter_get_type_descriptor(*args):
    """
    AIS_ExclusionFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ExclusionFilter_get_type_descriptor(*args)

class AIS_LengthDimension(AIS_Dimension):
    """
    Length dimension. Can be constructued:
    - Between two generic points.
    - Between two vertices.
    - Between two faces.
    - Between two parallel edges.
    - Between face and edge.

    In case of two points (vertices) or one linear edge the user-defined plane
    that includes this geometry is necessary to be set.

    In case of face-edge, edge-vertex or face-face lengthes the automatic plane
    computing is allowed. For this plane the third point is found on the
    edge or on the face.

    Please note that if the inappropriate geometry is defined
    or the distance between measured points is less than
    Precision::Confusion(), the dimension is invalid and its
    presentation can not be computed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_LengthDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_LengthDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_LengthDimension self, TopoDS_Face theFace, TopoDS_Edge theEdge) -> AIS_LengthDimension
        __init__(AIS_LengthDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace) -> AIS_LengthDimension
        __init__(AIS_LengthDimension self, gp_Pnt theFirstPoint, gp_Pnt theSecondPoint, gp_Pln thePlane) -> AIS_LengthDimension
        __init__(AIS_LengthDimension self, TopoDS_Shape theFirstShape, TopoDS_Shape theSecondShape, gp_Pln thePlane) -> AIS_LengthDimension
        __init__(AIS_LengthDimension self, TopoDS_Edge theEdge, gp_Pln thePlane) -> AIS_LengthDimension

        Construct length dimension of linear edge.
        @param theEdge [in] the edge to measure.
        @param thePlane [in] the plane to orient dimension.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        this = _AIS.new_AIS_LengthDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FirstPoint(self, *args):
        """
        @return first attachement point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_LengthDimension_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondPoint(self, *args):
        """
        @return second attachement point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_LengthDimension_SecondPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstShape(self, *args):
        """
        @return first attachement shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_LengthDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondShape(self, *args):
        """
        @return second attachement shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_LengthDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(AIS_LengthDimension self, gp_Pnt theFirstPoint, gp_Pnt theSecondPoint, gp_Pln thePlane)
        SetMeasuredGeometry(AIS_LengthDimension self, TopoDS_Edge theEdge, gp_Pln thePlane)
        SetMeasuredGeometry(AIS_LengthDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace)
        SetMeasuredGeometry(AIS_LengthDimension self, TopoDS_Face theFace, TopoDS_Edge theEdge)

        Measure distance between face and edge.
        The dimension will become invalid if the distance can not
        be measured or it is less than Precision::Confusion().
        @param theFace [in] the face (first shape).
        @param theEdge [in] the edge (second shape).

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _AIS.AIS_LengthDimension_SetMeasuredGeometry(self, *args)


    def SetMeasuredShapes(self, *args):
        """
        SetMeasuredShapes(AIS_LengthDimension self, TopoDS_Shape theFirstShape, TopoDS_Shape theSecondShape)

        Measure distance between generic pair of shapes (edges, vertices, length),
        where measuring is applicable.
        @param theFirstShape [in] the first shape.
        @param theSecondShape [in] the second shape.

        :type theFirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theSecondShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_LengthDimension_SetMeasuredShapes(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_LengthDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_LengthDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(AIS_LengthDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_LengthDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(AIS_LengthDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_LengthDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(AIS_LengthDimension self, gp_Pnt theTextPos)

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_LengthDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(AIS_LengthDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_LengthDimension_GetTextPosition(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(AIS_LengthDimension self, gp_Dir theDirection, Standard_Boolean const theUseDirection)

        Set custom direction for dimension. If it is not set, the direction is obtained
        from the measured geometry (e.g. line between points of dimension)
        The direction does not change flyout direction of dimension.
        @param theDirection [in] the dimension direction.
        @param theUseDirection [in] boolean value if custom direction should be used.

        :type theDirection: OCC.wrapper.gp.gp_Dir
        :type theUseDirection: bool

        """
        return _AIS.AIS_LengthDimension_SetDirection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_LengthDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_LengthDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_LengthDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_LengthDimension
AIS_LengthDimension_swigregister = _AIS.AIS_LengthDimension_swigregister
AIS_LengthDimension_swigregister(AIS_LengthDimension)

def AIS_LengthDimension_get_type_name(*args):
    """
    AIS_LengthDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_LengthDimension_get_type_name(*args)

def AIS_LengthDimension_get_type_descriptor(*args):
    """
    AIS_LengthDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_LengthDimension_get_type_descriptor(*args)

class AIS_PerpendicularRelation(AIS_Relation):
    """
    A framework to display constraints of perpendicularity
    between two or more interactive datums. These
    datums can be edges or faces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_PerpendicularRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_PerpendicularRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_PerpendicularRelation self, TopoDS_Shape aFShape, TopoDS_Shape aSShape, Handle_Geom_Plane aPlane) -> AIS_PerpendicularRelation
        __init__(AIS_PerpendicularRelation self, TopoDS_Shape aFShape, TopoDS_Shape aSShape) -> AIS_PerpendicularRelation

        Constructs an object to display constraints of
        perpendicularity on shapes.
        This object is defined by a first shape aFShape and a
        second shape aSShape.

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _AIS.new_AIS_PerpendicularRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_PerpendicularRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_PerpendicularRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_PerpendicularRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_PerpendicularRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_PerpendicularRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_PerpendicularRelation
AIS_PerpendicularRelation_swigregister = _AIS.AIS_PerpendicularRelation_swigregister
AIS_PerpendicularRelation_swigregister(AIS_PerpendicularRelation)

def AIS_PerpendicularRelation_get_type_name(*args):
    """
    AIS_PerpendicularRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_PerpendicularRelation_get_type_name(*args)

def AIS_PerpendicularRelation_get_type_descriptor(*args):
    """
    AIS_PerpendicularRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_PerpendicularRelation_get_type_descriptor(*args)

class AIS_ColoredDrawer(Prs3d.Prs3d_Drawer):
    """Customizable properties."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ColoredDrawer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ColoredDrawer(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ColoredDrawer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ColoredDrawer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ColoredDrawer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_ColoredDrawer self, Handle_Prs3d_Drawer theLink) -> AIS_ColoredDrawer

        Default constructor.

        :type theLink: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        this = _AIS.new_AIS_ColoredDrawer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsHidden(self, *args):
        """
        IsHidden(AIS_ColoredDrawer self) -> bool

        :rtype: bool

        """
        return _AIS.AIS_ColoredDrawer_IsHidden(self, *args)


    def SetHidden(self, *args):
        """
        SetHidden(AIS_ColoredDrawer self, bool const theToHide)

        :type theToHide: const bool

        """
        return _AIS.AIS_ColoredDrawer_SetHidden(self, *args)


    def HasOwnColor(self, *args):
        """
        HasOwnColor(AIS_ColoredDrawer self) -> bool

        :rtype: bool

        """
        return _AIS.AIS_ColoredDrawer_HasOwnColor(self, *args)


    def UnsetOwnColor(self, *args):
        """UnsetOwnColor(AIS_ColoredDrawer self)"""
        return _AIS.AIS_ColoredDrawer_UnsetOwnColor(self, *args)


    def SetOwnColor(self, *args):
        """
        SetOwnColor(AIS_ColoredDrawer self, Quantity_Color arg2)

        :type : OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_ColoredDrawer_SetOwnColor(self, *args)


    def HasOwnWidth(self, *args):
        """
        HasOwnWidth(AIS_ColoredDrawer self) -> bool

        :rtype: bool

        """
        return _AIS.AIS_ColoredDrawer_HasOwnWidth(self, *args)


    def UnsetOwnWidth(self, *args):
        """UnsetOwnWidth(AIS_ColoredDrawer self)"""
        return _AIS.AIS_ColoredDrawer_UnsetOwnWidth(self, *args)


    def SetOwnWidth(self, *args):
        """
        SetOwnWidth(AIS_ColoredDrawer self, Standard_Real const arg2)

        :type : float

        """
        return _AIS.AIS_ColoredDrawer_SetOwnWidth(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_ColoredDrawer
AIS_ColoredDrawer_swigregister = _AIS.AIS_ColoredDrawer_swigregister
AIS_ColoredDrawer_swigregister(AIS_ColoredDrawer)

def AIS_ColoredDrawer_get_type_name(*args):
    """
    AIS_ColoredDrawer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ColoredDrawer_get_type_name(*args)

def AIS_ColoredDrawer_get_type_descriptor(*args):
    """
    AIS_ColoredDrawer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ColoredDrawer_get_type_descriptor(*args)

class AIS_Chamf3dDimension(AIS_Relation):
    """
    A framework to define display of 3D chamfers.
    A chamfer is displayed with arrows and text. The text
    gives the length of the chamfer if it is a symmetrical
    chamfer, or the angle if it is not.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Chamf3dDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Chamf3dDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_Chamf3dDimension self, TopoDS_Shape aFShape, Standard_Real const aVal, TCollection_ExtendedString aText) -> AIS_Chamf3dDimension
        __init__(AIS_Chamf3dDimension self, TopoDS_Shape aFShape, Standard_Real const aVal, TCollection_ExtendedString aText, gp_Pnt aPosition, DsgPrs_ArrowSide const aSymbolPrs, Standard_Real const anArrowSize=0.0) -> AIS_Chamf3dDimension

        Constructs a display object for 3D chamfers.
        This object is defined by the shape aFShape, the
        dimension aVal, the text aText, the point of origin of
        the chamfer aPosition, the type of arrow aSymbolPrs
        with the size anArrowSize.

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aVal: float
        :type aText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aPosition: OCC.wrapper.gp.gp_Pnt
        :type aSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide
        :type anArrowSize: float

        """
        this = _AIS.new_AIS_Chamf3dDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def KindOfDimension(self, *args):
        """
        KindOfDimension(AIS_Chamf3dDimension self) -> AIS_KindOfDimension

        Indicates that we are concerned with a 3d length.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.AIS_Chamf3dDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the 3d chamfer dimension is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Chamf3dDimension_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_Chamf3dDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_Chamf3dDimension_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Chamf3dDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Chamf3dDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Chamf3dDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_Chamf3dDimension
AIS_Chamf3dDimension_swigregister = _AIS.AIS_Chamf3dDimension_swigregister
AIS_Chamf3dDimension_swigregister(AIS_Chamf3dDimension)

def AIS_Chamf3dDimension_get_type_name(*args):
    """
    AIS_Chamf3dDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Chamf3dDimension_get_type_name(*args)

def AIS_Chamf3dDimension_get_type_descriptor(*args):
    """
    AIS_Chamf3dDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Chamf3dDimension_get_type_descriptor(*args)

class AIS_ColorScale(AIS_InteractiveObject):
    """
    Class for drawing a custom color scale.

    The color scale consists of rectangular color bar (composed of fixed
    number of color intervals), optional labels, and title.
    The labels can be positioned either at the boundaries of the intervals,
    or at the middle of each interval.
    Colors and labels can be either defined automatically or set by the user.
    Automatic labels are calculated from numerical limits of the scale,
    its type (logarithmic or plain), and formatted by specified format string.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ColorScale
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ColorScale(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ColorScale_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ColorScale_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ColorScale_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def hueToValidRange(*args):
        """
        hueToValidRange(Standard_Real const theHue) -> Standard_Real

        Shift hue into valid range.
        Lightness and Saturation should be specified in valid range [0.0, 1.0],
        however Hue might be given out of Quantity_Color range to specify desired range for interpolation.

        :type theHue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_ColorScale_hueToValidRange(*args)

    hueToValidRange = staticmethod(hueToValidRange)

    def __init__(self, *args):
        """
        __init__(AIS_ColorScale self) -> AIS_ColorScale

        Default constructor.


        """
        this = _AIS.new_AIS_ColorScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        #self.handle




    def FindColor(self, *args):
        """
        FindColor(AIS_ColorScale self, Standard_Real const theValue, Standard_Real const theMin, Standard_Real const theMax, Standard_Integer const theColorsCount, NCollection_Vec3_Standard_Real theColorHlsMin, NCollection_Vec3_Standard_Real theColorHlsMax, Quantity_Color theColor) -> Standard_Boolean
        FindColor(AIS_ColorScale self, Standard_Real const theValue, Standard_Real const theMin, Standard_Real const theMax, Standard_Integer const theColorsCount, Quantity_Color theColor) -> Standard_Boolean
        FindColor(AIS_ColorScale self, Standard_Real const theValue, Quantity_Color theColor) -> Standard_Boolean

        Calculate color according passed value; returns true if value is in range or false, if isn't

        :type theValue: float
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ColorScale_FindColor(self, *args)


    def GetMin(self, *args):
        """
        GetMin(AIS_ColorScale self) -> Standard_Real

        Returns minimal value of color scale, 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_ColorScale_GetMin(self, *args)


    def SetMin(self, *args):
        """
        SetMin(AIS_ColorScale self, Standard_Real const theMin)

        Sets the minimal value of color scale.

        :type theMin: float

        """
        return _AIS.AIS_ColorScale_SetMin(self, *args)


    def GetMax(self, *args):
        """
        GetMax(AIS_ColorScale self) -> Standard_Real

        Returns maximal value of color scale, 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_ColorScale_GetMax(self, *args)


    def SetMax(self, *args):
        """
        SetMax(AIS_ColorScale self, Standard_Real const theMax)

        Sets the maximal value of color scale.

        :type theMax: float

        """
        return _AIS.AIS_ColorScale_SetMax(self, *args)


    def GetRange(self, *args):
        """
        GetRange(AIS_ColorScale self)

        Returns minimal and maximal values of color scale, 0.0 to 1.0 by default.

        :type theMin: float
        :type theMax: float

        """
        return _AIS.AIS_ColorScale_GetRange(self, *args)


    def SetRange(self, *args):
        """
        SetRange(AIS_ColorScale self, Standard_Real const theMin, Standard_Real const theMax)

        Sets the minimal and maximal value of color scale.
        Note that values order will be ignored - the minimum and maximum values will be swapped if needed.
        ::SetReversed() should be called to swap displaying order.

        :type theMin: float
        :type theMax: float

        """
        return _AIS.AIS_ColorScale_SetRange(self, *args)


    def HueMin(self, *args):
        """
        HueMin(AIS_ColorScale self) -> Standard_Real

        Returns the hue angle corresponding to minimum value, 230 by default (blue).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_ColorScale_HueMin(self, *args)


    def HueMax(self, *args):
        """
        HueMax(AIS_ColorScale self) -> Standard_Real

        Returns the hue angle corresponding to maximum value, 0 by default (red).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_ColorScale_HueMax(self, *args)


    def HueRange(self, *args):
        """
        HueRange(AIS_ColorScale self)

        Returns the hue angle range corresponding to minimum and maximum values, 230 to 0 by default (blue to red).

        :type theMinAngle: float
        :type theMaxAngle: float

        """
        return _AIS.AIS_ColorScale_HueRange(self, *args)


    def SetHueRange(self, *args):
        """
        SetHueRange(AIS_ColorScale self, Standard_Real const theMinAngle, Standard_Real const theMaxAngle)

        Sets hue angle range corresponding to minimum and maximum values.
        The valid angle range is [0, 360], see Quantity_Color and Quantity_TOC_HLS for more details.

        :type theMinAngle: float
        :type theMaxAngle: float

        """
        return _AIS.AIS_ColorScale_SetHueRange(self, *args)


    def ColorRange(self, *args):
        """
        ColorRange(AIS_ColorScale self, Quantity_Color theMinColor, Quantity_Color theMaxColor)

        Returns color range corresponding to minimum and maximum values, blue to red by default.

        :type theMinColor: OCC.wrapper.Quantity.Quantity_Color
        :type theMaxColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_ColorScale_ColorRange(self, *args)


    def SetColorRange(self, *args):
        """
        SetColorRange(AIS_ColorScale self, Quantity_Color theMinColor, Quantity_Color theMaxColor)

        Sets color range corresponding to minimum and maximum values.

        :type theMinColor: OCC.wrapper.Quantity.Quantity_Color
        :type theMaxColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_ColorScale_SetColorRange(self, *args)


    def GetLabelType(self, *args):
        """
        GetLabelType(AIS_ColorScale self) -> Aspect_TypeOfColorScaleData

        Returns the type of labels, Aspect_TOCSD_AUTO by default.
        Aspect_TOCSD_AUTO - labels as boundary values for intervals
        Aspect_TOCSD_USER - user specified label is used

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.AIS_ColorScale_GetLabelType(self, *args)


    def SetLabelType(self, *args):
        """
        SetLabelType(AIS_ColorScale self, Aspect_TypeOfColorScaleData const theType)

        Sets the type of labels.
        Aspect_TOCSD_AUTO - labels as boundary values for intervals
        Aspect_TOCSD_USER - user specified label is used

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.AIS_ColorScale_SetLabelType(self, *args)


    def GetColorType(self, *args):
        """
        GetColorType(AIS_ColorScale self) -> Aspect_TypeOfColorScaleData

        Returns the type of colors, Aspect_TOCSD_AUTO by default.
        Aspect_TOCSD_AUTO - value between Red and Blue
        Aspect_TOCSD_USER - user specified color from color map

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.AIS_ColorScale_GetColorType(self, *args)


    def SetColorType(self, *args):
        """
        SetColorType(AIS_ColorScale self, Aspect_TypeOfColorScaleData const theType)

        Sets the type of colors.
        Aspect_TOCSD_AUTO - value between Red and Blue
        Aspect_TOCSD_USER - user specified color from color map

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.AIS_ColorScale_SetColorType(self, *args)


    def GetNumberOfIntervals(self, *args):
        """
        GetNumberOfIntervals(AIS_ColorScale self) -> Standard_Integer

        Returns the number of color scale intervals, 10 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_GetNumberOfIntervals(self, *args)


    def SetNumberOfIntervals(self, *args):
        """
        SetNumberOfIntervals(AIS_ColorScale self, Standard_Integer const theNum)

        Sets the number of color scale intervals.

        :type theNum: int

        """
        return _AIS.AIS_ColorScale_SetNumberOfIntervals(self, *args)


    def GetTitle(self, *args):
        """
        Returns the color scale title string, empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.AIS_ColorScale_GetTitle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTitle(self, *args):
        """
        SetTitle(AIS_ColorScale self, TCollection_ExtendedString theTitle)

        Sets the color scale title string.

        :type theTitle: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.AIS_ColorScale_SetTitle(self, *args)


    def GetFormat(self, *args):
        """
        Returns the format for numbers, "%.4g" by default.
        The same like format for function printf().
        Used if GetLabelType() is TOCSD_AUTO;

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_ColorScale_GetFormat(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Format(self, *args):
        """
        Returns the format of text.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_ColorScale_Format(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFormat(self, *args):
        """
        SetFormat(AIS_ColorScale self, TCollection_AsciiString theFormat)

        Sets the color scale auto label format specification.

        :type theFormat: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_ColorScale_SetFormat(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(AIS_ColorScale self, Standard_Integer const theIndex) -> TCollection_ExtendedString

        Returns the user specified label with index theIndex.
        Index is in range from 1 to GetNumberOfIntervals() or to
        GetNumberOfIntervals() + 1 if IsLabelAtBorder() is true.
        Returns empty string if label not defined.

        :type theIndex: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.AIS_ColorScale_GetLabel(self, *args)


    def GetIntervalColor(self, *args):
        """
        GetIntervalColor(AIS_ColorScale self, Standard_Integer const theIndex) -> Quantity_Color

        Returns the user specified color from color map with index (starts at 1).
        Returns default color if index is out of range in color map.

        :type theIndex: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_ColorScale_GetIntervalColor(self, *args)


    def SetIntervalColor(self, *args):
        """
        SetIntervalColor(AIS_ColorScale self, Quantity_Color theColor, Standard_Integer const theIndex)

        Sets the color of the specified interval. 
        Note that list is automatically resized to include specified index.
        @param theColor color value to set
        @param theIndex index in range [1, GetNumberOfIntervals()];
        appended to the end of list if -1 is specified

        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theIndex: int

        """
        return _AIS.AIS_ColorScale_SetIntervalColor(self, *args)


    def GetLabels(self, *args):
        """
        GetLabels(AIS_ColorScale self, NCollection_Sequence_TCollection_ExtendedString theLabels)

        Returns the user specified labels.

        :type theLabels: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _AIS.AIS_ColorScale_GetLabels(self, *args)


    def Labels(self, *args):
        """
        Returns the user specified labels.

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _AIS.AIS_ColorScale_Labels(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLabels(self, *args):
        """
        SetLabels(AIS_ColorScale self, NCollection_Sequence_TCollection_ExtendedString theSeq)

        Sets the color scale labels.
        The length of the sequence should be equal to GetNumberOfIntervals() or to GetNumberOfIntervals() + 1 if IsLabelAtBorder() is true.
        If length of the sequence does not much the number of intervals,
        then these labels will be considered as "free" and will be located
        at the virtual intervals corresponding to the number of labels
        (with flag IsLabelAtBorder() having the same effect as in normal case).

        :type theSeq: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _AIS.AIS_ColorScale_SetLabels(self, *args)


    def GetColors(self, *args):
        """
        Returns the user specified colors.

        :rtype: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        res = _AIS.AIS_ColorScale_GetColors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(AIS_ColorScale self, NCollection_Sequence_Quantity_Color theSeq)

        Sets the color scale colors.
        The length of the sequence should be equal to GetNumberOfIntervals().

        :type theSeq: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        return _AIS.AIS_ColorScale_SetColors(self, *args)


    def GetLabelPosition(self, *args):
        """
        GetLabelPosition(AIS_ColorScale self) -> Aspect_TypeOfColorScalePosition

        Returns the position of labels concerning color filled rectangles, Aspect_TOCSP_RIGHT by default.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.AIS_ColorScale_GetLabelPosition(self, *args)


    def SetLabelPosition(self, *args):
        """
        SetLabelPosition(AIS_ColorScale self, Aspect_TypeOfColorScalePosition const thePos)

        Sets the color scale labels position relative to color bar.

        :type thePos: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.AIS_ColorScale_SetLabelPosition(self, *args)


    def GetTitlePosition(self, *args):
        """
        GetTitlePosition(AIS_ColorScale self) -> Aspect_TypeOfColorScalePosition

        Returns the position of color scale title, Aspect_TOCSP_LEFT by default.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.AIS_ColorScale_GetTitlePosition(self, *args)


    def SetTitlePosition(self, *args):
        """
        SetTitlePosition(AIS_ColorScale self, Aspect_TypeOfColorScalePosition const thePos)

        Sets the color scale title position.

        :type thePos: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.AIS_ColorScale_SetTitlePosition(self, *args)


    def IsReversed(self, *args):
        """
        IsReversed(AIS_ColorScale self) -> Standard_Boolean

        Returns TRUE if the labels and colors used in reversed order, FALSE by default.
        - Normal,   bottom-up order with Minimal value on the Bottom and Maximum value on Top.
        - Reversed, top-down  order with Maximum value on the Bottom and Minimum value on Top.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ColorScale_IsReversed(self, *args)


    def SetReversed(self, *args):
        """
        SetReversed(AIS_ColorScale self, Standard_Boolean const theReverse)

        Sets true if the labels and colors used in reversed order.

        :type theReverse: bool

        """
        return _AIS.AIS_ColorScale_SetReversed(self, *args)


    def IsSmoothTransition(self, *args):
        """
        IsSmoothTransition(AIS_ColorScale self) -> Standard_Boolean

        Return TRUE if color transition between neighbor intervals
        should be linearly interpolated, FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ColorScale_IsSmoothTransition(self, *args)


    def SetSmoothTransition(self, *args):
        """
        SetSmoothTransition(AIS_ColorScale self, Standard_Boolean const theIsSmooth)

        Setup smooth color transition.

        :type theIsSmooth: bool

        """
        return _AIS.AIS_ColorScale_SetSmoothTransition(self, *args)


    def IsLabelAtBorder(self, *args):
        """
        IsLabelAtBorder(AIS_ColorScale self) -> Standard_Boolean

        Returns TRUE if the labels are placed at border of color intervals, TRUE by default.
        The automatically generated label will show value exactly on the current position:
        - value connecting two neighbor intervals (TRUE)
        - value in the middle of interval (FALSE)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ColorScale_IsLabelAtBorder(self, *args)


    def SetLabelAtBorder(self, *args):
        """
        SetLabelAtBorder(AIS_ColorScale self, Standard_Boolean const theOn)

        Sets true if the labels are placed at border of color intervals (TRUE by default).
        If set to False, labels will be drawn at color intervals rather than at borders.

        :type theOn: bool

        """
        return _AIS.AIS_ColorScale_SetLabelAtBorder(self, *args)


    def IsLogarithmic(self, *args):
        """
        IsLogarithmic(AIS_ColorScale self) -> Standard_Boolean

        Returns TRUE if the color scale has logarithmic intervals, FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ColorScale_IsLogarithmic(self, *args)


    def SetLogarithmic(self, *args):
        """
        SetLogarithmic(AIS_ColorScale self, Standard_Boolean const isLogarithmic)

        Sets true if the color scale has logarithmic intervals.

        :type isLogarithmic: bool

        """
        return _AIS.AIS_ColorScale_SetLogarithmic(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(AIS_ColorScale self, TCollection_ExtendedString theLabel, Standard_Integer const theIndex)

        Sets the color scale label at index.
        Note that list is automatically resized to include specified index.
        @param theLabel new label text
        @param theIndex index in range [1, GetNumberOfIntervals()] or [1, GetNumberOfIntervals() + 1] if IsLabelAtBorder() is true;
        label is appended to the end of list if negative index is specified

        :type theLabel: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theIndex: int

        """
        return _AIS.AIS_ColorScale_SetLabel(self, *args)


    def GetSize(self, *args):
        """
        GetSize(AIS_ColorScale self)

        Returns the size of color bar, 0 and 0 by default
        (e.g. should be set by user explicitly before displaying).

        :type theBreadth: int
        :type theHeight: int

        """
        return _AIS.AIS_ColorScale_GetSize(self, *args)


    def SetSize(self, *args):
        """
        SetSize(AIS_ColorScale self, Standard_Integer const theBreadth, Standard_Integer const theHeight)

        Sets the size of color bar.

        :type theBreadth: int
        :type theHeight: int

        """
        return _AIS.AIS_ColorScale_SetSize(self, *args)


    def GetBreadth(self, *args):
        """
        GetBreadth(AIS_ColorScale self) -> Standard_Integer

        Returns the breadth of color bar, 0 by default
        (e.g. should be set by user explicitly before displaying).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_GetBreadth(self, *args)


    def SetBreadth(self, *args):
        """
        SetBreadth(AIS_ColorScale self, Standard_Integer const theBreadth)

        Sets the width of color bar.

        :type theBreadth: int

        """
        return _AIS.AIS_ColorScale_SetBreadth(self, *args)


    def GetHeight(self, *args):
        """
        GetHeight(AIS_ColorScale self) -> Standard_Integer

        Returns the height of color bar, 0 by default
        (e.g. should be set by user explicitly before displaying).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_GetHeight(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(AIS_ColorScale self, Standard_Integer const theHeight)

        Sets the height of color bar.

        :type theHeight: int

        """
        return _AIS.AIS_ColorScale_SetHeight(self, *args)


    def GetPosition(self, *args):
        """
        GetPosition(AIS_ColorScale self)

        Returns the bottom-left position of color scale, 0x0 by default.

        :type theX: float
        :type theY: float

        """
        return _AIS.AIS_ColorScale_GetPosition(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(AIS_ColorScale self, Standard_Integer const theX, Standard_Integer const theY)

        Sets the position of color scale.

        :type theX: int
        :type theY: int

        """
        return _AIS.AIS_ColorScale_SetPosition(self, *args)


    def GetXPosition(self, *args):
        """
        GetXPosition(AIS_ColorScale self) -> Standard_Integer

        Returns the left position of color scale, 0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_GetXPosition(self, *args)


    def SetXPosition(self, *args):
        """
        SetXPosition(AIS_ColorScale self, Standard_Integer const theX)

        Sets the left position of color scale.

        :type theX: int

        """
        return _AIS.AIS_ColorScale_SetXPosition(self, *args)


    def GetYPosition(self, *args):
        """
        GetYPosition(AIS_ColorScale self) -> Standard_Integer

        Returns the bottom position of color scale, 0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_GetYPosition(self, *args)


    def SetYPosition(self, *args):
        """
        SetYPosition(AIS_ColorScale self, Standard_Integer const theY)

        Sets the bottom position of color scale.

        :type theY: int

        """
        return _AIS.AIS_ColorScale_SetYPosition(self, *args)


    def GetTextHeight(self, *args):
        """
        GetTextHeight(AIS_ColorScale self) -> Standard_Integer

        Returns the font height of text labels, 20 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_GetTextHeight(self, *args)


    def SetTextHeight(self, *args):
        """
        SetTextHeight(AIS_ColorScale self, Standard_Integer const theHeight)

        Sets the height of text of color scale.

        :type theHeight: int

        """
        return _AIS.AIS_ColorScale_SetTextHeight(self, *args)


    def TextWidth(self, *args):
        """
        TextWidth(AIS_ColorScale self, TCollection_ExtendedString theText) -> Standard_Integer

        Returns the width of text.
        @param theText [in] the text of which to calculate width.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_TextWidth(self, *args)


    def TextHeight(self, *args):
        """
        TextHeight(AIS_ColorScale self, TCollection_ExtendedString theText) -> Standard_Integer

        Returns the height of text.
        @param theText [in] the text of which to calculate height.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ColorScale_TextHeight(self, *args)


    def TextSize(self, *args):
        """
        TextSize(AIS_ColorScale self, TCollection_ExtendedString theText, Standard_Integer const theHeight)

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theHeight: int
        :type theWidth: int
        :type theAscent: int
        :type theDescent: int

        """
        return _AIS.AIS_ColorScale_TextSize(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_ColorScale self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if specified display mode is supported.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ColorScale_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_ColorScale self, Handle_PrsMgr_PresentationManager thePresentationManager, Handle_Prs3d_Presentation thePresentation, Standard_Integer const theMode)

        Compute presentation.

        :type thePresentationManager: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theMode: int

        """
        return _AIS.AIS_ColorScale_Compute(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_ColorScale
AIS_ColorScale_swigregister = _AIS.AIS_ColorScale_swigregister
AIS_ColorScale_swigregister(AIS_ColorScale)

def AIS_ColorScale_get_type_name(*args):
    """
    AIS_ColorScale_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ColorScale_get_type_name(*args)

def AIS_ColorScale_get_type_descriptor(*args):
    """
    AIS_ColorScale_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ColorScale_get_type_descriptor(*args)

def AIS_ColorScale_hueToValidRange(*args):
    """
    AIS_ColorScale_hueToValidRange(Standard_Real const theHue) -> Standard_Real

    Shift hue into valid range.
    Lightness and Saturation should be specified in valid range [0.0, 1.0],
    however Hue might be given out of Quantity_Color range to specify desired range for interpolation.

    :type theHue: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _AIS.AIS_ColorScale_hueToValidRange(*args)

class AIS_ManipulatorObjectSequence(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ManipulatorObjectSequence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ManipulatorObjectSequence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_ManipulatorObjectSequence self) -> AIS_ManipulatorObjectSequence
        __init__(AIS_ManipulatorObjectSequence self, NCollection_Sequence_Handle_AIS_InteractiveObject theOther) -> AIS_ManipulatorObjectSequence

        :type theOther: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject

        """
        this = _AIS.new_AIS_ManipulatorObjectSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject

        """
        res = _AIS.AIS_ManipulatorObjectSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(AIS_ManipulatorObjectSequence self, Handle_AIS_InteractiveObject theItem)
        Append(AIS_ManipulatorObjectSequence self, NCollection_Sequence_Handle_AIS_InteractiveObject theSequence)

        :type theSequence: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_ManipulatorObjectSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(AIS_ManipulatorObjectSequence self) -> NCollection_Sequence_Handle_AIS_InteractiveObject

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_ManipulatorObjectSequence_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ManipulatorObjectSequence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ManipulatorObjectSequence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ManipulatorObjectSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_ManipulatorObjectSequence
AIS_ManipulatorObjectSequence_swigregister = _AIS.AIS_ManipulatorObjectSequence_swigregister
AIS_ManipulatorObjectSequence_swigregister(AIS_ManipulatorObjectSequence)

def AIS_ManipulatorObjectSequence_get_type_name(*args):
    """
    AIS_ManipulatorObjectSequence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ManipulatorObjectSequence_get_type_name(*args)

def AIS_ManipulatorObjectSequence_get_type_descriptor(*args):
    """
    AIS_ManipulatorObjectSequence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ManipulatorObjectSequence_get_type_descriptor(*args)

class AIS_Selection(Standard.Standard_Transient):
    """Class holding the list of selected owners."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Selection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Selection(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Selection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Selection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Selection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Selection self) -> AIS_Selection

        creates a new selection.


        """
        this = _AIS.new_AIS_Selection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(AIS_Selection self)

        removes all the object of the selection.


        """
        return _AIS.AIS_Selection_Clear(self, *args)


    def Select(self, *args):
        """
        Select(AIS_Selection self, Handle_SelectMgr_EntityOwner theObject) -> AIS_SelectStatus

        if the object is not yet in the selection, it will be added.
        if the object is already in the selection, it will be removed.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.AIS.AIS_SelectStatus

        """
        return _AIS.AIS_Selection_Select(self, *args)


    def AddSelect(self, *args):
        """
        AddSelect(AIS_Selection self, Handle_SelectMgr_EntityOwner theObject) -> AIS_SelectStatus

        the object is always add int the selection.
        faster when the number of objects selected is great.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.AIS.AIS_SelectStatus

        """
        return _AIS.AIS_Selection_AddSelect(self, *args)


    def ClearAndSelect(self, *args):
        """
        ClearAndSelect(AIS_Selection self, Handle_SelectMgr_EntityOwner theObject)

        clears the selection and adds the object in the selection.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_Selection_ClearAndSelect(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(AIS_Selection self, Handle_SelectMgr_EntityOwner theObject) -> Standard_Boolean

        checks if the object is in the selection.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Selection_IsSelected(self, *args)


    def Objects(self, *args):
        """
        Return the list of selected objects.

        :rtype: OCC.wrapper.AIS.AIS_NListOfEntityOwner

        """
        res = _AIS.AIS_Selection_Objects(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Extent(self, *args):
        """
        Extent(AIS_Selection self) -> Standard_Integer

        Return the number of selected objects.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Selection_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(AIS_Selection self) -> Standard_Boolean

        Return true if list of selected objects is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Selection_IsEmpty(self, *args)


    def Init(self, *args):
        """
        Init(AIS_Selection self)

        Start iteration through selected objects.


        """
        return _AIS.AIS_Selection_Init(self, *args)


    def More(self, *args):
        """
        More(AIS_Selection self) -> Standard_Boolean

        Return true if iterator points to selected object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Selection_More(self, *args)


    def Next(self, *args):
        """
        Next(AIS_Selection self)

        Continue iteration through selected objects.


        """
        return _AIS.AIS_Selection_Next(self, *args)


    def Value(self, *args):
        """
        Return selected object at iterator position.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.AIS_Selection_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_Selection
AIS_Selection_swigregister = _AIS.AIS_Selection_swigregister
AIS_Selection_swigregister(AIS_Selection)

def AIS_Selection_get_type_name(*args):
    """
    AIS_Selection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Selection_get_type_name(*args)

def AIS_Selection_get_type_descriptor(*args):
    """
    AIS_Selection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Selection_get_type_descriptor(*args)

class AIS_DimensionOwner(SelectMgr.SelectMgr_EntityOwner):
    """
    The owner is the entity which makes it possible to link
    the sensitive primitives and the reference shapes that
    you want to detect. It stocks the various pieces of
    information which make it possible to find objects. An
    owner has a priority which you can modulate, so as to
    make one entity more selectable than another. You
    might want to make edges more selectable than
    faces, for example. In that case, you could attribute sa
    higher priority to the one compared to the other. An
    edge, could have priority 5, for example, and a face,
    priority 4. The default priority is 5.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_DimensionOwner
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_DimensionOwner(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_DimensionOwner_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_DimensionOwner_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_DimensionOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_DimensionOwner self, Handle_SelectMgr_SelectableObject theSelObject, AIS_DimensionSelectionMode const theSelMode, Standard_Integer const thePriority=0) -> AIS_DimensionOwner

        Initializes the dimension owner, theSO, and attributes it
        the priority, thePriority.

        :type theSelObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theSelMode: OCC.wrapper.AIS.AIS_DimensionSelectionMode
        :type thePriority: int

        """
        this = _AIS.new_AIS_DimensionOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SelectionMode(self, *args):
        """
        SelectionMode(AIS_DimensionOwner self) -> AIS_DimensionSelectionMode

        :rtype: OCC.wrapper.AIS.AIS_DimensionSelectionMode

        """
        return _AIS.AIS_DimensionOwner_SelectionMode(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(AIS_DimensionOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode=0)

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _AIS.AIS_DimensionOwner_HilightWithColor(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(AIS_DimensionOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode=0) -> Standard_Boolean

        Returns true if an object with the selection mode
        aMode is highlighted in the presentation manager aPM.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_DimensionOwner_IsHilighted(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(AIS_DimensionOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode=0)

        Removes highlighting from the selected part of dimension.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _AIS.AIS_DimensionOwner_Unhilight(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_DimensionOwner
AIS_DimensionOwner_swigregister = _AIS.AIS_DimensionOwner_swigregister
AIS_DimensionOwner_swigregister(AIS_DimensionOwner)

def AIS_DimensionOwner_get_type_name(*args):
    """
    AIS_DimensionOwner_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_DimensionOwner_get_type_name(*args)

def AIS_DimensionOwner_get_type_descriptor(*args):
    """
    AIS_DimensionOwner_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_DimensionOwner_get_type_descriptor(*args)

class AIS_Line(AIS_InteractiveObject):
    """
    Constructs line datums to be used in construction of
    composite shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Line
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Line(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Line_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Line_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Line self, Handle_Geom_Line aLine) -> AIS_Line
        __init__(AIS_Line self, Handle_Geom_Point aStartPoint, Handle_Geom_Point aEndPoint) -> AIS_Line

        Initializes a starting point aStartPoint
        and a finishing point aEndPoint for the line.

        :type aStartPoint: OCC.wrapper.Geom.Handle_Geom_Point
        :type aEndPoint: OCC.wrapper.Geom.Handle_Geom_Point

        """
        this = _AIS.new_AIS_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_Line self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_Line_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_Line self) -> Standard_Integer

        Returns the signature 5.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Line_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Line self) -> AIS_KindOfInteractive

        Returns the type Datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Line_Type(self, *args)


    def Line(self, *args):
        """
        Constructs an infinite line.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Line

        """
        res = _AIS.AIS_Line_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Points(self, *args):
        """
        Points(AIS_Line self, Handle_Geom_Point thePStart, Handle_Geom_Point thePEnd)

        Returns the starting point thePStart and the end point thePEnd of the line set by SetPoints.

        :type thePStart: OCC.wrapper.Geom.Handle_Geom_Point
        :type thePEnd: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.AIS_Line_Points(self, *args)


    def SetLine(self, *args):
        """
        SetLine(AIS_Line self, Handle_Geom_Line theLine)

        instantiates an infinite line.

        :type theLine: OCC.wrapper.Geom.Handle_Geom_Line

        """
        return _AIS.AIS_Line_SetLine(self, *args)


    def SetPoints(self, *args):
        """
        SetPoints(AIS_Line self, Handle_Geom_Point thePStart, Handle_Geom_Point thePEnd)

        Sets the starting point thePStart and ending point thePEnd of the
        infinite line to create a finite line segment.

        :type thePStart: OCC.wrapper.Geom.Handle_Geom_Point
        :type thePEnd: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.AIS_Line_SetPoints(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_Line self, Quantity_Color aColor)

        Provides a new color setting aColor for the line in the drawing tool, or "Drawer".

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Line_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_Line self, Standard_Real const aValue)

        Provides the new width setting aValue for the line in
        the drawing tool, or "Drawer".

        :type aValue: float

        """
        return _AIS.AIS_Line_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Line self)

        Removes the color setting and returns the original color.


        """
        return _AIS.AIS_Line_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(AIS_Line self)

        Removes the width setting and returns the original width.


        """
        return _AIS.AIS_Line_UnsetWidth(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Line
AIS_Line_swigregister = _AIS.AIS_Line_swigregister
AIS_Line_swigregister(AIS_Line)

def AIS_Line_get_type_name(*args):
    """
    AIS_Line_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Line_get_type_name(*args)

def AIS_Line_get_type_descriptor(*args):
    """
    AIS_Line_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Line_get_type_descriptor(*args)

class AIS_ConcentricRelation(AIS_Relation):
    """
    A framework to define a constraint by a relation of
    concentricity between two or more interactive datums.
    The display of this constraint is also defined.
    A plane is used to create an axis along which the
    relation of concentricity can be extended.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ConcentricRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ConcentricRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_ConcentricRelation self, TopoDS_Shape aFShape, TopoDS_Shape aSShape, Handle_Geom_Plane aPlane) -> AIS_ConcentricRelation

        Constructs the display object for concentric relations
        between shapes.
        This object is defined by the two shapes, aFShape
        and aSShape and the plane aPlane.
        aPlane is provided to create an axis along which the
        relation of concentricity can be extended.

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        this = _AIS.new_AIS_ConcentricRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_ConcentricRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_ConcentricRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ConcentricRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ConcentricRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ConcentricRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_ConcentricRelation
AIS_ConcentricRelation_swigregister = _AIS.AIS_ConcentricRelation_swigregister
AIS_ConcentricRelation_swigregister(AIS_ConcentricRelation)

def AIS_ConcentricRelation_get_type_name(*args):
    """
    AIS_ConcentricRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ConcentricRelation_get_type_name(*args)

def AIS_ConcentricRelation_get_type_descriptor(*args):
    """
    AIS_ConcentricRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ConcentricRelation_get_type_descriptor(*args)

class AIS_MaxRadiusDimension(AIS_EllipseRadiusDimension):
    """
    Ellipse  Max  radius  dimension  of  a  Shape  which  can  be  Edge
    or  Face  (planar  or  cylindrical(surface  of  extrusion  or
    surface  of  offset))
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_MaxRadiusDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_MaxRadiusDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_MaxRadiusDimension self, TopoDS_Shape aShape, Standard_Real const aVal, TCollection_ExtendedString aText) -> AIS_MaxRadiusDimension
        __init__(AIS_MaxRadiusDimension self, TopoDS_Shape aShape, Standard_Real const aVal, TCollection_ExtendedString aText, gp_Pnt aPosition, DsgPrs_ArrowSide const aSymbolPrs, Standard_Real const anArrowSize=0.0) -> AIS_MaxRadiusDimension

        Max  Ellipse  radius dimension with  position
        Shape  can  be  edge  ,  planar  face  or  cylindrical  face

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aVal: float
        :type aText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aPosition: OCC.wrapper.gp.gp_Pnt
        :type aSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide
        :type anArrowSize: float

        """
        this = _AIS.new_AIS_MaxRadiusDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_MaxRadiusDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_MaxRadiusDimension_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_MaxRadiusDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_MaxRadiusDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_MaxRadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_MaxRadiusDimension
AIS_MaxRadiusDimension_swigregister = _AIS.AIS_MaxRadiusDimension_swigregister
AIS_MaxRadiusDimension_swigregister(AIS_MaxRadiusDimension)

def AIS_MaxRadiusDimension_get_type_name(*args):
    """
    AIS_MaxRadiusDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_MaxRadiusDimension_get_type_name(*args)

def AIS_MaxRadiusDimension_get_type_descriptor(*args):
    """
    AIS_MaxRadiusDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_MaxRadiusDimension_get_type_descriptor(*args)

class AIS_C0RegularityFilter(SelectMgr.SelectMgr_Filter):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_C0RegularityFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_C0RegularityFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_C0RegularityFilter self, TopoDS_Shape aShape) -> AIS_C0RegularityFilter

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _AIS.new_AIS_C0RegularityFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ActsOn(self, *args):
        """
        ActsOn(AIS_C0RegularityFilter self, TopAbs_ShapeEnum const aType) -> Standard_Boolean

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_C0RegularityFilter_ActsOn(self, *args)


    def IsOk(self, *args):
        """
        IsOk(AIS_C0RegularityFilter self, Handle_SelectMgr_EntityOwner EO) -> Standard_Boolean

        :type EO: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_C0RegularityFilter_IsOk(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_C0RegularityFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_C0RegularityFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_C0RegularityFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_C0RegularityFilter
AIS_C0RegularityFilter_swigregister = _AIS.AIS_C0RegularityFilter_swigregister
AIS_C0RegularityFilter_swigregister(AIS_C0RegularityFilter)

def AIS_C0RegularityFilter_get_type_name(*args):
    """
    AIS_C0RegularityFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_C0RegularityFilter_get_type_name(*args)

def AIS_C0RegularityFilter_get_type_descriptor(*args):
    """
    AIS_C0RegularityFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_C0RegularityFilter_get_type_descriptor(*args)

class AIS_GlobalStatus(Standard.Standard_Transient):
    """
    Stores  information  about objects in graphic context:
    - Status Of Display : in the main viewer
    hidden in the main viewer
    - Displayed Modes
    - Active Selection Modes
    - is the Interactive Object Current ?
    - Layer Index
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_GlobalStatus
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_GlobalStatus(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_GlobalStatus_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_GlobalStatus_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_GlobalStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_GlobalStatus self) -> AIS_GlobalStatus
        __init__(AIS_GlobalStatus self, AIS_DisplayStatus const aStat, Standard_Integer const aDispMode, Standard_Integer const aSelMode, Standard_Boolean const ishilighted, Standard_Integer const aLayerIndex=0) -> AIS_GlobalStatus

        :type aStat: OCC.wrapper.AIS.AIS_DisplayStatus
        :type aDispMode: int
        :type aSelMode: int
        :type ishilighted: bool
        :type aLayerIndex: int

        """
        this = _AIS.new_AIS_GlobalStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetGraphicStatus(self, *args):
        """
        SetGraphicStatus(AIS_GlobalStatus self, AIS_DisplayStatus const theStatus)

        :type theStatus: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.AIS_GlobalStatus_SetGraphicStatus(self, *args)


    def AddSelectionMode(self, *args):
        """
        AddSelectionMode(AIS_GlobalStatus self, Standard_Integer const theMode)

        :type theMode: int

        """
        return _AIS.AIS_GlobalStatus_AddSelectionMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(AIS_GlobalStatus self, Standard_Integer const theMode)

        Sets display mode.

        :type theMode: int

        """
        return _AIS.AIS_GlobalStatus_SetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(AIS_GlobalStatus self) -> Standard_Integer

        Returns the display mode.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_GlobalStatus_DisplayMode(self, *args)


    def SetLayerIndex(self, *args):
        """
        SetLayerIndex(AIS_GlobalStatus self, Standard_Integer const theIndex)

        :type theIndex: int

        """
        return _AIS.AIS_GlobalStatus_SetLayerIndex(self, *args)


    def SetHilightStatus(self, *args):
        """
        SetHilightStatus(AIS_GlobalStatus self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.AIS_GlobalStatus_SetHilightStatus(self, *args)


    def SetHilightStyle(self, *args):
        """
        SetHilightStyle(AIS_GlobalStatus self, Handle_Prs3d_Drawer theStyle)

        Changes applied highlight style for a particular object

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.AIS_GlobalStatus_SetHilightStyle(self, *args)


    def HilightStyle(self, *args):
        """
        Returns applied highlight style for a particular object

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.AIS_GlobalStatus_HilightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsSubIntensityOn(self, *args):
        """
        IsSubIntensityOn(AIS_GlobalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_GlobalStatus_IsSubIntensityOn(self, *args)


    def SubIntensityOn(self, *args):
        """SubIntensityOn(AIS_GlobalStatus self)"""
        return _AIS.AIS_GlobalStatus_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """SubIntensityOff(AIS_GlobalStatus self)"""
        return _AIS.AIS_GlobalStatus_SubIntensityOff(self, *args)


    def RemoveSelectionMode(self, *args):
        """
        RemoveSelectionMode(AIS_GlobalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.AIS_GlobalStatus_RemoveSelectionMode(self, *args)


    def ClearSelectionModes(self, *args):
        """ClearSelectionModes(AIS_GlobalStatus self)"""
        return _AIS.AIS_GlobalStatus_ClearSelectionModes(self, *args)


    def GraphicStatus(self, *args):
        """
        GraphicStatus(AIS_GlobalStatus self) -> AIS_DisplayStatus

        :rtype: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.AIS_GlobalStatus_GraphicStatus(self, *args)


    def SelectionModes(self, *args):
        """
        keeps the active selection modes of the object
        in the main viewer.

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.AIS_GlobalStatus_SelectionModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsHilighted(self, *args):
        """
        IsHilighted(AIS_GlobalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_GlobalStatus_IsHilighted(self, *args)


    def IsSModeIn(self, *args):
        """
        IsSModeIn(AIS_GlobalStatus self, Standard_Integer const aMode) -> Standard_Boolean

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_GlobalStatus_IsSModeIn(self, *args)


    def GetLayerIndex(self, *args):
        """
        GetLayerIndex(AIS_GlobalStatus self) -> Standard_Integer

        Returns layer index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_GlobalStatus_GetLayerIndex(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_GlobalStatus
AIS_GlobalStatus_swigregister = _AIS.AIS_GlobalStatus_swigregister
AIS_GlobalStatus_swigregister(AIS_GlobalStatus)

def AIS_GlobalStatus_get_type_name(*args):
    """
    AIS_GlobalStatus_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_GlobalStatus_get_type_name(*args)

def AIS_GlobalStatus_get_type_descriptor(*args):
    """
    AIS_GlobalStatus_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_GlobalStatus_get_type_descriptor(*args)

class AIS_TexturedShape(AIS_Shape):
    """
    This class allows to map textures on shapes.
    Presentations modes AIS_WireFrame (0) and AIS_Shaded (1) behave in the same manner as in AIS_Shape,
    whilst new modes 2 (bounding box) and 3 (texture mapping) extends it functionality.

    The texture itself is parametrized in (0,1)x(0,1).
    Each face of a shape located in UV space is provided with these parameters:
    - Umin - starting position in U
    - Umax - ending   position in U
    - Vmin - starting position in V
    - Vmax - ending   position in V
    Each face is triangulated and a texel is assigned to each node.
    Facets are then filled using a linear interpolation of texture between each 'three texels'.
    User can act on:
    - the number of occurrences of the texture on the face
    - the position of the origin of the texture
    - the scale factor of the texture
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_TexturedShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_TexturedShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_TexturedShape self, TopoDS_Shape theShape) -> AIS_TexturedShape

        Initializes the textured shape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _AIS.new_AIS_TexturedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetTextureFileName(self, *args):
        """
        SetTextureFileName(AIS_TexturedShape self, TCollection_AsciiString theTextureFileName)

        Sets the texture source. <theTextureFileName> can specify path to texture image or one of the standard predefined textures.
        The accepted file types are those used in Image_AlienPixMap with extensions such as rgb, png, jpg and more.
        To specify the standard predefined texture, the <theTextureFileName> should contain integer - the Graphic3d_NameOfTexture2D enumeration index.
        Setting texture source using this method resets the source pixmap (if was set previously).

        :type theTextureFileName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_TexturedShape_SetTextureFileName(self, *args)


    def SetTexturePixMap(self, *args):
        """
        SetTexturePixMap(AIS_TexturedShape self, Handle_Image_PixMap theTexturePixMap)

        Sets the texture source. <theTexturePixMap> specifies image data.
        Please note that the data should be in Bottom-Up order, the flag of Image_PixMap::IsTopDown() will be ignored by graphic driver.
        Setting texture source using this method resets the source by filename (if was set previously).

        :type theTexturePixMap: OCC.wrapper.Image.Handle_Image_PixMap

        """
        return _AIS.AIS_TexturedShape_SetTexturePixMap(self, *args)


    def TextureMapState(self, *args):
        """
        TextureMapState(AIS_TexturedShape self) -> Standard_Boolean

        @return flag to control texture mapping (for presentation mode 3)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TexturedShape_TextureMapState(self, *args)


    def SetTextureMapOn(self, *args):
        """
        SetTextureMapOn(AIS_TexturedShape self)

        Enables texture mapping


        """
        return _AIS.AIS_TexturedShape_SetTextureMapOn(self, *args)


    def SetTextureMapOff(self, *args):
        """
        SetTextureMapOff(AIS_TexturedShape self)

        Disables texture mapping


        """
        return _AIS.AIS_TexturedShape_SetTextureMapOff(self, *args)


    def TextureFile(self, *args):
        """
        TextureFile(AIS_TexturedShape self) -> Standard_CString

        @return path to the texture file

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _AIS.AIS_TexturedShape_TextureFile(self, *args)


    def TexturePixMap(self, *args):
        """
        @return the source pixmap for texture map

        :rtype: OCC.wrapper.Image.Handle_Image_PixMap

        """
        res = _AIS.AIS_TexturedShape_TexturePixMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateAttributes(self, *args):
        """
        UpdateAttributes(AIS_TexturedShape self)

        Use this method to display the textured shape without recomputing the whole presentation.
        Use this method when ONLY the texture content has been changed.
        If other parameters (ie: scale factors, texture origin, texture repeat...) have changed, the whole presentation has to be recomputed:
        @code
        if (myShape->DisplayMode() == 3)
        {
        myAISContext->RecomputePrsOnly (myShape);
        }
        else
        {
        myAISContext->SetDisplayMode (myShape, 3, Standard_False);
        myAISContext->Display        (myShape, Standard_True);
        }
        @endcode


        """
        return _AIS.AIS_TexturedShape_UpdateAttributes(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_TexturedShape self, Quantity_Color theColor)

        Sets the color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_TexturedShape_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_TexturedShape self)

        Removes settings for the color.


        """
        return _AIS.AIS_TexturedShape_UnsetColor(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(AIS_TexturedShape self, Graphic3d_MaterialAspect theAspect)

        Sets the material aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.AIS_TexturedShape_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(AIS_TexturedShape self)

        Removes settings for material aspect.


        """
        return _AIS.AIS_TexturedShape_UnsetMaterial(self, *args)


    def EnableTextureModulate(self, *args):
        """
        EnableTextureModulate(AIS_TexturedShape self)

        Enables texture modulation


        """
        return _AIS.AIS_TexturedShape_EnableTextureModulate(self, *args)


    def DisableTextureModulate(self, *args):
        """
        DisableTextureModulate(AIS_TexturedShape self)

        Disables texture modulation


        """
        return _AIS.AIS_TexturedShape_DisableTextureModulate(self, *args)


    def TextureRepeat(self, *args):
        """
        TextureRepeat(AIS_TexturedShape self) -> Standard_Boolean

        @return texture repeat flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TexturedShape_TextureRepeat(self, *args)


    def URepeat(self, *args):
        """
        URepeat(AIS_TexturedShape self) -> Standard_Real

        @return texture repeat U value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_TexturedShape_URepeat(self, *args)


    def VRepeat(self, *args):
        """
        VRepeat(AIS_TexturedShape self) -> Standard_Real

        @return texture repeat V value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_TexturedShape_VRepeat(self, *args)


    def SetTextureRepeat(self, *args):
        """
        SetTextureRepeat(AIS_TexturedShape self, Standard_Boolean const theToRepeat, Standard_Real const theURepeat=1.0, Standard_Real const theVRepeat=1.0)

        Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1).
        Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax).
        If RepeatYN is set to false, texture coordinates are clamped in the range (0,1)x(0,1) of the face.

        :type theToRepeat: bool
        :type theURepeat: float
        :type theVRepeat: float

        """
        return _AIS.AIS_TexturedShape_SetTextureRepeat(self, *args)


    def TextureOrigin(self, *args):
        """
        TextureOrigin(AIS_TexturedShape self) -> Standard_Boolean

        @return true if texture UV origin has been modified

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TexturedShape_TextureOrigin(self, *args)


    def TextureUOrigin(self, *args):
        """
        TextureUOrigin(AIS_TexturedShape self) -> Standard_Real

        @return texture origin U position (0.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_TexturedShape_TextureUOrigin(self, *args)


    def TextureVOrigin(self, *args):
        """
        TextureVOrigin(AIS_TexturedShape self) -> Standard_Real

        @return texture origin V position (0.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_TexturedShape_TextureVOrigin(self, *args)


    def SetTextureOrigin(self, *args):
        """
        SetTextureOrigin(AIS_TexturedShape self, Standard_Boolean const theToSetTextureOrigin, Standard_Real const theUOrigin=0.0, Standard_Real const theVOrigin=0.0)

        Use this method to change the origin of the texture. The texel (0,0) will be mapped to the surface (UOrigin,VOrigin)

        :type theToSetTextureOrigin: bool
        :type theUOrigin: float
        :type theVOrigin: float

        """
        return _AIS.AIS_TexturedShape_SetTextureOrigin(self, *args)


    def TextureScale(self, *args):
        """
        TextureScale(AIS_TexturedShape self) -> Standard_Boolean

        @return true if scale factor should be applied to texture mapping

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TexturedShape_TextureScale(self, *args)


    def TextureScaleU(self, *args):
        """
        TextureScaleU(AIS_TexturedShape self) -> Standard_Real

        @return scale factor for U coordinate (1.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_TexturedShape_TextureScaleU(self, *args)


    def TextureScaleV(self, *args):
        """
        TextureScaleV(AIS_TexturedShape self) -> Standard_Real

        @return scale factor for V coordinate (1.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_TexturedShape_TextureScaleV(self, *args)


    def SetTextureScale(self, *args):
        """
        SetTextureScale(AIS_TexturedShape self, Standard_Boolean const theToSetTextureScale, Standard_Real const theScaleU=1.0, Standard_Real const theScaleV=1.0)

        Use this method to scale the texture (percent of the face).
        You can specify a scale factor for both U and V.
        Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat,
        the texture will appear twice on the face in each direction.

        :type theToSetTextureScale: bool
        :type theScaleU: float
        :type theScaleV: float

        """
        return _AIS.AIS_TexturedShape_SetTextureScale(self, *args)


    def ShowTriangles(self, *args):
        """
        ShowTriangles(AIS_TexturedShape self) -> Standard_Boolean
        ShowTriangles(AIS_TexturedShape self, Standard_Boolean const theToShowTriangles)

        Use this method to show the triangulation of the shape (for debugging etc.).

        :type theToShowTriangles: bool

        """
        return _AIS.AIS_TexturedShape_ShowTriangles(self, *args)


    def TextureModulate(self, *args):
        """
        TextureModulate(AIS_TexturedShape self) -> Standard_Boolean

        @return true if texture color modulation is turned on

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TexturedShape_TextureModulate(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_TexturedShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_TexturedShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_TexturedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_TexturedShape
AIS_TexturedShape_swigregister = _AIS.AIS_TexturedShape_swigregister
AIS_TexturedShape_swigregister(AIS_TexturedShape)

def AIS_TexturedShape_get_type_name(*args):
    """
    AIS_TexturedShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_TexturedShape_get_type_name(*args)

def AIS_TexturedShape_get_type_descriptor(*args):
    """
    AIS_TexturedShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_TexturedShape_get_type_descriptor(*args)

class AIS_PlaneTrihedron(AIS_InteractiveObject):
    """
    To construct a selectable 2d axis system in a 3d
    drawing. This can be placed anywhere in the 3d
    system, and provides a coordinate system for
    drawing curves and shapes in a plane.
    There are 3 selection modes:
    -   mode 0   selection of the whole plane "trihedron"
    -   mode 1   selection of the origin of the plane "trihedron"
    -   mode 2   selection of the axes.
    Warning
    For the presentation of planes and trihedra, the
    millimetre is default unit of length, and 100 the default
    value for the representation of the axes. If you modify
    these dimensions, you must temporarily recover the
    Drawer object. From inside it, take the Aspects in
    which   the values for length are stocked, for example,
    PlaneAspect for planes and LineAspect for
    trihedra. Change these values and recalculate the presentation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_PlaneTrihedron
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_PlaneTrihedron(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_PlaneTrihedron_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_PlaneTrihedron_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_PlaneTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_PlaneTrihedron self, Handle_Geom_Plane aPlane) -> AIS_PlaneTrihedron

        Initializes the plane aPlane. The plane trihedron is
        constructed from this and an axis.

        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        this = _AIS.new_AIS_PlaneTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Component(self, *args):
        """
        Component(AIS_PlaneTrihedron self) -> Handle_Geom_Plane

        Returns the component specified in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.AIS_PlaneTrihedron_Component(self, *args)


    def SetComponent(self, *args):
        """
        SetComponent(AIS_PlaneTrihedron self, Handle_Geom_Plane aPlane)

        Creates an instance of the component object aPlane.

        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.AIS_PlaneTrihedron_SetComponent(self, *args)


    def XAxis(self, *args):
        """
        XAxis(AIS_PlaneTrihedron self) -> Handle_AIS_Line

        Returns the "XAxis".

        :rtype: OCC.wrapper.AIS.Handle_AIS_Line

        """
        return _AIS.AIS_PlaneTrihedron_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(AIS_PlaneTrihedron self) -> Handle_AIS_Line

        Returns the "YAxis".

        :rtype: OCC.wrapper.AIS.Handle_AIS_Line

        """
        return _AIS.AIS_PlaneTrihedron_YAxis(self, *args)


    def Position(self, *args):
        """
        Position(AIS_PlaneTrihedron self) -> Handle_AIS_Point

        Returns the point of origin of the plane trihedron.

        :rtype: OCC.wrapper.AIS.Handle_AIS_Point

        """
        return _AIS.AIS_PlaneTrihedron_Position(self, *args)


    def SetLength(self, *args):
        """
        SetLength(AIS_PlaneTrihedron self, Standard_Real const theLength)

        Sets the length of the X and Y axes.

        :type theLength: float

        """
        return _AIS.AIS_PlaneTrihedron_SetLength(self, *args)


    def GetLength(self, *args):
        """
        GetLength(AIS_PlaneTrihedron self) -> Standard_Real

        Returns the length of X and Y axes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_PlaneTrihedron_GetLength(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_PlaneTrihedron self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode selected, aMode, is valid.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_PlaneTrihedron_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_PlaneTrihedron self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_PlaneTrihedron_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_PlaneTrihedron self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_PlaneTrihedron_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_PlaneTrihedron self) -> AIS_KindOfInteractive

        Returns datum as the type of Interactive Object.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_PlaneTrihedron_Type(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_PlaneTrihedron self, Quantity_Color theColor)

        Allows you to provide settings for the color aColor.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_PlaneTrihedron_SetColor(self, *args)


    def SetXLabel(self, *args):
        """
        SetXLabel(AIS_PlaneTrihedron self, TCollection_AsciiString theLabel)

        :type theLabel: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_PlaneTrihedron_SetXLabel(self, *args)


    def SetYLabel(self, *args):
        """
        SetYLabel(AIS_PlaneTrihedron self, TCollection_AsciiString theLabel)

        :type theLabel: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_PlaneTrihedron_SetYLabel(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_PlaneTrihedron
AIS_PlaneTrihedron_swigregister = _AIS.AIS_PlaneTrihedron_swigregister
AIS_PlaneTrihedron_swigregister(AIS_PlaneTrihedron)

def AIS_PlaneTrihedron_get_type_name(*args):
    """
    AIS_PlaneTrihedron_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_PlaneTrihedron_get_type_name(*args)

def AIS_PlaneTrihedron_get_type_descriptor(*args):
    """
    AIS_PlaneTrihedron_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_PlaneTrihedron_get_type_descriptor(*args)

class AIS_AnimationTimer(Standard.Standard_Transient):
    """Auxiliary class defining the animation timer."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_AnimationTimer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_AnimationTimer(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_AnimationTimer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_AnimationTimer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_AnimationTimer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_AnimationTimer self) -> AIS_AnimationTimer

        Empty constructor.


        """
        this = _AIS.new_AIS_AnimationTimer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ElapsedTime(self, *args):
        """
        ElapsedTime(AIS_AnimationTimer self) -> Standard_Real

        Return elapsed time in seconds.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_AnimationTimer_ElapsedTime(self, *args)


    def PlaybackSpeed(self, *args):
        """
        PlaybackSpeed(AIS_AnimationTimer self) -> Standard_Real

        Return playback speed coefficient (1.0 means normal speed).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_AnimationTimer_PlaybackSpeed(self, *args)


    def SetPlaybackSpeed(self, *args):
        """
        SetPlaybackSpeed(AIS_AnimationTimer self, Standard_Real const theSpeed)

        Setup playback speed coefficient.

        :type theSpeed: float

        """
        return _AIS.AIS_AnimationTimer_SetPlaybackSpeed(self, *args)


    def IsStarted(self, *args):
        """
        IsStarted(AIS_AnimationTimer self) -> Standard_Boolean

        Return true if timer has been started.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_AnimationTimer_IsStarted(self, *args)


    def Start(self, *args):
        """
        Start(AIS_AnimationTimer self)

        Start the timer.


        """
        return _AIS.AIS_AnimationTimer_Start(self, *args)


    def Pause(self, *args):
        """
        Pause(AIS_AnimationTimer self)

        Pause the timer.


        """
        return _AIS.AIS_AnimationTimer_Pause(self, *args)


    def Stop(self, *args):
        """
        Stop(AIS_AnimationTimer self)

        Stop the timer.


        """
        return _AIS.AIS_AnimationTimer_Stop(self, *args)


    def Seek(self, *args):
        """
        Seek(AIS_AnimationTimer self, Standard_Real const theTime)

        Seek the timer to specified position.

        :type theTime: float

        """
        return _AIS.AIS_AnimationTimer_Seek(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_AnimationTimer
AIS_AnimationTimer_swigregister = _AIS.AIS_AnimationTimer_swigregister
AIS_AnimationTimer_swigregister(AIS_AnimationTimer)

def AIS_AnimationTimer_get_type_name(*args):
    """
    AIS_AnimationTimer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_AnimationTimer_get_type_name(*args)

def AIS_AnimationTimer_get_type_descriptor(*args):
    """
    AIS_AnimationTimer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_AnimationTimer_get_type_descriptor(*args)

class AIS_OffsetDimension(AIS_Relation):
    """
    A framework to display dimensions of offsets.
    The relation between the offset and the basis shape
    is indicated. This relation is displayed with arrows and
    text. The text gives the dsitance between the offset
    and the basis shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_OffsetDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_OffsetDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_OffsetDimension self, TopoDS_Shape FistShape, TopoDS_Shape SecondShape, Standard_Real const aVal, TCollection_ExtendedString aText) -> AIS_OffsetDimension

        Constructs the offset display object defined by the
        first shape aFShape, the second shape aSShape, the
        dimension aVal, and the text aText.

        :type FistShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SecondShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aVal: float
        :type aText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        this = _AIS.new_AIS_OffsetDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_OffsetDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_OffsetDimension_Compute(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(AIS_OffsetDimension self) -> AIS_KindOfDimension

        Indicates that the dimension we are concerned with is an offset.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.AIS_OffsetDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the offset datum is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_OffsetDimension_IsMovable(self, *args)


    def SetRelativePos(self, *args):
        """
        SetRelativePos(AIS_OffsetDimension self, gp_Trsf aTrsf)

        Sets a transformation aTrsf for presentation and
        selection to a relative position.

        :type aTrsf: OCC.wrapper.gp.gp_Trsf

        """
        return _AIS.AIS_OffsetDimension_SetRelativePos(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_OffsetDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_OffsetDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_OffsetDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_OffsetDimension
AIS_OffsetDimension_swigregister = _AIS.AIS_OffsetDimension_swigregister
AIS_OffsetDimension_swigregister(AIS_OffsetDimension)

def AIS_OffsetDimension_get_type_name(*args):
    """
    AIS_OffsetDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_OffsetDimension_get_type_name(*args)

def AIS_OffsetDimension_get_type_descriptor(*args):
    """
    AIS_OffsetDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_OffsetDimension_get_type_descriptor(*args)

class AIS_IdenticRelation(AIS_Relation):
    """
    Constructs a constraint by a relation of identity
    between two or more datums figuring in shape
    Interactive Objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_IdenticRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_IdenticRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_IdenticRelation self, TopoDS_Shape FirstShape, TopoDS_Shape SecondShape, Handle_Geom_Plane aPlane) -> AIS_IdenticRelation

        Initializes the relation of identity between the two
        entities, FirstShape and SecondShape. The plane
        aPlane is initialized in case a visual reference is
        needed to show identity.

        :type FirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SecondShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        this = _AIS.new_AIS_IdenticRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasUsers(self, *args):
        """
        HasUsers(AIS_IdenticRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_IdenticRelation_HasUsers(self, *args)


    def Users(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfTransient

        """
        res = _AIS.AIS_IdenticRelation_Users(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddUser(self, *args):
        """
        AddUser(AIS_IdenticRelation self, Handle_Standard_Transient theUser)

        :type theUser: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.AIS_IdenticRelation_AddUser(self, *args)


    def ClearUsers(self, *args):
        """ClearUsers(AIS_IdenticRelation self)"""
        return _AIS.AIS_IdenticRelation_ClearUsers(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_IdenticRelation_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_IdenticRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_IdenticRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_IdenticRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_IdenticRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_IdenticRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_IdenticRelation
AIS_IdenticRelation_swigregister = _AIS.AIS_IdenticRelation_swigregister
AIS_IdenticRelation_swigregister(AIS_IdenticRelation)

def AIS_IdenticRelation_get_type_name(*args):
    """
    AIS_IdenticRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_IdenticRelation_get_type_name(*args)

def AIS_IdenticRelation_get_type_descriptor(*args):
    """
    AIS_IdenticRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_IdenticRelation_get_type_descriptor(*args)

class AIS_Chamf2dDimension(AIS_Relation):
    """
    A framework to define display of 2D chamfers.
    A chamfer is displayed with arrows and text. The text
    gives the length of the chamfer if it is a symmetrical
    chamfer, or the angle if it is not.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Chamf2dDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Chamf2dDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_Chamf2dDimension self, TopoDS_Shape aFShape, Handle_Geom_Plane aPlane, Standard_Real const aVal, TCollection_ExtendedString aText) -> AIS_Chamf2dDimension
        __init__(AIS_Chamf2dDimension self, TopoDS_Shape aFShape, Handle_Geom_Plane aPlane, Standard_Real const aVal, TCollection_ExtendedString aText, gp_Pnt aPosition, DsgPrs_ArrowSide const aSymbolPrs, Standard_Real const anArrowSize=0.0) -> AIS_Chamf2dDimension

        Constructs the display object for 2D chamfers.
        This object is defined by the face aFShape, the plane
        aPlane, the dimension aVal, the position aPosition,
        the type of arrow aSymbolPrs with the size
        anArrowSize, and the text aText.

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type aVal: float
        :type aText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aPosition: OCC.wrapper.gp.gp_Pnt
        :type aSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide
        :type anArrowSize: float

        """
        this = _AIS.new_AIS_Chamf2dDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def KindOfDimension(self, *args):
        """
        KindOfDimension(AIS_Chamf2dDimension self) -> AIS_KindOfDimension

        Indicates that we are concerned with a 2d length.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.AIS_Chamf2dDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the 2d chamfer dimension is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Chamf2dDimension_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_Chamf2dDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_Chamf2dDimension_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Chamf2dDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Chamf2dDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Chamf2dDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_Chamf2dDimension
AIS_Chamf2dDimension_swigregister = _AIS.AIS_Chamf2dDimension_swigregister
AIS_Chamf2dDimension_swigregister(AIS_Chamf2dDimension)

def AIS_Chamf2dDimension_get_type_name(*args):
    """
    AIS_Chamf2dDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Chamf2dDimension_get_type_name(*args)

def AIS_Chamf2dDimension_get_type_descriptor(*args):
    """
    AIS_Chamf2dDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Chamf2dDimension_get_type_descriptor(*args)

class AIS_TextLabel(AIS_InteractiveObject):
    """Presentation of the text."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_TextLabel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_TextLabel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_TextLabel self) -> AIS_TextLabel

        Default constructor


        """
        this = _AIS.new_AIS_TextLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetColor(self, *args):
        """
        SetColor(AIS_TextLabel self, Quantity_Color theColor)

        Setup color of entire text.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_TextLabel_SetColor(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(AIS_TextLabel self, Standard_Real const theValue)

        Setup transparency within [0, 1] range.

        :type theValue: float

        """
        return _AIS.AIS_TextLabel_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(AIS_TextLabel self)

        Removes the transparency setting.


        """
        return _AIS.AIS_TextLabel_UnsetTransparency(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(AIS_TextLabel self, Graphic3d_MaterialAspect arg2)

        Material has no effect for text label.

        :type : OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.AIS_TextLabel_SetMaterial(self, *args)


    def SetText(self, *args):
        """
        SetText(AIS_TextLabel self, TCollection_ExtendedString theText)

        Setup text.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.AIS_TextLabel_SetText(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(AIS_TextLabel self, gp_Pnt thePosition)

        Setup position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_TextLabel_SetPosition(self, *args)


    def SetHJustification(self, *args):
        """
        SetHJustification(AIS_TextLabel self, Graphic3d_HorizontalTextAlignment const theHJust)

        Setup horizontal justification.

        :type theHJust: OCC.wrapper.Graphic3d.Graphic3d_HorizontalTextAlignment

        """
        return _AIS.AIS_TextLabel_SetHJustification(self, *args)


    def SetVJustification(self, *args):
        """
        SetVJustification(AIS_TextLabel self, Graphic3d_VerticalTextAlignment const theVJust)

        Setup vertical justification.

        :type theVJust: OCC.wrapper.Graphic3d.Graphic3d_VerticalTextAlignment

        """
        return _AIS.AIS_TextLabel_SetVJustification(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(AIS_TextLabel self, Standard_Real const theAngle)

        Setup angle.

        :type theAngle: float

        """
        return _AIS.AIS_TextLabel_SetAngle(self, *args)


    def SetZoomable(self, *args):
        """
        SetZoomable(AIS_TextLabel self, Standard_Boolean const theIsZoomable)

        Setup zoomable property.

        :type theIsZoomable: bool

        """
        return _AIS.AIS_TextLabel_SetZoomable(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(AIS_TextLabel self, Standard_Real const theHeight)

        Setup height.

        :type theHeight: float

        """
        return _AIS.AIS_TextLabel_SetHeight(self, *args)


    def SetFontAspect(self, *args):
        """
        SetFontAspect(AIS_TextLabel self, Font_FontAspect const theFontAspect)

        Setup font aspect.

        :type theFontAspect: OCC.wrapper.Font.Font_FontAspect

        """
        return _AIS.AIS_TextLabel_SetFontAspect(self, *args)


    def SetFont(self, *args):
        """
        SetFont(AIS_TextLabel self, Standard_CString theFont)

        Setup font.

        :type theFont: OCC.wrapper.Standard.Standard_CString

        """
        return _AIS.AIS_TextLabel_SetFont(self, *args)


    def SetOrientation3D(self, *args):
        """
        SetOrientation3D(AIS_TextLabel self, gp_Ax2 theOrientation)

        Setup label orientation in the model 3D space.

        :type theOrientation: OCC.wrapper.gp.gp_Ax2

        """
        return _AIS.AIS_TextLabel_SetOrientation3D(self, *args)


    def UnsetOrientation3D(self, *args):
        """
        UnsetOrientation3D(AIS_TextLabel self)

        Reset label orientation in the model 3D space.


        """
        return _AIS.AIS_TextLabel_UnsetOrientation3D(self, *args)


    def Position(self, *args):
        """
        Returns position.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_TextLabel_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Orientation3D(self, *args):
        """
        Returns label orientation in the model 3D space.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _AIS.AIS_TextLabel_Orientation3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOrientation3D(self, *args):
        """
        HasOrientation3D(AIS_TextLabel self) -> Standard_Boolean

        Returns true if the current text placement mode uses text orientation in the model 3D space.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TextLabel_HasOrientation3D(self, *args)


    def SetFlipping(self, *args):
        """
        SetFlipping(AIS_TextLabel self, Standard_Boolean const theIsFlipping)

        :type theIsFlipping: bool

        """
        return _AIS.AIS_TextLabel_SetFlipping(self, *args)


    def HasFlipping(self, *args):
        """
        HasFlipping(AIS_TextLabel self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TextLabel_HasFlipping(self, *args)


    def SetDisplayType(self, *args):
        """
        SetDisplayType(AIS_TextLabel self, Aspect_TypeOfDisplayText const theDisplayType)

        Define the display type of the text.

        TODT_NORMAL     Default display. Text only.
        TODT_SUBTITLE   There is a subtitle under the text.
        TODT_DEKALE     The text is displayed with a 3D style.
        TODT_BLEND      The text is displayed in XOR.
        TODT_DIMENSION  Dimension line under text will be invisible.

        :type theDisplayType: OCC.wrapper.Aspect.Aspect_TypeOfDisplayText

        """
        return _AIS.AIS_TextLabel_SetDisplayType(self, *args)


    def SetColorSubTitle(self, *args):
        """
        SetColorSubTitle(AIS_TextLabel self, Quantity_Color theColor)

        Modifies the colour of the subtitle for the TODT_SUBTITLE TextDisplayType
        and the colour of backgroubd for the TODT_DEKALE TextDisplayType.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_TextLabel_SetColorSubTitle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_TextLabel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_TextLabel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_TextLabel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_TextLabel
AIS_TextLabel_swigregister = _AIS.AIS_TextLabel_swigregister
AIS_TextLabel_swigregister(AIS_TextLabel)

def AIS_TextLabel_get_type_name(*args):
    """
    AIS_TextLabel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_TextLabel_get_type_name(*args)

def AIS_TextLabel_get_type_descriptor(*args):
    """
    AIS_TextLabel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_TextLabel_get_type_descriptor(*args)

class AIS_PointCloud(AIS_InteractiveObject):
    """
    Interactive object for set of points.
    The presentation supports two display modes:
    - Points.
    - Bounding box for highlighting.
    Presentation provides selection by bouding box.
    Selection and consequently highlighting can disabled by
    setting default selection mode to -1. There will be no way
    to select object from interactive view. Any calls to
    AIS_InteractiveContext::AddOrRemoveSelected should be also prohibited,
    to avoid programmatic highlighting (workaround is setting non-supported
    hilight mode, e.g. 100);
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_PointCloud
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_PointCloud(self) 
            return h

    SM_Points = _AIS.AIS_PointCloud_SM_Points
    SM_BndBox = _AIS.AIS_PointCloud_SM_BndBox

    def __init__(self, *args):
        """
        __init__(AIS_PointCloud self) -> AIS_PointCloud

        Constructor.


        """
        this = _AIS.new_AIS_PointCloud(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetPoints(self, *args):
        """
        SetPoints(AIS_PointCloud self, Handle_Graphic3d_ArrayOfPoints thePoints)
        SetPoints(AIS_PointCloud self, Handle_TColgp_HArray1OfPnt theCoords, Handle_Quantity_HArray1OfColor theColors=0, Handle_TColgp_HArray1OfDir theNormals=0)

        Sets the points with optional colors.
        The input data will be copied into internal buffer.
        The input arrays should have equal length, otherwise
        the presentation will not be computed and displayed.
        @param theCoords  [in] the array of coordinates
        @param theColors  [in] optional array of colors
        @param theNormals [in] optional array of normals

        :type theCoords: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt
        :type theColors: OCC.wrapper.Quantity.Handle_Quantity_HArray1OfColor
        :type theNormals: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfDir

        """
        return _AIS.AIS_PointCloud_SetPoints(self, *args)


    def GetPoints(self, *args):
        """
        GetPoints(AIS_PointCloud self) -> Handle_Graphic3d_ArrayOfPoints

        Get the points array.
        Method might be overridden to fill in points array dynamically from application data structures.
        @return the array of points

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPoints

        """
        return _AIS.AIS_PointCloud_GetPoints(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(AIS_PointCloud self) -> Bnd_Box

        Get bounding box for presentation.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.AIS_PointCloud_GetBoundingBox(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_PointCloud self, Quantity_Color theColor)

        Setup custom color. Affects presentation only when no per-point color attribute has been assigned.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_PointCloud_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_PointCloud self)

        Restore default color.


        """
        return _AIS.AIS_PointCloud_UnsetColor(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(AIS_PointCloud self, Graphic3d_MaterialAspect theMat)

        Setup custom material. Affects presentation only when normals are defined.

        :type theMat: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.AIS_PointCloud_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(AIS_PointCloud self)

        Restore default material.


        """
        return _AIS.AIS_PointCloud_UnsetMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_PointCloud_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_PointCloud_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_PointCloud_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DisplayMode(self):
        return _AIS.AIS_PointCloud_DisplayMode(self)
    __swig_destroy__ = _AIS.delete_AIS_PointCloud
AIS_PointCloud_swigregister = _AIS.AIS_PointCloud_swigregister
AIS_PointCloud_swigregister(AIS_PointCloud)

def AIS_PointCloud_get_type_name(*args):
    """
    AIS_PointCloud_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_PointCloud_get_type_name(*args)

def AIS_PointCloud_get_type_descriptor(*args):
    """
    AIS_PointCloud_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_PointCloud_get_type_descriptor(*args)

class AIS_MinRadiusDimension(AIS_EllipseRadiusDimension):
    """
    --  Ellipse  Min  radius  dimension  of  a  Shape  which
    can  be  Edge  or  Face  (planar  or  cylindrical(surface  of
    extrusion  or  surface  of  offset))
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_MinRadiusDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_MinRadiusDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_MinRadiusDimension self, TopoDS_Shape aShape, Standard_Real const aVal, TCollection_ExtendedString aText) -> AIS_MinRadiusDimension
        __init__(AIS_MinRadiusDimension self, TopoDS_Shape aShape, Standard_Real const aVal, TCollection_ExtendedString aText, gp_Pnt aPosition, DsgPrs_ArrowSide const aSymbolPrs, Standard_Real const anArrowSize=0.0) -> AIS_MinRadiusDimension

        Max  Ellipse  radius dimension with  position
        Shape  can  be  edge  ,  planar  face  or  cylindrical  face

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aVal: float
        :type aText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aPosition: OCC.wrapper.gp.gp_Pnt
        :type aSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide
        :type anArrowSize: float

        """
        this = _AIS.new_AIS_MinRadiusDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_MinRadiusDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_MinRadiusDimension_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_MinRadiusDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_MinRadiusDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_MinRadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_MinRadiusDimension
AIS_MinRadiusDimension_swigregister = _AIS.AIS_MinRadiusDimension_swigregister
AIS_MinRadiusDimension_swigregister(AIS_MinRadiusDimension)

def AIS_MinRadiusDimension_get_type_name(*args):
    """
    AIS_MinRadiusDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_MinRadiusDimension_get_type_name(*args)

def AIS_MinRadiusDimension_get_type_descriptor(*args):
    """
    AIS_MinRadiusDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_MinRadiusDimension_get_type_descriptor(*args)

class Handle_AIS_MultipleConnectedInteractive(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_MultipleConnectedInteractive self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_MultipleConnectedInteractive self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_MultipleConnectedInteractive self, AIS_MultipleConnectedInteractive thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_MultipleConnectedInteractive theHandle) -> Handle_AIS_MultipleConnectedInteractive
        assign(Handle_AIS_MultipleConnectedInteractive self, AIS_MultipleConnectedInteractive thePtr) -> Handle_AIS_MultipleConnectedInteractive
        assign(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_MultipleConnectedInteractive theHandle) -> Handle_AIS_MultipleConnectedInteractive

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_MultipleConnectedInteractive self) -> AIS_MultipleConnectedInteractive

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_MultipleConnectedInteractive self) -> AIS_MultipleConnectedInteractive

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_MultipleConnectedInteractive self) -> AIS_MultipleConnectedInteractive

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_MultipleConnectedInteractive___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_MultipleConnectedInteractive___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_MultipleConnectedInteractive(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_MultipleConnectedInteractive_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_MultipleConnectedInteractive

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_MultipleConnectedInteractive self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Connect(self, *args):
        """
        Connect(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, Handle_Geom_Transformation theLocation, Handle_Graphic3d_TransformPers theTrsfPers) -> Handle_AIS_InteractiveObject
        Connect(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj) -> Handle_AIS_InteractiveObject
        Connect(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, gp_Trsf theLocation) -> Handle_AIS_InteractiveObject
        Connect(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, gp_Trsf theLocation, Handle_Graphic3d_TransformPers theTrsfPers) -> Handle_AIS_InteractiveObject
        Connect(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theInteractive, gp_Trsf theLocation, Graphic3d_TransModeFlags const & theTrsfPersFlag, gp_Pnt theTrsfPersPoint) -> Handle_AIS_InteractiveObject

        :type theInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLocation: OCC.wrapper.gp.gp_Trsf
        :type theTrsfPersFlag: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type theTrsfPersPoint: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Connect(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_MultipleConnectedInteractive self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Signature(self, *args)


    def HasConnection(self, *args):
        """
        HasConnection(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the object is connected to others.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasConnection(self, *args)


    def Disconnect(self, *args):
        """
        Disconnect(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveObject theInteractive)

        Removes the connection with theInteractive.

        :type theInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Disconnect(self, *args)


    def DisconnectAll(self, *args):
        """
        DisconnectAll(Handle_AIS_MultipleConnectedInteractive self)

        Clears all the connections to objects.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_DisconnectAll(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_MultipleConnectedInteractive self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)
        Compute(Handle_AIS_MultipleConnectedInteractive self, Handle_Prs3d_Projector aProjector, Handle_Prs3d_Presentation aPresentation)

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Compute(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_AcceptShapeDecomposition(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_MultipleConnectedInteractive self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GlobalSelOwner(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_MultipleConnectedInteractive self, Handle_AIS_InteractiveContext theCtx)

        Assigns interactive context.

        :type theCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetContext(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_MultipleConnectedInteractive self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_MultipleConnectedInteractive self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_MultipleConnectedInteractive self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_MultipleConnectedInteractive self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_MultipleConnectedInteractive self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_MultipleConnectedInteractive self)"""
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_MultipleConnectedInteractive self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_MultipleConnectedInteractive self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_MultipleConnectedInteractive self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_MultipleConnectedInteractive self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_MultipleConnectedInteractive self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_MultipleConnectedInteractive self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_MultipleConnectedInteractive self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_MultipleConnectedInteractive self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_MultipleConnectedInteractive self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_MultipleConnectedInteractive self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_MultipleConnectedInteractive self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_MultipleConnectedInteractive self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_MultipleConnectedInteractive self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_MultipleConnectedInteractive self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_MultipleConnectedInteractive self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_MultipleConnectedInteractive self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_MultipleConnectedInteractive self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_MultipleConnectedInteractive self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_MultipleConnectedInteractive self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_MultipleConnectedInteractive self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_MultipleConnectedInteractive self)
        RecomputePrimitives(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_MultipleConnectedInteractive self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_MultipleConnectedInteractive self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_MultipleConnectedInteractive self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_MultipleConnectedInteractive self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_MultipleConnectedInteractive self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_MultipleConnectedInteractive self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_MultipleConnectedInteractive self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_MultipleConnectedInteractive self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_MultipleConnectedInteractive self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_MultipleConnectedInteractive self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_MultipleConnectedInteractive self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_MultipleConnectedInteractive self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_MultipleConnectedInteractive self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_MultipleConnectedInteractive self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_MultipleConnectedInteractive self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_MultipleConnectedInteractive self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_MultipleConnectedInteractive self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_MultipleConnectedInteractive self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GlobalSelectionMode(self, *args)


    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_MultipleConnectedInteractive self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_MultipleConnectedInteractive self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_MultipleConnectedInteractive self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_MultipleConnectedInteractive self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_MultipleConnectedInteractive self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_MultipleConnectedInteractive self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_MultipleConnectedInteractive self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_MultipleConnectedInteractive self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_MultipleConnectedInteractive self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_MultipleConnectedInteractive self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_MultipleConnectedInteractive self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_MultipleConnectedInteractive self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_MultipleConnectedInteractive self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_MultipleConnectedInteractive self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_MultipleConnectedInteractive self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_MultipleConnectedInteractive self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_MultipleConnectedInteractive self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_MultipleConnectedInteractive self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_MultipleConnectedInteractive self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_MultipleConnectedInteractive self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_MultipleConnectedInteractive self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_MultipleConnectedInteractive self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_MultipleConnectedInteractive self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MultipleConnectedInteractive_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_MultipleConnectedInteractive self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_MultipleConnectedInteractive self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_MultipleConnectedInteractive self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_MultipleConnectedInteractive self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_MultipleConnectedInteractive self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_MultipleConnectedInteractive self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_MultipleConnectedInteractive self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_MultipleConnectedInteractive self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_MultipleConnectedInteractive self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MultipleConnectedInteractive_DecrementRefCounter(self, *args)

Handle_AIS_MultipleConnectedInteractive_swigregister = _AIS.Handle_AIS_MultipleConnectedInteractive_swigregister
Handle_AIS_MultipleConnectedInteractive_swigregister(Handle_AIS_MultipleConnectedInteractive)

def Handle_AIS_MultipleConnectedInteractive_DownCast(thing):
    return _AIS.Handle_AIS_MultipleConnectedInteractive_DownCast(thing)
Handle_AIS_MultipleConnectedInteractive_DownCast = _AIS.Handle_AIS_MultipleConnectedInteractive_DownCast

class NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,AIS_ListOfInteractive,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,AIS_ListOfInteractive,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,AIS_ListOfInteractive,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,AIS_ListOfInteractive,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _AIS.new_NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Handle_AIS_InteractiveObject theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Handle_AIS_InteractiveObject theItem) -> NCollection_List_Handle_AIS_InteractiveObject

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_AIS_InteractiveObject

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_AIS_InteractiveObject

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_AIS_InteractiveObject

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_swigregister = _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _AIS.NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher_IteratorHelper)


try:
	AIS_DataMapofIntegerListOfinteractive = NCollection_DataMap_Standard_Integer_AIS_ListOfInteractive_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class AIS_Manipulator(AIS_InteractiveObject):
    """
    Interactive object class to manipulate local transformation of another interactive
    object or a group of objects via mouse.
    It manages three types of manipulations in 3D space:
    - translation through axis
    - scaling within axis
    - rotation around axis
    To enable one of this modes, selection mode (from 1 to 3) is to be activated.
    There are three orthogonal transformation axes defined by position property of
    the manipulator. Particular transformation mode can be disabled for each
    of the axes or all of them. Furthermore each of the axes can be hidden or
    made visible.
    The following steps demonstrate how to attach, configure and use manipulator
    for an interactive object:
    Step 1. Create manipulator object and adjust it appearance:
    @code
    Handle(AIS_Manipulator) aManipulator = new AIS_Manipulator();
    aManipulator->SetPart (0, AIS_Manipulator::Scaling, Standard_False);
    aManipulator->SetPart (1, AIS_Manipulator::Rotation, Standard_False);
    // Attach manipulator to already displayed object and manage manipulation modes
    aManipulator->AttachToObject (anAISObject);
    aManipulator->EnableMode (AIS_Manipulator::Translation);
    aManipulator->EnableMode (AIS_Manipulator::Rotation);
    aManipulator->EnableMode (AIS_Manipulator::Scaling);
    @endcode
    Note that you can enable only one manipulation mode but have all visual parts displayed.
    This code allows you to view manipulator and select its manipulation parts.
    Note that manipulator activates mode on part selection.
    If this mode is activated, no selection will be performed for manipulator.
    It can be activated with highlighting. To enable this:
    @code
    aManipulator->SetModeActivationOnDetection (Standard_True);
    @endcode
    Step 2. To perform transformation of object use next code in your event processing chain:
    @code
    // catch mouse button down event
    if (aManipulator->HasActiveMode())
    {
    aManipulator->StartTransform (anXPix, anYPix, aV3dView);
    }
    ...
    // or track mouse move event
    if (aManipulator->HasActiveMode())
    {
    aManipulator->Transform (anXPix, anYPix, aV3dView);
    aV3dView->Redraw();
    }
    ...
    // or catch mouse button up event (apply) or escape event (cancel)
    aManipulator->StopTransform(/*Standard_Boolean toApply*/);
    @endcode
    Step 3. To deactivate current manipulation mode use:
    @code aManipulator->DeactivateCurrentMode();
    @endcode
    Step 4. To detach manipulator from object use:
    @code
    aManipulator->Detach();
    @endcode
    The last method erases manipulator object.
    @warning
    On construction an instance of AIS_Manipulator object is bound to Graphic3d_ZLayerId_Topmost layer,
    so make sure to call for your AIS_InteractiveContext the method MainSelector()->SetPickClosest (Standard_False)
    otherwise you may notice issues with activation of modes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Manipulator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Manipulator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_Manipulator self) -> AIS_Manipulator
        __init__(AIS_Manipulator self, gp_Ax2 thePosition) -> AIS_Manipulator

        Constructs a manipulator object with input location and positions of axes and all parts to be displayed.

        :type thePosition: OCC.wrapper.gp.gp_Ax2

        """
        this = _AIS.new_AIS_Manipulator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetPart(self, *args):
        """
        SetPart(AIS_Manipulator self, Standard_Integer const theAxisIndex, AIS_ManipulatorMode const theMode, Standard_Boolean const theIsEnabled)

        Disable or enable visual parts for translation, rotation or scaling for some axis.
        By default all parts are enabled (will be displayed).
        @warning Enabling or disabling of visual parts of manipulator does not manage the manipulation (selection) mode.
        @warning Raises program error if axis index is < 0 or > 2.

        :type theAxisIndex: int
        :type theMode: OCC.wrapper.AIS.AIS_ManipulatorMode
        :type theIsEnabled: bool

        """
        return _AIS.AIS_Manipulator_SetPart(self, *args)


    def EnableMode(self, *args):
        """
        EnableMode(AIS_Manipulator self, AIS_ManipulatorMode const theMode)

        Enable manipualtion mode.
        @warning It activates selection mode in the current context.
        If manipulator is not displayed, no mode will be activated.

        :type theMode: OCC.wrapper.AIS.AIS_ManipulatorMode

        """
        return _AIS.AIS_Manipulator_EnableMode(self, *args)


    def SetModeActivationOnDetection(self, *args):
        """
        SetModeActivationOnDetection(AIS_Manipulator self, Standard_Boolean const theToEnable)

        Enables mode activation on detection (highlighting).
        By default, mode is activated on selection of manipulator part.
        @warning If this mode is enabled, selection of parts does nothing.

        :type theToEnable: bool

        """
        return _AIS.AIS_Manipulator_SetModeActivationOnDetection(self, *args)


    def IsModeActivationOnDetection(self, *args):
        """
        IsModeActivationOnDetection(AIS_Manipulator self) -> Standard_Boolean

        @return true if manual mode activation is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Manipulator_IsModeActivationOnDetection(self, *args)


    def StartTransform(self, *args):
        """
        StartTransform(AIS_Manipulator self, Standard_Integer const theX, Standard_Integer const theY, Handle_V3d_View theView)

        Init start (reference) transformation.
        @warning It is used in chain with StartTransform-Transform(gp_Trsf)-StopTransform
        and is used only for custom transform set. If Transform(const Standard_Integer, const Standard_Integer) is used,
        initial data is set automatically, and it is reset on DeactivateCurrentMode call if it is not reset yet.

        :type theX: int
        :type theY: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.AIS_Manipulator_StartTransform(self, *args)


    def StopTransform(self, *args):
        """
        StopTransform(AIS_Manipulator self, Standard_Boolean const theToApply)

        Reset start (reference) transformation.
        @param theToApply [in] option to apply or to cancel the started transformation.
        @warning It is used in chain with StartTransform-Transform(gp_Trsf)-StopTransform
        and is used only for custom transform set.

        :type theToApply: bool

        """
        return _AIS.AIS_Manipulator_StopTransform(self, *args)


    def Transform(self, *args):
        """
        Transform(AIS_Manipulator self, gp_Trsf aTrsf)
        Transform(AIS_Manipulator self, Standard_Integer const theX, Standard_Integer const theY, Handle_V3d_View theView) -> gp_Trsf

        Apply transformation made from mouse moving from start position
        (save on the first Tranform() call and reset on DeactivateCurrentMode() call.)
        to the in/out mouse position (theX, theY)

        :type theX: int
        :type theY: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _AIS.AIS_Manipulator_Transform(self, *args)


    def ObjectTransformation(self, *args):
        """
        ObjectTransformation(AIS_Manipulator self, Standard_Integer const theX, Standard_Integer const theY, Handle_V3d_View theView, gp_Trsf theTrsf) -> Standard_Boolean

        Computes transformation of parent object according to the active mode and input motion vector.
        You can use this method to get object transformation according to current mode or use own algorithm
        to implement any other tranformation for modes.
        @return transformation of parent object.

        :type theX: int
        :type theY: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Manipulator_ObjectTransformation(self, *args)


    def DeactivateCurrentMode(self, *args):
        """
        DeactivateCurrentMode(AIS_Manipulator self)

        Make inactive the current selected manipulator part and reset current axis index and current mode.
        After its call HasActiveMode() returns false.
        @sa HasActiveMode()


        """
        return _AIS.AIS_Manipulator_DeactivateCurrentMode(self, *args)


    def Detach(self, *args):
        """
        Detach(AIS_Manipulator self)

        Detaches himself from the owner object, and removes itself from context.


        """
        return _AIS.AIS_Manipulator_Detach(self, *args)


    def Objects(self, *args):
        """
        Objects(AIS_Manipulator self) -> Handle_AIS_ManipulatorObjectSequence

        @return all owning objects.

        :rtype: OCC.wrapper.AIS.Handle_AIS_ManipulatorObjectSequence

        """
        return _AIS.AIS_Manipulator_Objects(self, *args)


    def Object(self, *args):
        """
        Object(AIS_Manipulator self) -> Handle_AIS_InteractiveObject
        Object(AIS_Manipulator self, Standard_Integer const theIndex) -> Handle_AIS_InteractiveObject

        @return one of the owning objects.
        @warning raises program error if theIndex is more than owning objects count or less than 1.

        :type theIndex: int
        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_Manipulator_Object(self, *args)


    def IsAttached(self, *args):
        """
        IsAttached(AIS_Manipulator self) -> Standard_Boolean

        @return true if manipulator is attached to some interactive object (has owning object).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Manipulator_IsAttached(self, *args)


    def HasActiveMode(self, *args):
        """
        HasActiveMode(AIS_Manipulator self) -> Standard_Boolean

        @return true if some part of manipulator is selected (transformation mode is active, and owning object can be transformed).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Manipulator_HasActiveMode(self, *args)


    def HasActiveTransformation(self, *args):
        """
        HasActiveTransformation(AIS_Manipulator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Manipulator_HasActiveTransformation(self, *args)


    def StartTransformation(self, *args):
        """
        StartTransformation(AIS_Manipulator self) -> gp_Trsf
        StartTransformation(AIS_Manipulator self, Standard_Integer theIndex) -> gp_Trsf

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _AIS.AIS_Manipulator_StartTransformation(self, *args)


    def SetZoomPersistence(self, *args):
        """
        SetZoomPersistence(AIS_Manipulator self, Standard_Boolean const theToEnable)

        Enable or disable zoom persistence mode for the manipulator. With
        this mode turned on the presentation will keep fixed screen size.
        @warning when turned on this option overrides transform persistence
        properties and local transformation to achieve necessary visual effect.
        @warning revise use of AdjustSize argument of of \sa AttachToObjects method
        when enabling zoom persistence.

        :type theToEnable: bool

        """
        return _AIS.AIS_Manipulator_SetZoomPersistence(self, *args)


    def ZoomPersistence(self, *args):
        """
        ZoomPersistence(AIS_Manipulator self) -> Standard_Boolean

        Returns state of zoom persistence mode, whether it turned on or off.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Manipulator_ZoomPersistence(self, *args)


    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(AIS_Manipulator self, Handle_Graphic3d_TransformPers theTrsfPers)

        Redefines transform persistence management to setup transformation for sub-presentation of axes.
        @warning this interactive object does not support custom transformation persistence when
        using \sa ZoomPersistence mode. In this mode the transformation persistence flags for
        presentations are overridden by this class.
        @warning Invokes debug assertion to catch incompatible usage of the method with \sa ZoomPersistence mode,
        silently does nothing in release mode.
        @warning revise use of AdjustSize argument of of \sa AttachToObjects method
        when enabling zoom persistence.

        :type theTrsfPers: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        return _AIS.AIS_Manipulator_SetTransformPersistence(self, *args)


    def ActiveMode(self, *args):
        """
        ActiveMode(AIS_Manipulator self) -> AIS_ManipulatorMode

        @name Setters for parameters

        :rtype: OCC.wrapper.AIS.AIS_ManipulatorMode

        """
        return _AIS.AIS_Manipulator_ActiveMode(self, *args)


    def Position(self, *args):
        """
        @return poition of manipulator interactive object.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _AIS.AIS_Manipulator_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(AIS_Manipulator self, gp_Ax2 thePosition)

        Sets position of the manipulator object.

        :type thePosition: OCC.wrapper.gp.gp_Ax2

        """
        return _AIS.AIS_Manipulator_SetPosition(self, *args)


    def Size(self, *args):
        """
        Size(AIS_Manipulator self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _AIS.AIS_Manipulator_Size(self, *args)


    def SetSize(self, *args):
        """
        SetSize(AIS_Manipulator self, Standard_ShortReal const theSideLength)

        Sets size (length of side of the manipulator cubic bounding box.

        :type theSideLength: float

        """
        return _AIS.AIS_Manipulator_SetSize(self, *args)


    def SetGap(self, *args):
        """
        SetGap(AIS_Manipulator self, Standard_ShortReal const theValue)

        Sets gaps between translator, scaler and rotator sub-presentations.

        :type theValue: float

        """
        return _AIS.AIS_Manipulator_SetGap(self, *args)


    def SetTransformBehavior(self, *args):
        """
        SetTransformBehavior(AIS_Manipulator self, AIS_Manipulator::BehaviorOnTransform const & theSettings)

        Sets behavior settings for transformation action carried on the manipulator,
        whether it translates, rotates together with the transformed object or not.

        :type theSettings: BehaviorOnTransform

        """
        return _AIS.AIS_Manipulator_SetTransformBehavior(self, *args)


    def ChangeTransformBehavior(self, *args):
        """
        ChangeTransformBehavior(AIS_Manipulator self) -> AIS_Manipulator::BehaviorOnTransform &

        @return behavior settings for transformation action of the manipulator.

        :rtype: BehaviorOnTransform

        """
        return _AIS.AIS_Manipulator_ChangeTransformBehavior(self, *args)


    def TransformBehavior(self, *args):
        """
        @return behavior settings for transformation action of the manipulator.

        :rtype: BehaviorOnTransform

        """
        res = _AIS.AIS_Manipulator_TransformBehavior(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(AIS_Manipulator self, Handle_PrsMgr_PresentationManager thePrsMgr, Handle_Prs3d_Presentation thePrs, Standard_Integer const theMode=0)

        Fills presentation.
        @note Manipulator presentation does not use display mode and for all modes has the same presentation.

        :type thePrsMgr: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theMode: int

        """
        return _AIS.AIS_Manipulator_Compute(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(AIS_Manipulator self) -> Standard_Boolean

        Disables auto highlighting to use HilightSelected() and HilightOwnerWithColor() overridden methods.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Manipulator_IsAutoHilight(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(AIS_Manipulator self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw ).


        """
        return _AIS.AIS_Manipulator_ClearSelected(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(AIS_Manipulator self, Handle_PrsMgr_PresentationManager thePM, NCollection_Sequence_Handle_SelectMgr_EntityOwner theSeq)

        Method which draws selected owners ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theSeq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.AIS_Manipulator_HilightSelected(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(AIS_Manipulator self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_Manipulator_HilightOwnerWithColor(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Manipulator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Manipulator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Manipulator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def attach(self, *args):
        """
        attach(AIS_Manipulator self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False, Standard_Boolean const enableAllModes=True)
        attach(AIS_Manipulator self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False)
        attach(AIS_Manipulator self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const adjustPosition=True)
        attach(AIS_Manipulator self, Handle_AIS_InteractiveObject theObject)
        attach(AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False, Standard_Boolean const enableAllModes=True)
        attach(AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False)
        attach(AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject, Standard_Boolean const adjustPosition=True)
        attach(AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject)
        """
        return _AIS.AIS_Manipulator_attach(self, *args)


    def SetLocalTransformation(self, *args):
        return _AIS.AIS_Manipulator_SetLocalTransformation(self, *args)
    __swig_destroy__ = _AIS.delete_AIS_Manipulator
AIS_Manipulator_swigregister = _AIS.AIS_Manipulator_swigregister
AIS_Manipulator_swigregister(AIS_Manipulator)

def AIS_Manipulator_get_type_name(*args):
    """
    AIS_Manipulator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Manipulator_get_type_name(*args)

def AIS_Manipulator_get_type_descriptor(*args):
    """
    AIS_Manipulator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Manipulator_get_type_descriptor(*args)

class NCollection_Sequence_Handle_AIS_InteractiveObject(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> NCollection_Sequence< opencascade::handle< AIS_InteractiveObject > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> NCollection_Sequence< opencascade::handle< AIS_InteractiveObject > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> NCollection_Sequence< opencascade::handle< AIS_InteractiveObject > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> NCollection_Sequence< opencascade::handle< AIS_InteractiveObject > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _AIS.new_NCollection_Sequence_Handle_AIS_InteractiveObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_AIS_InteractiveObject self)

        Reverse sequence


        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_AIS_InteractiveObject self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_AIS_InteractiveObject self, NCollection_Sequence_Handle_AIS_InteractiveObject theOther) -> NCollection_Sequence_Handle_AIS_InteractiveObject

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_AIS_InteractiveObject self, NCollection_Sequence_Handle_AIS_InteractiveObject theOther) -> NCollection_Sequence_Handle_AIS_InteractiveObject

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_AIS_InteractiveObject self, NCollection_Sequence< opencascade::handle< AIS_InteractiveObject > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theItem)
        Append(NCollection_Sequence_Handle_AIS_InteractiveObject self, NCollection_Sequence_Handle_AIS_InteractiveObject theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theItem)
        Prepend(NCollection_Sequence_Handle_AIS_InteractiveObject self, NCollection_Sequence_Handle_AIS_InteractiveObject theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex, Handle_AIS_InteractiveObject theItem)
        InsertBefore(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_InteractiveObject theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_AIS_InteractiveObject self, NCollection_Sequence< opencascade::handle< AIS_InteractiveObject > >::Iterator & thePosition, Handle_AIS_InteractiveObject theItem)
        InsertAfter(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_InteractiveObject theSeq)
        InsertAfter(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex, Handle_AIS_InteractiveObject theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_InteractiveObject theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> Handle_AIS_InteractiveObject

        First item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_AIS_InteractiveObject self) -> Handle_AIS_InteractiveObject

        Last item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex) -> Handle_AIS_InteractiveObject

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_AIS_InteractiveObject self, Standard_Integer const theIndex, Handle_AIS_InteractiveObject theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_SetValue(self, *args)


    def __iter__(self):
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Handle_AIS_InteractiveObject
NCollection_Sequence_Handle_AIS_InteractiveObject_swigregister = _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_swigregister
NCollection_Sequence_Handle_AIS_InteractiveObject_swigregister(NCollection_Sequence_Handle_AIS_InteractiveObject)

def NCollection_Sequence_Handle_AIS_InteractiveObject_delNode(*args):
    """
    NCollection_Sequence_Handle_AIS_InteractiveObject_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_delNode(*args)

class NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper___next__(self)
NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper_swigregister = _AIS.NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper_swigregister
NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper_swigregister(NCollection_Sequence_Handle_AIS_InteractiveObject_IteratorHelper)


try:
	AIS_SequenceOfInteractive = NCollection_Sequence_Handle_AIS_InteractiveObject
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_PlaneTrihedron(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_PlaneTrihedron self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_PlaneTrihedron_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_PlaneTrihedron self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_PlaneTrihedron self, AIS_PlaneTrihedron thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_PlaneTrihedron_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_PlaneTrihedron self, Handle_AIS_PlaneTrihedron theHandle) -> Handle_AIS_PlaneTrihedron
        assign(Handle_AIS_PlaneTrihedron self, AIS_PlaneTrihedron thePtr) -> Handle_AIS_PlaneTrihedron
        assign(Handle_AIS_PlaneTrihedron self, Handle_AIS_PlaneTrihedron theHandle) -> Handle_AIS_PlaneTrihedron

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_PlaneTrihedron_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_PlaneTrihedron self) -> AIS_PlaneTrihedron

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_PlaneTrihedron_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_PlaneTrihedron self) -> AIS_PlaneTrihedron

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_PlaneTrihedron___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_PlaneTrihedron self) -> AIS_PlaneTrihedron

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_PlaneTrihedron___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_PlaneTrihedron___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_PlaneTrihedron___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_PlaneTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_PlaneTrihedron_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_PlaneTrihedron

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_PlaneTrihedron self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_PlaneTrihedron_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Component(self, *args):
        """
        Component(Handle_AIS_PlaneTrihedron self) -> Handle_Geom_Plane

        Returns the component specified in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Component(self, *args)


    def SetComponent(self, *args):
        """
        SetComponent(Handle_AIS_PlaneTrihedron self, Handle_Geom_Plane aPlane)

        Creates an instance of the component object aPlane.

        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetComponent(self, *args)


    def XAxis(self, *args):
        """
        XAxis(Handle_AIS_PlaneTrihedron self) -> Handle_AIS_Line

        Returns the "XAxis".

        :rtype: OCC.wrapper.AIS.Handle_AIS_Line

        """
        return _AIS.Handle_AIS_PlaneTrihedron_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(Handle_AIS_PlaneTrihedron self) -> Handle_AIS_Line

        Returns the "YAxis".

        :rtype: OCC.wrapper.AIS.Handle_AIS_Line

        """
        return _AIS.Handle_AIS_PlaneTrihedron_YAxis(self, *args)


    def Position(self, *args):
        """
        Position(Handle_AIS_PlaneTrihedron self) -> Handle_AIS_Point

        Returns the point of origin of the plane trihedron.

        :rtype: OCC.wrapper.AIS.Handle_AIS_Point

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Position(self, *args)


    def SetLength(self, *args):
        """
        SetLength(Handle_AIS_PlaneTrihedron self, Standard_Real const theLength)

        Sets the length of the X and Y axes.

        :type theLength: float

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetLength(self, *args)


    def GetLength(self, *args):
        """
        GetLength(Handle_AIS_PlaneTrihedron self) -> Standard_Real

        Returns the length of X and Y axes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GetLength(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_PlaneTrihedron self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode selected, aMode, is valid.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_PlaneTrihedron self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_PlaneTrihedron self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_PlaneTrihedron self) -> AIS_KindOfInteractive

        Returns datum as the type of Interactive Object.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Type(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_PlaneTrihedron self, Quantity_Color theColor)

        Allows you to provide settings for the color aColor.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetColor(self, *args)


    def SetXLabel(self, *args):
        """
        SetXLabel(Handle_AIS_PlaneTrihedron self, TCollection_AsciiString theLabel)

        :type theLabel: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetXLabel(self, *args)


    def SetYLabel(self, *args):
        """
        SetYLabel(Handle_AIS_PlaneTrihedron self, TCollection_AsciiString theLabel)

        :type theLabel: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetYLabel(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_PlaneTrihedron self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_PlaneTrihedron self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_PlaneTrihedron_CurrentFacingModel(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_PlaneTrihedron self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_PlaneTrihedron self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_PlaneTrihedron self)"""
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_PlaneTrihedron self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_PlaneTrihedron self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_PlaneTrihedron self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_PlaneTrihedron self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_PlaneTrihedron self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_PlaneTrihedron self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_PlaneTrihedron self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_PlaneTrihedron self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_PlaneTrihedron self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_PlaneTrihedron self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_PlaneTrihedron self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_PlaneTrihedron self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_PlaneTrihedron self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_PlaneTrihedron self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_PlaneTrihedron self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_PlaneTrihedron self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_PlaneTrihedron self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_PlaneTrihedron self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_PlaneTrihedron self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_PlaneTrihedron self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_PlaneTrihedron self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_PlaneTrihedron self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_PlaneTrihedron self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_PlaneTrihedron self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_PlaneTrihedron self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_PlaneTrihedron self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_PlaneTrihedron_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_PlaneTrihedron self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_PlaneTrihedron_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_PlaneTrihedron self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_PlaneTrihedron self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_PlaneTrihedron_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_PlaneTrihedron self)
        RecomputePrimitives(Handle_AIS_PlaneTrihedron self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PlaneTrihedron_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_PlaneTrihedron self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_PlaneTrihedron_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_PlaneTrihedron self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_PlaneTrihedron self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_PlaneTrihedron self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_PlaneTrihedron self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_PlaneTrihedron self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_PlaneTrihedron self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_PlaneTrihedron self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_PlaneTrihedron_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_PlaneTrihedron self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_PlaneTrihedron self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_PlaneTrihedron_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_PlaneTrihedron self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_PlaneTrihedron_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_PlaneTrihedron self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_PlaneTrihedron self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_PlaneTrihedron self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_PlaneTrihedron self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_PlaneTrihedron self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_PlaneTrihedron self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_PlaneTrihedron self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PlaneTrihedron_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_PlaneTrihedron self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_PlaneTrihedron self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_PlaneTrihedron_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_PlaneTrihedron self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_PlaneTrihedron self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_PlaneTrihedron self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_PlaneTrihedron self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_PlaneTrihedron_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_PlaneTrihedron self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_PlaneTrihedron self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_PlaneTrihedron self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_PlaneTrihedron self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_PlaneTrihedron self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_PlaneTrihedron self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_PlaneTrihedron self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_PlaneTrihedron self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_PlaneTrihedron_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_PlaneTrihedron self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_PlaneTrihedron self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_PlaneTrihedron self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_PlaneTrihedron_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_PlaneTrihedron self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_PlaneTrihedron_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_PlaneTrihedron self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_PlaneTrihedron_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_PlaneTrihedron self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_PlaneTrihedron self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_PlaneTrihedron self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_PlaneTrihedron self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_PlaneTrihedron_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_PlaneTrihedron self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_PlaneTrihedron_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_PlaneTrihedron self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_PlaneTrihedron self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_PlaneTrihedron self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_PlaneTrihedron self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PlaneTrihedron_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_PlaneTrihedron self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_PlaneTrihedron self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_PlaneTrihedron_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_PlaneTrihedron self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_PlaneTrihedron_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_PlaneTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_PlaneTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_PlaneTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_PlaneTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PlaneTrihedron_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_PlaneTrihedron self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_PlaneTrihedron_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_PlaneTrihedron self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_PlaneTrihedron self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_PlaneTrihedron_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_PlaneTrihedron self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PlaneTrihedron_DecrementRefCounter(self, *args)

Handle_AIS_PlaneTrihedron_swigregister = _AIS.Handle_AIS_PlaneTrihedron_swigregister
Handle_AIS_PlaneTrihedron_swigregister(Handle_AIS_PlaneTrihedron)

def Handle_AIS_PlaneTrihedron_DownCast(thing):
    return _AIS.Handle_AIS_PlaneTrihedron_DownCast(thing)
Handle_AIS_PlaneTrihedron_DownCast = _AIS.Handle_AIS_PlaneTrihedron_DownCast

class NCollection_Sequence_Handle_AIS_Relation(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_AIS_Relation self) -> NCollection_Sequence< opencascade::handle< AIS_Relation > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_AIS_Relation self) -> NCollection_Sequence< opencascade::handle< AIS_Relation > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_AIS_Relation self) -> NCollection_Sequence< opencascade::handle< AIS_Relation > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_AIS_Relation self) -> NCollection_Sequence< opencascade::handle< AIS_Relation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _AIS.new_NCollection_Sequence_Handle_AIS_Relation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_AIS_Relation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_AIS_Relation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_AIS_Relation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_AIS_Relation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_AIS_Relation self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_AIS_Relation self)

        Reverse sequence


        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_AIS_Relation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_AIS_Relation self, NCollection_Sequence_Handle_AIS_Relation theOther) -> NCollection_Sequence_Handle_AIS_Relation

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_AIS_Relation self, NCollection_Sequence_Handle_AIS_Relation theOther) -> NCollection_Sequence_Handle_AIS_Relation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_AIS_Relation self, NCollection_Sequence< opencascade::handle< AIS_Relation > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_AIS_Relation self, Handle_AIS_Relation theItem)
        Append(NCollection_Sequence_Handle_AIS_Relation self, NCollection_Sequence_Handle_AIS_Relation theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_AIS_Relation self, Handle_AIS_Relation theItem)
        Prepend(NCollection_Sequence_Handle_AIS_Relation self, NCollection_Sequence_Handle_AIS_Relation theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex, Handle_AIS_Relation theItem)
        InsertBefore(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_Relation theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_AIS_Relation self, NCollection_Sequence< opencascade::handle< AIS_Relation > >::Iterator & thePosition, Handle_AIS_Relation theItem)
        InsertAfter(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_Relation theSeq)
        InsertAfter(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex, Handle_AIS_Relation theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_Relation theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Relation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_AIS_Relation self) -> Handle_AIS_Relation

        First item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Relation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_AIS_Relation self) -> Handle_AIS_Relation

        Last item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Relation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex) -> Handle_AIS_Relation

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Relation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_AIS_Relation self, Standard_Integer const theIndex, Handle_AIS_Relation theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_SetValue(self, *args)


    def __iter__(self):
        return _AIS.NCollection_Sequence_Handle_AIS_Relation___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Handle_AIS_Relation
NCollection_Sequence_Handle_AIS_Relation_swigregister = _AIS.NCollection_Sequence_Handle_AIS_Relation_swigregister
NCollection_Sequence_Handle_AIS_Relation_swigregister(NCollection_Sequence_Handle_AIS_Relation)

def NCollection_Sequence_Handle_AIS_Relation_delNode(*args):
    """
    NCollection_Sequence_Handle_AIS_Relation_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _AIS.NCollection_Sequence_Handle_AIS_Relation_delNode(*args)

class NCollection_Sequence_Handle_AIS_Relation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_Sequence_Handle_AIS_Relation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Handle_AIS_Relation_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_Sequence_Handle_AIS_Relation_IteratorHelper___next__(self)
NCollection_Sequence_Handle_AIS_Relation_IteratorHelper_swigregister = _AIS.NCollection_Sequence_Handle_AIS_Relation_IteratorHelper_swigregister
NCollection_Sequence_Handle_AIS_Relation_IteratorHelper_swigregister(NCollection_Sequence_Handle_AIS_Relation_IteratorHelper)


try:
	AIS_SequenceOfDimension = NCollection_Sequence_Handle_AIS_Relation
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_AIS_InteractiveObject(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_AIS_InteractiveObject self) -> NCollection_List< opencascade::handle< AIS_InteractiveObject > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_AIS_InteractiveObject self) -> NCollection_List< opencascade::handle< AIS_InteractiveObject > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_AIS_InteractiveObject self) -> NCollection_List< opencascade::handle< AIS_InteractiveObject > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_AIS_InteractiveObject self) -> NCollection_List< opencascade::handle< AIS_InteractiveObject > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _AIS.new_NCollection_List_Handle_AIS_InteractiveObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_AIS_InteractiveObject self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_AIS_InteractiveObject self, NCollection_List_Handle_AIS_InteractiveObject theOther) -> NCollection_List_Handle_AIS_InteractiveObject

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_AIS_InteractiveObject self, NCollection_List_Handle_AIS_InteractiveObject theOther) -> NCollection_List_Handle_AIS_InteractiveObject

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_AIS_InteractiveObject self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_List_Handle_AIS_InteractiveObject_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_List_Handle_AIS_InteractiveObject_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theItem) -> Handle_AIS_InteractiveObject
        Append(NCollection_List_Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theItem, NCollection_List< opencascade::handle< AIS_InteractiveObject > >::Iterator & theIter)
        Append(NCollection_List_Handle_AIS_InteractiveObject self, NCollection_List_Handle_AIS_InteractiveObject theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theItem) -> Handle_AIS_InteractiveObject
        Prepend(NCollection_List_Handle_AIS_InteractiveObject self, NCollection_List_Handle_AIS_InteractiveObject theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_AIS_InteractiveObject self)

        RemoveFirst item


        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_AIS_InteractiveObject self, NCollection_List< opencascade::handle< AIS_InteractiveObject > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theItem, NCollection_List< opencascade::handle< AIS_InteractiveObject > >::Iterator & theIter) -> Handle_AIS_InteractiveObject
        InsertBefore(NCollection_List_Handle_AIS_InteractiveObject self, NCollection_List_Handle_AIS_InteractiveObject theOther, NCollection_List< opencascade::handle< AIS_InteractiveObject > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theItem, NCollection_List< opencascade::handle< AIS_InteractiveObject > >::Iterator & theIter) -> Handle_AIS_InteractiveObject
        InsertAfter(NCollection_List_Handle_AIS_InteractiveObject self, NCollection_List_Handle_AIS_InteractiveObject theOther, NCollection_List< opencascade::handle< AIS_InteractiveObject > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_AIS_InteractiveObject self)

        Reverse the list


        """
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_Reverse(self, *args)


    def __iter__(self):
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_List_Handle_AIS_InteractiveObject
NCollection_List_Handle_AIS_InteractiveObject_swigregister = _AIS.NCollection_List_Handle_AIS_InteractiveObject_swigregister
NCollection_List_Handle_AIS_InteractiveObject_swigregister(NCollection_List_Handle_AIS_InteractiveObject)

class NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper___next__(self)
NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper_swigregister = _AIS.NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper_swigregister
NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper_swigregister(NCollection_List_Handle_AIS_InteractiveObject_IteratorHelper)


try:
	AIS_ListOfInteractive = NCollection_List_Handle_AIS_InteractiveObject
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_AnimationCamera(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_AnimationCamera self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_AnimationCamera_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_AnimationCamera self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_AnimationCamera_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_AnimationCamera self, AIS_AnimationCamera thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_AnimationCamera_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_AnimationCamera self, Handle_AIS_AnimationCamera theHandle) -> Handle_AIS_AnimationCamera
        assign(Handle_AIS_AnimationCamera self, AIS_AnimationCamera thePtr) -> Handle_AIS_AnimationCamera
        assign(Handle_AIS_AnimationCamera self, Handle_AIS_AnimationCamera theHandle) -> Handle_AIS_AnimationCamera

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_AnimationCamera_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_AnimationCamera self) -> AIS_AnimationCamera

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_AnimationCamera_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_AnimationCamera self) -> AIS_AnimationCamera

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_AnimationCamera___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_AnimationCamera self) -> AIS_AnimationCamera

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_AnimationCamera___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_AnimationCamera___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_AnimationCamera___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_AnimationCamera(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_AnimationCamera_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_AnimationCamera

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_AnimationCamera self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_AnimationCamera_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AnimationCamera_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AnimationCamera_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def View(self, *args):
        """
        Return the target view.

        :rtype: OCC.wrapper.V3d.Handle_V3d_View

        """
        res = _AIS.Handle_AIS_AnimationCamera_View(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CameraStart(self, *args):
        """
        Return camera start position.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _AIS.Handle_AIS_AnimationCamera_CameraStart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCameraStart(self, *args):
        """
        SetCameraStart(Handle_AIS_AnimationCamera self, Handle_Graphic3d_Camera theCameraStart)

        Define camera start position.

        :type theCameraStart: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _AIS.Handle_AIS_AnimationCamera_SetCameraStart(self, *args)


    def CameraEnd(self, *args):
        """
        Return camera end position.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        res = _AIS.Handle_AIS_AnimationCamera_CameraEnd(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCameraEnd(self, *args):
        """
        SetCameraEnd(Handle_AIS_AnimationCamera self, Handle_Graphic3d_Camera theCameraEnd)

        Define camera end position.

        :type theCameraEnd: OCC.wrapper.Graphic3d.Handle_Graphic3d_Camera

        """
        return _AIS.Handle_AIS_AnimationCamera_SetCameraEnd(self, *args)


    def Name(self, *args):
        """
        Animation name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_AnimationCamera_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPts(self, *args):
        """
        StartPts(Handle_AIS_AnimationCamera self) -> Standard_Real

        @return start time of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationCamera_StartPts(self, *args)


    def SetStartPts(self, *args):
        """
        SetStartPts(Handle_AIS_AnimationCamera self, Standard_Real const thePtsStart)

        Sets time limits for animation in the animation timeline

        :type thePtsStart: float

        """
        return _AIS.Handle_AIS_AnimationCamera_SetStartPts(self, *args)


    def Duration(self, *args):
        """
        Duration(Handle_AIS_AnimationCamera self) -> Standard_Real

        @return duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationCamera_Duration(self, *args)


    def UpdateTotalDuration(self, *args):
        """
        UpdateTotalDuration(Handle_AIS_AnimationCamera self)

        Update total duration considering all animations on timeline.


        """
        return _AIS.Handle_AIS_AnimationCamera_UpdateTotalDuration(self, *args)


    def HasOwnDuration(self, *args):
        """
        HasOwnDuration(Handle_AIS_AnimationCamera self) -> Standard_Boolean

        Return true if duration is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationCamera_HasOwnDuration(self, *args)


    def OwnDuration(self, *args):
        """
        OwnDuration(Handle_AIS_AnimationCamera self) -> Standard_Real

        @return own duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationCamera_OwnDuration(self, *args)


    def SetOwnDuration(self, *args):
        """
        SetOwnDuration(Handle_AIS_AnimationCamera self, Standard_Real const theDuration)

        Defines duration of the animation.

        :type theDuration: float

        """
        return _AIS.Handle_AIS_AnimationCamera_SetOwnDuration(self, *args)


    def Add(self, *args):
        """
        Add(Handle_AIS_AnimationCamera self, Handle_AIS_Animation theAnimation)

        Add single animation to the timeline.
        @param theAnimation input animation

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_AnimationCamera_Add(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_AIS_AnimationCamera self)

        Clear animation timeline - remove all animations from it.


        """
        return _AIS.Handle_AIS_AnimationCamera_Clear(self, *args)


    def Find(self, *args):
        """
        Find(Handle_AIS_AnimationCamera self, TCollection_AsciiString theAnimationName) -> Handle_AIS_Animation

        Return the child animation with the given name.

        :type theAnimationName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_AnimationCamera_Find(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_AIS_AnimationCamera self, Handle_AIS_Animation theAnimation) -> Standard_Boolean

        Remove the child animation.

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationCamera_Remove(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_AIS_AnimationCamera self, Handle_AIS_Animation theAnimationOld, Handle_AIS_Animation theAnimationNew) -> Standard_Boolean

        Replace the child animation.

        :type theAnimationOld: OCC.wrapper.AIS.Handle_AIS_Animation
        :type theAnimationNew: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationCamera_Replace(self, *args)


    def CopyFrom(self, *args):
        """
        CopyFrom(Handle_AIS_AnimationCamera self, Handle_AIS_Animation theOther)

        Clears own children and then copy child animations from another object.
        Copy also Start Time and Duration values.

        :type theOther: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_AnimationCamera_CopyFrom(self, *args)


    def Children(self, *args):
        """
        Return sequence of child animations.

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_Animation

        """
        res = _AIS.Handle_AIS_AnimationCamera_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartTimer(self, *args):
        """
        StartTimer(Handle_AIS_AnimationCamera self, Standard_Real const theStartPts, Standard_Real const thePlaySpeed, Standard_Boolean const theToUpdate, Standard_Boolean const theToStopTimer)

        Start animation with internally defined timer instance.
        Calls ::Start() internally.
        @param theStartPts    starting timer position (presentation timestamp)
        @param thePlaySpeed   playback speed (1.0 means normal speed)
        @param theToUpdate    flag to update defined animations to specified start position
        @param theToStopTimer flag to pause timer at the starting position

        :type theStartPts: float
        :type thePlaySpeed: float
        :type theToUpdate: bool
        :type theToStopTimer: bool

        """
        return _AIS.Handle_AIS_AnimationCamera_StartTimer(self, *args)


    def UpdateTimer(self, *args):
        """
        UpdateTimer(Handle_AIS_AnimationCamera self) -> Standard_Real

        Update single frame of animation, update timer state
        @return current time of timeline progress.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationCamera_UpdateTimer(self, *args)


    def ElapsedTime(self, *args):
        """
        ElapsedTime(Handle_AIS_AnimationCamera self) -> Standard_Real

        Return elapsed time.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationCamera_ElapsedTime(self, *args)


    def Start(self, *args):
        """
        Start(Handle_AIS_AnimationCamera self, Standard_Boolean const theToUpdate)

        Start animation. This method changes status of the animation to Started.
        This status defines whether animation is to be performed in the timeline or not.
        @param theToUpdate call Update() method

        :type theToUpdate: bool

        """
        return _AIS.Handle_AIS_AnimationCamera_Start(self, *args)


    def Pause(self, *args):
        """
        Pause(Handle_AIS_AnimationCamera self)

        Pause the process timeline.


        """
        return _AIS.Handle_AIS_AnimationCamera_Pause(self, *args)


    def Stop(self, *args):
        """
        Stop(Handle_AIS_AnimationCamera self)

        Stop animation. This method changed status of the animation to Stopped.
        This status shows that animation will not be performed in the timeline or it is finished.


        """
        return _AIS.Handle_AIS_AnimationCamera_Stop(self, *args)


    def IsStopped(self, *args):
        """
        IsStopped(Handle_AIS_AnimationCamera self) -> bool

        Check if animation is to be performed in the animation timeline.
        @return True if it is stopped of finished.

        :rtype: bool

        """
        return _AIS.Handle_AIS_AnimationCamera_IsStopped(self, *args)


    def Update(self, *args):
        """
        Update(Handle_AIS_AnimationCamera self, Standard_Real const thePts) -> Standard_Boolean

        Update single frame of animation, update timer state
        @param thePts [in] the time moment within [0; Duration()]
        @return True if timeline is in progress

        :type thePts: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationCamera_Update(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_AnimationCamera self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_AnimationCamera_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_AnimationCamera self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_AnimationCamera self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationCamera_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_AnimationCamera self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_AnimationCamera self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationCamera_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_AnimationCamera self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_AnimationCamera_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_AnimationCamera self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AnimationCamera_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_AnimationCamera self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_AnimationCamera_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_AnimationCamera self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AnimationCamera_DecrementRefCounter(self, *args)

Handle_AIS_AnimationCamera_swigregister = _AIS.Handle_AIS_AnimationCamera_swigregister
Handle_AIS_AnimationCamera_swigregister(Handle_AIS_AnimationCamera)

def Handle_AIS_AnimationCamera_DownCast(thing):
    return _AIS.Handle_AIS_AnimationCamera_DownCast(thing)
Handle_AIS_AnimationCamera_DownCast = _AIS.Handle_AIS_AnimationCamera_DownCast

class Handle_AIS_IdenticRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_IdenticRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_IdenticRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_IdenticRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_IdenticRelation self, AIS_IdenticRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_IdenticRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_IdenticRelation self, Handle_AIS_IdenticRelation theHandle) -> Handle_AIS_IdenticRelation
        assign(Handle_AIS_IdenticRelation self, AIS_IdenticRelation thePtr) -> Handle_AIS_IdenticRelation
        assign(Handle_AIS_IdenticRelation self, Handle_AIS_IdenticRelation theHandle) -> Handle_AIS_IdenticRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_IdenticRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_IdenticRelation self) -> AIS_IdenticRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_IdenticRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_IdenticRelation self) -> AIS_IdenticRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_IdenticRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_IdenticRelation self) -> AIS_IdenticRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_IdenticRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_IdenticRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_IdenticRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_IdenticRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_IdenticRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_IdenticRelation

    def HasUsers(self, *args):
        """
        HasUsers(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasUsers(self, *args)


    def Users(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfTransient

        """
        res = _AIS.Handle_AIS_IdenticRelation_Users(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddUser(self, *args):
        """
        AddUser(Handle_AIS_IdenticRelation self, Handle_Standard_Transient theUser)

        :type theUser: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_IdenticRelation_AddUser(self, *args)


    def ClearUsers(self, *args):
        """ClearUsers(Handle_AIS_IdenticRelation self)"""
        return _AIS.Handle_AIS_IdenticRelation_ClearUsers(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_IdenticRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_IdenticRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_IdenticRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_IdenticRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_IdenticRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_IdenticRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_IdenticRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_IdenticRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_IdenticRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_IdenticRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_IdenticRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_IdenticRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_IdenticRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_IdenticRelation_KindOfDimension(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_IdenticRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_IdenticRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_IdenticRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_IdenticRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_IdenticRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_IdenticRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_IdenticRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_IdenticRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_IdenticRelation self)"""
        return _AIS.Handle_AIS_IdenticRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_IdenticRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_IdenticRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_IdenticRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_IdenticRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_IdenticRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_IdenticRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_IdenticRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_IdenticRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_IdenticRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_IdenticRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_IdenticRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_IdenticRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_IdenticRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_IdenticRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_IdenticRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_IdenticRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_IdenticRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_IdenticRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_IdenticRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_IdenticRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_IdenticRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_IdenticRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_IdenticRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_IdenticRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_IdenticRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_IdenticRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_IdenticRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_IdenticRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_IdenticRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_IdenticRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_IdenticRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_IdenticRelation self)"""
        return _AIS.Handle_AIS_IdenticRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_IdenticRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_IdenticRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_IdenticRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_IdenticRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_IdenticRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_IdenticRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_IdenticRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_IdenticRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_IdenticRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_IdenticRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_IdenticRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_IdenticRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_IdenticRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_IdenticRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_IdenticRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_IdenticRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_IdenticRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_IdenticRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_IdenticRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_IdenticRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_IdenticRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_IdenticRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_IdenticRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_IdenticRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_IdenticRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_IdenticRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_IdenticRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_IdenticRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_IdenticRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_IdenticRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_IdenticRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_IdenticRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_IdenticRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_IdenticRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_IdenticRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_IdenticRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_IdenticRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_IdenticRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_IdenticRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_IdenticRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_IdenticRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_IdenticRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_IdenticRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_IdenticRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_IdenticRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_IdenticRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_IdenticRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_IdenticRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_IdenticRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_IdenticRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_IdenticRelation self)
        RecomputePrimitives(Handle_AIS_IdenticRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_IdenticRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_IdenticRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_IdenticRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_IdenticRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_IdenticRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_IdenticRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_IdenticRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_IdenticRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_IdenticRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_IdenticRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_IdenticRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_IdenticRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_IdenticRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_IdenticRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_IdenticRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_IdenticRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_IdenticRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_IdenticRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_IdenticRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_IdenticRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_IdenticRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_IdenticRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_IdenticRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_IdenticRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_IdenticRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_IdenticRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_IdenticRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_IdenticRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_IdenticRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_IdenticRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_IdenticRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_IdenticRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_IdenticRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_IdenticRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_IdenticRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_IdenticRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_IdenticRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_IdenticRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_IdenticRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_IdenticRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_IdenticRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_IdenticRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_IdenticRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_IdenticRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_IdenticRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_IdenticRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_IdenticRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_IdenticRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_IdenticRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_IdenticRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_IdenticRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_IdenticRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_IdenticRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_IdenticRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_IdenticRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_IdenticRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_IdenticRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_IdenticRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_IdenticRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_IdenticRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_IdenticRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_IdenticRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_IdenticRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_IdenticRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_IdenticRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_IdenticRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_IdenticRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_IdenticRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_IdenticRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_IdenticRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_IdenticRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_IdenticRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_IdenticRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_IdenticRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_IdenticRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_IdenticRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_IdenticRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_IdenticRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_IdenticRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_IdenticRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_IdenticRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_IdenticRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_IdenticRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_IdenticRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_IdenticRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_IdenticRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_IdenticRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_IdenticRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_IdenticRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_IdenticRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_IdenticRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_IdenticRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_IdenticRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_IdenticRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_IdenticRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_IdenticRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_IdenticRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_IdenticRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_IdenticRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_IdenticRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_IdenticRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_IdenticRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_IdenticRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_IdenticRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_IdenticRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_IdenticRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_IdenticRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_IdenticRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_IdenticRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_IdenticRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_IdenticRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_IdenticRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_IdenticRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_IdenticRelation_DecrementRefCounter(self, *args)

Handle_AIS_IdenticRelation_swigregister = _AIS.Handle_AIS_IdenticRelation_swigregister
Handle_AIS_IdenticRelation_swigregister(Handle_AIS_IdenticRelation)

def Handle_AIS_IdenticRelation_DownCast(thing):
    return _AIS.Handle_AIS_IdenticRelation_DownCast(thing)
Handle_AIS_IdenticRelation_DownCast = _AIS.Handle_AIS_IdenticRelation_DownCast

class Handle_AIS_AngleDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_AngleDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_AngleDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_AngleDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_AngleDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_AngleDimension self, AIS_AngleDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_AngleDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_AngleDimension self, Handle_AIS_AngleDimension theHandle) -> Handle_AIS_AngleDimension
        assign(Handle_AIS_AngleDimension self, AIS_AngleDimension thePtr) -> Handle_AIS_AngleDimension
        assign(Handle_AIS_AngleDimension self, Handle_AIS_AngleDimension theHandle) -> Handle_AIS_AngleDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_AngleDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_AngleDimension self) -> AIS_AngleDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_AngleDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_AngleDimension self) -> AIS_AngleDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_AngleDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_AngleDimension self) -> AIS_AngleDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_AngleDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_AngleDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_AngleDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_AngleDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_AngleDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_AngleDimension

    def FirstPoint(self, *args):
        """
        @return first point forming the angle.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_AngleDimension_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondPoint(self, *args):
        """
        @return second point forming the angle.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_AngleDimension_SecondPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CenterPoint(self, *args):
        """
        @return center point forming the angle.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_AngleDimension_CenterPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstShape(self, *args):
        """
        @return first argument shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_AngleDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondShape(self, *args):
        """
        @return second argument shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_AngleDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ThirdShape(self, *args):
        """
        @return third argument shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_AngleDimension_ThirdShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(Handle_AIS_AngleDimension self, TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge)
        SetMeasuredGeometry(Handle_AIS_AngleDimension self, gp_Pnt theFirstPoint, gp_Pnt theSecondPoint, gp_Pnt theThridPoint)
        SetMeasuredGeometry(Handle_AIS_AngleDimension self, TopoDS_Vertex theFirstVertex, TopoDS_Vertex theSecondVertex, TopoDS_Vertex theThirdVertex)
        SetMeasuredGeometry(Handle_AIS_AngleDimension self, TopoDS_Face theCone)
        SetMeasuredGeometry(Handle_AIS_AngleDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace)
        SetMeasuredGeometry(Handle_AIS_AngleDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, gp_Pnt thePoint)

        Measures angle between two planar faces.
        @param theFirstFace [in] the first face.
        @param theSecondFace [in] the second face.
        @param thePoint [in] the point which the dimension plane should pass through.
        This point can lay on the one of the faces or not.

        :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_AngleDimension_SetMeasuredGeometry(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_AngleDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_AngleDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(Handle_AIS_AngleDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_AngleDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(Handle_AIS_AngleDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_AngleDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(Handle_AIS_AngleDimension self, gp_Pnt theTextPos)

        Principle of horizontal text alignment settings:
        - divide circle into two halves according to attachment points
        - if aTextPos is between attach points -> Center + positive flyout
        - if aTextPos is not between attach points but in this half -> Left or Right + positive flyout
        - if aTextPos is between reflections of attach points -> Center + negative flyout
        - if aTextPos is not between reflections of attach points -> Left or Right + negative flyout

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_AngleDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(Handle_AIS_AngleDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_AngleDimension_GetTextPosition(self, *args)


    def SetType(self, *args):
        """
        SetType(Handle_AIS_AngleDimension self, AIS_TypeOfAngle const theType)

        Sets angle type.
        @param theType [in] the type value.

        :type theType: OCC.wrapper.AIS.AIS_TypeOfAngle

        """
        return _AIS.Handle_AIS_AngleDimension_SetType(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_AIS_AngleDimension self) -> AIS_TypeOfAngle

        @return the current angle type.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfAngle

        """
        return _AIS.Handle_AIS_AngleDimension_GetType(self, *args)


    def SetArrowsVisibility(self, *args):
        """
        SetArrowsVisibility(Handle_AIS_AngleDimension self, AIS_TypeOfAngleArrowVisibility const & theType)

        Sets visible arrows type
        @param theType [in] the type of visibility of arrows.

        :type theType: OCC.wrapper.AIS.AIS_TypeOfAngleArrowVisibility

        """
        return _AIS.Handle_AIS_AngleDimension_SetArrowsVisibility(self, *args)


    def GetArrowsVisibility(self, *args):
        """
        GetArrowsVisibility(Handle_AIS_AngleDimension self) -> AIS_TypeOfAngleArrowVisibility

        @return the type of visibility of arrows.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfAngleArrowVisibility

        """
        return _AIS.Handle_AIS_AngleDimension_GetArrowsVisibility(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_AngleDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_AngleDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AngleDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AngleDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetValue(self, *args):
        """
        GetValue(Handle_AIS_AngleDimension self) -> Standard_Real

        Gets dimension measurement value. If the value to display is not
        specified by user, then the dimension object is responsible to
        compute it on its own in model space coordinates.
        @return the dimension value (in model units) which is used
        during display of the presentation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AngleDimension_GetValue(self, *args)


    def SetComputedValue(self, *args):
        """
        SetComputedValue(Handle_AIS_AngleDimension self)

        Sets computed dimension value. Resets custom value mode if it was set.


        """
        return _AIS.Handle_AIS_AngleDimension_SetComputedValue(self, *args)


    def SetCustomValue(self, *args):
        """
        SetCustomValue(Handle_AIS_AngleDimension self, Standard_Real const theValue)
        SetCustomValue(Handle_AIS_AngleDimension self, TCollection_ExtendedString theValue)

        Sets user-defined dimension value.
        Unit conversion during the display is not applyed.
        @param theValue [in] the user-defined value to display.

        :type theValue: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_AngleDimension_SetCustomValue(self, *args)


    def GetCustomValue(self, *args):
        """
        Gets user-defined dimension value.
        @return dimension value string.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_AngleDimension_GetCustomValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPlane(self, *args):
        """
        Get the dimension plane in which the 2D dimension presentation is computed.
        By default, if plane is not defined by user, it is computed automatically
        after dimension geometry is computed.
        If computed dimension geometry (points) can't be placed on the user-defined
        plane, dimension geometry was set as invalid (validity flag is set to false)
        and dimension presentation will not be computed.
        If user-defined plane allow geometry placement on it, it will be used for
        computing of the dimension presentation.
        @return dimension plane used for presentation computing.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _AIS.Handle_AIS_AngleDimension_GetPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetGeometryType(self, *args):
        """
        GetGeometryType(Handle_AIS_AngleDimension self) -> Standard_Integer

        Geometry type defines type of shapes on which the dimension is to be built. 
        @return type of geometry on which the dimension will be built.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_GetGeometryType(self, *args)


    def SetCustomPlane(self, *args):
        """
        SetCustomPlane(Handle_AIS_AngleDimension self, gp_Pln thePlane)

        Sets user-defined plane where the 2D dimension presentation will be placed.
        Checks validity of this plane if geometry has been set already.
        Validity of the plane is checked according to the geometry set
        and has different criteria for different kinds of dimensions.

        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        return _AIS.Handle_AIS_AngleDimension_SetCustomPlane(self, *args)


    def UnsetCustomPlane(self, *args):
        """
        UnsetCustomPlane(Handle_AIS_AngleDimension self)

        Unsets user-defined plane. Therefore the plane for dimension will be
        computed automatically.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetCustomPlane(self, *args)


    def IsTextPositionCustom(self, *args):
        """
        IsTextPositionCustom(Handle_AIS_AngleDimension self) -> Standard_Boolean

        @return TRUE if text position is set by user with method SetTextPosition().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsTextPositionCustom(self, *args)


    def DimensionAspect(self, *args):
        """
        DimensionAspect(Handle_AIS_AngleDimension self) -> Handle_Prs3d_DimensionAspect

        Gets the dimension aspect from AIS object drawer.
        Dimension aspect contains aspects of line, text and arrows for dimension presentation.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_AngleDimension_DimensionAspect(self, *args)


    def SetDimensionAspect(self, *args):
        """
        SetDimensionAspect(Handle_AIS_AngleDimension self, Handle_Prs3d_DimensionAspect theDimensionAspect)

        Sets new dimension aspect for the interactive object drawer.
        The dimension aspect provides dynamic properties which are generally
        used during computation of dimension presentations.

        :type theDimensionAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_AngleDimension_SetDimensionAspect(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_AngleDimension self) -> AIS_KindOfDimension

        @return the kind of dimension.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_AngleDimension_KindOfDimension(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_AngleDimension self) -> AIS_KindOfInteractive

        @return the kind of interactive.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_AngleDimension_Type(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_AngleDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode theMode.
        The interactive context can have a default mode of representation for
        the set of Interactive Objects. This mode may not be accepted by object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_AcceptDisplayMode(self, *args)


    def DisplaySpecialSymbol(self, *args):
        """
        DisplaySpecialSymbol(Handle_AIS_AngleDimension self) -> AIS_DisplaySpecialSymbol

        @return dimension special symbol display options.

        :rtype: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_AngleDimension_DisplaySpecialSymbol(self, *args)


    def SetDisplaySpecialSymbol(self, *args):
        """
        SetDisplaySpecialSymbol(Handle_AIS_AngleDimension self, AIS_DisplaySpecialSymbol const theDisplaySpecSymbol)

        Specifies whether to display special symbol or not.

        :type theDisplaySpecSymbol: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_AngleDimension_SetDisplaySpecialSymbol(self, *args)


    def SpecialSymbol(self, *args):
        """
        SpecialSymbol(Handle_AIS_AngleDimension self) -> Standard_ExtCharacter

        @return special symbol.

        :rtype: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_AngleDimension_SpecialSymbol(self, *args)


    def SetSpecialSymbol(self, *args):
        """
        SetSpecialSymbol(Handle_AIS_AngleDimension self, Standard_ExtCharacter const theSpecialSymbol)

        Specifies special symbol.

        :type theSpecialSymbol: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_AngleDimension_SetSpecialSymbol(self, *args)


    def UnsetFixedTextPosition(self, *args):
        """
        UnsetFixedTextPosition(Handle_AIS_AngleDimension self)

        Unsets user defined text positioning and enables text positioning
        by other parameters: text alignment, extension size, flyout and custom plane.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetFixedTextPosition(self, *args)


    def SelToleranceForText2d(self, *args):
        """
        SelToleranceForText2d(Handle_AIS_AngleDimension self) -> Standard_Real

        Returns selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        Important! Only for 2d text.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AngleDimension_SelToleranceForText2d(self, *args)


    def SetSelToleranceForText2d(self, *args):
        """
        SetSelToleranceForText2d(Handle_AIS_AngleDimension self, Standard_Real const theTol)

        Sets selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        to change this tolerance use this method
        Important! Only for 2d text.

        :type theTol: float

        """
        return _AIS.Handle_AIS_AngleDimension_SetSelToleranceForText2d(self, *args)


    def GetFlyout(self, *args):
        """
        GetFlyout(Handle_AIS_AngleDimension self) -> Standard_Real

        @return flyout value for dimension.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AngleDimension_GetFlyout(self, *args)


    def SetFlyout(self, *args):
        """
        SetFlyout(Handle_AIS_AngleDimension self, Standard_Real const theFlyout)

        Sets flyout value for dimension.

        :type theFlyout: float

        """
        return _AIS.Handle_AIS_AngleDimension_SetFlyout(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Check that the input geometry for dimension is valid and the
        presentation can be successfully computed.
        @return TRUE if dimension geometry is ok.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsValid(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_AngleDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_AngleDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_AngleDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_AngleDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_AngleDimension_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_AngleDimension self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_AngleDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_AngleDimension self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_AngleDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_AngleDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_AngleDimension self)"""
        return _AIS.Handle_AIS_AngleDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_AngleDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_AngleDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_AngleDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_AngleDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_AngleDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_AngleDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_AngleDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_AngleDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_AngleDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_AngleDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_AngleDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_AngleDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_AngleDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_AngleDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_AngleDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_AngleDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_AngleDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_AngleDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_AngleDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_AngleDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_AngleDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_AngleDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_AngleDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_AngleDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_AngleDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AngleDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_AngleDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_AngleDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_AngleDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_AngleDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_AngleDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_AngleDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_AngleDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_AngleDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AngleDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_AngleDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_AngleDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_AngleDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_AngleDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_AngleDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_AngleDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_AngleDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_AngleDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_AngleDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_AngleDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_AngleDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_AngleDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_AngleDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_AngleDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_AngleDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_AngleDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_AngleDimension self)
        RecomputePrimitives(Handle_AIS_AngleDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_AngleDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_AngleDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_AngleDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_AngleDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_AngleDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_AngleDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_AngleDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_AngleDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def More(self, *args):
        """
        More(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_AngleDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_AngleDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_AngleDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_AngleDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_AngleDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_AngleDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_AngleDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_AngleDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_AngleDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_AngleDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_AngleDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_AngleDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_AngleDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_AngleDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_AngleDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_AngleDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_AngleDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_AngleDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_AngleDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_AngleDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_AngleDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_AngleDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_AngleDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_AngleDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_AngleDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_AngleDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_AngleDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_AngleDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_AngleDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_AngleDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_AngleDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_AngleDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_AngleDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_AngleDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_AngleDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_AngleDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_AngleDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_AngleDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_AngleDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_AngleDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_AngleDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_AngleDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_AngleDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_AngleDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_AngleDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_AngleDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_AngleDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_AngleDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_AngleDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_AngleDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_AngleDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_AngleDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_AngleDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_AngleDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_AngleDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_AngleDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_AngleDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_AngleDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_AngleDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_AngleDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_AngleDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_AngleDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_AngleDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_AngleDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_AngleDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_AngleDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_AngleDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_AngleDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_AngleDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_AngleDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_AngleDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_AngleDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_AngleDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_AngleDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_AngleDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_AngleDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_AngleDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_AngleDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_AngleDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_AngleDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_AngleDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_AngleDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_AngleDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_AngleDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_AngleDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_AngleDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_AngleDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_AngleDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_AngleDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_AngleDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_AngleDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_AngleDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_AngleDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_AngleDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_AngleDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_AngleDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_AngleDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_AngleDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_AngleDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_AngleDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_AngleDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_AngleDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AngleDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_AngleDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_AngleDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_AngleDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_AngleDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_AngleDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_AngleDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AngleDimension_DecrementRefCounter(self, *args)

Handle_AIS_AngleDimension_swigregister = _AIS.Handle_AIS_AngleDimension_swigregister
Handle_AIS_AngleDimension_swigregister(Handle_AIS_AngleDimension)

def Handle_AIS_AngleDimension_DownCast(thing):
    return _AIS.Handle_AIS_AngleDimension_DownCast(thing)
Handle_AIS_AngleDimension_DownCast = _AIS.Handle_AIS_AngleDimension_DownCast

class Handle_AIS_Axis(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Axis self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Axis_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Axis self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Axis_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Axis self, AIS_Axis thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Axis_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Axis self, Handle_AIS_Axis theHandle) -> Handle_AIS_Axis
        assign(Handle_AIS_Axis self, AIS_Axis thePtr) -> Handle_AIS_Axis
        assign(Handle_AIS_Axis self, Handle_AIS_Axis theHandle) -> Handle_AIS_Axis

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Axis_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Axis self) -> AIS_Axis

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Axis_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Axis self) -> AIS_Axis

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Axis___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Axis self) -> AIS_Axis

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Axis___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Axis___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Axis___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Axis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Axis_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Axis

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Axis self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Axis_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Axis_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Axis_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Component(self, *args):
        """
        Returns the axis entity aComponent and identifies it
        as a component of a shape.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Line

        """
        res = _AIS.Handle_AIS_Axis_Component(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetComponent(self, *args):
        """
        SetComponent(Handle_AIS_Axis self, Handle_Geom_Line aComponent)

        Sets the coordinates of the lin aComponent.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Line

        """
        return _AIS.Handle_AIS_Axis_SetComponent(self, *args)


    def Axis2Placement(self, *args):
        """
        Returns the position of axis2 and   positions it by
        identifying it as the x, y, or z axis and giving its
        direction in 3D space. The coordinate system used is right-handed.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        res = _AIS.Handle_AIS_Axis_Axis2Placement(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis2Placement(self, *args):
        """
        SetAxis2Placement(Handle_AIS_Axis self, Handle_Geom_Axis2Placement aComponent, AIS_TypeOfAxis const anAxisType)

        Allows you to provide settings for aComponent:the
        position and direction of an axis in 3D space. The
        coordinate system used is right-handed.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement
        :type anAxisType: OCC.wrapper.AIS.AIS_TypeOfAxis

        """
        return _AIS.Handle_AIS_Axis_SetAxis2Placement(self, *args)


    def SetAxis1Placement(self, *args):
        """
        SetAxis1Placement(Handle_AIS_Axis self, Handle_Geom_Axis1Placement anAxis)

        Constructs a new line to serve as the axis anAxis in 3D space.

        :type anAxis: OCC.wrapper.Geom.Handle_Geom_Axis1Placement

        """
        return _AIS.Handle_AIS_Axis_SetAxis1Placement(self, *args)


    def TypeOfAxis(self, *args):
        """
        TypeOfAxis(Handle_AIS_Axis self) -> AIS_TypeOfAxis

        Returns the type of axis.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfAxis

        """
        return _AIS.Handle_AIS_Axis_TypeOfAxis(self, *args)


    def SetTypeOfAxis(self, *args):
        """
        SetTypeOfAxis(Handle_AIS_Axis self, AIS_TypeOfAxis const theTypeAxis)

        Constructs the entity theTypeAxis to stock information
        concerning type of axis.

        :type theTypeAxis: OCC.wrapper.AIS.AIS_TypeOfAxis

        """
        return _AIS.Handle_AIS_Axis_SetTypeOfAxis(self, *args)


    def IsXYZAxis(self, *args):
        """
        IsXYZAxis(Handle_AIS_Axis self) -> Standard_Boolean

        Returns a signature of 2 for axis datums. When you
        activate mode 2 by a signature, you pick AIS objects
        of type AIS_Axis.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_IsXYZAxis(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Axis self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the interactive object accepts the display mode aMode.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_Axis self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Axis_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Axis self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Axis_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Axis self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Axis_Type(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Axis self, Quantity_Color aColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Axis_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Axis self, Standard_Real const aValue)

        :type aValue: float

        """
        return _AIS.Handle_AIS_Axis_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Axis self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_Axis_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Axis self)"""
        return _AIS.Handle_AIS_Axis_UnsetWidth(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Axis self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Axis self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Axis_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Axis self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Axis_CurrentFacingModel(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Axis self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Axis_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Axis self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Axis_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Axis self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Axis_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Axis self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Axis self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Axis_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Axis self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Axis_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Axis_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Axis self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Axis_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Axis self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Axis_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Axis self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Axis_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Axis self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Axis_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Axis self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Axis_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Axis self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Axis_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Axis self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Axis_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Axis self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Axis_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Axis self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Axis_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Axis self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Axis_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Axis self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Axis_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Axis self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Axis_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Axis self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Axis_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Axis self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Axis_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Axis self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Axis_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Axis self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Axis_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Axis self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Axis_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Axis self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Axis self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Axis_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Axis self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Axis_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Axis self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Axis_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Axis self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Axis self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Axis_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Axis self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Axis_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Axis self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Axis_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Axis self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Axis_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Axis self)
        RecomputePrimitives(Handle_AIS_Axis self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Axis_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Axis self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Axis_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Axis self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Axis_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Axis_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Axis self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Axis_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Axis self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Axis_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Axis self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Axis self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Axis_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Axis_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Axis self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Axis_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Axis self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Axis_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Axis self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Axis_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Axis self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Axis_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Axis self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Axis_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Axis self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Axis_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Axis self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Axis_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Axis self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Axis self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Axis_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Axis self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Axis_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Axis self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Axis_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Axis self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Axis_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Axis self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Axis_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Axis self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Axis_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Axis self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Axis_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Axis self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Axis_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Axis self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Axis_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Axis self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Axis_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Axis_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Axis self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Axis_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Axis self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Axis_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Axis_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Axis self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Axis self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Axis_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Axis self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Axis_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Axis self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Axis_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Axis self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Axis_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Axis self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Axis self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Axis_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Axis self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Axis_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Axis_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Axis self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Axis self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Axis_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Axis_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Axis_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Axis_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Axis_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Axis self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Axis_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Axis self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Axis_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Axis self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Axis_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Axis self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Axis self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Axis_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Axis_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Axis self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Axis_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Axis self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Axis_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Axis self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Axis_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Axis_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Axis self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Axis self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Axis_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Axis self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Axis_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Axis_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Axis_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Axis self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Axis_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Axis_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Axis self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Axis_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Axis self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Axis_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Axis self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Axis_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Axis self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Axis self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Axis self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Axis self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Axis_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Axis self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Axis_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Axis self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Axis_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Axis self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Axis_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Axis self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Axis_DecrementRefCounter(self, *args)

Handle_AIS_Axis_swigregister = _AIS.Handle_AIS_Axis_swigregister
Handle_AIS_Axis_swigregister(Handle_AIS_Axis)

def Handle_AIS_Axis_DownCast(thing):
    return _AIS.Handle_AIS_Axis_DownCast(thing)
Handle_AIS_Axis_DownCast = _AIS.Handle_AIS_Axis_DownCast

class AIS_(object):
    """
    Application Interactive Services provide the means to create links between an application GUI viewer and
    the packages which are used to manage selection and presentation.
    The tools AIS defined in order to do this include different sorts of entities:
    both the selectable viewable objects themselves and the context and attribute managers to define their selection and display.
    To orient the user as he works in a modeling environment, views and selections must be comprehensible.
    There must be several different sorts of selectable and viewable object defined.
    These must also be interactive, that is, connecting graphic representation and the underlying reference geometry.
    These entities are called Interactive Objects, and are divided into four types:
    -   the Datum
    -   the Relation
    -   the Object
    -   None.
    The Datum groups together the construction elements such as lines, circles, points, trihedra, plane trihedra, planes and axes.
    The Relation is made up of constraints on one or more interactive shapes and the corresponding reference geometry.
    For example, you might want to constrain two edges in a parallel relation.
    This contraint is considered as an object in its own right, and is shown as a sensitive primitive.
    This takes the graphic form of a perpendicular arrow marked with the || symbol and lying between the two edges.
    The Object type includes topological shapes, and connections between shapes.
    None, in order not to eliminate the object, tells the application to look further until it finds an object definition in its generation which is accepted.
    Inside these categories, you have the possibility of an additional characterization by means of a signature.
    The signature provides an index to the further characterization.
    By default, the Interactive Object has a None type and a signature of 0 (equivalent to None.)
    If you want to give a particular type and signature to your interactive object, you must redefine the two virtual methods: Type and Signature.
    In the C++ inheritance structure of the package, each class representing a specific Interactive Object inherits AIS_InteractiveObject.
    Among these inheriting classes, AIS_Relation functions as the abstract mother class for tinheriting classes defining display of specific relational constraints and types of dimension.
    Some of these include:
    -   display of constraints based on relations of symmetry, tangency, parallelism and concentricity
    -   display of dimensions for angles, offsets, diameters, radii and chamfers.
    No viewer can show everything at once with any coherence or clarity.
    Views must be managed carefully both sequentially and at any given instant.
    Another function of the view is that of a context to carry out design in.
    The design changes are applied to the objects in the view and then extended to the underlying reference geometry by a solver.
    To make sense of this complicated visual data, several display and selection tools are required.
    To facilitate management, each object and each construction element has a selection priority.
    There are also means to modify the default priority.
    To define an environment of dynamic detection, you can use standard filter classes or create your own.
    A filter questions the owner of the sensitive primitive to determine if it has the the desired qualities.
    If it answers positively, it is kept. If not, it is rejected.
    The standard filters supplied in AIS include:
    - AIS_AttributeFilter
    - AIS_SignatureFilter
    - AIS_TypeFilter.
    A set of functions allows you to choose the interactive objects which you want to act on, the selection modes which you want to activate.
    An interactive object can have a certain number of graphic attributes which are specific to it, such as visualization mode, color, and material.
    By the same token, the interactive context has a set of graphic attributes, the Drawer which is valid by default for the objects it controls.
    When an interactive object is visualized, the required graphic attributes are first taken from the object's own Drawer if one exists, or from the context drawer for the others.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nearest(*args):
        """
        Nearest(TopoDS_Shape aShape, gp_Pnt aPoint) -> gp_Pnt
        Nearest(gp_Lin theLine, gp_Pnt thePoint) -> gp_Pnt
        Nearest(Handle_Geom_Curve theCurve, gp_Pnt thePoint, gp_Pnt theFirstPoint, gp_Pnt theLastPoint, gp_Pnt theNearestPoint) -> Standard_Boolean

        For the given point finds nearest point on the curve,
        @return TRUE if found point is belongs to the curve
        and FALSE otherwise.

        :type theCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theFirstPoint: OCC.wrapper.gp.gp_Pnt
        :type theLastPoint: OCC.wrapper.gp.gp_Pnt
        :type theNearestPoint: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS__Nearest(*args)

    Nearest = staticmethod(Nearest)

    def Farest(*args):
        """
        Farest(TopoDS_Shape aShape, gp_Pnt aPoint) -> gp_Pnt

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPoint: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS__Farest(*args)

    Farest = staticmethod(Farest)

    def ComputeGeomCurve(*args):
        """
        ComputeGeomCurve(Handle_Geom_Curve aCurve, Standard_Real const first1, Standard_Real const last1, gp_Pnt FirstPnt1, gp_Pnt LastPnt1, Handle_Geom_Plane aPlane) -> Standard_Boolean

        Checks if aCurve belongs to aPlane; if not, projects aCurve in aPlane
        and returns aCurve;
        Return TRUE if ok

        :type aCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type first1: float
        :type last1: float
        :type FirstPnt1: OCC.wrapper.gp.gp_Pnt
        :type LastPnt1: OCC.wrapper.gp.gp_Pnt
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type isOnPlane: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS__ComputeGeomCurve(*args)

    ComputeGeomCurve = staticmethod(ComputeGeomCurve)

    def ComputeGeometry(*args):
        """
        ComputeGeometry(TopoDS_Edge theEdge, Handle_Geom_Curve theCurve, gp_Pnt theFirstPnt, gp_Pnt theLastPnt) -> Standard_Boolean
        ComputeGeometry(TopoDS_Edge theEdge, Handle_Geom_Curve theCurve, gp_Pnt theFirstPnt, gp_Pnt theLastPnt) -> Standard_Boolean
        ComputeGeometry(TopoDS_Edge theEdge, Handle_Geom_Curve theCurve, gp_Pnt theFirstPnt, gp_Pnt theLastPnt, Handle_Geom_Curve theExtCurve, Handle_Geom_Plane thePlane) -> Standard_Boolean
        ComputeGeometry(TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge, Handle_Geom_Curve theFirstCurve, Handle_Geom_Curve theSecondCurve, gp_Pnt theFirstPnt1, gp_Pnt theLastPnt1, gp_Pnt theFirstPnt2, gp_Pnt theLastPnt2, Handle_Geom_Plane thePlane) -> Standard_Boolean
        ComputeGeometry(TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge, Handle_Geom_Curve theFirstCurve, Handle_Geom_Curve theSecondCurve, gp_Pnt theFirstPnt1, gp_Pnt theLastPnt1, gp_Pnt theFirstPnt2, gp_Pnt theLastPnt2) -> Standard_Boolean
        ComputeGeometry(TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge, Handle_Geom_Curve theFirstCurve, Handle_Geom_Curve theSecondCurve, gp_Pnt theFirstPnt1, gp_Pnt theLastPnt1, gp_Pnt theFirstPnt2, gp_Pnt theLastPnt2, Handle_Geom_Curve theExtCurve, Handle_Geom_Plane thePlane) -> Standard_Boolean
        ComputeGeometry(TopoDS_Vertex aVertex, gp_Pnt point, Handle_Geom_Plane aPlane) -> Standard_Boolean

        :type aVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type point: OCC.wrapper.gp.gp_Pnt
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type isOnPlane: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS__ComputeGeometry(*args)

    ComputeGeometry = staticmethod(ComputeGeometry)

    def GetPlaneFromFace(*args):
        """
        GetPlaneFromFace(TopoDS_Face aFace, gp_Pln aPlane, Handle_Geom_Surface aSurf) -> Standard_Boolean

        Tryes to get Plane from Face.  Returns Surface of Face
        in aSurf.  Returns Standard_True  and Plane of Face in
        aPlane in following  cases:
        Face is Plane, Offset of Plane,
        Extrusion of Line  and Offset of  Extrusion of Line
        Returns pure type of Surface which can be:
        Plane, Cylinder, Cone, Sphere, Torus,
        SurfaceOfRevolution, SurfaceOfExtrusion

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type aPlane: OCC.wrapper.gp.gp_Pln
        :type aSurf: OCC.wrapper.Geom.Handle_Geom_Surface
        :type aSurfType: OCC.wrapper.AIS.AIS_KindOfSurface
        :type Offset: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS__GetPlaneFromFace(*args)

    GetPlaneFromFace = staticmethod(GetPlaneFromFace)

    def InitFaceLength(*args):
        """
        InitFaceLength(TopoDS_Face aFace, gp_Pln aPlane, Handle_Geom_Surface aSurface)

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type aPlane: OCC.wrapper.gp.gp_Pln
        :type aSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type aSurfaceType: OCC.wrapper.AIS.AIS_KindOfSurface
        :type anOffset: float

        """
        return _AIS.AIS__InitFaceLength(*args)

    InitFaceLength = staticmethod(InitFaceLength)

    def InitLengthBetweenCurvilinearFaces(*args):
        """
        InitLengthBetweenCurvilinearFaces(TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, Handle_Geom_Surface theFirstSurf, Handle_Geom_Surface theSecondSurf, gp_Pnt theFirstAttach, gp_Pnt theSecondAttach, gp_Dir theDirOnPlane)

        Finds attachment points on two curvilinear faces for length dimension.
        @param thePlaneDir [in] the direction on the dimension plane to
        compute the plane automatically. It will not be taken into account if
        plane is defined by user.

        :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theFirstSurf: OCC.wrapper.Geom.Handle_Geom_Surface
        :type theSecondSurf: OCC.wrapper.Geom.Handle_Geom_Surface
        :type theFirstAttach: OCC.wrapper.gp.gp_Pnt
        :type theSecondAttach: OCC.wrapper.gp.gp_Pnt
        :type theDirOnPlane: OCC.wrapper.gp.gp_Dir

        """
        return _AIS.AIS__InitLengthBetweenCurvilinearFaces(*args)

    InitLengthBetweenCurvilinearFaces = staticmethod(InitLengthBetweenCurvilinearFaces)

    def InitAngleBetweenPlanarFaces(*args):
        """
        InitAngleBetweenPlanarFaces(TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, gp_Pnt theCenter, gp_Pnt theFirstAttach, gp_Pnt theSecondAttach, Standard_Boolean const theIsFirstPointSet) -> Standard_Boolean

        Finds three points for the angle dimension between
        two planes.

        :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theCenter: OCC.wrapper.gp.gp_Pnt
        :type theFirstAttach: OCC.wrapper.gp.gp_Pnt
        :type theSecondAttach: OCC.wrapper.gp.gp_Pnt
        :type theIsFirstPointSet: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS__InitAngleBetweenPlanarFaces(*args)

    InitAngleBetweenPlanarFaces = staticmethod(InitAngleBetweenPlanarFaces)

    def InitAngleBetweenCurvilinearFaces(*args):
        """
        InitAngleBetweenCurvilinearFaces(TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, AIS_KindOfSurface const theFirstSurfType, AIS_KindOfSurface const theSecondSurfType, gp_Pnt theCenter, gp_Pnt theFirstAttach, gp_Pnt theSecondAttach, Standard_Boolean const theIsFirstPointSet) -> Standard_Boolean

        Finds three points for the angle dimension between
        two curvilinear surfaces.

        :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theFirstSurfType: OCC.wrapper.AIS.AIS_KindOfSurface
        :type theSecondSurfType: OCC.wrapper.AIS.AIS_KindOfSurface
        :type theCenter: OCC.wrapper.gp.gp_Pnt
        :type theFirstAttach: OCC.wrapper.gp.gp_Pnt
        :type theSecondAttach: OCC.wrapper.gp.gp_Pnt
        :type theIsFirstPointSet: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS__InitAngleBetweenCurvilinearFaces(*args)

    InitAngleBetweenCurvilinearFaces = staticmethod(InitAngleBetweenCurvilinearFaces)

    def ProjectPointOnPlane(*args):
        """
        ProjectPointOnPlane(gp_Pnt aPoint, gp_Pln aPlane) -> gp_Pnt

        :type aPoint: OCC.wrapper.gp.gp_Pnt
        :type aPlane: OCC.wrapper.gp.gp_Pln
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS__ProjectPointOnPlane(*args)

    ProjectPointOnPlane = staticmethod(ProjectPointOnPlane)

    def ProjectPointOnLine(*args):
        """
        ProjectPointOnLine(gp_Pnt aPoint, gp_Lin aLine) -> gp_Pnt

        :type aPoint: OCC.wrapper.gp.gp_Pnt
        :type aLine: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS__ProjectPointOnLine(*args)

    ProjectPointOnLine = staticmethod(ProjectPointOnLine)

    def TranslatePointToBound(*args):
        """
        TranslatePointToBound(gp_Pnt aPoint, gp_Dir aDir, Bnd_Box aBndBox) -> gp_Pnt

        :type aPoint: OCC.wrapper.gp.gp_Pnt
        :type aDir: OCC.wrapper.gp.gp_Dir
        :type aBndBox: OCC.wrapper.Bnd.Bnd_Box
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS__TranslatePointToBound(*args)

    TranslatePointToBound = staticmethod(TranslatePointToBound)

    def InDomain(*args):
        """
        InDomain(Standard_Real const aFirstPar, Standard_Real const aLastPar, Standard_Real const anAttachPar) -> Standard_Boolean

        returns  True  if  point  with anAttachPar  is
        in  domain  of  arc

        :type aFirstPar: float
        :type aLastPar: float
        :type anAttachPar: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS__InDomain(*args)

    InDomain = staticmethod(InDomain)

    def NearestApex(*args):
        """
        NearestApex(gp_Elips elips, gp_Pnt pApex, gp_Pnt nApex, Standard_Real const fpara, Standard_Real const lpara) -> gp_Pnt

        computes  nearest  to  ellipse  arc  apex

        :type elips: OCC.wrapper.gp.gp_Elips
        :type pApex: OCC.wrapper.gp.gp_Pnt
        :type nApex: OCC.wrapper.gp.gp_Pnt
        :type fpara: float
        :type lpara: float
        :type IsInDomain: bool
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS__NearestApex(*args)

    NearestApex = staticmethod(NearestApex)

    def DistanceFromApex(*args):
        """
        DistanceFromApex(gp_Elips elips, gp_Pnt Apex, Standard_Real const par) -> Standard_Real

        computes  length  of  ellipse  arc  in  parametric  units

        :type elips: OCC.wrapper.gp.gp_Elips
        :type Apex: OCC.wrapper.gp.gp_Pnt
        :type par: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS__DistanceFromApex(*args)

    DistanceFromApex = staticmethod(DistanceFromApex)

    def ComputeProjEdgePresentation(*args):
        """
        ComputeProjEdgePresentation(Handle_Prs3d_Presentation aPres, Handle_Prs3d_Drawer aDrawer, TopoDS_Edge anEdge, Handle_Geom_Curve ProjCurve, gp_Pnt FirstP, gp_Pnt LastP, Quantity_NameOfColor const aColor=Quantity_NOC_PURPLE, Standard_Real const aWidth=2, Aspect_TypeOfLine const aProjTOL=Aspect_TOL_DASH, Aspect_TypeOfLine const aCallTOL=Aspect_TOL_DOT)

        :type aPres: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type ProjCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type FirstP: OCC.wrapper.gp.gp_Pnt
        :type LastP: OCC.wrapper.gp.gp_Pnt
        :type aColor: OCC.wrapper.Quantity.Quantity_NameOfColor
        :type aWidth: float
        :type aProjTOL: OCC.wrapper.Aspect.Aspect_TypeOfLine
        :type aCallTOL: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.AIS__ComputeProjEdgePresentation(*args)

    ComputeProjEdgePresentation = staticmethod(ComputeProjEdgePresentation)

    def ComputeProjVertexPresentation(*args):
        """
        ComputeProjVertexPresentation(Handle_Prs3d_Presentation aPres, Handle_Prs3d_Drawer aDrawer, TopoDS_Vertex aVertex, gp_Pnt ProjPoint, Quantity_NameOfColor const aColor=Quantity_NOC_PURPLE, Standard_Real const aWidth=2, Aspect_TypeOfMarker const aProjTOM=Aspect_TOM_PLUS, Aspect_TypeOfLine const aCallTOL=Aspect_TOL_DOT)

        :type aPres: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type aVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type ProjPoint: OCC.wrapper.gp.gp_Pnt
        :type aColor: OCC.wrapper.Quantity.Quantity_NameOfColor
        :type aWidth: float
        :type aProjTOM: OCC.wrapper.Aspect.Aspect_TypeOfMarker
        :type aCallTOL: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.AIS__ComputeProjVertexPresentation(*args)

    ComputeProjVertexPresentation = staticmethod(ComputeProjVertexPresentation)

    def __init__(self):
        """
        Application Interactive Services provide the means to create links between an application GUI viewer and
        the packages which are used to manage selection and presentation.
        The tools AIS defined in order to do this include different sorts of entities:
        both the selectable viewable objects themselves and the context and attribute managers to define their selection and display.
        To orient the user as he works in a modeling environment, views and selections must be comprehensible.
        There must be several different sorts of selectable and viewable object defined.
        These must also be interactive, that is, connecting graphic representation and the underlying reference geometry.
        These entities are called Interactive Objects, and are divided into four types:
        -   the Datum
        -   the Relation
        -   the Object
        -   None.
        The Datum groups together the construction elements such as lines, circles, points, trihedra, plane trihedra, planes and axes.
        The Relation is made up of constraints on one or more interactive shapes and the corresponding reference geometry.
        For example, you might want to constrain two edges in a parallel relation.
        This contraint is considered as an object in its own right, and is shown as a sensitive primitive.
        This takes the graphic form of a perpendicular arrow marked with the || symbol and lying between the two edges.
        The Object type includes topological shapes, and connections between shapes.
        None, in order not to eliminate the object, tells the application to look further until it finds an object definition in its generation which is accepted.
        Inside these categories, you have the possibility of an additional characterization by means of a signature.
        The signature provides an index to the further characterization.
        By default, the Interactive Object has a None type and a signature of 0 (equivalent to None.)
        If you want to give a particular type and signature to your interactive object, you must redefine the two virtual methods: Type and Signature.
        In the C++ inheritance structure of the package, each class representing a specific Interactive Object inherits AIS_InteractiveObject.
        Among these inheriting classes, AIS_Relation functions as the abstract mother class for tinheriting classes defining display of specific relational constraints and types of dimension.
        Some of these include:
        -   display of constraints based on relations of symmetry, tangency, parallelism and concentricity
        -   display of dimensions for angles, offsets, diameters, radii and chamfers.
        No viewer can show everything at once with any coherence or clarity.
        Views must be managed carefully both sequentially and at any given instant.
        Another function of the view is that of a context to carry out design in.
        The design changes are applied to the objects in the view and then extended to the underlying reference geometry by a solver.
        To make sense of this complicated visual data, several display and selection tools are required.
        To facilitate management, each object and each construction element has a selection priority.
        There are also means to modify the default priority.
        To define an environment of dynamic detection, you can use standard filter classes or create your own.
        A filter questions the owner of the sensitive primitive to determine if it has the the desired qualities.
        If it answers positively, it is kept. If not, it is rejected.
        The standard filters supplied in AIS include:
        - AIS_AttributeFilter
        - AIS_SignatureFilter
        - AIS_TypeFilter.
        A set of functions allows you to choose the interactive objects which you want to act on, the selection modes which you want to activate.
        An interactive object can have a certain number of graphic attributes which are specific to it, such as visualization mode, color, and material.
        By the same token, the interactive context has a set of graphic attributes, the Drawer which is valid by default for the objects it controls.
        When an interactive object is visualized, the required graphic attributes are first taken from the object's own Drawer if one exists, or from the context drawer for the others.
        """
        this = _AIS.new_AIS_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_AIS_
AIS__swigregister = _AIS.AIS__swigregister
AIS__swigregister(AIS_)

def AIS__Nearest(*args):
    """
    Nearest(TopoDS_Shape aShape, gp_Pnt aPoint) -> gp_Pnt
    Nearest(gp_Lin theLine, gp_Pnt thePoint) -> gp_Pnt
    AIS__Nearest(Handle_Geom_Curve theCurve, gp_Pnt thePoint, gp_Pnt theFirstPoint, gp_Pnt theLastPoint, gp_Pnt theNearestPoint) -> Standard_Boolean

    For the given point finds nearest point on the curve,
    @return TRUE if found point is belongs to the curve
    and FALSE otherwise.

    :type theCurve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type thePoint: OCC.wrapper.gp.gp_Pnt
    :type theFirstPoint: OCC.wrapper.gp.gp_Pnt
    :type theLastPoint: OCC.wrapper.gp.gp_Pnt
    :type theNearestPoint: OCC.wrapper.gp.gp_Pnt
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AIS.AIS__Nearest(*args)

def AIS__Farest(*args):
    """
    AIS__Farest(TopoDS_Shape aShape, gp_Pnt aPoint) -> gp_Pnt

    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aPoint: OCC.wrapper.gp.gp_Pnt
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _AIS.AIS__Farest(*args)

def AIS__ComputeGeomCurve(*args):
    """
    AIS__ComputeGeomCurve(Handle_Geom_Curve aCurve, Standard_Real const first1, Standard_Real const last1, gp_Pnt FirstPnt1, gp_Pnt LastPnt1, Handle_Geom_Plane aPlane) -> Standard_Boolean

    Checks if aCurve belongs to aPlane; if not, projects aCurve in aPlane
    and returns aCurve;
    Return TRUE if ok

    :type aCurve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type first1: float
    :type last1: float
    :type FirstPnt1: OCC.wrapper.gp.gp_Pnt
    :type LastPnt1: OCC.wrapper.gp.gp_Pnt
    :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
    :type isOnPlane: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AIS.AIS__ComputeGeomCurve(*args)

def AIS__ComputeGeometry(*args):
    """
    ComputeGeometry(TopoDS_Edge theEdge, Handle_Geom_Curve theCurve, gp_Pnt theFirstPnt, gp_Pnt theLastPnt) -> Standard_Boolean
    ComputeGeometry(TopoDS_Edge theEdge, Handle_Geom_Curve theCurve, gp_Pnt theFirstPnt, gp_Pnt theLastPnt) -> Standard_Boolean
    ComputeGeometry(TopoDS_Edge theEdge, Handle_Geom_Curve theCurve, gp_Pnt theFirstPnt, gp_Pnt theLastPnt, Handle_Geom_Curve theExtCurve, Handle_Geom_Plane thePlane) -> Standard_Boolean
    ComputeGeometry(TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge, Handle_Geom_Curve theFirstCurve, Handle_Geom_Curve theSecondCurve, gp_Pnt theFirstPnt1, gp_Pnt theLastPnt1, gp_Pnt theFirstPnt2, gp_Pnt theLastPnt2, Handle_Geom_Plane thePlane) -> Standard_Boolean
    ComputeGeometry(TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge, Handle_Geom_Curve theFirstCurve, Handle_Geom_Curve theSecondCurve, gp_Pnt theFirstPnt1, gp_Pnt theLastPnt1, gp_Pnt theFirstPnt2, gp_Pnt theLastPnt2) -> Standard_Boolean
    ComputeGeometry(TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge, Handle_Geom_Curve theFirstCurve, Handle_Geom_Curve theSecondCurve, gp_Pnt theFirstPnt1, gp_Pnt theLastPnt1, gp_Pnt theFirstPnt2, gp_Pnt theLastPnt2, Handle_Geom_Curve theExtCurve, Handle_Geom_Plane thePlane) -> Standard_Boolean
    AIS__ComputeGeometry(TopoDS_Vertex aVertex, gp_Pnt point, Handle_Geom_Plane aPlane) -> Standard_Boolean

    :type aVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type point: OCC.wrapper.gp.gp_Pnt
    :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
    :type isOnPlane: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AIS.AIS__ComputeGeometry(*args)

def AIS__GetPlaneFromFace(*args):
    """
    AIS__GetPlaneFromFace(TopoDS_Face aFace, gp_Pln aPlane, Handle_Geom_Surface aSurf) -> Standard_Boolean

    Tryes to get Plane from Face.  Returns Surface of Face
    in aSurf.  Returns Standard_True  and Plane of Face in
    aPlane in following  cases:
    Face is Plane, Offset of Plane,
    Extrusion of Line  and Offset of  Extrusion of Line
    Returns pure type of Surface which can be:
    Plane, Cylinder, Cone, Sphere, Torus,
    SurfaceOfRevolution, SurfaceOfExtrusion

    :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type aPlane: OCC.wrapper.gp.gp_Pln
    :type aSurf: OCC.wrapper.Geom.Handle_Geom_Surface
    :type aSurfType: OCC.wrapper.AIS.AIS_KindOfSurface
    :type Offset: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AIS.AIS__GetPlaneFromFace(*args)

def AIS__InitFaceLength(*args):
    """
    AIS__InitFaceLength(TopoDS_Face aFace, gp_Pln aPlane, Handle_Geom_Surface aSurface)

    :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type aPlane: OCC.wrapper.gp.gp_Pln
    :type aSurface: OCC.wrapper.Geom.Handle_Geom_Surface
    :type aSurfaceType: OCC.wrapper.AIS.AIS_KindOfSurface
    :type anOffset: float

    """
    return _AIS.AIS__InitFaceLength(*args)

def AIS__InitLengthBetweenCurvilinearFaces(*args):
    """
    AIS__InitLengthBetweenCurvilinearFaces(TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, Handle_Geom_Surface theFirstSurf, Handle_Geom_Surface theSecondSurf, gp_Pnt theFirstAttach, gp_Pnt theSecondAttach, gp_Dir theDirOnPlane)

    Finds attachment points on two curvilinear faces for length dimension.
    @param thePlaneDir [in] the direction on the dimension plane to
    compute the plane automatically. It will not be taken into account if
    plane is defined by user.

    :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theFirstSurf: OCC.wrapper.Geom.Handle_Geom_Surface
    :type theSecondSurf: OCC.wrapper.Geom.Handle_Geom_Surface
    :type theFirstAttach: OCC.wrapper.gp.gp_Pnt
    :type theSecondAttach: OCC.wrapper.gp.gp_Pnt
    :type theDirOnPlane: OCC.wrapper.gp.gp_Dir

    """
    return _AIS.AIS__InitLengthBetweenCurvilinearFaces(*args)

def AIS__InitAngleBetweenPlanarFaces(*args):
    """
    AIS__InitAngleBetweenPlanarFaces(TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, gp_Pnt theCenter, gp_Pnt theFirstAttach, gp_Pnt theSecondAttach, Standard_Boolean const theIsFirstPointSet) -> Standard_Boolean

    Finds three points for the angle dimension between
    two planes.

    :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theCenter: OCC.wrapper.gp.gp_Pnt
    :type theFirstAttach: OCC.wrapper.gp.gp_Pnt
    :type theSecondAttach: OCC.wrapper.gp.gp_Pnt
    :type theIsFirstPointSet: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AIS.AIS__InitAngleBetweenPlanarFaces(*args)

def AIS__InitAngleBetweenCurvilinearFaces(*args):
    """
    AIS__InitAngleBetweenCurvilinearFaces(TopoDS_Face theFirstFace, TopoDS_Face theSecondFace, AIS_KindOfSurface const theFirstSurfType, AIS_KindOfSurface const theSecondSurfType, gp_Pnt theCenter, gp_Pnt theFirstAttach, gp_Pnt theSecondAttach, Standard_Boolean const theIsFirstPointSet) -> Standard_Boolean

    Finds three points for the angle dimension between
    two curvilinear surfaces.

    :type theFirstFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theSecondFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theFirstSurfType: OCC.wrapper.AIS.AIS_KindOfSurface
    :type theSecondSurfType: OCC.wrapper.AIS.AIS_KindOfSurface
    :type theCenter: OCC.wrapper.gp.gp_Pnt
    :type theFirstAttach: OCC.wrapper.gp.gp_Pnt
    :type theSecondAttach: OCC.wrapper.gp.gp_Pnt
    :type theIsFirstPointSet: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AIS.AIS__InitAngleBetweenCurvilinearFaces(*args)

def AIS__ProjectPointOnPlane(*args):
    """
    AIS__ProjectPointOnPlane(gp_Pnt aPoint, gp_Pln aPlane) -> gp_Pnt

    :type aPoint: OCC.wrapper.gp.gp_Pnt
    :type aPlane: OCC.wrapper.gp.gp_Pln
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _AIS.AIS__ProjectPointOnPlane(*args)

def AIS__ProjectPointOnLine(*args):
    """
    AIS__ProjectPointOnLine(gp_Pnt aPoint, gp_Lin aLine) -> gp_Pnt

    :type aPoint: OCC.wrapper.gp.gp_Pnt
    :type aLine: OCC.wrapper.gp.gp_Lin
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _AIS.AIS__ProjectPointOnLine(*args)

def AIS__TranslatePointToBound(*args):
    """
    AIS__TranslatePointToBound(gp_Pnt aPoint, gp_Dir aDir, Bnd_Box aBndBox) -> gp_Pnt

    :type aPoint: OCC.wrapper.gp.gp_Pnt
    :type aDir: OCC.wrapper.gp.gp_Dir
    :type aBndBox: OCC.wrapper.Bnd.Bnd_Box
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _AIS.AIS__TranslatePointToBound(*args)

def AIS__InDomain(*args):
    """
    AIS__InDomain(Standard_Real const aFirstPar, Standard_Real const aLastPar, Standard_Real const anAttachPar) -> Standard_Boolean

    returns  True  if  point  with anAttachPar  is
    in  domain  of  arc

    :type aFirstPar: float
    :type aLastPar: float
    :type anAttachPar: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AIS.AIS__InDomain(*args)

def AIS__NearestApex(*args):
    """
    AIS__NearestApex(gp_Elips elips, gp_Pnt pApex, gp_Pnt nApex, Standard_Real const fpara, Standard_Real const lpara) -> gp_Pnt

    computes  nearest  to  ellipse  arc  apex

    :type elips: OCC.wrapper.gp.gp_Elips
    :type pApex: OCC.wrapper.gp.gp_Pnt
    :type nApex: OCC.wrapper.gp.gp_Pnt
    :type fpara: float
    :type lpara: float
    :type IsInDomain: bool
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _AIS.AIS__NearestApex(*args)

def AIS__DistanceFromApex(*args):
    """
    AIS__DistanceFromApex(gp_Elips elips, gp_Pnt Apex, Standard_Real const par) -> Standard_Real

    computes  length  of  ellipse  arc  in  parametric  units

    :type elips: OCC.wrapper.gp.gp_Elips
    :type Apex: OCC.wrapper.gp.gp_Pnt
    :type par: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _AIS.AIS__DistanceFromApex(*args)

def AIS__ComputeProjEdgePresentation(*args):
    """
    AIS__ComputeProjEdgePresentation(Handle_Prs3d_Presentation aPres, Handle_Prs3d_Drawer aDrawer, TopoDS_Edge anEdge, Handle_Geom_Curve ProjCurve, gp_Pnt FirstP, gp_Pnt LastP, Quantity_NameOfColor const aColor=Quantity_NOC_PURPLE, Standard_Real const aWidth=2, Aspect_TypeOfLine const aProjTOL=Aspect_TOL_DASH, Aspect_TypeOfLine const aCallTOL=Aspect_TOL_DOT)

    :type aPres: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type ProjCurve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type FirstP: OCC.wrapper.gp.gp_Pnt
    :type LastP: OCC.wrapper.gp.gp_Pnt
    :type aColor: OCC.wrapper.Quantity.Quantity_NameOfColor
    :type aWidth: float
    :type aProjTOL: OCC.wrapper.Aspect.Aspect_TypeOfLine
    :type aCallTOL: OCC.wrapper.Aspect.Aspect_TypeOfLine

    """
    return _AIS.AIS__ComputeProjEdgePresentation(*args)

def AIS__ComputeProjVertexPresentation(*args):
    """
    AIS__ComputeProjVertexPresentation(Handle_Prs3d_Presentation aPres, Handle_Prs3d_Drawer aDrawer, TopoDS_Vertex aVertex, gp_Pnt ProjPoint, Quantity_NameOfColor const aColor=Quantity_NOC_PURPLE, Standard_Real const aWidth=2, Aspect_TypeOfMarker const aProjTOM=Aspect_TOM_PLUS, Aspect_TypeOfLine const aCallTOL=Aspect_TOL_DOT)

    :type aPres: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type aVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type ProjPoint: OCC.wrapper.gp.gp_Pnt
    :type aColor: OCC.wrapper.Quantity.Quantity_NameOfColor
    :type aWidth: float
    :type aProjTOM: OCC.wrapper.Aspect.Aspect_TypeOfMarker
    :type aCallTOL: OCC.wrapper.Aspect.Aspect_TypeOfLine

    """
    return _AIS.AIS__ComputeProjVertexPresentation(*args)

class Handle_AIS_DiameterDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_DiameterDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_DiameterDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_DiameterDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_DiameterDimension self, AIS_DiameterDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_DiameterDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_DiameterDimension self, Handle_AIS_DiameterDimension theHandle) -> Handle_AIS_DiameterDimension
        assign(Handle_AIS_DiameterDimension self, AIS_DiameterDimension thePtr) -> Handle_AIS_DiameterDimension
        assign(Handle_AIS_DiameterDimension self, Handle_AIS_DiameterDimension theHandle) -> Handle_AIS_DiameterDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_DiameterDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_DiameterDimension self) -> AIS_DiameterDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_DiameterDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_DiameterDimension self) -> AIS_DiameterDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_DiameterDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_DiameterDimension self) -> AIS_DiameterDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_DiameterDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_DiameterDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_DiameterDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_DiameterDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_DiameterDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_DiameterDimension

    def Circle(self, *args):
        """
        @return measured geometry circle.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        res = _AIS.Handle_AIS_DiameterDimension_Circle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AnchorPoint(self, *args):
        """
        AnchorPoint(Handle_AIS_DiameterDimension self) -> gp_Pnt

        @return anchor point on circle for diameter dimension.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_DiameterDimension_AnchorPoint(self, *args)


    def Shape(self, *args):
        """
        @return the measured shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_DiameterDimension_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(Handle_AIS_DiameterDimension self, gp_Circ theCircle)
        SetMeasuredGeometry(Handle_AIS_DiameterDimension self, TopoDS_Shape theShape)

        Measure diameter on the passed shape, if applicable.
        The dimension will become invalid if the passed shape is not
        measurable or if measured diameter value is less than Precision::Confusion().
        @param theShape [in] the shape to measure.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_DiameterDimension_SetMeasuredGeometry(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_DiameterDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_DiameterDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(Handle_AIS_DiameterDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_DiameterDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(Handle_AIS_DiameterDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_DiameterDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(Handle_AIS_DiameterDimension self, gp_Pnt theTextPos)

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_DiameterDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(Handle_AIS_DiameterDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_DiameterDimension_GetTextPosition(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_DiameterDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_DiameterDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_DiameterDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_DiameterDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetValue(self, *args):
        """
        GetValue(Handle_AIS_DiameterDimension self) -> Standard_Real

        Gets dimension measurement value. If the value to display is not
        specified by user, then the dimension object is responsible to
        compute it on its own in model space coordinates.
        @return the dimension value (in model units) which is used
        during display of the presentation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_DiameterDimension_GetValue(self, *args)


    def SetComputedValue(self, *args):
        """
        SetComputedValue(Handle_AIS_DiameterDimension self)

        Sets computed dimension value. Resets custom value mode if it was set.


        """
        return _AIS.Handle_AIS_DiameterDimension_SetComputedValue(self, *args)


    def SetCustomValue(self, *args):
        """
        SetCustomValue(Handle_AIS_DiameterDimension self, Standard_Real const theValue)
        SetCustomValue(Handle_AIS_DiameterDimension self, TCollection_ExtendedString theValue)

        Sets user-defined dimension value.
        Unit conversion during the display is not applyed.
        @param theValue [in] the user-defined value to display.

        :type theValue: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_DiameterDimension_SetCustomValue(self, *args)


    def GetCustomValue(self, *args):
        """
        Gets user-defined dimension value.
        @return dimension value string.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_DiameterDimension_GetCustomValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPlane(self, *args):
        """
        Get the dimension plane in which the 2D dimension presentation is computed.
        By default, if plane is not defined by user, it is computed automatically
        after dimension geometry is computed.
        If computed dimension geometry (points) can't be placed on the user-defined
        plane, dimension geometry was set as invalid (validity flag is set to false)
        and dimension presentation will not be computed.
        If user-defined plane allow geometry placement on it, it will be used for
        computing of the dimension presentation.
        @return dimension plane used for presentation computing.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _AIS.Handle_AIS_DiameterDimension_GetPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetGeometryType(self, *args):
        """
        GetGeometryType(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Geometry type defines type of shapes on which the dimension is to be built. 
        @return type of geometry on which the dimension will be built.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_GetGeometryType(self, *args)


    def SetCustomPlane(self, *args):
        """
        SetCustomPlane(Handle_AIS_DiameterDimension self, gp_Pln thePlane)

        Sets user-defined plane where the 2D dimension presentation will be placed.
        Checks validity of this plane if geometry has been set already.
        Validity of the plane is checked according to the geometry set
        and has different criteria for different kinds of dimensions.

        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        return _AIS.Handle_AIS_DiameterDimension_SetCustomPlane(self, *args)


    def UnsetCustomPlane(self, *args):
        """
        UnsetCustomPlane(Handle_AIS_DiameterDimension self)

        Unsets user-defined plane. Therefore the plane for dimension will be
        computed automatically.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetCustomPlane(self, *args)


    def IsTextPositionCustom(self, *args):
        """
        IsTextPositionCustom(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        @return TRUE if text position is set by user with method SetTextPosition().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsTextPositionCustom(self, *args)


    def DimensionAspect(self, *args):
        """
        DimensionAspect(Handle_AIS_DiameterDimension self) -> Handle_Prs3d_DimensionAspect

        Gets the dimension aspect from AIS object drawer.
        Dimension aspect contains aspects of line, text and arrows for dimension presentation.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_DiameterDimension_DimensionAspect(self, *args)


    def SetDimensionAspect(self, *args):
        """
        SetDimensionAspect(Handle_AIS_DiameterDimension self, Handle_Prs3d_DimensionAspect theDimensionAspect)

        Sets new dimension aspect for the interactive object drawer.
        The dimension aspect provides dynamic properties which are generally
        used during computation of dimension presentations.

        :type theDimensionAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_DiameterDimension_SetDimensionAspect(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_DiameterDimension self) -> AIS_KindOfDimension

        @return the kind of dimension.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_DiameterDimension_KindOfDimension(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_DiameterDimension self) -> AIS_KindOfInteractive

        @return the kind of interactive.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_DiameterDimension_Type(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_DiameterDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode theMode.
        The interactive context can have a default mode of representation for
        the set of Interactive Objects. This mode may not be accepted by object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_AcceptDisplayMode(self, *args)


    def DisplaySpecialSymbol(self, *args):
        """
        DisplaySpecialSymbol(Handle_AIS_DiameterDimension self) -> AIS_DisplaySpecialSymbol

        @return dimension special symbol display options.

        :rtype: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_DiameterDimension_DisplaySpecialSymbol(self, *args)


    def SetDisplaySpecialSymbol(self, *args):
        """
        SetDisplaySpecialSymbol(Handle_AIS_DiameterDimension self, AIS_DisplaySpecialSymbol const theDisplaySpecSymbol)

        Specifies whether to display special symbol or not.

        :type theDisplaySpecSymbol: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_DiameterDimension_SetDisplaySpecialSymbol(self, *args)


    def SpecialSymbol(self, *args):
        """
        SpecialSymbol(Handle_AIS_DiameterDimension self) -> Standard_ExtCharacter

        @return special symbol.

        :rtype: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_DiameterDimension_SpecialSymbol(self, *args)


    def SetSpecialSymbol(self, *args):
        """
        SetSpecialSymbol(Handle_AIS_DiameterDimension self, Standard_ExtCharacter const theSpecialSymbol)

        Specifies special symbol.

        :type theSpecialSymbol: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_DiameterDimension_SetSpecialSymbol(self, *args)


    def UnsetFixedTextPosition(self, *args):
        """
        UnsetFixedTextPosition(Handle_AIS_DiameterDimension self)

        Unsets user defined text positioning and enables text positioning
        by other parameters: text alignment, extension size, flyout and custom plane.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetFixedTextPosition(self, *args)


    def SelToleranceForText2d(self, *args):
        """
        SelToleranceForText2d(Handle_AIS_DiameterDimension self) -> Standard_Real

        Returns selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        Important! Only for 2d text.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_DiameterDimension_SelToleranceForText2d(self, *args)


    def SetSelToleranceForText2d(self, *args):
        """
        SetSelToleranceForText2d(Handle_AIS_DiameterDimension self, Standard_Real const theTol)

        Sets selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        to change this tolerance use this method
        Important! Only for 2d text.

        :type theTol: float

        """
        return _AIS.Handle_AIS_DiameterDimension_SetSelToleranceForText2d(self, *args)


    def GetFlyout(self, *args):
        """
        GetFlyout(Handle_AIS_DiameterDimension self) -> Standard_Real

        @return flyout value for dimension.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_DiameterDimension_GetFlyout(self, *args)


    def SetFlyout(self, *args):
        """
        SetFlyout(Handle_AIS_DiameterDimension self, Standard_Real const theFlyout)

        Sets flyout value for dimension.

        :type theFlyout: float

        """
        return _AIS.Handle_AIS_DiameterDimension_SetFlyout(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Check that the input geometry for dimension is valid and the
        presentation can be successfully computed.
        @return TRUE if dimension geometry is ok.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsValid(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_DiameterDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_DiameterDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_DiameterDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_DiameterDimension_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_DiameterDimension self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_DiameterDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_DiameterDimension self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_DiameterDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_DiameterDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_DiameterDimension self)"""
        return _AIS.Handle_AIS_DiameterDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_DiameterDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_DiameterDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_DiameterDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_DiameterDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_DiameterDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_DiameterDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_DiameterDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_DiameterDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_DiameterDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_DiameterDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_DiameterDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_DiameterDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_DiameterDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_DiameterDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_DiameterDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_DiameterDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_DiameterDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_DiameterDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_DiameterDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_DiameterDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_DiameterDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_DiameterDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_DiameterDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_DiameterDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_DiameterDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_DiameterDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_DiameterDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_DiameterDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_DiameterDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_DiameterDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_DiameterDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_DiameterDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_DiameterDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_DiameterDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_DiameterDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_DiameterDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_DiameterDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_DiameterDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_DiameterDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_DiameterDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_DiameterDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_DiameterDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_DiameterDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_DiameterDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_DiameterDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_DiameterDimension self)
        RecomputePrimitives(Handle_AIS_DiameterDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_DiameterDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_DiameterDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_DiameterDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_DiameterDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_DiameterDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_DiameterDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_DiameterDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_DiameterDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_DiameterDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_DiameterDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_DiameterDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_DiameterDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_DiameterDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_DiameterDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_DiameterDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_DiameterDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_DiameterDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_DiameterDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_DiameterDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_DiameterDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_DiameterDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_DiameterDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_DiameterDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_DiameterDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_DiameterDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_DiameterDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_DiameterDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_DiameterDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_DiameterDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_DiameterDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_DiameterDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_DiameterDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_DiameterDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_DiameterDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_DiameterDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_DiameterDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_DiameterDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_DiameterDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_DiameterDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_DiameterDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_DiameterDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_DiameterDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_DiameterDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_DiameterDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_DiameterDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_DiameterDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_DiameterDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_DiameterDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_DiameterDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_DiameterDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_DiameterDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_DiameterDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_DiameterDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_DiameterDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_DiameterDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_DiameterDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_DiameterDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_DiameterDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_DiameterDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_DiameterDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_DiameterDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_DiameterDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_DiameterDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_DiameterDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_DiameterDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_DiameterDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_DiameterDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_DiameterDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_DiameterDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_DiameterDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_DiameterDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_DiameterDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_DiameterDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_DiameterDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_DiameterDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_DiameterDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_DiameterDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_DiameterDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_DiameterDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_DiameterDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_DiameterDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_DiameterDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_DiameterDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_DiameterDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_DiameterDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_DiameterDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_DiameterDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_DiameterDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_DiameterDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_DiameterDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_DiameterDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_DiameterDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_DiameterDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_DiameterDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_DiameterDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_DiameterDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_DiameterDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_DiameterDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_DiameterDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_DiameterDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_DiameterDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_DiameterDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_DiameterDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_DiameterDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_DiameterDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_DiameterDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_DiameterDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DiameterDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_DiameterDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_DiameterDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_DiameterDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_DiameterDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_DiameterDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DiameterDimension_DecrementRefCounter(self, *args)

Handle_AIS_DiameterDimension_swigregister = _AIS.Handle_AIS_DiameterDimension_swigregister
Handle_AIS_DiameterDimension_swigregister(Handle_AIS_DiameterDimension)

def Handle_AIS_DiameterDimension_DownCast(thing):
    return _AIS.Handle_AIS_DiameterDimension_DownCast(thing)
Handle_AIS_DiameterDimension_DownCast = _AIS.Handle_AIS_DiameterDimension_DownCast

class Handle_AIS_Point(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Point self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Point_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Point self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Point_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Point self, AIS_Point thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Point_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Point self, Handle_AIS_Point theHandle) -> Handle_AIS_Point
        assign(Handle_AIS_Point self, AIS_Point thePtr) -> Handle_AIS_Point
        assign(Handle_AIS_Point self, Handle_AIS_Point theHandle) -> Handle_AIS_Point

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Point_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Point self) -> AIS_Point

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Point_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Point self) -> AIS_Point

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Point___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Point self) -> AIS_Point

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Point___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Point___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Point___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Point_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Point

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Point self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Point_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Point_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Point_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Signature(self, *args):
        """
        Signature(Handle_AIS_Point self) -> Standard_Integer

        Returns index 1, the default index for a point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Point_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Point self) -> AIS_KindOfInteractive

        Indicates that a point is a datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Point_Type(self, *args)


    def Component(self, *args):
        """
        Component(Handle_AIS_Point self) -> Handle_Geom_Point

        Returns the component specified in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.Handle_AIS_Point_Component(self, *args)


    def SetComponent(self, *args):
        """
        SetComponent(Handle_AIS_Point self, Handle_Geom_Point aComponent)

        Constructs an instance of the point aComponent.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.Handle_AIS_Point_SetComponent(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Point self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode selected is valid for point datums.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_Point self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Point_Compute(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Point self, Quantity_Color theColor)

        Allows you to provide settings for the Color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Point_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Point self)

        Allows you to remove color settings.


        """
        return _AIS.Handle_AIS_Point_UnsetColor(self, *args)


    def SetMarker(self, *args):
        """
        SetMarker(Handle_AIS_Point self, Aspect_TypeOfMarker const aType)

        Allows you to provide settings for a marker. These include
        -   type of marker,
        -   marker color,
        -   scale factor.

        :type aType: OCC.wrapper.Aspect.Aspect_TypeOfMarker

        """
        return _AIS.Handle_AIS_Point_SetMarker(self, *args)


    def UnsetMarker(self, *args):
        """
        UnsetMarker(Handle_AIS_Point self)

        Removes the marker settings.


        """
        return _AIS.Handle_AIS_Point_UnsetMarker(self, *args)


    def HasMarker(self, *args):
        """
        HasMarker(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the point datum has a marker.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasMarker(self, *args)


    def Vertex(self, *args):
        """
        Vertex(Handle_AIS_Point self) -> TopoDS_Vertex

        Converts a point into a vertex.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _AIS.Handle_AIS_Point_Vertex(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Point self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Point self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Point_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Point self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Point_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Point self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Point_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Point self)"""
        return _AIS.Handle_AIS_Point_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Point self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Point_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Point self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Point_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Point self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Point_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Point self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Point self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Point_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Point self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Point_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Point_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Point self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Point_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Point self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Point_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Point self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Point_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Point self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Point_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Point self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Point_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Point self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Point_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Point self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Point_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Point self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Point_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Point self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Point_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Point self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Point_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Point self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Point_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Point self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Point_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Point self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Point_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Point self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Point_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Point self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Point_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Point self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Point_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Point self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Point_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Point self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Point self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Point_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Point self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Point_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Point self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Point_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Point self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Point self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Point_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Point self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Point_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Point self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Point_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Point self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Point_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Point self)
        RecomputePrimitives(Handle_AIS_Point self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Point_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Point self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Point_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Point self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Point_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Point_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Point self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Point_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Point self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Point_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Point self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Point self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Point_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Point_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Point self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Point_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Point self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Point_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Point self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Point_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Point self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Point_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Point self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Point_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Point self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Point_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Point self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Point_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Point self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Point self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Point_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Point self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Point_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Point self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Point_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Point self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Point_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Point self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Point_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Point self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Point_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Point self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Point_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Point self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Point_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Point self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Point_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Point self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Point_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Point_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Point self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Point_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Point self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Point_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Point_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Point self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Point self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Point_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Point self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Point_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Point self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Point_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Point self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Point_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Point self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Point self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Point_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Point self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Point_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Point_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Point self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Point self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Point_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Point_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Point_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Point_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Point_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Point self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Point_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Point self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Point_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Point self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Point_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Point self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Point self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Point_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Point_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Point self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Point_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Point self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Point_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Point self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Point_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Point_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Point self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Point self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Point_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Point self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Point_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Point_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Point_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Point self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Point_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Point_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Point self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Point_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Point self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Point_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Point self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Point_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Point self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Point self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Point self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Point self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Point_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Point self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Point_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Point self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Point_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Point self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Point_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Point self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Point_DecrementRefCounter(self, *args)

Handle_AIS_Point_swigregister = _AIS.Handle_AIS_Point_swigregister
Handle_AIS_Point_swigregister(Handle_AIS_Point)

def Handle_AIS_Point_DownCast(thing):
    return _AIS.Handle_AIS_Point_DownCast(thing)
Handle_AIS_Point_DownCast = _AIS.Handle_AIS_Point_DownCast

class Handle_AIS_Dimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Dimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Dimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Dimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Dimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Dimension self, AIS_Dimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Dimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Dimension self, Handle_AIS_Dimension theHandle) -> Handle_AIS_Dimension
        assign(Handle_AIS_Dimension self, AIS_Dimension thePtr) -> Handle_AIS_Dimension
        assign(Handle_AIS_Dimension self, Handle_AIS_Dimension theHandle) -> Handle_AIS_Dimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Dimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Dimension self) -> AIS_Dimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Dimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Dimension self) -> AIS_Dimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Dimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Dimension self) -> AIS_Dimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Dimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Dimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Dimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Dimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Dimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Dimension

    def GetValue(self, *args):
        """
        GetValue(Handle_AIS_Dimension self) -> Standard_Real

        Gets dimension measurement value. If the value to display is not
        specified by user, then the dimension object is responsible to
        compute it on its own in model space coordinates.
        @return the dimension value (in model units) which is used
        during display of the presentation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Dimension_GetValue(self, *args)


    def SetComputedValue(self, *args):
        """
        SetComputedValue(Handle_AIS_Dimension self)

        Sets computed dimension value. Resets custom value mode if it was set.


        """
        return _AIS.Handle_AIS_Dimension_SetComputedValue(self, *args)


    def SetCustomValue(self, *args):
        """
        SetCustomValue(Handle_AIS_Dimension self, Standard_Real const theValue)
        SetCustomValue(Handle_AIS_Dimension self, TCollection_ExtendedString theValue)

        Sets user-defined dimension value.
        Unit conversion during the display is not applyed.
        @param theValue [in] the user-defined value to display.

        :type theValue: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_Dimension_SetCustomValue(self, *args)


    def GetCustomValue(self, *args):
        """
        Gets user-defined dimension value.
        @return dimension value string.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_Dimension_GetCustomValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPlane(self, *args):
        """
        Get the dimension plane in which the 2D dimension presentation is computed.
        By default, if plane is not defined by user, it is computed automatically
        after dimension geometry is computed.
        If computed dimension geometry (points) can't be placed on the user-defined
        plane, dimension geometry was set as invalid (validity flag is set to false)
        and dimension presentation will not be computed.
        If user-defined plane allow geometry placement on it, it will be used for
        computing of the dimension presentation.
        @return dimension plane used for presentation computing.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _AIS.Handle_AIS_Dimension_GetPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetGeometryType(self, *args):
        """
        GetGeometryType(Handle_AIS_Dimension self) -> Standard_Integer

        Geometry type defines type of shapes on which the dimension is to be built. 
        @return type of geometry on which the dimension will be built.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_GetGeometryType(self, *args)


    def SetCustomPlane(self, *args):
        """
        SetCustomPlane(Handle_AIS_Dimension self, gp_Pln thePlane)

        Sets user-defined plane where the 2D dimension presentation will be placed.
        Checks validity of this plane if geometry has been set already.
        Validity of the plane is checked according to the geometry set
        and has different criteria for different kinds of dimensions.

        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        return _AIS.Handle_AIS_Dimension_SetCustomPlane(self, *args)


    def UnsetCustomPlane(self, *args):
        """
        UnsetCustomPlane(Handle_AIS_Dimension self)

        Unsets user-defined plane. Therefore the plane for dimension will be
        computed automatically.


        """
        return _AIS.Handle_AIS_Dimension_UnsetCustomPlane(self, *args)


    def IsTextPositionCustom(self, *args):
        """
        IsTextPositionCustom(Handle_AIS_Dimension self) -> Standard_Boolean

        @return TRUE if text position is set by user with method SetTextPosition().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsTextPositionCustom(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(Handle_AIS_Dimension self, gp_Pnt arg2)

        Fixes the absolute text position and adjusts flyout, plane and text alignment
        according to it. Updates presentation if the text position is valid.
        ATTENTION! It does not change vertical text alignment.
        @param theTextPos [in] the point of text position.

        :type : OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Dimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(Handle_AIS_Dimension self) -> gp_Pnt

        Computes absolute text position from dimension parameters
        (flyout, plane and text alignment).

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Dimension_GetTextPosition(self, *args)


    def DimensionAspect(self, *args):
        """
        DimensionAspect(Handle_AIS_Dimension self) -> Handle_Prs3d_DimensionAspect

        Gets the dimension aspect from AIS object drawer.
        Dimension aspect contains aspects of line, text and arrows for dimension presentation.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_Dimension_DimensionAspect(self, *args)


    def SetDimensionAspect(self, *args):
        """
        SetDimensionAspect(Handle_AIS_Dimension self, Handle_Prs3d_DimensionAspect theDimensionAspect)

        Sets new dimension aspect for the interactive object drawer.
        The dimension aspect provides dynamic properties which are generally
        used during computation of dimension presentations.

        :type theDimensionAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_Dimension_SetDimensionAspect(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_Dimension self) -> AIS_KindOfDimension

        @return the kind of dimension.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_Dimension_KindOfDimension(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Dimension self) -> AIS_KindOfInteractive

        @return the kind of interactive.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Dimension_Type(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Dimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode theMode.
        The interactive context can have a default mode of representation for
        the set of Interactive Objects. This mode may not be accepted by object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_AcceptDisplayMode(self, *args)


    def DisplaySpecialSymbol(self, *args):
        """
        DisplaySpecialSymbol(Handle_AIS_Dimension self) -> AIS_DisplaySpecialSymbol

        @return dimension special symbol display options.

        :rtype: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_Dimension_DisplaySpecialSymbol(self, *args)


    def SetDisplaySpecialSymbol(self, *args):
        """
        SetDisplaySpecialSymbol(Handle_AIS_Dimension self, AIS_DisplaySpecialSymbol const theDisplaySpecSymbol)

        Specifies whether to display special symbol or not.

        :type theDisplaySpecSymbol: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_Dimension_SetDisplaySpecialSymbol(self, *args)


    def SpecialSymbol(self, *args):
        """
        SpecialSymbol(Handle_AIS_Dimension self) -> Standard_ExtCharacter

        @return special symbol.

        :rtype: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_Dimension_SpecialSymbol(self, *args)


    def SetSpecialSymbol(self, *args):
        """
        SetSpecialSymbol(Handle_AIS_Dimension self, Standard_ExtCharacter const theSpecialSymbol)

        Specifies special symbol.

        :type theSpecialSymbol: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_Dimension_SetSpecialSymbol(self, *args)


    def GetDisplayUnits(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_Dimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_Dimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(Handle_AIS_Dimension self, TCollection_AsciiString arg2)

        :type : OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_Dimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(Handle_AIS_Dimension self, TCollection_AsciiString arg2)

        :type : OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_Dimension_SetModelUnits(self, *args)


    def UnsetFixedTextPosition(self, *args):
        """
        UnsetFixedTextPosition(Handle_AIS_Dimension self)

        Unsets user defined text positioning and enables text positioning
        by other parameters: text alignment, extension size, flyout and custom plane.


        """
        return _AIS.Handle_AIS_Dimension_UnsetFixedTextPosition(self, *args)


    def SelToleranceForText2d(self, *args):
        """
        SelToleranceForText2d(Handle_AIS_Dimension self) -> Standard_Real

        Returns selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        Important! Only for 2d text.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Dimension_SelToleranceForText2d(self, *args)


    def SetSelToleranceForText2d(self, *args):
        """
        SetSelToleranceForText2d(Handle_AIS_Dimension self, Standard_Real const theTol)

        Sets selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        to change this tolerance use this method
        Important! Only for 2d text.

        :type theTol: float

        """
        return _AIS.Handle_AIS_Dimension_SetSelToleranceForText2d(self, *args)


    def GetFlyout(self, *args):
        """
        GetFlyout(Handle_AIS_Dimension self) -> Standard_Real

        @return flyout value for dimension.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Dimension_GetFlyout(self, *args)


    def SetFlyout(self, *args):
        """
        SetFlyout(Handle_AIS_Dimension self, Standard_Real const theFlyout)

        Sets flyout value for dimension.

        :type theFlyout: float

        """
        return _AIS.Handle_AIS_Dimension_SetFlyout(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_AIS_Dimension self) -> Standard_Boolean

        Check that the input geometry for dimension is valid and the
        presentation can be successfully computed.
        @return TRUE if dimension geometry is ok.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsValid(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Dimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Dimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Dimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Dimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Signature(self, *args):
        """
        Signature(Handle_AIS_Dimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Dimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Dimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Dimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Dimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Dimension_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Dimension self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Dimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Dimension self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_Dimension_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Dimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Dimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Dimension self)"""
        return _AIS.Handle_AIS_Dimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Dimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Dimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Dimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Dimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Dimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Dimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Dimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Dimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Dimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Dimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Dimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Dimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Dimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Dimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Dimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Dimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Dimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Dimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Dimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Dimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Dimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Dimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Dimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Dimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Dimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Dimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Dimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Dimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Dimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Dimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Dimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Dimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Dimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Dimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Dimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Dimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Dimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Dimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Dimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Dimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Dimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Dimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Dimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Dimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Dimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Dimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Dimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Dimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Dimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Dimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Dimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Dimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Dimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Dimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Dimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Dimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Dimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Dimension self)
        RecomputePrimitives(Handle_AIS_Dimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Dimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Dimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Dimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Dimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Dimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Dimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Dimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Dimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Dimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Dimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Dimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Dimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Dimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Dimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Dimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Dimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Dimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Dimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Dimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Dimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Dimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Dimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Dimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Dimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Dimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Dimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Dimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Dimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Dimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Dimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Dimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Dimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Dimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Dimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Dimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Dimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Dimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Dimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Dimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Dimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Dimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Dimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Dimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Dimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Dimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Dimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Dimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Dimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Dimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Dimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Dimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Dimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Dimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Dimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Dimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Dimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Dimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Dimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Dimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Dimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Dimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Dimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Dimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Dimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Dimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Dimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Dimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Dimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Dimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Dimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Dimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Dimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Dimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Dimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Dimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Dimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Dimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Dimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Dimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Dimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Dimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Dimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Dimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Dimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Dimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Dimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Dimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Dimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Dimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Dimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Dimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Dimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Dimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Dimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Dimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Dimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Dimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Dimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Dimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Dimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Dimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Dimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Dimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Dimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Dimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Dimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Dimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Dimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Dimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Dimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Dimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Dimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Dimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Dimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Dimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Dimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Dimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Dimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Dimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Dimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Dimension_DecrementRefCounter(self, *args)

Handle_AIS_Dimension_swigregister = _AIS.Handle_AIS_Dimension_swigregister
Handle_AIS_Dimension_swigregister(Handle_AIS_Dimension)

def Handle_AIS_Dimension_DownCast(thing):
    return _AIS.Handle_AIS_Dimension_DownCast(thing)
Handle_AIS_Dimension_DownCast = _AIS.Handle_AIS_Dimension_DownCast

class NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< AIS_ColoredDrawer >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< AIS_ColoredDrawer >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< AIS_ColoredDrawer >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< AIS_ColoredDrawer >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _AIS.new_NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_AIS_ColoredDrawer theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_AIS_ColoredDrawer theItem) -> Handle_AIS_ColoredDrawer

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_AIS_ColoredDrawer

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_AIS_ColoredDrawer

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_AIS_ColoredDrawer

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_swigregister = _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _AIS.NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher_IteratorHelper)


try:
	AIS_DataMapOfShapeDrawer = NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_EllipseRadiusDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_EllipseRadiusDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_EllipseRadiusDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_EllipseRadiusDimension self, AIS_EllipseRadiusDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_EllipseRadiusDimension self, Handle_AIS_EllipseRadiusDimension theHandle) -> Handle_AIS_EllipseRadiusDimension
        assign(Handle_AIS_EllipseRadiusDimension self, AIS_EllipseRadiusDimension thePtr) -> Handle_AIS_EllipseRadiusDimension
        assign(Handle_AIS_EllipseRadiusDimension self, Handle_AIS_EllipseRadiusDimension theHandle) -> Handle_AIS_EllipseRadiusDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_EllipseRadiusDimension self) -> AIS_EllipseRadiusDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_EllipseRadiusDimension self) -> AIS_EllipseRadiusDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_EllipseRadiusDimension self) -> AIS_EllipseRadiusDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_EllipseRadiusDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_EllipseRadiusDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_EllipseRadiusDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_EllipseRadiusDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_EllipseRadiusDimension

    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_EllipseRadiusDimension self) -> AIS_KindOfDimension

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsMovable(self, *args)


    def ComputeGeometry(self, *args):
        """ComputeGeometry(Handle_AIS_EllipseRadiusDimension self)"""
        return _AIS.Handle_AIS_EllipseRadiusDimension_ComputeGeometry(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_EllipseRadiusDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_EllipseRadiusDimension self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_EllipseRadiusDimension self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_EllipseRadiusDimension self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Type(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_EllipseRadiusDimension self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_EllipseRadiusDimension self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_EllipseRadiusDimension self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_EllipseRadiusDimension self)"""
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_EllipseRadiusDimension self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_EllipseRadiusDimension self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_EllipseRadiusDimension self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_EllipseRadiusDimension self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_EllipseRadiusDimension self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_EllipseRadiusDimension self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_EllipseRadiusDimension self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_EllipseRadiusDimension self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_EllipseRadiusDimension self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_EllipseRadiusDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_EllipseRadiusDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_EllipseRadiusDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_EllipseRadiusDimension self)"""
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_EllipseRadiusDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_EllipseRadiusDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_EllipseRadiusDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_EllipseRadiusDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_EllipseRadiusDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_EllipseRadiusDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_EllipseRadiusDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_EllipseRadiusDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_EllipseRadiusDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_EllipseRadiusDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_EllipseRadiusDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_EllipseRadiusDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_EllipseRadiusDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_EllipseRadiusDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_EllipseRadiusDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_EllipseRadiusDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_EllipseRadiusDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_EllipseRadiusDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_EllipseRadiusDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_EllipseRadiusDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_EllipseRadiusDimension self)
        RecomputePrimitives(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_EllipseRadiusDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_EllipseRadiusDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_EllipseRadiusDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_EllipseRadiusDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_EllipseRadiusDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_EllipseRadiusDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_EllipseRadiusDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_EllipseRadiusDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_EllipseRadiusDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_EllipseRadiusDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_EllipseRadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_EllipseRadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_EllipseRadiusDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_EllipseRadiusDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_EllipseRadiusDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_EllipseRadiusDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_EllipseRadiusDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_EllipseRadiusDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_EllipseRadiusDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_EllipseRadiusDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_EllipseRadiusDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_EllipseRadiusDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_EllipseRadiusDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_EllipseRadiusDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_EllipseRadiusDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_EllipseRadiusDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_EllipseRadiusDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_EllipseRadiusDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_EllipseRadiusDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_EllipseRadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_EllipseRadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_EllipseRadiusDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_EllipseRadiusDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_EllipseRadiusDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_EllipseRadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_EllipseRadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_EllipseRadiusDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_EllipseRadiusDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_EllipseRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_EllipseRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EllipseRadiusDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_EllipseRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_EllipseRadiusDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_EllipseRadiusDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_EllipseRadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_EllipseRadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_EllipseRadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_EllipseRadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_EllipseRadiusDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_EllipseRadiusDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_EllipseRadiusDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EllipseRadiusDimension_DecrementRefCounter(self, *args)

Handle_AIS_EllipseRadiusDimension_swigregister = _AIS.Handle_AIS_EllipseRadiusDimension_swigregister
Handle_AIS_EllipseRadiusDimension_swigregister(Handle_AIS_EllipseRadiusDimension)

def Handle_AIS_EllipseRadiusDimension_DownCast(thing):
    return _AIS.Handle_AIS_EllipseRadiusDimension_DownCast(thing)
Handle_AIS_EllipseRadiusDimension_DownCast = _AIS.Handle_AIS_EllipseRadiusDimension_DownCast

class Handle_AIS_ConcentricRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ConcentricRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ConcentricRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ConcentricRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ConcentricRelation self, AIS_ConcentricRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ConcentricRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ConcentricRelation self, Handle_AIS_ConcentricRelation theHandle) -> Handle_AIS_ConcentricRelation
        assign(Handle_AIS_ConcentricRelation self, AIS_ConcentricRelation thePtr) -> Handle_AIS_ConcentricRelation
        assign(Handle_AIS_ConcentricRelation self, Handle_AIS_ConcentricRelation theHandle) -> Handle_AIS_ConcentricRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ConcentricRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ConcentricRelation self) -> AIS_ConcentricRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ConcentricRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ConcentricRelation self) -> AIS_ConcentricRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ConcentricRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ConcentricRelation self) -> AIS_ConcentricRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ConcentricRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ConcentricRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ConcentricRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ConcentricRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ConcentricRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ConcentricRelation

    def Compute(self, *args):
        """
        Compute(Handle_AIS_ConcentricRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ConcentricRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ConcentricRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ConcentricRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ConcentricRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ConcentricRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_ConcentricRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_ConcentricRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_ConcentricRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_ConcentricRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_ConcentricRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_ConcentricRelation_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsMovable(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_ConcentricRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_ConcentricRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_ConcentricRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_ConcentricRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_ConcentricRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_ConcentricRelation self)"""
        return _AIS.Handle_AIS_ConcentricRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_ConcentricRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_ConcentricRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ConcentricRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_ConcentricRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_ConcentricRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_ConcentricRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_ConcentricRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ConcentricRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_ConcentricRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_ConcentricRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_ConcentricRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_ConcentricRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_ConcentricRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_ConcentricRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_ConcentricRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_ConcentricRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_ConcentricRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ConcentricRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_ConcentricRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_ConcentricRelation self)"""
        return _AIS.Handle_AIS_ConcentricRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_ConcentricRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_ConcentricRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_ConcentricRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ConcentricRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_ConcentricRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_ConcentricRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_ConcentricRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_ConcentricRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_ConcentricRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_ConcentricRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_ConcentricRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_ConcentricRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_ConcentricRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_ConcentricRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ConcentricRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_ConcentricRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ConcentricRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_ConcentricRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_ConcentricRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_ConcentricRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_ConcentricRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_ConcentricRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_ConcentricRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ConcentricRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_ConcentricRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_ConcentricRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_ConcentricRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ConcentricRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_ConcentricRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_ConcentricRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_ConcentricRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ConcentricRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_ConcentricRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ConcentricRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_ConcentricRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_ConcentricRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_ConcentricRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_ConcentricRelation self)
        RecomputePrimitives(Handle_AIS_ConcentricRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ConcentricRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_ConcentricRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_ConcentricRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_ConcentricRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_ConcentricRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_ConcentricRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ConcentricRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_ConcentricRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ConcentricRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ConcentricRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_ConcentricRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_ConcentricRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_ConcentricRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_ConcentricRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_ConcentricRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_ConcentricRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_ConcentricRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_ConcentricRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_ConcentricRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_ConcentricRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_ConcentricRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_ConcentricRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ConcentricRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_ConcentricRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_ConcentricRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ConcentricRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_ConcentricRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ConcentricRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_ConcentricRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_ConcentricRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_ConcentricRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ConcentricRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_ConcentricRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_ConcentricRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ConcentricRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_ConcentricRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ConcentricRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_ConcentricRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_ConcentricRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_ConcentricRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_ConcentricRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ConcentricRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_ConcentricRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_ConcentricRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_ConcentricRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_ConcentricRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_ConcentricRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_ConcentricRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ConcentricRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_ConcentricRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_ConcentricRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_ConcentricRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_ConcentricRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_ConcentricRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_ConcentricRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ConcentricRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_ConcentricRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_ConcentricRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ConcentricRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ConcentricRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_ConcentricRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_ConcentricRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ConcentricRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_ConcentricRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ConcentricRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_ConcentricRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ConcentricRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_ConcentricRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_ConcentricRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_ConcentricRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_ConcentricRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_ConcentricRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ConcentricRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_ConcentricRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ConcentricRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_ConcentricRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_ConcentricRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_ConcentricRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_ConcentricRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ConcentricRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ConcentricRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_ConcentricRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ConcentricRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_ConcentricRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ConcentricRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_ConcentricRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_ConcentricRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ConcentricRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ConcentricRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ConcentricRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ConcentricRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ConcentricRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ConcentricRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConcentricRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ConcentricRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ConcentricRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ConcentricRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ConcentricRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ConcentricRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConcentricRelation_DecrementRefCounter(self, *args)

Handle_AIS_ConcentricRelation_swigregister = _AIS.Handle_AIS_ConcentricRelation_swigregister
Handle_AIS_ConcentricRelation_swigregister(Handle_AIS_ConcentricRelation)

def Handle_AIS_ConcentricRelation_DownCast(thing):
    return _AIS.Handle_AIS_ConcentricRelation_DownCast(thing)
Handle_AIS_ConcentricRelation_DownCast = _AIS.Handle_AIS_ConcentricRelation_DownCast

class Handle_AIS_ExclusionFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ExclusionFilter self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ExclusionFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ExclusionFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ExclusionFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ExclusionFilter self, AIS_ExclusionFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ExclusionFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ExclusionFilter self, Handle_AIS_ExclusionFilter theHandle) -> Handle_AIS_ExclusionFilter
        assign(Handle_AIS_ExclusionFilter self, AIS_ExclusionFilter thePtr) -> Handle_AIS_ExclusionFilter
        assign(Handle_AIS_ExclusionFilter self, Handle_AIS_ExclusionFilter theHandle) -> Handle_AIS_ExclusionFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ExclusionFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ExclusionFilter self) -> AIS_ExclusionFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ExclusionFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ExclusionFilter self) -> AIS_ExclusionFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ExclusionFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ExclusionFilter self) -> AIS_ExclusionFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ExclusionFilter___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ExclusionFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ExclusionFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ExclusionFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ExclusionFilter_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ExclusionFilter

    def IsOk(self, *args):
        """
        IsOk(Handle_AIS_ExclusionFilter self, Handle_SelectMgr_EntityOwner anObj) -> Standard_Boolean

        :type anObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_IsOk(self, *args)


    def Add(self, *args):
        """
        Add(Handle_AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude) -> Standard_Boolean
        Add(Handle_AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude, Standard_Integer const SignatureInType) -> Standard_Boolean

        :type TypeToExclude: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type SignatureInType: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude) -> Standard_Boolean
        Remove(Handle_AIS_ExclusionFilter self, AIS_KindOfInteractive const TypeToExclude, Standard_Integer const SignatureInType) -> Standard_Boolean

        :type TypeToExclude: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type SignatureInType: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_Remove(self, *args)


    def Clear(self, *args):
        """Clear(Handle_AIS_ExclusionFilter self)"""
        return _AIS.Handle_AIS_ExclusionFilter_Clear(self, *args)


    def IsExclusionFlagOn(self, *args):
        """
        IsExclusionFlagOn(Handle_AIS_ExclusionFilter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_IsExclusionFlagOn(self, *args)


    def SetExclusionFlag(self, *args):
        """
        SetExclusionFlag(Handle_AIS_ExclusionFilter self, Standard_Boolean const Status)

        :type Status: bool

        """
        return _AIS.Handle_AIS_ExclusionFilter_SetExclusionFlag(self, *args)


    def IsStored(self, *args):
        """
        IsStored(Handle_AIS_ExclusionFilter self, AIS_KindOfInteractive const aType) -> Standard_Boolean

        :type aType: OCC.wrapper.AIS.AIS_KindOfInteractive
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_IsStored(self, *args)


    def ListOfStoredTypes(self, *args):
        """
        ListOfStoredTypes(Handle_AIS_ExclusionFilter self, NCollection_List_Standard_Integer TheList)

        :type TheList: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_ExclusionFilter_ListOfStoredTypes(self, *args)


    def ListOfSignature(self, *args):
        """
        ListOfSignature(Handle_AIS_ExclusionFilter self, AIS_KindOfInteractive const aType, NCollection_List_Standard_Integer TheStoredList)

        :type aType: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type TheStoredList: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_ExclusionFilter_ListOfSignature(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ExclusionFilter self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ExclusionFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ExclusionFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ExclusionFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ActsOn(self, *args):
        """
        ActsOn(Handle_AIS_ExclusionFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        Returns true in an AIS local context, if this filter
        operates on a type of subshape defined in a filter
        class inheriting this framework.
        This function completes IsOk in an AIS local context.

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_ActsOn(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ExclusionFilter self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ExclusionFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ExclusionFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ExclusionFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ExclusionFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ExclusionFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ExclusionFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ExclusionFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ExclusionFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ExclusionFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ExclusionFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ExclusionFilter self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ExclusionFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ExclusionFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ExclusionFilter_DecrementRefCounter(self, *args)

Handle_AIS_ExclusionFilter_swigregister = _AIS.Handle_AIS_ExclusionFilter_swigregister
Handle_AIS_ExclusionFilter_swigregister(Handle_AIS_ExclusionFilter)

def Handle_AIS_ExclusionFilter_DownCast(thing):
    return _AIS.Handle_AIS_ExclusionFilter_DownCast(thing)
Handle_AIS_ExclusionFilter_DownCast = _AIS.Handle_AIS_ExclusionFilter_DownCast

class AIS_RadiusDimension(AIS_Dimension):
    """
    Radius dimension. Can be constructued:
    - On generic circle.
    - On generic circle with user-defined anchor point on that circle.
    - On generic shape containing geometry that can be measured
    by diameter dimension: circle wire, arc, circular face, etc.
    The anchor point is the location of left attachement point of
    dimension on the circle. It can be user-specified, or computed as
    middle point on the arc. The radius dimension always lies in the
    plane of the measured circle. The dimension is considered as
    invalid if the user-specified anchor point is not lying on the circle,
    if the radius of the circle is less than Precision::Confusion().
    In case if the dimension is built on the arbitrary shape,
    it can be considered as invalid if the shape does not contain
    circle geometry.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_RadiusDimension
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_RadiusDimension(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_RadiusDimension self, gp_Circ theCircle) -> AIS_RadiusDimension
        __init__(AIS_RadiusDimension self, gp_Circ theCircle, gp_Pnt theAnchorPoint) -> AIS_RadiusDimension
        __init__(AIS_RadiusDimension self, TopoDS_Shape theShape) -> AIS_RadiusDimension

        Create radius dimension for the arbitrary shape (if possible).
        @param theShape [in] the shape to measure.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _AIS.new_AIS_RadiusDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Circle(self, *args):
        """
        @return measured geometry circle.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        res = _AIS.AIS_RadiusDimension_Circle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AnchorPoint(self, *args):
        """
        @return anchor point on circle for radius dimension.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_RadiusDimension_AnchorPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        @return the measured shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_RadiusDimension_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(AIS_RadiusDimension self, gp_Circ theCircle)
        SetMeasuredGeometry(AIS_RadiusDimension self, gp_Circ theCircle, gp_Pnt theAnchorPoint, Standard_Boolean const theHasAnchor)
        SetMeasuredGeometry(AIS_RadiusDimension self, TopoDS_Shape theShape)
        SetMeasuredGeometry(AIS_RadiusDimension self, TopoDS_Shape theShape, gp_Pnt theAnchorPoint, Standard_Boolean const theHasAnchor)

        Measure radius on the passed shape, if applicable.
        The dimension will become invalid if the passed shape is not
        measurable or if measured diameter value is less than Precision::Confusion().
        @param theShape [in] the shape to measure.
        @param theAnchorPoint [in] the point to attach the dimension lines, should be on the circle
        @param theHasAnchor   [in] should be set TRUE if theAnchorPoint should be used

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theAnchorPoint: OCC.wrapper.gp.gp_Pnt
        :type theHasAnchor: bool

        """
        return _AIS.AIS_RadiusDimension_SetMeasuredGeometry(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_RadiusDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.AIS_RadiusDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(AIS_RadiusDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_RadiusDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(AIS_RadiusDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.AIS_RadiusDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(AIS_RadiusDimension self, gp_Pnt theTextPos)

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_RadiusDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(AIS_RadiusDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_RadiusDimension_GetTextPosition(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_RadiusDimension_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_RadiusDimension_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_RadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_RadiusDimension
AIS_RadiusDimension_swigregister = _AIS.AIS_RadiusDimension_swigregister
AIS_RadiusDimension_swigregister(AIS_RadiusDimension)

def AIS_RadiusDimension_get_type_name(*args):
    """
    AIS_RadiusDimension_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_RadiusDimension_get_type_name(*args)

def AIS_RadiusDimension_get_type_descriptor(*args):
    """
    AIS_RadiusDimension_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_RadiusDimension_get_type_descriptor(*args)

class AIS_MidPointRelation(AIS_Relation):
    """presentation of equal distance to point myMidPoint"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_MidPointRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_MidPointRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_MidPointRelation self, TopoDS_Shape aSymmTool, TopoDS_Shape FirstShape, TopoDS_Shape SecondShape, Handle_Geom_Plane aPlane) -> AIS_MidPointRelation

        :type aSymmTool: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SecondShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        this = _AIS.new_AIS_MidPointRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsMovable(self, *args):
        """
        IsMovable(AIS_MidPointRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_MidPointRelation_IsMovable(self, *args)


    def SetTool(self, *args):
        """
        SetTool(AIS_MidPointRelation self, TopoDS_Shape aMidPointTool)

        :type aMidPointTool: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_MidPointRelation_SetTool(self, *args)


    def GetTool(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_MidPointRelation_GetTool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(AIS_MidPointRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        Computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_MidPointRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_MidPointRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_MidPointRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_MidPointRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_MidPointRelation
AIS_MidPointRelation_swigregister = _AIS.AIS_MidPointRelation_swigregister
AIS_MidPointRelation_swigregister(AIS_MidPointRelation)

def AIS_MidPointRelation_get_type_name(*args):
    """
    AIS_MidPointRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_MidPointRelation_get_type_name(*args)

def AIS_MidPointRelation_get_type_descriptor(*args):
    """
    AIS_MidPointRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_MidPointRelation_get_type_descriptor(*args)

class Handle_AIS_Selection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Selection self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Selection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Selection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Selection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Selection self, AIS_Selection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Selection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Selection self, Handle_AIS_Selection theHandle) -> Handle_AIS_Selection
        assign(Handle_AIS_Selection self, AIS_Selection thePtr) -> Handle_AIS_Selection
        assign(Handle_AIS_Selection self, Handle_AIS_Selection theHandle) -> Handle_AIS_Selection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Selection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Selection self) -> AIS_Selection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Selection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Selection self) -> AIS_Selection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Selection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Selection self) -> AIS_Selection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Selection___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Selection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Selection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Selection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Selection_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Selection

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Selection self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Selection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Selection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Selection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_AIS_Selection self)

        removes all the object of the selection.


        """
        return _AIS.Handle_AIS_Selection_Clear(self, *args)


    def Select(self, *args):
        """
        Select(Handle_AIS_Selection self, Handle_SelectMgr_EntityOwner theObject) -> AIS_SelectStatus

        if the object is not yet in the selection, it will be added.
        if the object is already in the selection, it will be removed.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.AIS.AIS_SelectStatus

        """
        return _AIS.Handle_AIS_Selection_Select(self, *args)


    def AddSelect(self, *args):
        """
        AddSelect(Handle_AIS_Selection self, Handle_SelectMgr_EntityOwner theObject) -> AIS_SelectStatus

        the object is always add int the selection.
        faster when the number of objects selected is great.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.AIS.AIS_SelectStatus

        """
        return _AIS.Handle_AIS_Selection_AddSelect(self, *args)


    def ClearAndSelect(self, *args):
        """
        ClearAndSelect(Handle_AIS_Selection self, Handle_SelectMgr_EntityOwner theObject)

        clears the selection and adds the object in the selection.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Selection_ClearAndSelect(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_AIS_Selection self, Handle_SelectMgr_EntityOwner theObject) -> Standard_Boolean

        checks if the object is in the selection.

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Selection_IsSelected(self, *args)


    def Objects(self, *args):
        """
        Return the list of selected objects.

        :rtype: OCC.wrapper.AIS.AIS_NListOfEntityOwner

        """
        res = _AIS.Handle_AIS_Selection_Objects(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Extent(self, *args):
        """
        Extent(Handle_AIS_Selection self) -> Standard_Integer

        Return the number of selected objects.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Selection_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_AIS_Selection self) -> Standard_Boolean

        Return true if list of selected objects is empty.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Selection_IsEmpty(self, *args)


    def Init(self, *args):
        """
        Init(Handle_AIS_Selection self)

        Start iteration through selected objects.


        """
        return _AIS.Handle_AIS_Selection_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Selection self) -> Standard_Boolean

        Return true if iterator points to selected object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Selection_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Selection self)

        Continue iteration through selected objects.


        """
        return _AIS.Handle_AIS_Selection_Next(self, *args)


    def Value(self, *args):
        """
        Return selected object at iterator position.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Selection_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AIS_Selection self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Selection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Selection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Selection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Selection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Selection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Selection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Selection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Selection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Selection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Selection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Selection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Selection self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Selection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Selection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Selection_DecrementRefCounter(self, *args)

Handle_AIS_Selection_swigregister = _AIS.Handle_AIS_Selection_swigregister
Handle_AIS_Selection_swigregister(Handle_AIS_Selection)

def Handle_AIS_Selection_DownCast(thing):
    return _AIS.Handle_AIS_Selection_DownCast(thing)
Handle_AIS_Selection_DownCast = _AIS.Handle_AIS_Selection_DownCast

class Handle_AIS_Animation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Animation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Animation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Animation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Animation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Animation self, AIS_Animation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Animation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Animation self, Handle_AIS_Animation theHandle) -> Handle_AIS_Animation
        assign(Handle_AIS_Animation self, AIS_Animation thePtr) -> Handle_AIS_Animation
        assign(Handle_AIS_Animation self, Handle_AIS_Animation theHandle) -> Handle_AIS_Animation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Animation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Animation self) -> AIS_Animation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Animation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Animation self) -> AIS_Animation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Animation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Animation self) -> AIS_Animation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Animation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Animation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Animation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Animation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Animation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Animation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Animation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Animation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Animation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Animation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Animation name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_Animation_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPts(self, *args):
        """
        StartPts(Handle_AIS_Animation self) -> Standard_Real

        @return start time of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Animation_StartPts(self, *args)


    def SetStartPts(self, *args):
        """
        SetStartPts(Handle_AIS_Animation self, Standard_Real const thePtsStart)

        Sets time limits for animation in the animation timeline

        :type thePtsStart: float

        """
        return _AIS.Handle_AIS_Animation_SetStartPts(self, *args)


    def Duration(self, *args):
        """
        Duration(Handle_AIS_Animation self) -> Standard_Real

        @return duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Animation_Duration(self, *args)


    def UpdateTotalDuration(self, *args):
        """
        UpdateTotalDuration(Handle_AIS_Animation self)

        Update total duration considering all animations on timeline.


        """
        return _AIS.Handle_AIS_Animation_UpdateTotalDuration(self, *args)


    def HasOwnDuration(self, *args):
        """
        HasOwnDuration(Handle_AIS_Animation self) -> Standard_Boolean

        Return true if duration is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Animation_HasOwnDuration(self, *args)


    def OwnDuration(self, *args):
        """
        OwnDuration(Handle_AIS_Animation self) -> Standard_Real

        @return own duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Animation_OwnDuration(self, *args)


    def SetOwnDuration(self, *args):
        """
        SetOwnDuration(Handle_AIS_Animation self, Standard_Real const theDuration)

        Defines duration of the animation.

        :type theDuration: float

        """
        return _AIS.Handle_AIS_Animation_SetOwnDuration(self, *args)


    def Add(self, *args):
        """
        Add(Handle_AIS_Animation self, Handle_AIS_Animation theAnimation)

        Add single animation to the timeline.
        @param theAnimation input animation

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_Animation_Add(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_AIS_Animation self)

        Clear animation timeline - remove all animations from it.


        """
        return _AIS.Handle_AIS_Animation_Clear(self, *args)


    def Find(self, *args):
        """
        Find(Handle_AIS_Animation self, TCollection_AsciiString theAnimationName) -> Handle_AIS_Animation

        Return the child animation with the given name.

        :type theAnimationName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_Animation_Find(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_AIS_Animation self, Handle_AIS_Animation theAnimation) -> Standard_Boolean

        Remove the child animation.

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Animation_Remove(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_AIS_Animation self, Handle_AIS_Animation theAnimationOld, Handle_AIS_Animation theAnimationNew) -> Standard_Boolean

        Replace the child animation.

        :type theAnimationOld: OCC.wrapper.AIS.Handle_AIS_Animation
        :type theAnimationNew: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Animation_Replace(self, *args)


    def CopyFrom(self, *args):
        """
        CopyFrom(Handle_AIS_Animation self, Handle_AIS_Animation theOther)

        Clears own children and then copy child animations from another object.
        Copy also Start Time and Duration values.

        :type theOther: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_Animation_CopyFrom(self, *args)


    def Children(self, *args):
        """
        Return sequence of child animations.

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_Animation

        """
        res = _AIS.Handle_AIS_Animation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartTimer(self, *args):
        """
        StartTimer(Handle_AIS_Animation self, Standard_Real const theStartPts, Standard_Real const thePlaySpeed, Standard_Boolean const theToUpdate, Standard_Boolean const theToStopTimer)

        Start animation with internally defined timer instance.
        Calls ::Start() internally.
        @param theStartPts    starting timer position (presentation timestamp)
        @param thePlaySpeed   playback speed (1.0 means normal speed)
        @param theToUpdate    flag to update defined animations to specified start position
        @param theToStopTimer flag to pause timer at the starting position

        :type theStartPts: float
        :type thePlaySpeed: float
        :type theToUpdate: bool
        :type theToStopTimer: bool

        """
        return _AIS.Handle_AIS_Animation_StartTimer(self, *args)


    def UpdateTimer(self, *args):
        """
        UpdateTimer(Handle_AIS_Animation self) -> Standard_Real

        Update single frame of animation, update timer state
        @return current time of timeline progress.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Animation_UpdateTimer(self, *args)


    def ElapsedTime(self, *args):
        """
        ElapsedTime(Handle_AIS_Animation self) -> Standard_Real

        Return elapsed time.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Animation_ElapsedTime(self, *args)


    def Start(self, *args):
        """
        Start(Handle_AIS_Animation self, Standard_Boolean const theToUpdate)

        Start animation. This method changes status of the animation to Started.
        This status defines whether animation is to be performed in the timeline or not.
        @param theToUpdate call Update() method

        :type theToUpdate: bool

        """
        return _AIS.Handle_AIS_Animation_Start(self, *args)


    def Pause(self, *args):
        """
        Pause(Handle_AIS_Animation self)

        Pause the process timeline.


        """
        return _AIS.Handle_AIS_Animation_Pause(self, *args)


    def Stop(self, *args):
        """
        Stop(Handle_AIS_Animation self)

        Stop animation. This method changed status of the animation to Stopped.
        This status shows that animation will not be performed in the timeline or it is finished.


        """
        return _AIS.Handle_AIS_Animation_Stop(self, *args)


    def IsStopped(self, *args):
        """
        IsStopped(Handle_AIS_Animation self) -> bool

        Check if animation is to be performed in the animation timeline.
        @return True if it is stopped of finished.

        :rtype: bool

        """
        return _AIS.Handle_AIS_Animation_IsStopped(self, *args)


    def Update(self, *args):
        """
        Update(Handle_AIS_Animation self, Standard_Real const thePts) -> Standard_Boolean

        Update single frame of animation, update timer state
        @param thePts [in] the time moment within [0; Duration()]
        @return True if timeline is in progress

        :type thePts: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Animation_Update(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Animation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Animation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Animation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Animation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Animation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Animation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Animation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Animation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Animation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Animation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Animation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Animation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Animation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Animation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Animation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Animation_DecrementRefCounter(self, *args)

Handle_AIS_Animation_swigregister = _AIS.Handle_AIS_Animation_swigregister
Handle_AIS_Animation_swigregister(Handle_AIS_Animation)

def Handle_AIS_Animation_DownCast(thing):
    return _AIS.Handle_AIS_Animation_DownCast(thing)
Handle_AIS_Animation_DownCast = _AIS.Handle_AIS_Animation_DownCast

class Handle_AIS_LengthDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_LengthDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_LengthDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_LengthDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_LengthDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_LengthDimension self, AIS_LengthDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_LengthDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_LengthDimension self, Handle_AIS_LengthDimension theHandle) -> Handle_AIS_LengthDimension
        assign(Handle_AIS_LengthDimension self, AIS_LengthDimension thePtr) -> Handle_AIS_LengthDimension
        assign(Handle_AIS_LengthDimension self, Handle_AIS_LengthDimension theHandle) -> Handle_AIS_LengthDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_LengthDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_LengthDimension self) -> AIS_LengthDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_LengthDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_LengthDimension self) -> AIS_LengthDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_LengthDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_LengthDimension self) -> AIS_LengthDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_LengthDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_LengthDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_LengthDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_LengthDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_LengthDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_LengthDimension

    def FirstPoint(self, *args):
        """
        @return first attachement point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_LengthDimension_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondPoint(self, *args):
        """
        @return second attachement point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_LengthDimension_SecondPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstShape(self, *args):
        """
        @return first attachement shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_LengthDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondShape(self, *args):
        """
        @return second attachement shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_LengthDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(Handle_AIS_LengthDimension self, gp_Pnt theFirstPoint, gp_Pnt theSecondPoint, gp_Pln thePlane)
        SetMeasuredGeometry(Handle_AIS_LengthDimension self, TopoDS_Edge theEdge, gp_Pln thePlane)
        SetMeasuredGeometry(Handle_AIS_LengthDimension self, TopoDS_Face theFirstFace, TopoDS_Face theSecondFace)
        SetMeasuredGeometry(Handle_AIS_LengthDimension self, TopoDS_Face theFace, TopoDS_Edge theEdge)

        Measure distance between face and edge.
        The dimension will become invalid if the distance can not
        be measured or it is less than Precision::Confusion().
        @param theFace [in] the face (first shape).
        @param theEdge [in] the edge (second shape).

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _AIS.Handle_AIS_LengthDimension_SetMeasuredGeometry(self, *args)


    def SetMeasuredShapes(self, *args):
        """
        SetMeasuredShapes(Handle_AIS_LengthDimension self, TopoDS_Shape theFirstShape, TopoDS_Shape theSecondShape)

        Measure distance between generic pair of shapes (edges, vertices, length),
        where measuring is applicable.
        @param theFirstShape [in] the first shape.
        @param theSecondShape [in] the second shape.

        :type theFirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theSecondShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_LengthDimension_SetMeasuredShapes(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_LengthDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_LengthDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(Handle_AIS_LengthDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_LengthDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(Handle_AIS_LengthDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_LengthDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(Handle_AIS_LengthDimension self, gp_Pnt theTextPos)

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_LengthDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(Handle_AIS_LengthDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_LengthDimension_GetTextPosition(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_AIS_LengthDimension self, gp_Dir theDirection, Standard_Boolean const theUseDirection)

        Set custom direction for dimension. If it is not set, the direction is obtained
        from the measured geometry (e.g. line between points of dimension)
        The direction does not change flyout direction of dimension.
        @param theDirection [in] the dimension direction.
        @param theUseDirection [in] boolean value if custom direction should be used.

        :type theDirection: OCC.wrapper.gp.gp_Dir
        :type theUseDirection: bool

        """
        return _AIS.Handle_AIS_LengthDimension_SetDirection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_LengthDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_LengthDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_LengthDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_LengthDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetValue(self, *args):
        """
        GetValue(Handle_AIS_LengthDimension self) -> Standard_Real

        Gets dimension measurement value. If the value to display is not
        specified by user, then the dimension object is responsible to
        compute it on its own in model space coordinates.
        @return the dimension value (in model units) which is used
        during display of the presentation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_LengthDimension_GetValue(self, *args)


    def SetComputedValue(self, *args):
        """
        SetComputedValue(Handle_AIS_LengthDimension self)

        Sets computed dimension value. Resets custom value mode if it was set.


        """
        return _AIS.Handle_AIS_LengthDimension_SetComputedValue(self, *args)


    def SetCustomValue(self, *args):
        """
        SetCustomValue(Handle_AIS_LengthDimension self, Standard_Real const theValue)
        SetCustomValue(Handle_AIS_LengthDimension self, TCollection_ExtendedString theValue)

        Sets user-defined dimension value.
        Unit conversion during the display is not applyed.
        @param theValue [in] the user-defined value to display.

        :type theValue: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_LengthDimension_SetCustomValue(self, *args)


    def GetCustomValue(self, *args):
        """
        Gets user-defined dimension value.
        @return dimension value string.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_LengthDimension_GetCustomValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPlane(self, *args):
        """
        Get the dimension plane in which the 2D dimension presentation is computed.
        By default, if plane is not defined by user, it is computed automatically
        after dimension geometry is computed.
        If computed dimension geometry (points) can't be placed on the user-defined
        plane, dimension geometry was set as invalid (validity flag is set to false)
        and dimension presentation will not be computed.
        If user-defined plane allow geometry placement on it, it will be used for
        computing of the dimension presentation.
        @return dimension plane used for presentation computing.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _AIS.Handle_AIS_LengthDimension_GetPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetGeometryType(self, *args):
        """
        GetGeometryType(Handle_AIS_LengthDimension self) -> Standard_Integer

        Geometry type defines type of shapes on which the dimension is to be built. 
        @return type of geometry on which the dimension will be built.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_GetGeometryType(self, *args)


    def SetCustomPlane(self, *args):
        """
        SetCustomPlane(Handle_AIS_LengthDimension self, gp_Pln thePlane)

        Sets user-defined plane where the 2D dimension presentation will be placed.
        Checks validity of this plane if geometry has been set already.
        Validity of the plane is checked according to the geometry set
        and has different criteria for different kinds of dimensions.

        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        return _AIS.Handle_AIS_LengthDimension_SetCustomPlane(self, *args)


    def UnsetCustomPlane(self, *args):
        """
        UnsetCustomPlane(Handle_AIS_LengthDimension self)

        Unsets user-defined plane. Therefore the plane for dimension will be
        computed automatically.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetCustomPlane(self, *args)


    def IsTextPositionCustom(self, *args):
        """
        IsTextPositionCustom(Handle_AIS_LengthDimension self) -> Standard_Boolean

        @return TRUE if text position is set by user with method SetTextPosition().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsTextPositionCustom(self, *args)


    def DimensionAspect(self, *args):
        """
        DimensionAspect(Handle_AIS_LengthDimension self) -> Handle_Prs3d_DimensionAspect

        Gets the dimension aspect from AIS object drawer.
        Dimension aspect contains aspects of line, text and arrows for dimension presentation.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_LengthDimension_DimensionAspect(self, *args)


    def SetDimensionAspect(self, *args):
        """
        SetDimensionAspect(Handle_AIS_LengthDimension self, Handle_Prs3d_DimensionAspect theDimensionAspect)

        Sets new dimension aspect for the interactive object drawer.
        The dimension aspect provides dynamic properties which are generally
        used during computation of dimension presentations.

        :type theDimensionAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_LengthDimension_SetDimensionAspect(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_LengthDimension self) -> AIS_KindOfDimension

        @return the kind of dimension.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_LengthDimension_KindOfDimension(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_LengthDimension self) -> AIS_KindOfInteractive

        @return the kind of interactive.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_LengthDimension_Type(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_LengthDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode theMode.
        The interactive context can have a default mode of representation for
        the set of Interactive Objects. This mode may not be accepted by object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_AcceptDisplayMode(self, *args)


    def DisplaySpecialSymbol(self, *args):
        """
        DisplaySpecialSymbol(Handle_AIS_LengthDimension self) -> AIS_DisplaySpecialSymbol

        @return dimension special symbol display options.

        :rtype: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_LengthDimension_DisplaySpecialSymbol(self, *args)


    def SetDisplaySpecialSymbol(self, *args):
        """
        SetDisplaySpecialSymbol(Handle_AIS_LengthDimension self, AIS_DisplaySpecialSymbol const theDisplaySpecSymbol)

        Specifies whether to display special symbol or not.

        :type theDisplaySpecSymbol: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_LengthDimension_SetDisplaySpecialSymbol(self, *args)


    def SpecialSymbol(self, *args):
        """
        SpecialSymbol(Handle_AIS_LengthDimension self) -> Standard_ExtCharacter

        @return special symbol.

        :rtype: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_LengthDimension_SpecialSymbol(self, *args)


    def SetSpecialSymbol(self, *args):
        """
        SetSpecialSymbol(Handle_AIS_LengthDimension self, Standard_ExtCharacter const theSpecialSymbol)

        Specifies special symbol.

        :type theSpecialSymbol: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_LengthDimension_SetSpecialSymbol(self, *args)


    def UnsetFixedTextPosition(self, *args):
        """
        UnsetFixedTextPosition(Handle_AIS_LengthDimension self)

        Unsets user defined text positioning and enables text positioning
        by other parameters: text alignment, extension size, flyout and custom plane.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetFixedTextPosition(self, *args)


    def SelToleranceForText2d(self, *args):
        """
        SelToleranceForText2d(Handle_AIS_LengthDimension self) -> Standard_Real

        Returns selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        Important! Only for 2d text.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_LengthDimension_SelToleranceForText2d(self, *args)


    def SetSelToleranceForText2d(self, *args):
        """
        SetSelToleranceForText2d(Handle_AIS_LengthDimension self, Standard_Real const theTol)

        Sets selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        to change this tolerance use this method
        Important! Only for 2d text.

        :type theTol: float

        """
        return _AIS.Handle_AIS_LengthDimension_SetSelToleranceForText2d(self, *args)


    def GetFlyout(self, *args):
        """
        GetFlyout(Handle_AIS_LengthDimension self) -> Standard_Real

        @return flyout value for dimension.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_LengthDimension_GetFlyout(self, *args)


    def SetFlyout(self, *args):
        """
        SetFlyout(Handle_AIS_LengthDimension self, Standard_Real const theFlyout)

        Sets flyout value for dimension.

        :type theFlyout: float

        """
        return _AIS.Handle_AIS_LengthDimension_SetFlyout(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Check that the input geometry for dimension is valid and the
        presentation can be successfully computed.
        @return TRUE if dimension geometry is ok.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsValid(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_LengthDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_LengthDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_LengthDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_LengthDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_LengthDimension_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_LengthDimension self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_LengthDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_LengthDimension self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_LengthDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_LengthDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_LengthDimension self)"""
        return _AIS.Handle_AIS_LengthDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_LengthDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_LengthDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_LengthDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_LengthDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_LengthDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_LengthDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_LengthDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_LengthDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_LengthDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_LengthDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_LengthDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_LengthDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_LengthDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_LengthDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_LengthDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_LengthDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_LengthDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_LengthDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_LengthDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_LengthDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_LengthDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_LengthDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_LengthDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_LengthDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_LengthDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_LengthDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_LengthDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_LengthDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_LengthDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_LengthDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_LengthDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_LengthDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_LengthDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_LengthDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_LengthDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_LengthDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_LengthDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_LengthDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_LengthDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_LengthDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_LengthDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_LengthDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_LengthDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_LengthDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_LengthDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_LengthDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_LengthDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_LengthDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_LengthDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_LengthDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_LengthDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_LengthDimension self)
        RecomputePrimitives(Handle_AIS_LengthDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_LengthDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_LengthDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_LengthDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_LengthDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_LengthDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_LengthDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_LengthDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_LengthDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_LengthDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_LengthDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_LengthDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_LengthDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_LengthDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_LengthDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_LengthDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_LengthDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_LengthDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_LengthDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_LengthDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_LengthDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_LengthDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_LengthDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_LengthDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_LengthDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_LengthDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_LengthDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_LengthDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_LengthDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_LengthDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_LengthDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_LengthDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_LengthDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_LengthDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_LengthDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_LengthDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_LengthDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_LengthDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_LengthDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_LengthDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_LengthDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_LengthDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_LengthDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_LengthDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_LengthDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_LengthDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_LengthDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_LengthDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_LengthDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_LengthDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_LengthDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_LengthDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_LengthDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_LengthDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_LengthDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_LengthDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_LengthDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_LengthDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_LengthDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_LengthDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_LengthDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_LengthDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_LengthDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_LengthDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_LengthDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_LengthDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_LengthDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_LengthDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_LengthDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_LengthDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_LengthDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_LengthDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_LengthDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_LengthDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_LengthDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_LengthDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_LengthDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_LengthDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_LengthDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_LengthDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_LengthDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_LengthDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_LengthDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_LengthDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_LengthDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_LengthDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_LengthDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_LengthDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_LengthDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_LengthDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_LengthDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_LengthDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_LengthDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_LengthDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_LengthDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_LengthDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_LengthDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_LengthDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_LengthDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_LengthDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_LengthDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_LengthDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_LengthDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_LengthDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_LengthDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_LengthDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_LengthDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_LengthDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_LengthDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_LengthDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_LengthDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_LengthDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_LengthDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LengthDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_LengthDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_LengthDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_LengthDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_LengthDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_LengthDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_LengthDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LengthDimension_DecrementRefCounter(self, *args)

Handle_AIS_LengthDimension_swigregister = _AIS.Handle_AIS_LengthDimension_swigregister
Handle_AIS_LengthDimension_swigregister(Handle_AIS_LengthDimension)

def Handle_AIS_LengthDimension_DownCast(thing):
    return _AIS.Handle_AIS_LengthDimension_DownCast(thing)
Handle_AIS_LengthDimension_DownCast = _AIS.Handle_AIS_LengthDimension_DownCast

class Handle_AIS_Relation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Relation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Relation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Relation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Relation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Relation self, AIS_Relation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Relation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Relation self, Handle_AIS_Relation theHandle) -> Handle_AIS_Relation
        assign(Handle_AIS_Relation self, AIS_Relation thePtr) -> Handle_AIS_Relation
        assign(Handle_AIS_Relation self, Handle_AIS_Relation theHandle) -> Handle_AIS_Relation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Relation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Relation self) -> AIS_Relation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Relation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Relation self) -> AIS_Relation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Relation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Relation self) -> AIS_Relation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Relation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Relation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Relation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Relation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Relation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Relation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Relation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Relation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Relation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Relation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Relation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Relation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Relation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_Relation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Relation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Relation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_Relation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_Relation_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_IsMovable(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_Relation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_Relation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Relation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_Relation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_Relation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Relation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_Relation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_Relation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_Relation self)"""
        return _AIS.Handle_AIS_Relation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_Relation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_Relation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_Relation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_Relation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Relation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_Relation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_Relation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_Relation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_Relation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Relation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_Relation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_Relation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_Relation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_Relation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Relation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_Relation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_Relation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_Relation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_Relation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_Relation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_Relation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_Relation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_Relation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_Relation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Relation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_Relation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_Relation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_Relation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Relation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Relation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Relation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Relation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Relation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Relation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Relation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Relation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Relation self)"""
        return _AIS.Handle_AIS_Relation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Relation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Relation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Relation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Relation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Relation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Relation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Relation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Relation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Relation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Relation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Relation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Relation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Relation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Relation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Relation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Relation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Relation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Relation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Relation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Relation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Relation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Relation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Relation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Relation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Relation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Relation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Relation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Relation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Relation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Relation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Relation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Relation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Relation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Relation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Relation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Relation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Relation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Relation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Relation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Relation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Relation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Relation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Relation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Relation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Relation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Relation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Relation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Relation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Relation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Relation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Relation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Relation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Relation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Relation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Relation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Relation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Relation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Relation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Relation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Relation self)
        RecomputePrimitives(Handle_AIS_Relation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Relation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Relation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Relation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Relation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Relation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Relation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Relation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Relation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Relation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Relation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Relation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Relation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Relation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Relation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Relation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Relation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Relation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Relation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Relation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Relation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Relation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Relation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Relation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Relation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Relation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Relation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Relation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Relation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Relation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Relation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Relation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Relation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Relation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Relation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Relation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Relation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Relation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Relation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Relation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Relation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Relation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Relation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Relation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Relation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Relation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Relation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Relation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Relation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Relation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Relation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Relation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Relation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Relation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Relation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Relation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Relation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Relation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Relation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Relation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Relation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Relation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Relation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Relation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Relation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Relation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Relation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Relation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Relation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Relation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Relation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Relation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Relation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Relation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Relation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Relation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Relation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Relation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Relation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Relation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Relation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Relation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Relation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Relation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Relation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Relation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Relation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Relation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Relation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Relation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Relation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Relation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Relation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Relation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Relation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Relation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Relation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Relation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Relation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Relation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Relation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Relation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Relation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Relation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Relation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Relation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Relation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Relation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Relation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Relation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Relation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Relation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Relation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Relation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Relation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Relation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Relation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Relation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Relation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Relation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Relation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Relation_DecrementRefCounter(self, *args)

Handle_AIS_Relation_swigregister = _AIS.Handle_AIS_Relation_swigregister
Handle_AIS_Relation_swigregister(Handle_AIS_Relation)

def Handle_AIS_Relation_DownCast(thing):
    return _AIS.Handle_AIS_Relation_DownCast(thing)
Handle_AIS_Relation_DownCast = _AIS.Handle_AIS_Relation_DownCast

class Handle_AIS_SignatureFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_SignatureFilter self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_SignatureFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_SignatureFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_SignatureFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_SignatureFilter self, AIS_SignatureFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_SignatureFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_SignatureFilter self, Handle_AIS_SignatureFilter theHandle) -> Handle_AIS_SignatureFilter
        assign(Handle_AIS_SignatureFilter self, AIS_SignatureFilter thePtr) -> Handle_AIS_SignatureFilter
        assign(Handle_AIS_SignatureFilter self, Handle_AIS_SignatureFilter theHandle) -> Handle_AIS_SignatureFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_SignatureFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_SignatureFilter self) -> AIS_SignatureFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_SignatureFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_SignatureFilter self) -> AIS_SignatureFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_SignatureFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_SignatureFilter self) -> AIS_SignatureFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_SignatureFilter___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_SignatureFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_SignatureFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_SignatureFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_SignatureFilter_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_SignatureFilter

    def IsOk(self, *args):
        """
        IsOk(Handle_AIS_SignatureFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        Returns False if the transient is not an AIS_InteractiveObject.
        Returns False if the signature of InteractiveObject
        is not the same as the stored one in the filter...

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SignatureFilter_IsOk(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_SignatureFilter self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_SignatureFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_SignatureFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_SignatureFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ActsOn(self, *args):
        """
        ActsOn(Handle_AIS_SignatureFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        Returns true in an AIS local context, if this filter
        operates on a type of subshape defined in a filter
        class inheriting this framework.
        This function completes IsOk in an AIS local context.

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SignatureFilter_ActsOn(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_SignatureFilter self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_SignatureFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_SignatureFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_SignatureFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SignatureFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_SignatureFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_SignatureFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SignatureFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_SignatureFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_SignatureFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_SignatureFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SignatureFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_SignatureFilter self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_SignatureFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_SignatureFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SignatureFilter_DecrementRefCounter(self, *args)

Handle_AIS_SignatureFilter_swigregister = _AIS.Handle_AIS_SignatureFilter_swigregister
Handle_AIS_SignatureFilter_swigregister(Handle_AIS_SignatureFilter)

def Handle_AIS_SignatureFilter_DownCast(thing):
    return _AIS.Handle_AIS_SignatureFilter_DownCast(thing)
Handle_AIS_SignatureFilter_DownCast = _AIS.Handle_AIS_SignatureFilter_DownCast

class AIS_EqualRadiusRelation(AIS_Relation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_EqualRadiusRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_EqualRadiusRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_EqualRadiusRelation self, TopoDS_Edge aFirstEdge, TopoDS_Edge aSecondEdge, Handle_Geom_Plane aPlane) -> AIS_EqualRadiusRelation

        Creates equal relation of two arc's radiuses.
        If one of edges is not in the given plane,
        the presentation method projects it onto the plane.

        :type aFirstEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aSecondEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        this = _AIS.new_AIS_EqualRadiusRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_EqualRadiusRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_EqualRadiusRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_EqualRadiusRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_EqualRadiusRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_EqualRadiusRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_EqualRadiusRelation
AIS_EqualRadiusRelation_swigregister = _AIS.AIS_EqualRadiusRelation_swigregister
AIS_EqualRadiusRelation_swigregister(AIS_EqualRadiusRelation)

def AIS_EqualRadiusRelation_get_type_name(*args):
    """
    AIS_EqualRadiusRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_EqualRadiusRelation_get_type_name(*args)

def AIS_EqualRadiusRelation_get_type_descriptor(*args):
    """
    AIS_EqualRadiusRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_EqualRadiusRelation_get_type_descriptor(*args)

class AIS_InteractiveContext(Standard.Standard_Transient):
    """
    The Interactive Context allows you to manage graphic behavior and selection of Interactive Objects in one or more viewers.
    Class methods make this highly transparent.
    It is essential to remember that an Interactive Object which is already known by the Interactive Context must be modified using Context methods.
    You can only directly call the methods available for an Interactive Object if it has not been loaded into an Interactive Context.

    Each selectable object must specify the selection mode that is
    responsible for selection of object as a whole (global selection mode).
    Interactive context itself supports decomposed object selection with selection filters support.
    By default, global selection mode is equal to 0, but it might be redefined if needed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_InteractiveContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_InteractiveContext(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_InteractiveContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_InteractiveContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_InteractiveContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_InteractiveContext self, Handle_V3d_Viewer MainViewer) -> AIS_InteractiveContext

        Constructs the interactive context object defined by the principal viewer MainViewer.

        :type MainViewer: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        this = _AIS.new_AIS_InteractiveContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def DisplayStatus(self, *args):
        """
        DisplayStatus(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj) -> AIS_DisplayStatus

        Returns the display status of the entity anIobj.
        This will be one of the following:
        - AIS_DS_Displayed displayed in main viewer
        - AIS_DS_Erased    hidden in main viewer
        - AIS_DS_Temporary temporarily displayed
        - AIS_DS_None      nowhere displayed.

        :type anIobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.AIS_InteractiveContext_DisplayStatus(self, *args)


    def Status(self, *args):
        """
        Status(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObj, TCollection_ExtendedString astatus)

        Returns the status of the Interactive Context for the view of the Interactive Object.

        :type anObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type astatus: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.AIS_InteractiveContext_Status(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj) -> Standard_Boolean
        IsDisplayed(AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Standard_Integer const aMode) -> Standard_Boolean

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsDisplayed(self, *args)


    def SetAutoActivateSelection(self, *args):
        """
        SetAutoActivateSelection(AIS_InteractiveContext self, Standard_Boolean const theIsAuto)

        Enable or disable automatic activation of default selection mode while displaying the object.

        :type theIsAuto: bool

        """
        return _AIS.AIS_InteractiveContext_SetAutoActivateSelection(self, *args)


    def GetAutoActivateSelection(self, *args):
        """
        GetAutoActivateSelection(AIS_InteractiveContext self) -> Standard_Boolean

        Manages displaying the new object should also automatically activate default selection mode; TRUE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_GetAutoActivateSelection(self, *args)


    def Display(self, *args):
        """
        Display(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)
        Display(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theDispMode, Standard_Integer const theSelectionMode, Standard_Boolean const theToUpdateViewer, Standard_Boolean const theToAllowDecomposition, AIS_DisplayStatus const theDispStatus=AIS_DS_None)

        Sets status, display mode and selection mode for specified Object
        If theSelectionMode equals -1, theIObj will not be activated: it will be displayed but will not be selectable.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theDispMode: int
        :type theSelectionMode: int
        :type theToUpdateViewer: bool
        :type theToAllowDecomposition: bool
        :type theDispStatus: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.AIS_InteractiveContext_Display(self, *args)


    def Load(self, *args):
        """
        Load(AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Standard_Integer const SelectionMode=-1, Standard_Boolean const AllowDecomp)

        Allows you to load the Interactive Object with a given selection mode,
        and/or with the desired decomposition option, whether the object is visualized or not.
        If AllowDecomp = Standard_True and, if the interactive object is of the "Shape" type,
        these "standard" selection modes will be automatically activated as a function of the modes present in the Local Context.
        The loaded objects will be selectable but displayable in highlighting only when detected by the Selector.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type SelectionMode: int
        :type AllowDecomp: bool

        """
        return _AIS.AIS_InteractiveContext_Load(self, *args)


    def Erase(self, *args):
        """
        Erase(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Hides the object. The object's presentations are simply flagged as invisible and therefore excluded from redrawing.
        To show hidden objects, use Display().

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_Erase(self, *args)


    def EraseAll(self, *args):
        """
        EraseAll(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Hides all objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing.
        To show all hidden objects, use DisplayAll().

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_EraseAll(self, *args)


    def DisplayAll(self, *args):
        """
        DisplayAll(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Displays all hidden objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_DisplayAll(self, *args)


    def EraseSelected(self, *args):
        """
        EraseSelected(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Hides selected objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing.
        To show hidden objects, use Display().

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_EraseSelected(self, *args)


    def DisplaySelected(self, *args):
        """
        DisplaySelected(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Displays current objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_DisplaySelected(self, *args)


    def ClearPrs(self, *args):
        """
        ClearPrs(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode, Standard_Boolean const theToUpdateViewer)

        Empties the graphic presentation of the mode indexed by aMode.
        Warning! Removes theIObj. theIObj is still active if it was previously activated.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_ClearPrs(self, *args)


    def Remove(self, *args):
        """
        Remove(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes Object from every viewer.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_Remove(self, *args)


    def RemoveAll(self, *args):
        """
        RemoveAll(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes all the objects from Context.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_RemoveAll(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer, Standard_Boolean const theAllModes)
        Redisplay(AIS_InteractiveContext self, AIS_KindOfInteractive const theTypeOfObject, Standard_Integer const theSignature, Standard_Boolean const theToUpdateViewer)

        Recomputes the Prs/Selection of displayed objects of a given type and a given signature.
        if signature = -1  doesn't take signature criterion.

        :type theTypeOfObject: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type theSignature: int
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_Redisplay(self, *args)


    def RecomputePrsOnly(self, *args):
        """
        RecomputePrsOnly(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer, Standard_Boolean const theAllModes)

        Recomputes the displayed presentations, flags the others.
        Doesn't update presentations.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool
        :type theAllModes: bool

        """
        return _AIS.AIS_InteractiveContext_RecomputePrsOnly(self, *args)


    def RecomputeSelectionOnly(self, *args):
        """
        RecomputeSelectionOnly(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIObj)

        Recomputes the active selections, flags the others.
        Doesn't update presentations.

        :type anIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_RecomputeSelectionOnly(self, *args)


    def Update(self, *args):
        """
        Update(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theUpdateViewer)

        Updates displayed interactive object by checking and recomputing its flagged as "to be recomputed" presentation and selection structures.
        This method does not force any recomputation on its own.
        The method recomputes selections even if they are loaded without activation in particular selector.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_Update(self, *args)


    def SetHighlightStyle(self, *args):
        """
        SetHighlightStyle(AIS_InteractiveContext self, Prs3d_TypeOfHighlight const theStyleType, Handle_Prs3d_Drawer theStyle)
        SetHighlightStyle(AIS_InteractiveContext self, Handle_Prs3d_Drawer theStyle)

        Setup the style of dynamic highlighting.

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.AIS_InteractiveContext_SetHighlightStyle(self, *args)


    def SelectionStyle(self, *args):
        """
        Returns current selection style settings.
        By default:
        - the color of selection is Quantity_NOC_GRAY80;
        - the presentation for selection is completely opaque;
        - the type of highlight is Aspect_TOHM_COLOR.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.AIS_InteractiveContext_SelectionStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSelectionStyle(self, *args):
        """
        SetSelectionStyle(AIS_InteractiveContext self, Handle_Prs3d_Drawer theStyle)

        Setup the style of selection highlighting.

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.AIS_InteractiveContext_SetSelectionStyle(self, *args)


    def HighlightStyle(self, *args):
        """
        Returns current dynamic highlight style settings.
        By default:
        - the color of dynamic highlight is Quantity_NOC_CYAN1;
        - the presentation for dynamic highlight is completely opaque;
        - the type of highlight is Aspect_TOHM_COLOR.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.AIS_InteractiveContext_HighlightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsHilighted(self, *args):
        """
        IsHilighted(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj) -> Standard_Boolean
        IsHilighted(AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwner) -> Standard_Boolean

        Returns true if the owner is marked as selected
        @param theOwner [in] the owner to check

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsHilighted(self, *args)


    def Hilight(self, *args):
        """
        Hilight(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Boolean const theIsToUpdateViewer)

        Updates the display in the viewer to take dynamic detection into account.
        On dynamic detection by the mouse cursor, sensitive primitives are highlighted.
        The highlight color of entities detected by mouse movement is white by default.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theIsToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_Hilight(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Handle_Prs3d_Drawer theStyle, Standard_Boolean const theToUpdateViewer)

        Changes the color of all the lines of the object in view.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes hilighting from the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_Unhilight(self, *args)


    def DisplayPriority(self, *args):
        """
        DisplayPriority(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj) -> Standard_Integer

        Returns the display priority of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_DisplayPriority(self, *args)


    def SetDisplayPriority(self, *args):
        """
        SetDisplayPriority(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const thePriority)

        Sets the display priority of the seen parts presentation of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type thePriority: int

        """
        return _AIS.AIS_InteractiveContext_SetDisplayPriority(self, *args)


    def GetZLayer(self, *args):
        """
        GetZLayer(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj) -> Graphic3d_ZLayerId

        Get Z layer id set for displayed interactive object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.AIS_InteractiveContext_GetZLayer(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Graphic3d_ZLayerId const theLayerId)

        Set Z layer id for interactive object.
        The Z layers can be used to display temporarily presentations of some object in front of the other objects in the scene.
        The ids for Z layers are generated by V3d_Viewer.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.AIS_InteractiveContext_SetZLayer(self, *args)


    def SetViewAffinity(self, *args):
        """
        SetViewAffinity(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Handle_V3d_View theView, Standard_Boolean const theIsVisible)

        Setup object visibility in specified view.
        Has no effect if object is not displayed in this context.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theIsVisible: bool

        """
        return _AIS.AIS_InteractiveContext_SetViewAffinity(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(AIS_InteractiveContext self) -> Standard_Integer

        Returns the Display Mode setting to be used by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_DisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(AIS_InteractiveContext self, Standard_Integer const theMode, Standard_Boolean const theToUpdateViewer)
        SetDisplayMode(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode, Standard_Boolean const theToUpdateViewer)

        Sets the display mode of seen Interactive Objects.
        theMode provides the display mode index of the entity theIObj.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Unsets the display mode of seen Interactive Objects.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnsetDisplayMode(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, TopLoc_Location theLocation)

        Puts the location on the initial graphic representation and the selection for the Object.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.AIS_InteractiveContext_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """
        ResetLocation(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject)

        Puts the Object back into its initial position.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_ResetLocation(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> Standard_Boolean

        Returns true if the Object has a location.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasLocation(self, *args)


    def Location(self, *args):
        """
        Location(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> TopLoc_Location

        Returns the location of the Object.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.AIS_InteractiveContext_Location(self, *args)


    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Graphic3d_TransModeFlags const & theFlag, gp_Pnt thePoint)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theFlag: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_InteractiveContext_SetTransformPersistence(self, *args)


    def SetPixelTolerance(self, *args):
        """
        SetPixelTolerance(AIS_InteractiveContext self, Standard_Integer const thePrecision=2)

        Setup pixel tolerance for MoveTo() operation.
        @sa MoveTo().

        :type thePrecision: int

        """
        return _AIS.AIS_InteractiveContext_SetPixelTolerance(self, *args)


    def PixelTolerance(self, *args):
        """
        PixelTolerance(AIS_InteractiveContext self) -> Standard_Integer

        Returns the pixel tolerance, default is 2.
        Pixel Tolerance extends sensitivity within MoveTo() operation (picking by point)
        and can be adjusted by application based on user input precision (e.g. screen pixel density, input device precision, etc.).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_PixelTolerance(self, *args)


    def SetSelectionSensitivity(self, *args):
        """
        SetSelectionSensitivity(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Standard_Integer const theMode, Standard_Integer const theNewSensitivity)

        Allows to manage sensitivity of a particular selection of interactive object theObject
        and changes previous sensitivity value of all sensitive entities in selection with theMode
        to the given theNewSensitivity.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theNewSensitivity: int

        """
        return _AIS.AIS_InteractiveContext_SetSelectionSensitivity(self, *args)


    def MoveTo(self, *args):
        """
        MoveTo(AIS_InteractiveContext self, Standard_Integer const theXPix, Standard_Integer const theYPix, Handle_V3d_View theView, Standard_Boolean const theToRedrawOnUpdate) -> AIS_StatusOfDetection

        Relays mouse position in pixels theXPix and theYPix to the interactive context selectors.
        This is done by the view theView passing this position to the main viewer and updating it.
        If theToRedrawOnUpdate is set to false, callee should call RedrawImmediate() to highlight detected object.
        @sa PickingStrategy()

        :type theXPix: int
        :type theYPix: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawOnUpdate: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfDetection

        """
        return _AIS.AIS_InteractiveContext_MoveTo(self, *args)


    def ClearDetected(self, *args):
        """
        ClearDetected(AIS_InteractiveContext self, Standard_Boolean theToRedrawImmediate) -> Standard_Boolean

        Clears the list of entities detected by MoveTo() and resets dynamic highlighting.
        @param theToRedrawImmediate if TRUE, the main Viewer will be redrawn on update
        @return TRUE if viewer needs to be updated (e.g. there were actually dynamically highlighted entities)

        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_ClearDetected(self, *args)


    def HasDetected(self, *args):
        """
        HasDetected(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is a mouse-detected entity in context.
        @sa DetectedOwner()/HasNextDetected()/HilightPreviousDetected()/HilightNextDetected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasDetected(self, *args)


    def DetectedOwner(self, *args):
        """
        DetectedOwner(AIS_InteractiveContext self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of the detected sensitive primitive which is currently dynamically highlighted.
        WARNING! This method is irrelevant to InitDetected()/MoreDetected()/NextDetected().
        @sa HasDetected()/HasNextDetected()/HilightPreviousDetected()/HilightNextDetected().

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_InteractiveContext_DetectedOwner(self, *args)


    def DetectedInteractive(self, *args):
        """
        DetectedInteractive(AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Returns the interactive objects last detected in context.
        In general this is just a wrapper for Handle(AIS_InteractiveObject)::DownCast(DetectedOwner()->Selectable()).
        @sa DetectedOwner()

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_DetectedInteractive(self, *args)


    def HasDetectedShape(self, *args):
        """
        HasDetectedShape(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is a detected shape in local context.
        @sa HasDetected()/DetectedShape()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasDetectedShape(self, *args)


    def DetectedShape(self, *args):
        """
        Returns the shape detected in local context.
        @sa DetectedOwner()

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_InteractiveContext_DetectedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasNextDetected(self, *args):
        """
        HasNextDetected(AIS_InteractiveContext self) -> Standard_Boolean

        returns True if other entities were detected in the last mouse detection
        @sa HilightPreviousDetected()/HilightNextDetected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasNextDetected(self, *args)


    def HilightNextDetected(self, *args):
        """
        HilightNextDetected(AIS_InteractiveContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        If more than 1 object is detected by the selector, only the "best" owner is hilighted at the mouse position.
        This Method allows the user to hilight one after another the other detected entities.
        If The method select is called, the selected entity will be the hilighted one!
        WARNING: Loop Method. When all the detected entities have been hilighted, the next call will hilight the first one again.
        @return the Rank of hilighted entity
        @sa HasNextDetected()/HilightPreviousDetected().

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_HilightNextDetected(self, *args)


    def HilightPreviousDetected(self, *args):
        """
        HilightPreviousDetected(AIS_InteractiveContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        Same as previous methods in reverse direction.
        @sa HasNextDetected()/HilightNextDetected().

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_HilightPreviousDetected(self, *args)


    def InitDetected(self, *args):
        """
        InitDetected(AIS_InteractiveContext self)

        Initialization for iteration through mouse-detected objects in
        interactive context or in local context if it is opened.
        @sa DetectedCurrentOwner()/MoreDetected()/NextDetected().


        """
        return _AIS.AIS_InteractiveContext_InitDetected(self, *args)


    def MoreDetected(self, *args):
        """
        MoreDetected(AIS_InteractiveContext self) -> Standard_Boolean

        Return TRUE if there is more mouse-detected objects after the current one
        during iteration through mouse-detected interactive objects.
        @sa DetectedCurrentOwner()/InitDetected()/NextDetected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_MoreDetected(self, *args)


    def NextDetected(self, *args):
        """
        NextDetected(AIS_InteractiveContext self)

        Gets next current object during iteration through mouse-detected interactive objects.
        @sa DetectedCurrentOwner()/InitDetected()/MoreDetected().


        """
        return _AIS.AIS_InteractiveContext_NextDetected(self, *args)


    def DetectedCurrentOwner(self, *args):
        """
        DetectedCurrentOwner(AIS_InteractiveContext self) -> Handle_SelectMgr_EntityOwner

        Returns the owner from detected list pointed by current iterator position.
        WARNING! This method is irrelevant to DetectedOwner() which returns last picked Owner regardless of iterator position!
        @sa InitDetected()/MoreDetected()/NextDetected().

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_InteractiveContext_DetectedCurrentOwner(self, *args)


    def SetSelectedAspect(self, *args):
        """
        SetSelectedAspect(AIS_InteractiveContext self, Handle_Prs3d_BasicAspect theAspect, Standard_Boolean const theToUpdateViewer)

        Sets the graphic basic aspect to the current presentation of ALL selected objects.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetSelectedAspect(self, *args)


    def AddSelect(self, *args):
        """
        AddSelect(AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theObject) -> AIS_StatusOfPick
        AddSelect(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> AIS_StatusOfPick

        Adds object in the selection.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.AIS_InteractiveContext_AddSelect(self, *args)


    def Select(self, *args):
        """
        Select(AIS_InteractiveContext self, Standard_Integer const theXPMin, Standard_Integer const theYPMin, Standard_Integer const theXPMax, Standard_Integer const theYPMax, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        Select(AIS_InteractiveContext self, NCollection_Array1_gp_Pnt2d thePolyline, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        Select(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick

        Stores and hilights the previous detected; Unhilights the previous picked.
        @sa MoveTo().

        :type theToUpdateViewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.AIS_InteractiveContext_Select(self, *args)


    def ShiftSelect(self, *args):
        """
        ShiftSelect(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        ShiftSelect(AIS_InteractiveContext self, NCollection_Array1_gp_Pnt2d thePolyline, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        ShiftSelect(AIS_InteractiveContext self, Standard_Integer const theXPMin, Standard_Integer const theYPMin, Standard_Integer const theXPMax, Standard_Integer const theYPMax, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick

        Rectangle of selection; adds new detected entities into the picked list,
        removes the detected entities that were already stored.

        :type theXPMin: int
        :type theYPMin: int
        :type theXPMax: int
        :type theYPMax: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToUpdateViewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.AIS_InteractiveContext_ShiftSelect(self, *args)


    def FitSelected(self, *args):
        """
        FitSelected(AIS_InteractiveContext self, Handle_V3d_View theView, Standard_Real const theMargin, Standard_Boolean const theToUpdate)
        FitSelected(AIS_InteractiveContext self, Handle_V3d_View theView)

        Fits the view correspondingly to the bounds of selected objects.
        Infinite objects are ignored if infinite state of AIS_InteractiveObject is set to true.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.AIS_InteractiveContext_FitSelected(self, *args)


    def SetToHilightSelected(self, *args):
        """
        SetToHilightSelected(AIS_InteractiveContext self, Standard_Boolean const toHilight)

        Specify whether selected object must be hilighted when mouse cursor is moved above it (in MoveTo method).
        By default this value is false and selected object is not hilighted in this case.

        :type toHilight: bool

        """
        return _AIS.AIS_InteractiveContext_SetToHilightSelected(self, *args)


    def ToHilightSelected(self, *args):
        """
        ToHilightSelected(AIS_InteractiveContext self) -> Standard_Boolean

        Return value specified whether selected object must be hilighted when mouse cursor is moved above it

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_ToHilightSelected(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwners, Standard_Boolean const theToUpdateViewer)
        SetSelected(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const theToUpdateViewer)

        Puts the interactive object aniObj in the list of selected objects.
        Performs selection filters check.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetSelected(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Highlights selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_HilightSelected(self, *args)


    def UnhilightSelected(self, *args):
        """
        UnhilightSelected(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes highlighting from selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnhilightSelected(self, *args)


    def UpdateSelected(self, *args):
        """
        UpdateSelected(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Updates the list of selected objects:
        i.e. highlights the newly selected ones and unhighlights previously selected objects.
        @sa HilightSelected().

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UpdateSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Empties previous selected objects in order to get the selected objects detected by the selector using UpdateSelected.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_ClearSelected(self, *args)


    def AddOrRemoveSelected(self, *args):
        """
        AddOrRemoveSelected(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const theToUpdateViewer)
        AddOrRemoveSelected(AIS_InteractiveContext self, TopoDS_Shape theShape, Standard_Boolean const theToUpdateViewer)
        AddOrRemoveSelected(AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwner, Standard_Boolean const theToUpdateViewer)

        Allows to highlight or unhighlight the owner given depending on its selection status

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_AddOrRemoveSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwner) -> Standard_Boolean
        IsSelected(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj) -> Standard_Boolean

        Returns true is the object given is selected

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsSelected(self, *args)


    def FirstSelectedObject(self, *args):
        """
        FirstSelectedObject(AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Returns the first selected object in the list of current selected.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_FirstSelectedObject(self, *args)


    def NbSelected(self, *args):
        """
        NbSelected(AIS_InteractiveContext self) -> Standard_Integer

        Count a number of selected entities using InitSelected()+MoreSelected()+NextSelected() iterator.
        @sa SelectedOwner()/InitSelected()/MoreSelected()/NextSelected().

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_NbSelected(self, *args)


    def InitSelected(self, *args):
        """
        InitSelected(AIS_InteractiveContext self)

        Initializes a scan of the selected objects.
        @sa SelectedOwner()/MoreSelected()/NextSelected().


        """
        return _AIS.AIS_InteractiveContext_InitSelected(self, *args)


    def MoreSelected(self, *args):
        """
        MoreSelected(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is another object found by the scan of the list of selected objects.
        @sa SelectedOwner()/InitSelected()/NextSelected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_MoreSelected(self, *args)


    def NextSelected(self, *args):
        """
        NextSelected(AIS_InteractiveContext self)

        Continues the scan to the next object in the list of selected objects.
        @sa SelectedOwner()/InitSelected()/MoreSelected().


        """
        return _AIS.AIS_InteractiveContext_NextSelected(self, *args)


    def SelectedOwner(self, *args):
        """
        SelectedOwner(AIS_InteractiveContext self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of the selected entity.
        @sa InitSelected()/MoreSelected()/NextSelected().

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_InteractiveContext_SelectedOwner(self, *args)


    def SelectedInteractive(self, *args):
        """
        SelectedInteractive(AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Return Handle(AIS_InteractiveObject)::DownCast (SelectedOwner()->Selectable()).
        @sa SelectedOwner().

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_SelectedInteractive(self, *args)


    def HasSelectedShape(self, *args):
        """
        HasSelectedShape(AIS_InteractiveContext self) -> Standard_Boolean

        Returns TRUE if the interactive context has a shape selected.
        @sa SelectedShape().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasSelectedShape(self, *args)


    def SelectedShape(self, *args):
        """
        SelectedShape(AIS_InteractiveContext self) -> TopoDS_Shape

        Returns the selected shape.
        Basically it is just a shape returned stored by StdSelect_BRepOwner with graphic transformation being applied:
        @code
        const Handle(StdSelect_BRepOwner) aBRepOwner = Handle(StdSelect_BRepOwner)::DownCast (SelectedOwner());
        TopoDS_Shape aSelShape     = aBRepOwner->Shape();
        TopoDS_Shape aLocatedShape = aSelShape.Located (aBRepOwner->Location() * aSelShape.Location());
        @endcode
        @sa SelectedOwner()/HasSelectedShape().

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_InteractiveContext_SelectedShape(self, *args)


    def HasApplicative(self, *args):
        """
        HasApplicative(AIS_InteractiveContext self) -> Standard_Boolean

        Returns SelectedInteractive()->HasOwner().
        @sa SelectedOwner().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasApplicative(self, *args)


    def Applicative(self, *args):
        """
        Applicative(AIS_InteractiveContext self) -> Handle_Standard_Transient

        Returns SelectedInteractive()->GetOwner().
        @sa SelectedOwner().

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.AIS_InteractiveContext_Applicative(self, *args)


    def BeginImmediateDraw(self, *args):
        """
        BeginImmediateDraw(AIS_InteractiveContext self) -> Standard_Boolean

        initializes the list of presentations to be displayed
        returns False if no local context is opened.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_BeginImmediateDraw(self, *args)


    def ImmediateAdd(self, *args):
        """
        ImmediateAdd(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode=0) -> Standard_Boolean

        returns True if <anIObj> has been stored in the list.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_ImmediateAdd(self, *args)


    def EndImmediateDraw(self, *args):
        """
        EndImmediateDraw(AIS_InteractiveContext self, Handle_V3d_View theView) -> Standard_Boolean
        EndImmediateDraw(AIS_InteractiveContext self) -> Standard_Boolean

        Uses the First Active View of Main Viewer!
        returns True if the immediate display has been done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_EndImmediateDraw(self, *args)


    def IsImmediateModeOn(self, *args):
        """
        IsImmediateModeOn(AIS_InteractiveContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsImmediateModeOn(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(AIS_InteractiveContext self, Handle_V3d_Viewer theViewer)

        Redraws immediate structures in all views of the viewer given taking into account its visibility.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        return _AIS.AIS_InteractiveContext_RedrawImmediate(self, *args)


    def SetSelectionModeActive(self, *args):
        """
        SetSelectionModeActive(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode, Standard_Boolean const theToActivate, AIS_SelectionModesConcurrency const theConcurrency=AIS_SelectionModesConcurrency_Multiple, Standard_Boolean const theIsForce)

        Activates or deactivates the selection mode for specified object.
        Has no effect if selection mode was already active/deactivated.
        @param theObj         object to activate/deactivate selection mode
        @param theMode        selection mode to activate/deactivate;
        deactivation of -1 selection mode will effectively deactivate all selection modes;
        activation of -1 selection mode with AIS_SelectionModesConcurrency_Single
        will deactivate all selection modes, and will has no effect otherwise
        @param theToActivate  activation/deactivation flag
        @param theConcurrency specifies how to handle already activated selection modes;
        default value (AIS_SelectionModesConcurrency_Multiple) means active selection modes should be left as is,
        AIS_SelectionModesConcurrency_Single can be used if only one selection mode is expected to be active
        and AIS_SelectionModesConcurrency_GlobalOrLocal can be used if either AIS_InteractiveObject::GlobalSelectionMode()
        or any combination of Local selection modes is acceptable;
        this value is considered only if theToActivate set to TRUE
        @param theIsForce     when set to TRUE, the display status will be ignored while activating selection mode

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theToActivate: bool
        :type theConcurrency: OCC.wrapper.AIS.AIS_SelectionModesConcurrency
        :type theIsForce: bool

        """
        return _AIS.AIS_InteractiveContext_SetSelectionModeActive(self, *args)


    def Activate(self, *args):
        """
        Activate(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode=0, Standard_Boolean const theIsForce)
        Activate(AIS_InteractiveContext self, Standard_Integer const theMode, Standard_Boolean const theIsForce)

        Activates the given selection mode for the all displayed objects.

        :type theMode: int
        :type theIsForce: bool

        """
        return _AIS.AIS_InteractiveContext_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj)
        Deactivate(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode)
        Deactivate(AIS_InteractiveContext self, Standard_Integer const theMode)
        Deactivate(AIS_InteractiveContext self)

        Deactivates all the activated selection mode at all displayed objects.


        """
        return _AIS.AIS_InteractiveContext_Deactivate(self, *args)


    def ActivatedModes(self, *args):
        """
        ActivatedModes(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj, NCollection_List_Standard_Integer theList)

        Returns the list of activated selection modes.

        :type anIobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theList: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.AIS_InteractiveContext_ActivatedModes(self, *args)


    def EntityOwners(self, *args):
        """
        EntityOwners(AIS_InteractiveContext self, opencascade::handle< SelectMgr_IndexedMapOfOwner > & theOwners, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode=-1)

        Returns a collection containing all entity owners created for the interactive object in specified selection mode (in all active modes if the Mode == -1)

        :type theOwners: OCC.wrapper.AIS.Handle_SelectMgr_IndexedMapOfOwner
        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int

        """
        return _AIS.AIS_InteractiveContext_EntityOwners(self, *args)


    def Filters(self, *args):
        """
        Returns the list of filters active in a local context.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _AIS.AIS_InteractiveContext_Filters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddFilter(self, *args):
        """
        AddFilter(AIS_InteractiveContext self, Handle_SelectMgr_Filter theFilter)

        Allows you to add the filter.

        :type theFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.AIS_InteractiveContext_AddFilter(self, *args)


    def RemoveFilter(self, *args):
        """
        RemoveFilter(AIS_InteractiveContext self, Handle_SelectMgr_Filter theFilter)

        Removes a filter from context.

        :type theFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.AIS_InteractiveContext_RemoveFilter(self, *args)


    def RemoveFilters(self, *args):
        """
        RemoveFilters(AIS_InteractiveContext self)

        Remove all filters from context.


        """
        return _AIS.AIS_InteractiveContext_RemoveFilters(self, *args)


    def PickingStrategy(self, *args):
        """
        PickingStrategy(AIS_InteractiveContext self) -> SelectMgr_PickingStrategy

        Return picking strategy; SelectMgr_PickingStrategy_FirstAcceptable by default.
        @sa MoveTo()/Filters()

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_PickingStrategy

        """
        return _AIS.AIS_InteractiveContext_PickingStrategy(self, *args)


    def SetPickingStrategy(self, *args):
        """
        SetPickingStrategy(AIS_InteractiveContext self, SelectMgr_PickingStrategy const theStrategy)

        Setup picking strategy - which entities detected by picking line will be accepted, considering Selection Filters.
        By default (SelectMgr_PickingStrategy_FirstAcceptable), Selection Filters reduce the list of entities
        so that the context accepts topmost in remaining.

        This means that entities behind non-selectable (by filters) parts can be picked by user.
        If this behavior is undesirable, and user wants that non-selectable (by filters) parts
        should remain an obstacle for picking, SelectMgr_PickingStrategy_OnlyTopmost can be set instead.

        Notice, that since Selection Manager operates only objects registered in it,
        SelectMgr_PickingStrategy_OnlyTopmost will NOT prevent picking entities behind
        visible by unregistered in Selection Manager presentations (e.g. deactivated).
        Hence, SelectMgr_PickingStrategy_OnlyTopmost changes behavior only with Selection Filters enabled.

        :type theStrategy: OCC.wrapper.SelectMgr.SelectMgr_PickingStrategy

        """
        return _AIS.AIS_InteractiveContext_SetPickingStrategy(self, *args)


    def DefaultDrawer(self, *args):
        """
        Returns the default attribute manager.
        This contains all the color and line attributes which can be used by interactive objects which do not have their own attributes.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.AIS_InteractiveContext_DefaultDrawer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentViewer(self, *args):
        """
        Returns the current viewer.

        :rtype: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        res = _AIS.AIS_InteractiveContext_CurrentViewer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SelectionManager(self, *args):
        """
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectionManager

        """
        res = _AIS.AIS_InteractiveContext_SelectionManager(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MainPrsMgr(self, *args):
        """
        :rtype: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d

        """
        res = _AIS.AIS_InteractiveContext_MainPrsMgr(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MainSelector(self, *args):
        """
        :rtype: OCC.wrapper.StdSelect.Handle_StdSelect_ViewerSelector3d

        """
        res = _AIS.AIS_InteractiveContext_MainSelector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateCurrentViewer(self, *args):
        """
        UpdateCurrentViewer(AIS_InteractiveContext self)

        Updates the current viewer.


        """
        return _AIS.AIS_InteractiveContext_UpdateCurrentViewer(self, *args)


    def DisplayedObjects(self, *args):
        """
        DisplayedObjects(AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject aListOfIO, Standard_Boolean const OnlyFromNeutral)
        DisplayedObjects(AIS_InteractiveContext self, AIS_KindOfInteractive const WhichKind, Standard_Integer const WhichSignature, NCollection_List_Handle_AIS_InteractiveObject aListOfIO, Standard_Boolean const OnlyFromNeutral)

        gives the list of displayed objects of a particular Type and signature.
        by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int
        :type aListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive
        :type OnlyFromNeutral: bool

        """
        return _AIS.AIS_InteractiveContext_DisplayedObjects(self, *args)


    def ErasedObjects(self, *args):
        """
        ErasedObjects(AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)
        ErasedObjects(AIS_InteractiveContext self, AIS_KindOfInteractive const WhichKind, Standard_Integer const WhichSignature, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)

        gives the list of erased objects (hidden objects)
        Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int
        :type theListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive

        """
        return _AIS.AIS_InteractiveContext_ErasedObjects(self, *args)


    def ObjectsByDisplayStatus(self, *args):
        """
        ObjectsByDisplayStatus(AIS_InteractiveContext self, AIS_DisplayStatus const theStatus, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)
        ObjectsByDisplayStatus(AIS_InteractiveContext self, AIS_KindOfInteractive const WhichKind, Standard_Integer const WhichSignature, AIS_DisplayStatus const theStatus, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)

        gives the list of objects with indicated display status
        Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int
        :type theStatus: OCC.wrapper.AIS.AIS_DisplayStatus
        :type theListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive

        """
        return _AIS.AIS_InteractiveContext_ObjectsByDisplayStatus(self, *args)


    def ObjectsInside(self, *args):
        """
        ObjectsInside(AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject aListOfIO, AIS_KindOfInteractive const WhichKind=AIS_KOI_None, Standard_Integer const WhichSignature=-1)

        fills <aListOfIO> with objects of a particular Type and Signature with no consideration of display status.
        by Default, <WhichSignature> = -1 means control only on <WhichKind>.
        if <WhichKind> = AIS_KOI_None and <WhichSignature> = -1, all the objects are put into the list.

        :type aListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive
        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int

        """
        return _AIS.AIS_InteractiveContext_ObjectsInside(self, *args)


    def RebuildSelectionStructs(self, *args):
        """
        RebuildSelectionStructs(AIS_InteractiveContext self)

        Rebuilds 1st level of BVH selection forcibly


        """
        return _AIS.AIS_InteractiveContext_RebuildSelectionStructs(self, *args)


    def Disconnect(self, *args):
        """
        Disconnect(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theAssembly, Handle_AIS_InteractiveObject theObjToDisconnect=0)

        Disconnects theObjToDisconnect from theAssembly and removes dependent selection structures

        :type theAssembly: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theObjToDisconnect: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_Disconnect(self, *args)


    def ObjectsForView(self, *args):
        """
        ObjectsForView(AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject theListOfIO, Handle_V3d_View theView, Standard_Boolean const theIsVisibleInView, AIS_DisplayStatus const theStatus=AIS_DS_None)

        Query objects visible or hidden in specified view due to affinity mask.

        :type theListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theIsVisibleInView: bool
        :type theStatus: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.AIS_InteractiveContext_ObjectsForView(self, *args)


    def PurgeDisplay(self, *args):
        """
        PurgeDisplay(AIS_InteractiveContext self) -> Standard_Integer

        Clears all the structures which don't belong to objects displayed at neutral point
        only effective when no Local Context is opened...
        returns the number of removed  structures from the viewers.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_PurgeDisplay(self, *args)


    def ClearActiveSensitive(self, *args):
        """
        ClearActiveSensitive(AIS_InteractiveContext self, Handle_V3d_View aView)

        Clear visualization of sensitives.

        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.AIS_InteractiveContext_ClearActiveSensitive(self, *args)


    def DisplayActiveSensitive(self, *args):
        """
        DisplayActiveSensitive(AIS_InteractiveContext self, Handle_V3d_View aView)
        DisplayActiveSensitive(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObject, Handle_V3d_View aView)

        Visualization of sensitives - for debugging purposes!

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.AIS_InteractiveContext_DisplayActiveSensitive(self, *args)


    def SetLocalAttributes(self, *args):
        """
        SetLocalAttributes(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theToUpdateViewer)

        Sets the graphic attributes of the interactive object, such as visualization mode, color, and material.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetLocalAttributes(self, *args)


    def UnsetLocalAttributes(self, *args):
        """
        UnsetLocalAttributes(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the settings for local attributes of the Object and returns to defaults.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnsetLocalAttributes(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for SetColor(), SetTransparency(), SetMaterial() methods default facing model is Aspect_TOFM_TWO_SIDE.
        This mean that attributes is applying both on the front and back face.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.AIS_InteractiveContext_SetCurrentFacingModel(self, *args)


    def HasColor(self, *args):
        """
        HasColor(AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj) -> Standard_Boolean

        Returns true if a view of the Interactive Object has color.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Quantity_Color acolor)

        Returns the color of the Object in the interactive context.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type acolor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_InteractiveContext_Color(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Quantity_Color theColor, Standard_Boolean const theToUpdateViewer)

        Sets the color of the selected entity.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the color selection for the selected entity.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnsetColor(self, *args)


    def Width(self, *args):
        """
        Width(AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj) -> Standard_Real

        Returns the width of the Interactive Object in the interactive context.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveContext_Width(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theValue, Standard_Boolean const theToUpdateViewer)

        Sets the width of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theValue: float
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the width setting of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnsetWidth(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Graphic3d_MaterialAspect theMaterial, Standard_Boolean const theToUpdateViewer)

        Provides the type of material setting for the view of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMaterial: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the type of material setting for viewing the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theValue, Standard_Boolean const theToUpdateViewer)

        Provides the transparency settings for viewing the Object.
        The transparency value aValue may be between 0.0, opaque, and 1.0, fully transparent.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theValue: float
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the transparency settings for viewing the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnsetTransparency(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode, Standard_ShortReal const theFactor, Standard_ShortReal const theUnits, Standard_Boolean const theToUpdateViewer)

        Sets up polygon offsets for the given AIS_InteractiveObject.
        It simply calls AIS_InteractiveObject::SetPolygonOffsets().

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theFactor: float
        :type theUnits: float
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObj) -> Standard_Boolean

        Simply calls AIS_InteractiveObject::HasPolygonOffsets().

        :type anObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObj)

        Retrieves current polygon offsets settings for Object.

        :type anObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.AIS_InteractiveContext_PolygonOffsets(self, *args)


    def SetTrihedronSize(self, *args):
        """
        SetTrihedronSize(AIS_InteractiveContext self, Standard_Real const theSize, Standard_Boolean const theToUpdateViewer)

        Sets the size aSize of the trihedron.
        Is used to change the default value 100 mm for display of trihedra.
        Use of this function in one of your own interactive objects requires a call to the Compute function of the new class.
        This will recalculate the presentation for every trihedron displayed.

        :type theSize: float
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetTrihedronSize(self, *args)


    def TrihedronSize(self, *args):
        """
        TrihedronSize(AIS_InteractiveContext self) -> Standard_Real

        returns the current value of trihedron size.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveContext_TrihedronSize(self, *args)


    def SetPlaneSize(self, *args):
        """
        SetPlaneSize(AIS_InteractiveContext self, Standard_Real const theSizeX, Standard_Real const theSizeY, Standard_Boolean const theToUpdateViewer)
        SetPlaneSize(AIS_InteractiveContext self, Standard_Real const theSize, Standard_Boolean const theToUpdateViewer)

        Sets the plane size aSize.

        :type theSize: float
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetPlaneSize(self, *args)


    def PlaneSize(self, *args):
        """
        PlaneSize(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if the length in the X direction XSize is the same as that in the Y direction YSize.

        :type XSize: float
        :type YSize: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_PlaneSize(self, *args)


    def SetAngleAndDeviation(self, *args):
        """
        SetAngleAndDeviation(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)

        Calls the AIS_Shape SetAngleAndDeviation to set both Angle and Deviation coefficients

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theAngle: float
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetAngleAndDeviation(self, *args)


    def SetHLRDeviationAngle(self, *args):
        """
        SetHLRDeviationAngle(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theAngle: float
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetHLRDeviationAngle(self, *args)


    def SetDeviationCoefficient(self, *args):
        """
        SetDeviationCoefficient(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theCoefficient, Standard_Boolean const theToUpdateViewer)
        SetDeviationCoefficient(AIS_InteractiveContext self, Standard_Real const theCoefficient)

        Sets the deviation coefficient theCoefficient.
        Drawings of curves or patches are made with respect to a maximal chordal deviation.
        A Deviation coefficient is used in the shading display mode.
        The shape is seen decomposed into triangles.
        These are used to calculate reflection of light from the surface of the object.
        The triangles are formed from chords of the curves in the shape.
        The deviation coefficient theCoefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve.
        If this limit is reached, a new triangle is begun.
        This deviation is absolute and is set through the method: SetMaximalChordialDeviation.
        The default value is 0.001.
        In drawing shapes, however, you are allowed to ask for a relative deviation.
        This deviation will be: SizeOfObject * DeviationCoefficient.

        :type theCoefficient: float

        """
        return _AIS.AIS_InteractiveContext_SetDeviationCoefficient(self, *args)


    def DeviationCoefficient(self, *args):
        """
        DeviationCoefficient(AIS_InteractiveContext self) -> Standard_Real

        Returns the deviation coefficient.
        Drawings of curves or patches are made with respect to a maximal chordal deviation.
        A Deviation coefficient is used in the shading display mode.
        The shape is seen decomposed into triangles.
        These are used to calculate reflection of light from the surface of the object.
        The triangles are formed from chords of the curves in the shape.
        The deviation coefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve.
        If this limit is reached, a new triangle is begun.
        This deviation is absolute and is set through Prs3d_Drawer::SetMaximalChordialDeviation.
        The default value is 0.001.
        In drawing shapes, however, you are allowed to ask for a relative deviation.
        This deviation will be: SizeOfObject * DeviationCoefficient.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveContext_DeviationCoefficient(self, *args)


    def SetDeviationAngle(self, *args):
        """
        SetDeviationAngle(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)
        SetDeviationAngle(AIS_InteractiveContext self, Standard_Real const anAngle)

        default 12 degrees

        :type anAngle: float

        """
        return _AIS.AIS_InteractiveContext_SetDeviationAngle(self, *args)


    def DeviationAngle(self, *args):
        """
        DeviationAngle(AIS_InteractiveContext self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveContext_DeviationAngle(self, *args)


    def SetHLRDeviationCoefficient(self, *args):
        """
        SetHLRDeviationCoefficient(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theCoefficient, Standard_Boolean const theToUpdateViewer)
        SetHLRDeviationCoefficient(AIS_InteractiveContext self, Standard_Real const aCoefficient)

        Sets the deviation coefficient aCoefficient for removal of hidden lines created by different viewpoints in different presentations.
        The Default value is 0.02.

        :type aCoefficient: float

        """
        return _AIS.AIS_InteractiveContext_SetHLRDeviationCoefficient(self, *args)


    def HLRDeviationCoefficient(self, *args):
        """
        HLRDeviationCoefficient(AIS_InteractiveContext self) -> Standard_Real

        Returns the real number value of the hidden line removal deviation coefficient.
        A Deviation coefficient is used in the shading display mode.
        The shape is seen decomposed into triangles.
        These are used to calculate reflection of light from the surface of the object.
        The triangles are formed from chords of the curves in the shape.
        The deviation coefficient give the highest value of the angle with which a chord can deviate from a tangent to a curve.
        If this limit is reached, a new triangle is begun.
        To find the hidden lines, hidden line display mode entails recalculation of the view at each different projector perspective.
        Because hidden lines entail calculations of more than usual complexity to decompose them into these triangles,
        a deviation coefficient allowing greater tolerance is used.
        This increases efficiency in calculation.
        The Default value is 0.02.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveContext_HLRDeviationCoefficient(self, *args)


    def SetHLRAngle(self, *args):
        """
        SetHLRAngle(AIS_InteractiveContext self, Standard_Real const theAngle)

        Sets the HLR angle.

        :type theAngle: float

        """
        return _AIS.AIS_InteractiveContext_SetHLRAngle(self, *args)


    def HLRAngle(self, *args):
        """
        HLRAngle(AIS_InteractiveContext self) -> Standard_Real

        Returns the real number value of the deviation angle in hidden line removal views in this interactive context.
        The default value is 20*PI/180.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_InteractiveContext_HLRAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args):
        """
        SetHLRAngleAndDeviation(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)
        SetHLRAngleAndDeviation(AIS_InteractiveContext self, Standard_Real const theAngle)

        compute with theAngle a HLRAngle and a HLRDeviationCoefficient
        and set them in myHLRAngle and in myHLRDeviationCoefficient of myDefaultDrawer;
        theAngle is in radian; ( 1 deg < angle in deg < 20 deg)

        :type theAngle: float

        """
        return _AIS.AIS_InteractiveContext_SetHLRAngleAndDeviation(self, *args)


    def HiddenLineAspect(self, *args):
        """
        HiddenLineAspect(AIS_InteractiveContext self) -> Handle_Prs3d_LineAspect

        Initializes hidden line aspect in the default drawing tool, or Drawer.
        The default values are:
        Color: Quantity_NOC_YELLOW
        Type of line: Aspect_TOL_DASH
        Width: 1.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.AIS_InteractiveContext_HiddenLineAspect(self, *args)


    def SetHiddenLineAspect(self, *args):
        """
        SetHiddenLineAspect(AIS_InteractiveContext self, Handle_Prs3d_LineAspect anAspect)

        Sets the hidden line aspect anAspect.
        Aspect defines display attributes for hidden lines in HLR projections.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.AIS_InteractiveContext_SetHiddenLineAspect(self, *args)


    def DrawHiddenLine(self, *args):
        """
        DrawHiddenLine(AIS_InteractiveContext self) -> Standard_Boolean

        returns Standard_True if the hidden lines are to be drawn.
        By default the hidden lines are not drawn.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_DrawHiddenLine(self, *args)


    def EnableDrawHiddenLine(self, *args):
        """EnableDrawHiddenLine(AIS_InteractiveContext self)"""
        return _AIS.AIS_InteractiveContext_EnableDrawHiddenLine(self, *args)


    def DisableDrawHiddenLine(self, *args):
        """DisableDrawHiddenLine(AIS_InteractiveContext self)"""
        return _AIS.AIS_InteractiveContext_DisableDrawHiddenLine(self, *args)


    def SetIsoNumber(self, *args):
        """
        SetIsoNumber(AIS_InteractiveContext self, Standard_Integer const NbIsos, AIS_TypeOfIso const WhichIsos=AIS_TOI_Both)

        Sets the number of U and V isoparameters displayed.

        :type NbIsos: int
        :type WhichIsos: OCC.wrapper.AIS.AIS_TypeOfIso

        """
        return _AIS.AIS_InteractiveContext_SetIsoNumber(self, *args)


    def IsoNumber(self, *args):
        """
        IsoNumber(AIS_InteractiveContext self, AIS_TypeOfIso const WhichIsos=AIS_TOI_Both) -> Standard_Integer

        Returns the number of U and V isoparameters displayed.

        :type WhichIsos: OCC.wrapper.AIS.AIS_TypeOfIso
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_IsoNumber(self, *args)


    def IsoOnPlane(self, *args):
        """
        IsoOnPlane(AIS_InteractiveContext self, Standard_Boolean const SwitchOn)
        IsoOnPlane(AIS_InteractiveContext self) -> Standard_Boolean

        Returns True if drawing isoparameters on planes is enabled.
        if <forUIsos> = False,

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsoOnPlane(self, *args)


    def IsoOnTriangulation(self, *args):
        """
        IsoOnTriangulation(AIS_InteractiveContext self, Standard_Boolean const theIsEnabled, Handle_AIS_InteractiveObject theObject)
        IsoOnTriangulation(AIS_InteractiveContext self, Standard_Boolean const theToSwitchOn)
        IsoOnTriangulation(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if drawing isolines on triangulation algorithm is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsoOnTriangulation(self, *args)


    def HasOpenedContext(self, *args):
        """
        HasOpenedContext(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is an open context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_HasOpenedContext(self, *args)


    def HighestIndex(self, *args):
        """
        HighestIndex(AIS_InteractiveContext self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_HighestIndex(self, *args)


    def LocalContext(self, *args):
        """
        LocalContext(AIS_InteractiveContext self) -> Handle_AIS_LocalContext

        For advanced usage! You should use other (non-internal) methods of class AIS_InteractiveContext without trying to obtain an instance of AIS_LocalContext.

        :rtype: OCC.wrapper.AIS.Handle_AIS_LocalContext

        """
        return _AIS.AIS_InteractiveContext_LocalContext(self, *args)


    def LocalSelector(self, *args):
        """
        LocalSelector(AIS_InteractiveContext self) -> Handle_StdSelect_ViewerSelector3d

        :rtype: OCC.wrapper.StdSelect.Handle_StdSelect_ViewerSelector3d

        """
        return _AIS.AIS_InteractiveContext_LocalSelector(self, *args)


    def OpenLocalContext(self, *args):
        """
        OpenLocalContext(AIS_InteractiveContext self, Standard_Boolean const UseDisplayedObjects, Standard_Boolean const AllowShapeDecomposition, Standard_Boolean const AcceptEraseOfObjects, Standard_Boolean const BothViewers) -> Standard_Integer

        Opens local contexts and specifies how this is to be done.
        The options listed above function in the following manner:
        - UseDisplayedObjects - allows you to load or not load the interactive objects visualized at Neutral Point in the local context which you open.
        If false, the local context is empty after being opened. If true, the objects at Neutral Point are loaded by their default selection mode.
        - AllowShapeDecomposition - AIS_Shape allows or prevents decomposition in standard shape location mode of objects at Neutral Point which are type-"privileged".
        This Flag is only taken into account when UseDisplayedObjects is true.
        - AcceptEraseOfObjects - authorises other local contexts to erase the interactive objects present in this context. This option is rarely used.
        - BothViewers - Has no use currently defined.
        This method returns the index of the created local context.
        It should be kept and used to close the context.
        Opening a local context allows you to prepare an environment for temporary presentations and selections which will disappear once the local context is closed.
        You can open several local contexts, but only the last one will be active.

        :type UseDisplayedObjects: bool
        :type AllowShapeDecomposition: bool
        :type AcceptEraseOfObjects: bool
        :type BothViewers: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_OpenLocalContext(self, *args)


    def CloseLocalContext(self, *args):
        """
        CloseLocalContext(AIS_InteractiveContext self, Standard_Integer const theIndex=-1, Standard_Boolean const theToUpdateViewer)

        Allows you to close local contexts. For greater security, you should close the context with the index Index given on opening.
        When you close a local context, the one before, which is still on the stack, reactivates.
        If none is left, you return to Neutral Point.
        If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode;
        the object is displayed but no viewer will be updated.
        Warning
        When the index isn't specified, the current context is closed.
        This option can be dangerous, as other Interactive Functions can open local contexts without necessarily warning the user.

        :type theIndex: int
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_CloseLocalContext(self, *args)


    def IndexOfCurrentLocal(self, *args):
        """
        IndexOfCurrentLocal(AIS_InteractiveContext self) -> Standard_Integer

        returns -1 if no opened local context.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_IndexOfCurrentLocal(self, *args)


    def CloseAllContexts(self, *args):
        """
        CloseAllContexts(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Allows you to close all local contexts at one go and return to Neutral Point.
        If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode;
        the object is displayed but no viewer will be updated.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_CloseAllContexts(self, *args)


    def ResetOriginalState(self, *args):
        """
        ResetOriginalState(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        to be used only with no opened local context..
        displays and activates objects in their original state before local contexts were opened...

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_ResetOriginalState(self, *args)


    def ClearLocalContext(self, *args):
        """
        ClearLocalContext(AIS_InteractiveContext self, AIS_ClearMode const TheMode=AIS_CM_All)

        clears Objects/Filters/Activated Modes list in the current opened local context.

        :type TheMode: OCC.wrapper.AIS.AIS_ClearMode

        """
        return _AIS.AIS_InteractiveContext_ClearLocalContext(self, *args)


    def UseDisplayedObjects(self, *args):
        """UseDisplayedObjects(AIS_InteractiveContext self)"""
        return _AIS.AIS_InteractiveContext_UseDisplayedObjects(self, *args)


    def NotUseDisplayedObjects(self, *args):
        """
        NotUseDisplayedObjects(AIS_InteractiveContext self)

        when a local Context is opened, one is able to use/not use the displayed objects at neutral point at anytime.


        """
        return _AIS.AIS_InteractiveContext_NotUseDisplayedObjects(self, *args)


    def SetShapeDecomposition(self, *args):
        """
        SetShapeDecomposition(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj, Standard_Boolean const aStatus)

        to be Used only with opened local context and
        if <anIobj> is of type shape...
        if <aStatus> = True <anIobj> will be sensitive to
        shape selection modes activation.
        = False, <anIobj> will not be sensitive any more.

        :type anIobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aStatus: bool

        """
        return _AIS.AIS_InteractiveContext_SetShapeDecomposition(self, *args)


    def SetTemporaryAttributes(self, *args):
        """
        SetTemporaryAttributes(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theToUpdateViewer)

        Sets the temporary graphic attributes of the entity anObj.
        These are provided by the attribute manager aDrawer and are valid for a particular local context only.
        If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode;
        the object is displayed but no viewer will be updated.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetTemporaryAttributes(self, *args)


    def ActivateStandardMode(self, *args):
        """
        ActivateStandardMode(AIS_InteractiveContext self, TopAbs_ShapeEnum const aStandardActivation)

        Provides an alternative to the Display methods when activating specific selection modes.
        This has the effect of activating the corresponding selection mode aStandardActivation for all objects
        in Local Context which accept decomposition into sub-shapes.
        Every new Object which has been loaded into the interactive context and which answers these decomposition criteria
        is automatically activated according to these modes.
        Warning
        If you have opened a local context by loading an object with the default options (<AllowShapeDecomposition >= Standard_True),
        all objects of the "Shape" type are also activated with the same modes.
        You can act on the state of these "Standard" objects by using SetShapeDecomposition(Status).

        :type aStandardActivation: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.AIS_InteractiveContext_ActivateStandardMode(self, *args)


    def DeactivateStandardMode(self, *args):
        """
        DeactivateStandardMode(AIS_InteractiveContext self, TopAbs_ShapeEnum const aStandardActivation)

        Provides an alternative to the Display methods when deactivating specific selection modes.
        This has the effect of deactivating the corresponding selection mode aStandardActivation for all objects
        in Local Context which accept decomposition into sub-shapes.

        :type aStandardActivation: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.AIS_InteractiveContext_DeactivateStandardMode(self, *args)


    def ActivatedStandardModes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.AIS_InteractiveContext_ActivatedStandardModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInLocal(self, *args):
        """
        IsInLocal(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean

        returns if possible, the first local context where the object is seen

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type TheIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsInLocal(self, *args)


    def SetAutomaticHilight(self, *args):
        """
        SetAutomaticHilight(AIS_InteractiveContext self, Standard_Boolean const aStatus)

        Sets the highlighting status aStatus of detected and selected entities.
        Whether you are in Neutral Point or local context, this is automatically managed by the Interactive Context.
        This function allows you to disconnect the automatic mode.

        :type aStatus: bool

        """
        return _AIS.AIS_InteractiveContext_SetAutomaticHilight(self, *args)


    def AutomaticHilight(self, *args):
        """
        AutomaticHilight(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if the automatic highlight mode is active in an open context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_AutomaticHilight(self, *args)


    def KeepTemporary(self, *args):
        """
        KeepTemporary(AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIObj, Standard_Integer const InWhichLocal=-1) -> Standard_Boolean

        Changes the status of a temporary object.
        It will be kept at the neutral point, i.e. put in the list of displayed objects along with its temporary attributes.
        These include display mode and selection mode, for example.
        Returns true if done.
        inWhichLocal gives the local context in which anIObj is displayed.
        By default, the index -1 refers to the last Local Context opened.

        :type anIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type InWhichLocal: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_KeepTemporary(self, *args)


    def SetCurrentObject(self, *args):
        """
        SetCurrentObject(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Updates the view of the current object in open context.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SetCurrentObject(self, *args)


    def AddOrRemoveCurrentObject(self, *args):
        """
        AddOrRemoveCurrentObject(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Boolean const theIsToUpdateViewer)

        Allows to add or remove the object given to the list of current and highlight/unhighlight it correspondingly.
        Is valid for global context only; for local context use method AddOrRemoveSelected.
        Since this method makes sence only for neutral point selection of a whole object,
        if 0 selection of the object is empty this method simply does nothing.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theIsToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_AddOrRemoveCurrentObject(self, *args)


    def UpdateCurrent(self, *args):
        """
        UpdateCurrent(AIS_InteractiveContext self)

        Updates the list of current objects, i.e. hilights new current objects, removes hilighting from former current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.


        """
        return _AIS.AIS_InteractiveContext_UpdateCurrent(self, *args)


    def IsCurrent(self, *args):
        """
        IsCurrent(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> Standard_Boolean

        Returns true if there is a non-null interactive object in Neutral Point.
        Objects selected when there is no open local context are called current objects;
        those selected in open local context, selected objects.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_IsCurrent(self, *args)


    def InitCurrent(self, *args):
        """
        InitCurrent(AIS_InteractiveContext self)

        Initializes a scan of the current selected objects in Neutral Point.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.


        """
        return _AIS.AIS_InteractiveContext_InitCurrent(self, *args)


    def MoreCurrent(self, *args):
        """
        MoreCurrent(AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is another object found by the scan of the list of current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_InteractiveContext_MoreCurrent(self, *args)


    def NextCurrent(self, *args):
        """
        NextCurrent(AIS_InteractiveContext self)

        Continues the scan to the next object in the list of current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.


        """
        return _AIS.AIS_InteractiveContext_NextCurrent(self, *args)


    def Current(self, *args):
        """
        Current(AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Returns the current interactive object.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_Current(self, *args)


    def NbCurrents(self, *args):
        """
        NbCurrents(AIS_InteractiveContext self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_InteractiveContext_NbCurrents(self, *args)


    def HilightCurrents(self, *args):
        """
        HilightCurrents(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Highlights current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_HilightCurrents(self, *args)


    def UnhilightCurrents(self, *args):
        """
        UnhilightCurrents(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes highlighting from current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_UnhilightCurrents(self, *args)


    def ClearCurrents(self, *args):
        """
        ClearCurrents(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Empties previous current objects in order to get the current objects detected by the selector using UpdateCurrent.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_ClearCurrents(self, *args)


    def DetectedCurrentShape(self, *args):
        """
        @return current mouse-detected shape or empty (null) shape, if current interactive object
        is not a shape (AIS_Shape) or there is no current mouse-detected interactive object at all.
        @sa DetectedCurrentOwner()/InitDetected()/MoreDetected()/NextDetected().

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_InteractiveContext_DetectedCurrentShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DetectedCurrentObject(self, *args):
        """
        DetectedCurrentObject(AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        @return current mouse-detected interactive object or null object, if there is no currently detected interactives
        @sa DetectedCurrentOwner()/InitDetected()/MoreDetected()/NextDetected().

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_InteractiveContext_DetectedCurrentObject(self, *args)


    def SubIntensityColor(self, *args):
        """
        Sub-intensity allows temporary highlighting of particular objects with specified color in a manner of selection highlight,
        but without actual selection (e.g., global status and owner's selection state will not be updated).
        The method returns the color of such highlighting.
        By default, it is Quantity_NOC_GRAY40.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _AIS.AIS_InteractiveContext_SubIntensityColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSubIntensityColor(self, *args):
        """
        SetSubIntensityColor(AIS_InteractiveContext self, Quantity_Color theColor)

        Sub-intensity allows temporary highlighting of particular objects with specified color in a manner of selection highlight,
        but without actual selection (e.g., global status and owner's selection state will not be updated).
        The method sets up the color for such highlighting.
        By default, this is Quantity_NOC_GRAY40.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_InteractiveContext_SetSubIntensityColor(self, *args)


    def SubIntensityOn(self, *args):
        """
        SubIntensityOn(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)
        SubIntensityOn(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        hilights/unhilights displayed objects which are displayed at neutral state with subintensity color.
        Available only for active local context.
        No effect if no local context.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """
        SubIntensityOff(AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)
        SubIntensityOff(AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes subintensity option for all objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.AIS_InteractiveContext_SubIntensityOff(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_InteractiveContext
AIS_InteractiveContext_swigregister = _AIS.AIS_InteractiveContext_swigregister
AIS_InteractiveContext_swigregister(AIS_InteractiveContext)

def AIS_InteractiveContext_get_type_name(*args):
    """
    AIS_InteractiveContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_InteractiveContext_get_type_name(*args)

def AIS_InteractiveContext_get_type_descriptor(*args):
    """
    AIS_InteractiveContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_InteractiveContext_get_type_descriptor(*args)

class Handle_AIS_MinRadiusDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_MinRadiusDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_MinRadiusDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_MinRadiusDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_MinRadiusDimension self, AIS_MinRadiusDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_MinRadiusDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_MinRadiusDimension self, Handle_AIS_MinRadiusDimension theHandle) -> Handle_AIS_MinRadiusDimension
        assign(Handle_AIS_MinRadiusDimension self, AIS_MinRadiusDimension thePtr) -> Handle_AIS_MinRadiusDimension
        assign(Handle_AIS_MinRadiusDimension self, Handle_AIS_MinRadiusDimension theHandle) -> Handle_AIS_MinRadiusDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_MinRadiusDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_MinRadiusDimension self) -> AIS_MinRadiusDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_MinRadiusDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_MinRadiusDimension self) -> AIS_MinRadiusDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_MinRadiusDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_MinRadiusDimension self) -> AIS_MinRadiusDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_MinRadiusDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_MinRadiusDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_MinRadiusDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_MinRadiusDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_MinRadiusDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_MinRadiusDimension

    def Compute(self, *args):
        """
        Compute(Handle_AIS_MinRadiusDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_MinRadiusDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_MinRadiusDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_MinRadiusDimension self) -> AIS_KindOfDimension

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_MinRadiusDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsMovable(self, *args)


    def ComputeGeometry(self, *args):
        """ComputeGeometry(Handle_AIS_MinRadiusDimension self)"""
        return _AIS.Handle_AIS_MinRadiusDimension_ComputeGeometry(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_MinRadiusDimension self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_MinRadiusDimension self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_MinRadiusDimension self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Type(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_MinRadiusDimension self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_MinRadiusDimension self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_MinRadiusDimension self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_MinRadiusDimension self)"""
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_MinRadiusDimension self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_MinRadiusDimension self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_MinRadiusDimension self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_MinRadiusDimension self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_MinRadiusDimension self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_MinRadiusDimension self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MinRadiusDimension_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_MinRadiusDimension self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_MinRadiusDimension self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_MinRadiusDimension self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_MinRadiusDimension self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_MinRadiusDimension self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_MinRadiusDimension self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_MinRadiusDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_MinRadiusDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MinRadiusDimension_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_MinRadiusDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_MinRadiusDimension self)"""
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_MinRadiusDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_MinRadiusDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_MinRadiusDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_MinRadiusDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_MinRadiusDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_MinRadiusDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_MinRadiusDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_MinRadiusDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_MinRadiusDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_MinRadiusDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_MinRadiusDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_MinRadiusDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_MinRadiusDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_MinRadiusDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_MinRadiusDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_MinRadiusDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_MinRadiusDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_MinRadiusDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_MinRadiusDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_MinRadiusDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_MinRadiusDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_MinRadiusDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_MinRadiusDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MinRadiusDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_MinRadiusDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MinRadiusDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_MinRadiusDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_MinRadiusDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_MinRadiusDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_MinRadiusDimension self)
        RecomputePrimitives(Handle_AIS_MinRadiusDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MinRadiusDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_MinRadiusDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_MinRadiusDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_MinRadiusDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_MinRadiusDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_MinRadiusDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_MinRadiusDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_MinRadiusDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_MinRadiusDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_MinRadiusDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_MinRadiusDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_MinRadiusDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_MinRadiusDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_MinRadiusDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_MinRadiusDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_MinRadiusDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_MinRadiusDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_MinRadiusDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_MinRadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_MinRadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_MinRadiusDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_MinRadiusDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_MinRadiusDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MinRadiusDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_MinRadiusDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_MinRadiusDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MinRadiusDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_MinRadiusDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_MinRadiusDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_MinRadiusDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MinRadiusDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_MinRadiusDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_MinRadiusDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_MinRadiusDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_MinRadiusDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_MinRadiusDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_MinRadiusDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_MinRadiusDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_MinRadiusDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_MinRadiusDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_MinRadiusDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_MinRadiusDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_MinRadiusDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MinRadiusDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_MinRadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MinRadiusDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_MinRadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MinRadiusDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_MinRadiusDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_MinRadiusDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_MinRadiusDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_MinRadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MinRadiusDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_MinRadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MinRadiusDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_MinRadiusDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_MinRadiusDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_MinRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_MinRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MinRadiusDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_MinRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_MinRadiusDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_MinRadiusDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_MinRadiusDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_MinRadiusDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_MinRadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_MinRadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_MinRadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_MinRadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MinRadiusDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_MinRadiusDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_MinRadiusDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_MinRadiusDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_MinRadiusDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_MinRadiusDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MinRadiusDimension_DecrementRefCounter(self, *args)

Handle_AIS_MinRadiusDimension_swigregister = _AIS.Handle_AIS_MinRadiusDimension_swigregister
Handle_AIS_MinRadiusDimension_swigregister(Handle_AIS_MinRadiusDimension)

def Handle_AIS_MinRadiusDimension_DownCast(thing):
    return _AIS.Handle_AIS_MinRadiusDimension_DownCast(thing)
Handle_AIS_MinRadiusDimension_DownCast = _AIS.Handle_AIS_MinRadiusDimension_DownCast

class Handle_AIS_AnimationTimer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_AnimationTimer self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_AnimationTimer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_AnimationTimer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_AnimationTimer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_AnimationTimer self, AIS_AnimationTimer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_AnimationTimer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_AnimationTimer self, Handle_AIS_AnimationTimer theHandle) -> Handle_AIS_AnimationTimer
        assign(Handle_AIS_AnimationTimer self, AIS_AnimationTimer thePtr) -> Handle_AIS_AnimationTimer
        assign(Handle_AIS_AnimationTimer self, Handle_AIS_AnimationTimer theHandle) -> Handle_AIS_AnimationTimer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_AnimationTimer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_AnimationTimer self) -> AIS_AnimationTimer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_AnimationTimer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_AnimationTimer self) -> AIS_AnimationTimer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_AnimationTimer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_AnimationTimer self) -> AIS_AnimationTimer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_AnimationTimer___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_AnimationTimer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_AnimationTimer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_AnimationTimer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_AnimationTimer_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_AnimationTimer

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_AnimationTimer self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_AnimationTimer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AnimationTimer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AnimationTimer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ElapsedTime(self, *args):
        """
        ElapsedTime(Handle_AIS_AnimationTimer self) -> Standard_Real

        Return elapsed time in seconds.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationTimer_ElapsedTime(self, *args)


    def PlaybackSpeed(self, *args):
        """
        PlaybackSpeed(Handle_AIS_AnimationTimer self) -> Standard_Real

        Return playback speed coefficient (1.0 means normal speed).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationTimer_PlaybackSpeed(self, *args)


    def SetPlaybackSpeed(self, *args):
        """
        SetPlaybackSpeed(Handle_AIS_AnimationTimer self, Standard_Real const theSpeed)

        Setup playback speed coefficient.

        :type theSpeed: float

        """
        return _AIS.Handle_AIS_AnimationTimer_SetPlaybackSpeed(self, *args)


    def IsStarted(self, *args):
        """
        IsStarted(Handle_AIS_AnimationTimer self) -> Standard_Boolean

        Return true if timer has been started.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationTimer_IsStarted(self, *args)


    def Start(self, *args):
        """
        Start(Handle_AIS_AnimationTimer self)

        Start the timer.


        """
        return _AIS.Handle_AIS_AnimationTimer_Start(self, *args)


    def Pause(self, *args):
        """
        Pause(Handle_AIS_AnimationTimer self)

        Pause the timer.


        """
        return _AIS.Handle_AIS_AnimationTimer_Pause(self, *args)


    def Stop(self, *args):
        """
        Stop(Handle_AIS_AnimationTimer self)

        Stop the timer.


        """
        return _AIS.Handle_AIS_AnimationTimer_Stop(self, *args)


    def Seek(self, *args):
        """
        Seek(Handle_AIS_AnimationTimer self, Standard_Real const theTime)

        Seek the timer to specified position.

        :type theTime: float

        """
        return _AIS.Handle_AIS_AnimationTimer_Seek(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_AnimationTimer self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_AnimationTimer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_AnimationTimer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_AnimationTimer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationTimer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_AnimationTimer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_AnimationTimer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationTimer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_AnimationTimer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_AnimationTimer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_AnimationTimer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AnimationTimer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_AnimationTimer self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_AnimationTimer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_AnimationTimer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AnimationTimer_DecrementRefCounter(self, *args)

Handle_AIS_AnimationTimer_swigregister = _AIS.Handle_AIS_AnimationTimer_swigregister
Handle_AIS_AnimationTimer_swigregister(Handle_AIS_AnimationTimer)

def Handle_AIS_AnimationTimer_DownCast(thing):
    return _AIS.Handle_AIS_AnimationTimer_DownCast(thing)
Handle_AIS_AnimationTimer_DownCast = _AIS.Handle_AIS_AnimationTimer_DownCast

class Handle_AIS_ParallelRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ParallelRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ParallelRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ParallelRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ParallelRelation self, AIS_ParallelRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ParallelRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ParallelRelation self, Handle_AIS_ParallelRelation theHandle) -> Handle_AIS_ParallelRelation
        assign(Handle_AIS_ParallelRelation self, AIS_ParallelRelation thePtr) -> Handle_AIS_ParallelRelation
        assign(Handle_AIS_ParallelRelation self, Handle_AIS_ParallelRelation theHandle) -> Handle_AIS_ParallelRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ParallelRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ParallelRelation self) -> AIS_ParallelRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ParallelRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ParallelRelation self) -> AIS_ParallelRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ParallelRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ParallelRelation self) -> AIS_ParallelRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ParallelRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ParallelRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ParallelRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ParallelRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ParallelRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ParallelRelation

    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the parallelism is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_ParallelRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ParallelRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ParallelRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ParallelRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ParallelRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ParallelRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_ParallelRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ParallelRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_ParallelRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_ParallelRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_ParallelRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_ParallelRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_ParallelRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_ParallelRelation_KindOfDimension(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_ParallelRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_ParallelRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_ParallelRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_ParallelRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_ParallelRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_ParallelRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_ParallelRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_ParallelRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_ParallelRelation self)"""
        return _AIS.Handle_AIS_ParallelRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_ParallelRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_ParallelRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_ParallelRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_ParallelRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ParallelRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_ParallelRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_ParallelRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_ParallelRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_ParallelRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ParallelRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_ParallelRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_ParallelRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_ParallelRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_ParallelRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ParallelRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_ParallelRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_ParallelRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_ParallelRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_ParallelRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_ParallelRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_ParallelRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_ParallelRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_ParallelRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_ParallelRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_ParallelRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_ParallelRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ParallelRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_ParallelRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ParallelRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_ParallelRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ParallelRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_ParallelRelation self)"""
        return _AIS.Handle_AIS_ParallelRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_ParallelRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_ParallelRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_ParallelRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ParallelRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_ParallelRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ParallelRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_ParallelRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_ParallelRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_ParallelRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_ParallelRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_ParallelRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_ParallelRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_ParallelRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_ParallelRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_ParallelRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_ParallelRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ParallelRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_ParallelRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_ParallelRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_ParallelRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ParallelRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_ParallelRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ParallelRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_ParallelRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_ParallelRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_ParallelRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_ParallelRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_ParallelRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_ParallelRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_ParallelRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ParallelRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_ParallelRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ParallelRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_ParallelRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_ParallelRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_ParallelRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_ParallelRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_ParallelRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ParallelRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_ParallelRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_ParallelRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_ParallelRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ParallelRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_ParallelRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ParallelRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_ParallelRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ParallelRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_ParallelRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_ParallelRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_ParallelRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_ParallelRelation self)
        RecomputePrimitives(Handle_AIS_ParallelRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ParallelRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_ParallelRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_ParallelRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_ParallelRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ParallelRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_ParallelRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_ParallelRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_ParallelRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ParallelRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_ParallelRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ParallelRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ParallelRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_ParallelRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_ParallelRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_ParallelRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_ParallelRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_ParallelRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_ParallelRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_ParallelRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_ParallelRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_ParallelRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_ParallelRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_ParallelRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_ParallelRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_ParallelRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ParallelRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_ParallelRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_ParallelRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ParallelRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_ParallelRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ParallelRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_ParallelRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_ParallelRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ParallelRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_ParallelRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ParallelRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_ParallelRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_ParallelRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_ParallelRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ParallelRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_ParallelRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ParallelRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_ParallelRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_ParallelRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_ParallelRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_ParallelRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ParallelRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_ParallelRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_ParallelRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_ParallelRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ParallelRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_ParallelRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_ParallelRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_ParallelRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ParallelRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_ParallelRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ParallelRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_ParallelRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_ParallelRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_ParallelRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_ParallelRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_ParallelRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ParallelRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_ParallelRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_ParallelRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_ParallelRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ParallelRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ParallelRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ParallelRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_ParallelRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_ParallelRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ParallelRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_ParallelRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ParallelRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_ParallelRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ParallelRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_ParallelRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_ParallelRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_ParallelRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_ParallelRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_ParallelRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_ParallelRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_ParallelRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ParallelRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_ParallelRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ParallelRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_ParallelRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_ParallelRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_ParallelRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_ParallelRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_ParallelRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ParallelRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ParallelRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ParallelRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_ParallelRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ParallelRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ParallelRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_ParallelRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ParallelRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_ParallelRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_ParallelRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ParallelRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ParallelRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ParallelRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ParallelRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ParallelRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ParallelRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ParallelRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ParallelRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ParallelRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ParallelRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ParallelRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ParallelRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ParallelRelation_DecrementRefCounter(self, *args)

Handle_AIS_ParallelRelation_swigregister = _AIS.Handle_AIS_ParallelRelation_swigregister
Handle_AIS_ParallelRelation_swigregister(Handle_AIS_ParallelRelation)

def Handle_AIS_ParallelRelation_DownCast(thing):
    return _AIS.Handle_AIS_ParallelRelation_DownCast(thing)
Handle_AIS_ParallelRelation_DownCast = _AIS.Handle_AIS_ParallelRelation_DownCast

class AIS_ColoredShape(AIS_Shape):
    """Presentation of the shape with customizable sub-shapes properties."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ColoredShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ColoredShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_ColoredShape self, TopoDS_Shape theShape) -> AIS_ColoredShape
        __init__(AIS_ColoredShape self, Handle_AIS_Shape theShape) -> AIS_ColoredShape

        Copy constructor

        :type theShape: OCC.wrapper.AIS.Handle_AIS_Shape

        """
        this = _AIS.new_AIS_ColoredShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def CustomAspects(self, *args):
        """
        CustomAspects(AIS_ColoredShape self, TopoDS_Shape theShape) -> Handle_AIS_ColoredDrawer

        Customize properties of specified sub-shape.
        The shape will be stored in the map but ignored, if it is not sub-shape of main Shape!
        This method can be used to mark sub-shapes with customizable properties.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.AIS.Handle_AIS_ColoredDrawer

        """
        return _AIS.AIS_ColoredShape_CustomAspects(self, *args)


    def ClearCustomAspects(self, *args):
        """
        ClearCustomAspects(AIS_ColoredShape self)

        Reset the map of custom sub-shape aspects.


        """
        return _AIS.AIS_ColoredShape_ClearCustomAspects(self, *args)


    def UnsetCustomAspects(self, *args):
        """
        UnsetCustomAspects(AIS_ColoredShape self, TopoDS_Shape theShape, Standard_Boolean const theToUnregister)

        Reset custom properties of specified sub-shape.
        @param theToUnregister unregister or not sub-shape from the map

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theToUnregister: bool

        """
        return _AIS.AIS_ColoredShape_UnsetCustomAspects(self, *args)


    def SetCustomColor(self, *args):
        """
        SetCustomColor(AIS_ColoredShape self, TopoDS_Shape theShape, Quantity_Color theColor)

        Customize color of specified sub-shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_ColoredShape_SetCustomColor(self, *args)


    def SetCustomWidth(self, *args):
        """
        SetCustomWidth(AIS_ColoredShape self, TopoDS_Shape theShape, Standard_Real const theLineWidth)

        Customize line width of specified sub-shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theLineWidth: float

        """
        return _AIS.AIS_ColoredShape_SetCustomWidth(self, *args)


    def CustomAspectsMap(self, *args):
        """
        Return the map of custom aspects.

        :rtype: OCC.wrapper.AIS.AIS_DataMapOfShapeDrawer

        """
        res = _AIS.AIS_ColoredShape_CustomAspectsMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCustomAspectsMap(self, *args):
        """
        ChangeCustomAspectsMap(AIS_ColoredShape self) -> NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher

        Return the map of custom aspects.

        :rtype: OCC.wrapper.AIS.AIS_DataMapOfShapeDrawer

        """
        return _AIS.AIS_ColoredShape_ChangeCustomAspectsMap(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_ColoredShape self, Quantity_Color theColor)

        Setup color of entire shape.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_ColoredShape_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_ColoredShape self, Standard_Real const theLineWidth)

        Setup line width of entire shape.

        :type theLineWidth: float

        """
        return _AIS.AIS_ColoredShape_SetWidth(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(AIS_ColoredShape self, Standard_Real const theValue)

        Sets transparency value.

        :type theValue: float

        """
        return _AIS.AIS_ColoredShape_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(AIS_ColoredShape self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _AIS.AIS_ColoredShape_UnsetTransparency(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(AIS_ColoredShape self, Graphic3d_MaterialAspect theAspect)

        Sets the material aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.AIS_ColoredShape_SetMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ColoredShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ColoredShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ColoredShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_ColoredShape
AIS_ColoredShape_swigregister = _AIS.AIS_ColoredShape_swigregister
AIS_ColoredShape_swigregister(AIS_ColoredShape)

def AIS_ColoredShape_get_type_name(*args):
    """
    AIS_ColoredShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ColoredShape_get_type_name(*args)

def AIS_ColoredShape_get_type_descriptor(*args):
    """
    AIS_ColoredShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ColoredShape_get_type_descriptor(*args)

class AIS_Trihedron(AIS_InteractiveObject):
    """
    Create a selectable trihedron
    The trihedron includes 1 origin, 3 axes and 3 labels.
    Default text of labels are "X", "Y", "Z".
    Color of origin and any axis, color of arrows and labels may be changed.
    Visual presentation might be shown in two, shaded and wireframe modes, wireframe by default).
    There are 4 modes of selection:
    - AIS_TrihedronSelectionMode_EntireObject to select trihedron,  priority = 1
    - AIS_TrihedronSelectionMode_Origin       to select its origin, priority = 5
    - AIS_TrihedronSelectionMode_Axes         to select its axis,   priority = 3
    - AIS_TrihedronSelectionMode_MainPlanes   to select its planes, priority = 2

    Warning!
    For the presentation of trihedron, the default unit of length is the millimetre,
    and the default value for the representation of the axes is 100.
    If you modify these dimensions, you must temporarily recover the Drawer.
    From inside it, you take the aspect in which the values for length are stocked.
    For trihedron, this is Prs3d_Drawer_LineAspect.
    You change the values inside this Aspect and recalculate the presentation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Trihedron
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Trihedron(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Trihedron_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Trihedron_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Trihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Trihedron self, Handle_Geom_Axis2Placement theComponent) -> AIS_Trihedron

        Initializes a trihedron entity.

        :type theComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        this = _AIS.new_AIS_Trihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDatumDisplayMode(self, *args):
        """
        SetDatumDisplayMode(AIS_Trihedron self, Prs3d_DatumMode theMode)

        Sets Shading or Wireframe display mode, triangle or segment graphic group is used relatively.

        :type theMode: OCC.wrapper.Prs3d.Prs3d_DatumMode

        """
        return _AIS.AIS_Trihedron_SetDatumDisplayMode(self, *args)


    def DatumDisplayMode(self, *args):
        """
        DatumDisplayMode(AIS_Trihedron self) -> Prs3d_DatumMode

        Returns datum display mode.

        :rtype: OCC.wrapper.Prs3d.Prs3d_DatumMode

        """
        return _AIS.AIS_Trihedron_DatumDisplayMode(self, *args)


    def Component(self, *args):
        """
        Returns the right-handed coordinate system set in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        res = _AIS.AIS_Trihedron_Component(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetComponent(self, *args):
        """
        SetComponent(AIS_Trihedron self, Handle_Geom_Axis2Placement theComponent)

        Constructs the right-handed coordinate system aComponent.

        :type theComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        return _AIS.AIS_Trihedron_SetComponent(self, *args)


    def HasOwnSize(self, *args):
        """
        HasOwnSize(AIS_Trihedron self) -> Standard_Boolean

        Returns true if the trihedron object has a size other
        than the default size of 100 mm. along each axis.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Trihedron_HasOwnSize(self, *args)


    def SetSize(self, *args):
        """
        SetSize(AIS_Trihedron self, Standard_Real const theValue)

        Sets the size aValue for the trihedron object.
        The default value is 100 mm.

        :type theValue: float

        """
        return _AIS.AIS_Trihedron_SetSize(self, *args)


    def UnsetSize(self, *args):
        """
        UnsetSize(AIS_Trihedron self)

        Removes any non-default settings for size of this trihedron object.
        If the object has 1 color, the default size of the
        drawer is reproduced, otherwise DatumAspect becomes null.


        """
        return _AIS.AIS_Trihedron_UnsetSize(self, *args)


    def Size(self, *args):
        """
        Size(AIS_Trihedron self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_Trihedron_Size(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_Trihedron self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the display mode selected, aMode, is valid for trihedron datums.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Trihedron_AcceptDisplayMode(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_Trihedron self) -> Standard_Integer

        Returns index 3, selection of the planes XOY, YOZ, XOZ.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Trihedron_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Trihedron self) -> AIS_KindOfInteractive

        Indicates that the type of Interactive Object is datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Trihedron_Type(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_Trihedron self, Quantity_Color theColor)

        Sets the color theColor for this trihedron object, it changes color of axes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetColor(self, *args)


    def SetTextColor(self, *args):
        """
        SetTextColor(AIS_Trihedron self, Quantity_Color theColor)

        Sets color of label of trihedron axes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetTextColor(self, *args)


    def HasTextColor(self, *args):
        """
        HasTextColor(AIS_Trihedron self) -> Standard_Boolean

        Returns true if trihedron has own text color

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Trihedron_HasTextColor(self, *args)


    def TextColor(self, *args):
        """
        TextColor(AIS_Trihedron self) -> Quantity_Color

        Returns trihedron text color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_TextColor(self, *args)


    def SetArrowColor(self, *args):
        """
        SetArrowColor(AIS_Trihedron self, Quantity_Color theColor)

        Sets color of arrow of trihedron axes. Used only in wireframe mode

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetArrowColor(self, *args)


    def HasArrowColor(self, *args):
        """
        HasArrowColor(AIS_Trihedron self) -> Standard_Boolean

        Returns true if trihedron has own arrow color

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Trihedron_HasArrowColor(self, *args)


    def ArrowColor(self, *args):
        """
        ArrowColor(AIS_Trihedron self) -> Quantity_Color

        Returns trihedron arrow color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_ArrowColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Trihedron self)

        Removes the settings for color.


        """
        return _AIS.AIS_Trihedron_UnsetColor(self, *args)


    def SetDatumPartColor(self, *args):
        """
        SetDatumPartColor(AIS_Trihedron self, Prs3d_DatumParts const thePart, Quantity_Color theColor)

        Sets color of datum part: origin or some of trihedron axes.
        If presentation is shading mode, this color is set for both sides of facing model

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetDatumPartColor(self, *args)


    def DatumPartColor(self, *args):
        """
        DatumPartColor(AIS_Trihedron self, Prs3d_DatumParts thePart) -> Quantity_Color

        Returns color of datum part: origin or some of trihedron axes.

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_DatumPartColor(self, *args)


    def SetOriginColor(self, *args):
        """
        SetOriginColor(AIS_Trihedron self, Quantity_Color theColor)

        Sets color of origin.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetOriginColor(self, *args)


    def SetXAxisColor(self, *args):
        """
        SetXAxisColor(AIS_Trihedron self, Quantity_Color theColor)

        Sets color of x-axis.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetXAxisColor(self, *args)


    def SetYAxisColor(self, *args):
        """
        SetYAxisColor(AIS_Trihedron self, Quantity_Color theColor)

        Sets color of y-axis.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetYAxisColor(self, *args)


    def SetAxisColor(self, *args):
        """
        SetAxisColor(AIS_Trihedron self, Quantity_Color theColor)

        Sets color of z-axis.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Trihedron_SetAxisColor(self, *args)


    def ToDrawArrows(self, *args):
        """
        ToDrawArrows(AIS_Trihedron self) -> Standard_Boolean

        Returns true if arrows are to be drawn

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Trihedron_ToDrawArrows(self, *args)


    def SetDrawArrows(self, *args):
        """
        SetDrawArrows(AIS_Trihedron self, Standard_Boolean const theToDraw)

        Sets whether to draw the arrows in visualization

        :type theToDraw: bool

        """
        return _AIS.AIS_Trihedron_SetDrawArrows(self, *args)


    def SetSelectionPriority(self, *args):
        """
        SetSelectionPriority(AIS_Trihedron self, Prs3d_DatumParts thePart, Standard_Integer thePriority)

        Sets priority of selection for owner of the given type

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :type thePriority: int

        """
        return _AIS.AIS_Trihedron_SetSelectionPriority(self, *args)


    def SelectionPriority(self, *args):
        """
        SelectionPriority(AIS_Trihedron self, Prs3d_DatumParts thePart) -> Standard_Integer

        Sets priority of selection for owner of the given type

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Trihedron_SelectionPriority(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(AIS_Trihedron self, Prs3d_DatumParts const thePart, TCollection_ExtendedString thePriority)

        Sets text label for trihedron axis. Parameter thePart should be XAxis, YAxis or ZAxis

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :type thePriority: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.AIS_Trihedron_SetLabel(self, *args)


    def Label(self, *args):
        """
        Returns text of axis. Parameter thePart should be XAxis, YAxis or ZAxis

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.AIS_Trihedron_Label(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(AIS_Trihedron self) -> Standard_Boolean

        Disables auto highlighting to use HilightSelected() and HilightOwnerWithColor() overridden methods.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Trihedron_IsAutoHilight(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(AIS_Trihedron self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw ).


        """
        return _AIS.AIS_Trihedron_ClearSelected(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(AIS_Trihedron self, Handle_PrsMgr_PresentationManager thePM, NCollection_Sequence_Handle_SelectMgr_EntityOwner theOwners)

        Method which draws selected owners ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theOwners: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.AIS_Trihedron_HilightSelected(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(AIS_Trihedron self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_Trihedron_HilightOwnerWithColor(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Trihedron
AIS_Trihedron_swigregister = _AIS.AIS_Trihedron_swigregister
AIS_Trihedron_swigregister(AIS_Trihedron)

def AIS_Trihedron_get_type_name(*args):
    """
    AIS_Trihedron_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Trihedron_get_type_name(*args)

def AIS_Trihedron_get_type_descriptor(*args):
    """
    AIS_Trihedron_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Trihedron_get_type_descriptor(*args)

class Handle_AIS_InteractiveObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_InteractiveObject self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_InteractiveObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_InteractiveObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_InteractiveObject self, AIS_InteractiveObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_InteractiveObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theHandle) -> Handle_AIS_InteractiveObject
        assign(Handle_AIS_InteractiveObject self, AIS_InteractiveObject thePtr) -> Handle_AIS_InteractiveObject
        assign(Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveObject theHandle) -> Handle_AIS_InteractiveObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_InteractiveObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_InteractiveObject self) -> AIS_InteractiveObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_InteractiveObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_InteractiveObject self) -> AIS_InteractiveObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_InteractiveObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_InteractiveObject self) -> AIS_InteractiveObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_InteractiveObject___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_InteractiveObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_InteractiveObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_InteractiveObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_InteractiveObject_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_InteractiveObject

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_InteractiveObject self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_InteractiveObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_InteractiveObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_InteractiveObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_AIS_InteractiveObject self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_InteractiveObject_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_InteractiveObject self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveObject_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_InteractiveObject self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_InteractiveObject_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_InteractiveObject self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_InteractiveObject_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_InteractiveObject self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_InteractiveObject_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_InteractiveObject self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_InteractiveObject_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_InteractiveObject self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_InteractiveObject_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_InteractiveObject self)"""
        return _AIS.Handle_AIS_InteractiveObject_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_InteractiveObject self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_InteractiveObject self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveObject_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_InteractiveObject self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_InteractiveObject self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_InteractiveObject self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_InteractiveObject_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_InteractiveObject self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_InteractiveObject_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_InteractiveObject_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_InteractiveObject self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_InteractiveObject_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_InteractiveObject self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_InteractiveObject_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_InteractiveObject self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_InteractiveObject_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_InteractiveObject self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_InteractiveObject_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_InteractiveObject self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveObject_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_InteractiveObject self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveObject_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_InteractiveObject self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_InteractiveObject_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_InteractiveObject self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_InteractiveObject_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_InteractiveObject self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_InteractiveObject_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_InteractiveObject self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveObject_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_InteractiveObject self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_InteractiveObject_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_InteractiveObject self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_InteractiveObject_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_InteractiveObject self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_InteractiveObject_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_InteractiveObject self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_InteractiveObject_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_InteractiveObject self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveObject_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_InteractiveObject self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_InteractiveObject_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_InteractiveObject self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_InteractiveObject_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_InteractiveObject self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_InteractiveObject_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_InteractiveObject self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_InteractiveObject_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_InteractiveObject self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_InteractiveObject_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_InteractiveObject self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_InteractiveObject_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_InteractiveObject self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_InteractiveObject_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_InteractiveObject self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_InteractiveObject self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_InteractiveObject_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_InteractiveObject self)
        RecomputePrimitives(Handle_AIS_InteractiveObject self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_InteractiveObject_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_InteractiveObject self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_InteractiveObject_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_InteractiveObject self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_InteractiveObject_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_InteractiveObject self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_InteractiveObject_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_InteractiveObject self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_InteractiveObject_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_InteractiveObject self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_InteractiveObject_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_InteractiveObject_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_InteractiveObject self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_InteractiveObject_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_InteractiveObject self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_InteractiveObject_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_InteractiveObject self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_InteractiveObject_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_InteractiveObject self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_InteractiveObject_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_InteractiveObject self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_InteractiveObject_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_InteractiveObject self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_InteractiveObject_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_InteractiveObject self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_InteractiveObject_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_InteractiveObject self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_InteractiveObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_InteractiveObject_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_InteractiveObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_InteractiveObject_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_InteractiveObject self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_InteractiveObject self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_InteractiveObject_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_InteractiveObject self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_InteractiveObject_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_InteractiveObject self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_InteractiveObject_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_InteractiveObject self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_InteractiveObject_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_InteractiveObject self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveObject_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_InteractiveObject self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_InteractiveObject_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_InteractiveObject_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_InteractiveObject self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_InteractiveObject_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_InteractiveObject self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_InteractiveObject_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_InteractiveObject_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_InteractiveObject self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_InteractiveObject self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_InteractiveObject_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_InteractiveObject self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_InteractiveObject_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_InteractiveObject self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_InteractiveObject_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_InteractiveObject self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_InteractiveObject_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_InteractiveObject self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_InteractiveObject self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_InteractiveObject_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_InteractiveObject self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_InteractiveObject_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_InteractiveObject_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_InteractiveObject self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_InteractiveObject self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_InteractiveObject_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_InteractiveObject_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_InteractiveObject_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_InteractiveObject_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_InteractiveObject_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_InteractiveObject self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_InteractiveObject_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_InteractiveObject self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_InteractiveObject_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_InteractiveObject self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_InteractiveObject_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_InteractiveObject self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_InteractiveObject self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_InteractiveObject_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_InteractiveObject_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_InteractiveObject self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_InteractiveObject_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_InteractiveObject self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_InteractiveObject_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_InteractiveObject self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_InteractiveObject_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_InteractiveObject_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_InteractiveObject self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_InteractiveObject self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_InteractiveObject_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_InteractiveObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_InteractiveObject_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_InteractiveObject_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_InteractiveObject_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_InteractiveObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_InteractiveObject_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_InteractiveObject_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_InteractiveObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_InteractiveObject_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_InteractiveObject self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_InteractiveObject_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_InteractiveObject self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_InteractiveObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_InteractiveObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_InteractiveObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_InteractiveObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_InteractiveObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_InteractiveObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_InteractiveObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_InteractiveObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_InteractiveObject self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_InteractiveObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_InteractiveObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveObject_DecrementRefCounter(self, *args)

Handle_AIS_InteractiveObject_swigregister = _AIS.Handle_AIS_InteractiveObject_swigregister
Handle_AIS_InteractiveObject_swigregister(Handle_AIS_InteractiveObject)

def Handle_AIS_InteractiveObject_DownCast(thing):
    return _AIS.Handle_AIS_InteractiveObject_DownCast(thing)
Handle_AIS_InteractiveObject_DownCast = _AIS.Handle_AIS_InteractiveObject_DownCast

class Handle_AIS_MaxRadiusDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_MaxRadiusDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_MaxRadiusDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_MaxRadiusDimension self, AIS_MaxRadiusDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_MaxRadiusDimension self, Handle_AIS_MaxRadiusDimension theHandle) -> Handle_AIS_MaxRadiusDimension
        assign(Handle_AIS_MaxRadiusDimension self, AIS_MaxRadiusDimension thePtr) -> Handle_AIS_MaxRadiusDimension
        assign(Handle_AIS_MaxRadiusDimension self, Handle_AIS_MaxRadiusDimension theHandle) -> Handle_AIS_MaxRadiusDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_MaxRadiusDimension self) -> AIS_MaxRadiusDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_MaxRadiusDimension self) -> AIS_MaxRadiusDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_MaxRadiusDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_MaxRadiusDimension self) -> AIS_MaxRadiusDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_MaxRadiusDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_MaxRadiusDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_MaxRadiusDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_MaxRadiusDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_MaxRadiusDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_MaxRadiusDimension

    def Compute(self, *args):
        """
        Compute(Handle_AIS_MaxRadiusDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_MaxRadiusDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_MaxRadiusDimension self) -> AIS_KindOfDimension

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsMovable(self, *args)


    def ComputeGeometry(self, *args):
        """ComputeGeometry(Handle_AIS_MaxRadiusDimension self)"""
        return _AIS.Handle_AIS_MaxRadiusDimension_ComputeGeometry(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_MaxRadiusDimension self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_MaxRadiusDimension self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_MaxRadiusDimension self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Type(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_MaxRadiusDimension self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_MaxRadiusDimension self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_MaxRadiusDimension self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_MaxRadiusDimension self)"""
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_MaxRadiusDimension self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_MaxRadiusDimension self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_MaxRadiusDimension self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_MaxRadiusDimension self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_MaxRadiusDimension self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_MaxRadiusDimension self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_MaxRadiusDimension self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_MaxRadiusDimension self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_MaxRadiusDimension self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_MaxRadiusDimension self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_MaxRadiusDimension self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_MaxRadiusDimension self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_MaxRadiusDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_MaxRadiusDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_MaxRadiusDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_MaxRadiusDimension self)"""
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_MaxRadiusDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_MaxRadiusDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_MaxRadiusDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_MaxRadiusDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_MaxRadiusDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_MaxRadiusDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_MaxRadiusDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_MaxRadiusDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_MaxRadiusDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_MaxRadiusDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_MaxRadiusDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_MaxRadiusDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_MaxRadiusDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_MaxRadiusDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_MaxRadiusDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_MaxRadiusDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_MaxRadiusDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_MaxRadiusDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_MaxRadiusDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_MaxRadiusDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_MaxRadiusDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_MaxRadiusDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_MaxRadiusDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_MaxRadiusDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_MaxRadiusDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_MaxRadiusDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_MaxRadiusDimension self)
        RecomputePrimitives(Handle_AIS_MaxRadiusDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_MaxRadiusDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_MaxRadiusDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_MaxRadiusDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_MaxRadiusDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_MaxRadiusDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_MaxRadiusDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_MaxRadiusDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_MaxRadiusDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_MaxRadiusDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_MaxRadiusDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_MaxRadiusDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_MaxRadiusDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_MaxRadiusDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_MaxRadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_MaxRadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_MaxRadiusDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_MaxRadiusDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_MaxRadiusDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_MaxRadiusDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_MaxRadiusDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_MaxRadiusDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_MaxRadiusDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_MaxRadiusDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_MaxRadiusDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_MaxRadiusDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_MaxRadiusDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_MaxRadiusDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_MaxRadiusDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_MaxRadiusDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_MaxRadiusDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_MaxRadiusDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_MaxRadiusDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_MaxRadiusDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_MaxRadiusDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_MaxRadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_MaxRadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_MaxRadiusDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_MaxRadiusDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_MaxRadiusDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_MaxRadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_MaxRadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_MaxRadiusDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_MaxRadiusDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_MaxRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_MaxRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MaxRadiusDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_MaxRadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_MaxRadiusDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_MaxRadiusDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_MaxRadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_MaxRadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_MaxRadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_MaxRadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_MaxRadiusDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_MaxRadiusDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_MaxRadiusDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_MaxRadiusDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MaxRadiusDimension_DecrementRefCounter(self, *args)

Handle_AIS_MaxRadiusDimension_swigregister = _AIS.Handle_AIS_MaxRadiusDimension_swigregister
Handle_AIS_MaxRadiusDimension_swigregister(Handle_AIS_MaxRadiusDimension)

def Handle_AIS_MaxRadiusDimension_DownCast(thing):
    return _AIS.Handle_AIS_MaxRadiusDimension_DownCast(thing)
Handle_AIS_MaxRadiusDimension_DownCast = _AIS.Handle_AIS_MaxRadiusDimension_DownCast

class AIS_LocalContext(Standard.Standard_Transient):
    """
    Defines a specific context  for selection.
    It becomes possible to:
    +  Load  InteractiveObjects  with   a mode   to be
    activated +  associate InteractiveObjects   with a
    set of  temporary   selectable Objects....   +   +
    activate StandardMode  of selection  for  Entities
    inheriting  BasicShape  from  AIS (Selection    Of
    vertices, edges,   wires,faces...  + Add   Filters
    acting on detected owners of sensitive primitives

    -     automatically    highlight   shapes   and
    InteractiveObjects  (highlight of  detected shape +
    highlight of detected selectable...
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_LocalContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_LocalContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_LocalContext self) -> AIS_LocalContext
        __init__(AIS_LocalContext self, Handle_AIS_InteractiveContext aCtx, Standard_Integer const anIndex, Standard_Boolean const LoadDisplayed, Standard_Boolean const AcceptStandardModes, Standard_Boolean const AcceptErase, Standard_Boolean const UseBothViewers) -> AIS_LocalContext

        Constructor By Default, the  displayed objects are
        automatically loaded.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext
        :type anIndex: int
        :type LoadDisplayed: bool
        :type AcceptStandardModes: bool
        :type AcceptErase: bool
        :type UseBothViewers: bool

        """
        this = _AIS.new_AIS_LocalContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AcceptErase(self, *args):
        """
        AcceptErase(AIS_LocalContext self, Standard_Boolean const aStatus)
        AcceptErase(AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_AcceptErase(self, *args)


    def SetContext(self, *args):
        """
        SetContext(AIS_LocalContext self, Handle_AIS_InteractiveContext aCtx)

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.AIS_LocalContext_SetContext(self, *args)


    def Selection(self, *args):
        """
        :rtype: OCC.wrapper.AIS.Handle_AIS_Selection

        """
        res = _AIS.AIS_LocalContext_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Terminate(self, *args):
        """
        Terminate(AIS_LocalContext self, Standard_Boolean const updateviewer)

        :type updateviewer: bool

        """
        return _AIS.AIS_LocalContext_Terminate(self, *args)


    def Display(self, *args):
        """
        Display(AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive, Standard_Integer const DisplayMode=0, Standard_Boolean const AllowShapeDecomposition, Standard_Integer const ActivationMode=0) -> Standard_Boolean

        returns true if done...

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type DisplayMode: int
        :type AllowShapeDecomposition: bool
        :type ActivationMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_Display(self, *args)


    def Load(self, *args):
        """
        Load(AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive, Standard_Boolean const AllowShapeDecomposition, Standard_Integer const ActivationMode=0) -> Standard_Boolean

        loads <anInteractive> with nodisplay...
        returns true if done

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type AllowShapeDecomposition: bool
        :type ActivationMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_Load(self, *args)


    def Erase(self, *args):
        """
        Erase(AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive) -> Standard_Boolean

        returns true if done...

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_Erase(self, *args)


    def Remove(self, *args):
        """
        Remove(AIS_LocalContext self, Handle_AIS_InteractiveObject aSelectable) -> Standard_Boolean

        :type aSelectable: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_Remove(self, *args)


    def ClearPrs(self, *args):
        """
        ClearPrs(AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive, Standard_Integer const aMode) -> Standard_Boolean

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_ClearPrs(self, *args)


    def SetShapeDecomposition(self, *args):
        """
        SetShapeDecomposition(AIS_LocalContext self, Handle_AIS_InteractiveObject aStoredObject, Standard_Boolean const aStatus)

        allows  or  forbids   the   shape  decomposition  into
        Activated Standard   Mode  for   <aStoredObject>
        does nothing if the object doesn't inherits
        BasicShape from AIS

        :type aStoredObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aStatus: bool

        """
        return _AIS.AIS_LocalContext_SetShapeDecomposition(self, *args)


    def Clear(self, *args):
        """
        Clear(AIS_LocalContext self, AIS_ClearMode const atype=AIS_CM_All)

        according to <atype>  , clears the  different parts of
        the selector (filters, modeof activation, objects...)

        :type atype: OCC.wrapper.AIS.AIS_ClearMode

        """
        return _AIS.AIS_LocalContext_Clear(self, *args)


    def SetSelectionModeActive(self, *args):
        """
        SetSelectionModeActive(AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode, Standard_Boolean const theIsActive, AIS_SelectionModesConcurrency const theActiveFilter)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theIsActive: bool
        :type theActiveFilter: OCC.wrapper.AIS.AIS_SelectionModesConcurrency

        """
        return _AIS.AIS_LocalContext_SetSelectionModeActive(self, *args)


    def ActivateMode(self, *args):
        """
        ActivateMode(AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode)

        optional : activation of a mode which is not 0 for a selectable...

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int

        """
        return _AIS.AIS_LocalContext_ActivateMode(self, *args)


    def DeactivateMode(self, *args):
        """
        DeactivateMode(AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int

        """
        return _AIS.AIS_LocalContext_DeactivateMode(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(AIS_LocalContext self, Handle_AIS_InteractiveObject theObj)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_Deactivate(self, *args)


    def ActivateStandardMode(self, *args):
        """
        ActivateStandardMode(AIS_LocalContext self, TopAbs_ShapeEnum const aType)

        decomposition of shapes into <aType>

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.AIS_LocalContext_ActivateStandardMode(self, *args)


    def DeactivateStandardMode(self, *args):
        """
        DeactivateStandardMode(AIS_LocalContext self, TopAbs_ShapeEnum const aType)

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.AIS_LocalContext_DeactivateStandardMode(self, *args)


    def StandardModes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.AIS_LocalContext_StandardModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddFilter(self, *args):
        """
        AddFilter(AIS_LocalContext self, Handle_SelectMgr_Filter aFilter)

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.AIS_LocalContext_AddFilter(self, *args)


    def RemoveFilter(self, *args):
        """
        RemoveFilter(AIS_LocalContext self, Handle_SelectMgr_Filter aFilter)

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.AIS_LocalContext_RemoveFilter(self, *args)


    def ListOfFilter(self, *args):
        """
        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _AIS.AIS_LocalContext_ListOfFilter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Filter(self, *args):
        """
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_OrFilter

        """
        res = _AIS.AIS_LocalContext_Filter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAutomaticHilight(self, *args):
        """
        SetAutomaticHilight(AIS_LocalContext self, Standard_Boolean const aStatus)

        if <aStatus> = True , the shapes or subshapes detected
        by the selector will be automatically hilighted in the
        main viewer.
        Else the user has to manage the detected shape outside the
        Shape Selector....

        :type aStatus: bool

        """
        return _AIS.AIS_LocalContext_SetAutomaticHilight(self, *args)


    def AutomaticHilight(self, *args):
        """
        AutomaticHilight(AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_AutomaticHilight(self, *args)


    def MoveTo(self, *args):
        """
        MoveTo(AIS_LocalContext self, Standard_Integer const theXpix, Standard_Integer const theYpix, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> AIS_StatusOfDetection

        :type theXpix: int
        :type theYpix: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfDetection

        """
        return _AIS.AIS_LocalContext_MoveTo(self, *args)


    def HasNextDetected(self, *args):
        """
        HasNextDetected(AIS_LocalContext self) -> Standard_Boolean

        returns True if more than one entity
        was detected at the last Mouse position.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_HasNextDetected(self, *args)


    def HilightNextDetected(self, *args):
        """
        HilightNextDetected(AIS_LocalContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        returns True if  last detected. the next detected will
        be first one (endless loop)

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_LocalContext_HilightNextDetected(self, *args)


    def HilightPreviousDetected(self, *args):
        """
        HilightPreviousDetected(AIS_LocalContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_LocalContext_HilightPreviousDetected(self, *args)


    def UnhilightLastDetected(self, *args):
        """
        UnhilightLastDetected(AIS_LocalContext self, Handle_V3d_Viewer theViewer) -> Standard_Boolean
        UnhilightLastDetected(AIS_LocalContext self, Handle_V3d_View theView) -> Standard_Boolean

        returns True if something was done...

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_UnhilightLastDetected(self, *args)


    def AddSelect(self, *args):
        """
        AddSelect(AIS_LocalContext self, Handle_SelectMgr_EntityOwner theObject) -> AIS_StatusOfPick

        returns the number of selected

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.AIS_LocalContext_AddSelect(self, *args)


    def Select(self, *args):
        """
        Select(AIS_LocalContext self, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        Select(AIS_LocalContext self, Standard_Integer const XPMin, Standard_Integer const YPMin, Standard_Integer const XPMax, Standard_Integer const YPMax, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        Select(AIS_LocalContext self, NCollection_Array1_gp_Pnt2d Polyline, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick

        :type Polyline: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type aView: OCC.wrapper.V3d.Handle_V3d_View
        :type updateviewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.AIS_LocalContext_Select(self, *args)


    def ShiftSelect(self, *args):
        """
        ShiftSelect(AIS_LocalContext self, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        ShiftSelect(AIS_LocalContext self, Standard_Integer const XPMin, Standard_Integer const YPMin, Standard_Integer const XPMax, Standard_Integer const YPMax, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        ShiftSelect(AIS_LocalContext self, NCollection_Array1_gp_Pnt2d Polyline, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick

        :type Polyline: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type aView: OCC.wrapper.V3d.Handle_V3d_View
        :type updateviewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.AIS_LocalContext_ShiftSelect(self, *args)


    def HilightPicked(self, *args):
        """
        HilightPicked(AIS_LocalContext self, Standard_Boolean const updateviewer)

        :type updateviewer: bool

        """
        return _AIS.AIS_LocalContext_HilightPicked(self, *args)


    def UnhilightPicked(self, *args):
        """
        UnhilightPicked(AIS_LocalContext self, Standard_Boolean const updateviewer)

        :type updateviewer: bool

        """
        return _AIS.AIS_LocalContext_UnhilightPicked(self, *args)


    def UpdateSelected(self, *args):
        """
        UpdateSelected(AIS_LocalContext self, Standard_Boolean const updateviewer)
        UpdateSelected(AIS_LocalContext self, Handle_AIS_InteractiveObject anobj, Standard_Boolean const updateviewer)

        Part of advanced selection highlighting mechanism.
        If no owners belonging to anobj are selected, calls anobj->ClearSelected(),
        otherwise calls anobj->HilightSelected(). This method can be used to avoid
        redrawing the whole selection belonging to several Selectable Objects.

        :type anobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type updateviewer: bool

        """
        return _AIS.AIS_LocalContext_UpdateSelected(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(AIS_LocalContext self, Handle_AIS_InteractiveObject anobj, Standard_Boolean const updateviewer)

        useful  to  update selection with objects  coming from
        Collector or stack

        :type anobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type updateviewer: bool

        """
        return _AIS.AIS_LocalContext_SetSelected(self, *args)


    def AddOrRemoveSelected(self, *args):
        """
        AddOrRemoveSelected(AIS_LocalContext self, Handle_AIS_InteractiveObject anobj, Standard_Boolean const updateviewer)
        AddOrRemoveSelected(AIS_LocalContext self, TopoDS_Shape aShape, Standard_Boolean const updateviewer)
        AddOrRemoveSelected(AIS_LocalContext self, Handle_SelectMgr_EntityOwner theOwner, Standard_Boolean const toUpdateViewer)

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type toUpdateViewer: bool

        """
        return _AIS.AIS_LocalContext_AddOrRemoveSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(AIS_LocalContext self, Standard_Boolean const toUpdateViewer)

        Clears local context selection.
        @param toUpdateViewer [in] if TRUE the viewer will be updated.

        :type toUpdateViewer: bool

        """
        return _AIS.AIS_LocalContext_ClearSelected(self, *args)


    def ClearOutdatedSelection(self, *args):
        """
        ClearOutdatedSelection(AIS_LocalContext self, Handle_AIS_InteractiveObject theIO, Standard_Boolean const toClearDeactivated)

        Clears outdated selection and detection of owners for the
        interactive object. Use this method if selection structures
        of the interactive object have changed. The method unhilights
        and removes outdated entity owners from lists of selected
        and detected owners.
        @param theIO [in] the interactive object.
        @param toClearDeactivated [in] pass TRUE to treat deactivated
        entity owners as 'outdated' when clearing the selection.

        :type theIO: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type toClearDeactivated: bool

        """
        return _AIS.AIS_LocalContext_ClearOutdatedSelection(self, *args)


    def HasDetected(self, *args):
        """
        HasDetected(AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_HasDetected(self, *args)


    def InitDetected(self, *args):
        """
        InitDetected(AIS_LocalContext self)

        Initialization for iteration through mouse-detected objects in local context.


        """
        return _AIS.AIS_LocalContext_InitDetected(self, *args)


    def MoreDetected(self, *args):
        """
        MoreDetected(AIS_LocalContext self) -> Standard_Boolean

        @return true if there is more mouse-detected objects after the current one
        during iteration through mouse-detected interactive objects.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_MoreDetected(self, *args)


    def NextDetected(self, *args):
        """
        NextDetected(AIS_LocalContext self)

        Gets next current object during iteration through mouse-detected
        interactive objects.


        """
        return _AIS.AIS_LocalContext_NextDetected(self, *args)


    def DetectedCurrentOwner(self, *args):
        """
        DetectedCurrentOwner(AIS_LocalContext self) -> Handle_SelectMgr_EntityOwner

        @return current mouse-detected Owner or null object if there is no current detected.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_DetectedCurrentOwner(self, *args)


    def DetectedCurrentShape(self, *args):
        """
        @return current mouse-detected shape or empty (null) shape, if current interactive object
        is not a shape (AIS_Shape) or there is no current mouse-detected interactive object at all.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_LocalContext_DetectedCurrentShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DetectedCurrentObject(self, *args):
        """
        DetectedCurrentObject(AIS_LocalContext self) -> Handle_AIS_InteractiveObject

        @return current mouse-detected interactive object or null object if there is no current detected.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_DetectedCurrentObject(self, *args)


    def HasDetectedShape(self, *args):
        """
        HasDetectedShape(AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_HasDetectedShape(self, *args)


    def DetectedShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_LocalContext_DetectedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DetectedInteractive(self, *args):
        """
        DetectedInteractive(AIS_LocalContext self) -> Handle_AIS_InteractiveObject

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_DetectedInteractive(self, *args)


    def DetectedOwner(self, *args):
        """
        DetectedOwner(AIS_LocalContext self) -> Handle_SelectMgr_EntityOwner

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_DetectedOwner(self, *args)


    def InitSelected(self, *args):
        """InitSelected(AIS_LocalContext self)"""
        return _AIS.AIS_LocalContext_InitSelected(self, *args)


    def MoreSelected(self, *args):
        """
        MoreSelected(AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_MoreSelected(self, *args)


    def NextSelected(self, *args):
        """NextSelected(AIS_LocalContext self)"""
        return _AIS.AIS_LocalContext_NextSelected(self, *args)


    def HasShape(self, *args):
        """
        HasShape(AIS_LocalContext self) -> Standard_Boolean

        returns TRUE if the detected entity is a shape
        coming from a Decomposition of an element.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_HasShape(self, *args)


    def HasSelectedShape(self, *args):
        """
        HasSelectedShape(AIS_LocalContext self) -> Standard_Boolean

        returns true if current selection is not empty
        and the owner of selected object contains a shape.
        This method does not take into account decomposition
        status of detected shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_HasSelectedShape(self, *args)


    def SelectedShape(self, *args):
        """
        SelectedShape(AIS_LocalContext self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_LocalContext_SelectedShape(self, *args)


    def SelectedOwner(self, *args):
        """
        SelectedOwner(AIS_LocalContext self) -> Handle_SelectMgr_EntityOwner

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_SelectedOwner(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(AIS_LocalContext self, Handle_AIS_InteractiveObject aniobj) -> Standard_Boolean
        IsSelected(AIS_LocalContext self, Handle_SelectMgr_EntityOwner anOwner) -> Standard_Boolean

        :type anOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_IsSelected(self, *args)


    def SelectedInteractive(self, *args):
        """
        SelectedInteractive(AIS_LocalContext self) -> Handle_AIS_InteractiveObject

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_SelectedInteractive(self, *args)


    def HasApplicative(self, *args):
        """
        HasApplicative(AIS_LocalContext self) -> Standard_Boolean

        returns TRUE if an interactive element
        was associated with the current picked entity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_HasApplicative(self, *args)


    def SelectedApplicative(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.AIS_LocalContext_SelectedApplicative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayPriority(self, *args):
        """
        SetDisplayPriority(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject, Standard_Integer const Prior)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type Prior: int

        """
        return _AIS.AIS_LocalContext_SetDisplayPriority(self, *args)


    def DisplayedObjects(self, *args):
        """
        DisplayedObjects(AIS_LocalContext self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theMapToFill) -> Standard_Integer

        :type theMapToFill: OCC.wrapper.TColStd.TColStd_MapOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_LocalContext_DisplayedObjects(self, *args)


    def IsIn(self, *args):
        """
        IsIn(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_IsIn(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean
        IsDisplayed(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject, Standard_Integer const aMode) -> Standard_Boolean

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_IsDisplayed(self, *args)


    def SelectionModes(self, *args):
        """
        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.AIS_LocalContext_SelectionModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntensityOn(self, *args):
        """
        SubIntensityOn(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """
        SubIntensityOff(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_SubIntensityOff(self, *args)


    def Hilight(self, *args):
        """
        Hilight(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)
        Hilight(AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Handle_Prs3d_Drawer theStyle)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.AIS_LocalContext_Hilight(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.AIS_LocalContext_Unhilight(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(AIS_LocalContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_IsHilighted(self, *args)


    def HighlightStyle(self, *args):
        """
        HighlightStyle(AIS_LocalContext self, Handle_AIS_InteractiveObject theObject, Handle_Prs3d_Drawer theStyle) -> Standard_Boolean

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_HighlightStyle(self, *args)


    def SetPixelTolerance(self, *args):
        """
        SetPixelTolerance(AIS_LocalContext self, Standard_Integer const aPrecision=2)

        Define the current selection sensitivity for
        this local context according to the view size.

        :type aPrecision: int

        """
        return _AIS.AIS_LocalContext_SetPixelTolerance(self, *args)


    def PixelTolerance(self, *args):
        """
        PixelTolerance(AIS_LocalContext self) -> Standard_Integer

        Returns the pixel tolerance.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_LocalContext_PixelTolerance(self, *args)


    def SetSelectionSensitivity(self, *args):
        """
        SetSelectionSensitivity(AIS_LocalContext self, Handle_AIS_InteractiveObject theObject, Standard_Integer const theMode, Standard_Integer const theNewSensitivity)

        Allows to manage sensitivity of a particular selection of interactive object theObject
        and changes previous sensitivity value of all sensitive entities in selection with theMode
        to the given theNewSensitivity.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theNewSensitivity: int

        """
        return _AIS.AIS_LocalContext_SetSelectionSensitivity(self, *args)


    def BeginImmediateDraw(self, *args):
        """
        BeginImmediateDraw(AIS_LocalContext self) -> Standard_Boolean

        Resets the transient list of presentations previously displayed in immediate mode
        and begins accumulation of new list by following AddToImmediateList()/Color()/Highlight() calls.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_BeginImmediateDraw(self, *args)


    def ClearImmediateDraw(self, *args):
        """
        ClearImmediateDraw(AIS_LocalContext self)

        Resets the transient list of presentations previously displayed in immediate mode.


        """
        return _AIS.AIS_LocalContext_ClearImmediateDraw(self, *args)


    def ImmediateAdd(self, *args):
        """
        ImmediateAdd(AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode=0) -> Standard_Boolean

        Stores presentation theMode of object theObj in the transient list of presentations to be displayed in immediate mode.
        Will be taken in account in EndImmediateDraw method.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_ImmediateAdd(self, *args)


    def EndImmediateDraw(self, *args):
        """
        EndImmediateDraw(AIS_LocalContext self, Handle_V3d_Viewer theViewer) -> Standard_Boolean

        Allows rapid drawing of the view theView by avoiding an update of the whole background.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_EndImmediateDraw(self, *args)


    def IsImmediateModeOn(self, *args):
        """
        IsImmediateModeOn(AIS_LocalContext self) -> Standard_Boolean

        Returns true if Presentation Manager is accumulating transient list of presentations to be displayed in immediate mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalContext_IsImmediateModeOn(self, *args)


    def Status(self, *args):
        """
        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.AIS.Handle_AIS_LocalStatus

        """
        res = _AIS.AIS_LocalContext_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LoadContextObjects(self, *args):
        """LoadContextObjects(AIS_LocalContext self)"""
        return _AIS.AIS_LocalContext_LoadContextObjects(self, *args)


    def UnloadContextObjects(self, *args):
        """UnloadContextObjects(AIS_LocalContext self)"""
        return _AIS.AIS_LocalContext_UnloadContextObjects(self, *args)


    def DisplaySensitive(self, *args):
        """
        DisplaySensitive(AIS_LocalContext self, Handle_V3d_View aView)

        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.AIS_LocalContext_DisplaySensitive(self, *args)


    def ClearSensitive(self, *args):
        """
        ClearSensitive(AIS_LocalContext self, Handle_V3d_View aView)

        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.AIS_LocalContext_ClearSensitive(self, *args)


    def MainSelector(self, *args):
        """
        :rtype: OCC.wrapper.StdSelect.Handle_StdSelect_ViewerSelector3d

        """
        res = _AIS.AIS_LocalContext_MainSelector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindSelectedOwnerFromIO(self, *args):
        """
        FindSelectedOwnerFromIO(AIS_LocalContext self, Handle_AIS_InteractiveObject anIObj) -> Handle_SelectMgr_EntityOwner

        :type anIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_FindSelectedOwnerFromIO(self, *args)


    def FindSelectedOwnerFromShape(self, *args):
        """
        FindSelectedOwnerFromShape(AIS_LocalContext self, TopoDS_Shape aShape) -> Handle_SelectMgr_EntityOwner

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.AIS_LocalContext_FindSelectedOwnerFromShape(self, *args)


    def RestoreActivatedModes(self, *args):
        """
        RestoreActivatedModes(AIS_LocalContext self)

        Iterates through all interactive objects of local context and activates selection modes
        stored in local status


        """
        return _AIS.AIS_LocalContext_RestoreActivatedModes(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_LocalContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_LocalContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_LocalContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_LocalContext
AIS_LocalContext_swigregister = _AIS.AIS_LocalContext_swigregister
AIS_LocalContext_swigregister(AIS_LocalContext)

def AIS_LocalContext_get_type_name(*args):
    """
    AIS_LocalContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_LocalContext_get_type_name(*args)

def AIS_LocalContext_get_type_descriptor(*args):
    """
    AIS_LocalContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_LocalContext_get_type_descriptor(*args)

class Handle_AIS_InteractiveContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_InteractiveContext self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_InteractiveContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_InteractiveContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_InteractiveContext self, AIS_InteractiveContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_InteractiveContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveContext theHandle) -> Handle_AIS_InteractiveContext
        assign(Handle_AIS_InteractiveContext self, AIS_InteractiveContext thePtr) -> Handle_AIS_InteractiveContext
        assign(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveContext theHandle) -> Handle_AIS_InteractiveContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_InteractiveContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_InteractiveContext self) -> AIS_InteractiveContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_InteractiveContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_InteractiveContext self) -> AIS_InteractiveContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_InteractiveContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_InteractiveContext self) -> AIS_InteractiveContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_InteractiveContext___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_InteractiveContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_InteractiveContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_InteractiveContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_InteractiveContext_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_InteractiveContext

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_InteractiveContext self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_InteractiveContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_InteractiveContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_InteractiveContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DisplayStatus(self, *args):
        """
        DisplayStatus(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj) -> AIS_DisplayStatus

        Returns the display status of the entity anIobj.
        This will be one of the following:
        - AIS_DS_Displayed displayed in main viewer
        - AIS_DS_Erased    hidden in main viewer
        - AIS_DS_Temporary temporarily displayed
        - AIS_DS_None      nowhere displayed.

        :type anIobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.Handle_AIS_InteractiveContext_DisplayStatus(self, *args)


    def Status(self, *args):
        """
        Status(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObj, TCollection_ExtendedString astatus)

        Returns the status of the Interactive Context for the view of the Interactive Object.

        :type anObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type astatus: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_InteractiveContext_Status(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj) -> Standard_Boolean
        IsDisplayed(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Standard_Integer const aMode) -> Standard_Boolean

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsDisplayed(self, *args)


    def SetAutoActivateSelection(self, *args):
        """
        SetAutoActivateSelection(Handle_AIS_InteractiveContext self, Standard_Boolean const theIsAuto)

        Enable or disable automatic activation of default selection mode while displaying the object.

        :type theIsAuto: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetAutoActivateSelection(self, *args)


    def GetAutoActivateSelection(self, *args):
        """
        GetAutoActivateSelection(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Manages displaying the new object should also automatically activate default selection mode; TRUE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_GetAutoActivateSelection(self, *args)


    def Display(self, *args):
        """
        Display(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)
        Display(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theDispMode, Standard_Integer const theSelectionMode, Standard_Boolean const theToUpdateViewer, Standard_Boolean const theToAllowDecomposition, AIS_DisplayStatus const theDispStatus=AIS_DS_None)

        Sets status, display mode and selection mode for specified Object
        If theSelectionMode equals -1, theIObj will not be activated: it will be displayed but will not be selectable.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theDispMode: int
        :type theSelectionMode: int
        :type theToUpdateViewer: bool
        :type theToAllowDecomposition: bool
        :type theDispStatus: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.Handle_AIS_InteractiveContext_Display(self, *args)


    def Load(self, *args):
        """
        Load(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Standard_Integer const SelectionMode=-1, Standard_Boolean const AllowDecomp)

        Allows you to load the Interactive Object with a given selection mode,
        and/or with the desired decomposition option, whether the object is visualized or not.
        If AllowDecomp = Standard_True and, if the interactive object is of the "Shape" type,
        these "standard" selection modes will be automatically activated as a function of the modes present in the Local Context.
        The loaded objects will be selectable but displayable in highlighting only when detected by the Selector.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type SelectionMode: int
        :type AllowDecomp: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Load(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Hides the object. The object's presentations are simply flagged as invisible and therefore excluded from redrawing.
        To show hidden objects, use Display().

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Erase(self, *args)


    def EraseAll(self, *args):
        """
        EraseAll(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Hides all objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing.
        To show all hidden objects, use DisplayAll().

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_EraseAll(self, *args)


    def DisplayAll(self, *args):
        """
        DisplayAll(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Displays all hidden objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_DisplayAll(self, *args)


    def EraseSelected(self, *args):
        """
        EraseSelected(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Hides selected objects. The object's presentations are simply flagged as invisible and therefore excluded from redrawing.
        To show hidden objects, use Display().

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_EraseSelected(self, *args)


    def DisplaySelected(self, *args):
        """
        DisplaySelected(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Displays current objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_DisplaySelected(self, *args)


    def ClearPrs(self, *args):
        """
        ClearPrs(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode, Standard_Boolean const theToUpdateViewer)

        Empties the graphic presentation of the mode indexed by aMode.
        Warning! Removes theIObj. theIObj is still active if it was previously activated.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_ClearPrs(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes Object from every viewer.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Remove(self, *args)


    def RemoveAll(self, *args):
        """
        RemoveAll(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes all the objects from Context.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_RemoveAll(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer, Standard_Boolean const theAllModes)
        Redisplay(Handle_AIS_InteractiveContext self, AIS_KindOfInteractive const theTypeOfObject, Standard_Integer const theSignature, Standard_Boolean const theToUpdateViewer)

        Recomputes the Prs/Selection of displayed objects of a given type and a given signature.
        if signature = -1  doesn't take signature criterion.

        :type theTypeOfObject: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type theSignature: int
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Redisplay(self, *args)


    def RecomputePrsOnly(self, *args):
        """
        RecomputePrsOnly(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer, Standard_Boolean const theAllModes)

        Recomputes the displayed presentations, flags the others.
        Doesn't update presentations.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool
        :type theAllModes: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_RecomputePrsOnly(self, *args)


    def RecomputeSelectionOnly(self, *args):
        """
        RecomputeSelectionOnly(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIObj)

        Recomputes the active selections, flags the others.
        Doesn't update presentations.

        :type anIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_RecomputeSelectionOnly(self, *args)


    def Update(self, *args):
        """
        Update(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theUpdateViewer)

        Updates displayed interactive object by checking and recomputing its flagged as "to be recomputed" presentation and selection structures.
        This method does not force any recomputation on its own.
        The method recomputes selections even if they are loaded without activation in particular selector.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Update(self, *args)


    def HighlightStyle(self, *args):
        """
        Returns current dynamic highlight style settings.
        By default:
        - the color of dynamic highlight is Quantity_NOC_CYAN1;
        - the presentation for dynamic highlight is completely opaque;
        - the type of highlight is Aspect_TOHM_COLOR.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_InteractiveContext_HighlightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHighlightStyle(self, *args):
        """
        SetHighlightStyle(Handle_AIS_InteractiveContext self, Prs3d_TypeOfHighlight const theStyleType, Handle_Prs3d_Drawer theStyle)
        SetHighlightStyle(Handle_AIS_InteractiveContext self, Handle_Prs3d_Drawer theStyle)

        Setup the style of dynamic highlighting.

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_InteractiveContext_SetHighlightStyle(self, *args)


    def SelectionStyle(self, *args):
        """
        Returns current selection style settings.
        By default:
        - the color of selection is Quantity_NOC_GRAY80;
        - the presentation for selection is completely opaque;
        - the type of highlight is Aspect_TOHM_COLOR.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_InteractiveContext_SelectionStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSelectionStyle(self, *args):
        """
        SetSelectionStyle(Handle_AIS_InteractiveContext self, Handle_Prs3d_Drawer theStyle)

        Setup the style of selection highlighting.

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_InteractiveContext_SetSelectionStyle(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj) -> Standard_Boolean
        IsHilighted(Handle_AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwner) -> Standard_Boolean

        Returns true if the owner is marked as selected
        @param theOwner [in] the owner to check

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsHilighted(self, *args)


    def Hilight(self, *args):
        """
        Hilight(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Boolean const theIsToUpdateViewer)

        Updates the display in the viewer to take dynamic detection into account.
        On dynamic detection by the mouse cursor, sensitive primitives are highlighted.
        The highlight color of entities detected by mouse movement is white by default.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theIsToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Hilight(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Handle_Prs3d_Drawer theStyle, Standard_Boolean const theToUpdateViewer)

        Changes the color of all the lines of the object in view.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes hilighting from the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Unhilight(self, *args)


    def DisplayPriority(self, *args):
        """
        DisplayPriority(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj) -> Standard_Integer

        Returns the display priority of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_DisplayPriority(self, *args)


    def SetDisplayPriority(self, *args):
        """
        SetDisplayPriority(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const thePriority)

        Sets the display priority of the seen parts presentation of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type thePriority: int

        """
        return _AIS.Handle_AIS_InteractiveContext_SetDisplayPriority(self, *args)


    def GetZLayer(self, *args):
        """
        GetZLayer(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj) -> Graphic3d_ZLayerId

        Get Z layer id set for displayed interactive object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_InteractiveContext_GetZLayer(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Graphic3d_ZLayerId const theLayerId)

        Set Z layer id for interactive object.
        The Z layers can be used to display temporarily presentations of some object in front of the other objects in the scene.
        The ids for Z layers are generated by V3d_Viewer.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_InteractiveContext_SetZLayer(self, *args)


    def SetViewAffinity(self, *args):
        """
        SetViewAffinity(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Handle_V3d_View theView, Standard_Boolean const theIsVisible)

        Setup object visibility in specified view.
        Has no effect if object is not displayed in this context.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theIsVisible: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetViewAffinity(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_InteractiveContext self) -> Standard_Integer

        Returns the Display Mode setting to be used by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_DisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_InteractiveContext self, Standard_Integer const theMode, Standard_Boolean const theToUpdateViewer)
        SetDisplayMode(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode, Standard_Boolean const theToUpdateViewer)

        Sets the display mode of seen Interactive Objects.
        theMode provides the display mode index of the entity theIObj.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Unsets the display mode of seen Interactive Objects.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnsetDisplayMode(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, TopLoc_Location theLocation)

        Puts the location on the initial graphic representation and the selection for the Object.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_InteractiveContext_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """
        ResetLocation(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject)

        Puts the Object back into its initial position.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_ResetLocation(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> Standard_Boolean

        Returns true if the Object has a location.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> TopLoc_Location

        Returns the location of the Object.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_InteractiveContext_Location(self, *args)


    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Graphic3d_TransModeFlags const & theFlag, gp_Pnt thePoint)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theFlag: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_InteractiveContext_SetTransformPersistence(self, *args)


    def SetPixelTolerance(self, *args):
        """
        SetPixelTolerance(Handle_AIS_InteractiveContext self, Standard_Integer const thePrecision=2)

        Setup pixel tolerance for MoveTo() operation.
        @sa MoveTo().

        :type thePrecision: int

        """
        return _AIS.Handle_AIS_InteractiveContext_SetPixelTolerance(self, *args)


    def PixelTolerance(self, *args):
        """
        PixelTolerance(Handle_AIS_InteractiveContext self) -> Standard_Integer

        Returns the pixel tolerance, default is 2.
        Pixel Tolerance extends sensitivity within MoveTo() operation (picking by point)
        and can be adjusted by application based on user input precision (e.g. screen pixel density, input device precision, etc.).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_PixelTolerance(self, *args)


    def SetSelectionSensitivity(self, *args):
        """
        SetSelectionSensitivity(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Standard_Integer const theMode, Standard_Integer const theNewSensitivity)

        Allows to manage sensitivity of a particular selection of interactive object theObject
        and changes previous sensitivity value of all sensitive entities in selection with theMode
        to the given theNewSensitivity.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theNewSensitivity: int

        """
        return _AIS.Handle_AIS_InteractiveContext_SetSelectionSensitivity(self, *args)


    def MoveTo(self, *args):
        """
        MoveTo(Handle_AIS_InteractiveContext self, Standard_Integer const theXPix, Standard_Integer const theYPix, Handle_V3d_View theView, Standard_Boolean const theToRedrawOnUpdate) -> AIS_StatusOfDetection

        Relays mouse position in pixels theXPix and theYPix to the interactive context selectors.
        This is done by the view theView passing this position to the main viewer and updating it.
        If theToRedrawOnUpdate is set to false, callee should call RedrawImmediate() to highlight detected object.
        @sa PickingStrategy()

        :type theXPix: int
        :type theYPix: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawOnUpdate: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfDetection

        """
        return _AIS.Handle_AIS_InteractiveContext_MoveTo(self, *args)


    def ClearDetected(self, *args):
        """
        ClearDetected(Handle_AIS_InteractiveContext self, Standard_Boolean theToRedrawImmediate) -> Standard_Boolean

        Clears the list of entities detected by MoveTo() and resets dynamic highlighting.
        @param theToRedrawImmediate if TRUE, the main Viewer will be redrawn on update
        @return TRUE if viewer needs to be updated (e.g. there were actually dynamically highlighted entities)

        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_ClearDetected(self, *args)


    def HasDetected(self, *args):
        """
        HasDetected(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is a mouse-detected entity in context.
        @sa DetectedOwner()/HasNextDetected()/HilightPreviousDetected()/HilightNextDetected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasDetected(self, *args)


    def DetectedOwner(self, *args):
        """
        DetectedOwner(Handle_AIS_InteractiveContext self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of the detected sensitive primitive which is currently dynamically highlighted.
        WARNING! This method is irrelevant to InitDetected()/MoreDetected()/NextDetected().
        @sa HasDetected()/HasNextDetected()/HilightPreviousDetected()/HilightNextDetected().

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_InteractiveContext_DetectedOwner(self, *args)


    def DetectedInteractive(self, *args):
        """
        DetectedInteractive(Handle_AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Returns the interactive objects last detected in context.
        In general this is just a wrapper for Handle(AIS_InteractiveObject)::DownCast(DetectedOwner()->Selectable()).
        @sa DetectedOwner()

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_DetectedInteractive(self, *args)


    def HasDetectedShape(self, *args):
        """
        HasDetectedShape(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is a detected shape in local context.
        @sa HasDetected()/DetectedShape()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasDetectedShape(self, *args)


    def DetectedShape(self, *args):
        """
        Returns the shape detected in local context.
        @sa DetectedOwner()

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_InteractiveContext_DetectedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasNextDetected(self, *args):
        """
        HasNextDetected(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        returns True if other entities were detected in the last mouse detection
        @sa HilightPreviousDetected()/HilightNextDetected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasNextDetected(self, *args)


    def HilightNextDetected(self, *args):
        """
        HilightNextDetected(Handle_AIS_InteractiveContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        If more than 1 object is detected by the selector, only the "best" owner is hilighted at the mouse position.
        This Method allows the user to hilight one after another the other detected entities.
        If The method select is called, the selected entity will be the hilighted one!
        WARNING: Loop Method. When all the detected entities have been hilighted, the next call will hilight the first one again.
        @return the Rank of hilighted entity
        @sa HasNextDetected()/HilightPreviousDetected().

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_HilightNextDetected(self, *args)


    def HilightPreviousDetected(self, *args):
        """
        HilightPreviousDetected(Handle_AIS_InteractiveContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        Same as previous methods in reverse direction.
        @sa HasNextDetected()/HilightNextDetected().

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_HilightPreviousDetected(self, *args)


    def InitDetected(self, *args):
        """
        InitDetected(Handle_AIS_InteractiveContext self)

        Initialization for iteration through mouse-detected objects in
        interactive context or in local context if it is opened.
        @sa DetectedCurrentOwner()/MoreDetected()/NextDetected().


        """
        return _AIS.Handle_AIS_InteractiveContext_InitDetected(self, *args)


    def MoreDetected(self, *args):
        """
        MoreDetected(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Return TRUE if there is more mouse-detected objects after the current one
        during iteration through mouse-detected interactive objects.
        @sa DetectedCurrentOwner()/InitDetected()/NextDetected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_MoreDetected(self, *args)


    def NextDetected(self, *args):
        """
        NextDetected(Handle_AIS_InteractiveContext self)

        Gets next current object during iteration through mouse-detected interactive objects.
        @sa DetectedCurrentOwner()/InitDetected()/MoreDetected().


        """
        return _AIS.Handle_AIS_InteractiveContext_NextDetected(self, *args)


    def DetectedCurrentOwner(self, *args):
        """
        DetectedCurrentOwner(Handle_AIS_InteractiveContext self) -> Handle_SelectMgr_EntityOwner

        Returns the owner from detected list pointed by current iterator position.
        WARNING! This method is irrelevant to DetectedOwner() which returns last picked Owner regardless of iterator position!
        @sa InitDetected()/MoreDetected()/NextDetected().

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_InteractiveContext_DetectedCurrentOwner(self, *args)


    def SetSelectedAspect(self, *args):
        """
        SetSelectedAspect(Handle_AIS_InteractiveContext self, Handle_Prs3d_BasicAspect theAspect, Standard_Boolean const theToUpdateViewer)

        Sets the graphic basic aspect to the current presentation of ALL selected objects.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetSelectedAspect(self, *args)


    def AddSelect(self, *args):
        """
        AddSelect(Handle_AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theObject) -> AIS_StatusOfPick
        AddSelect(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> AIS_StatusOfPick

        Adds object in the selection.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.Handle_AIS_InteractiveContext_AddSelect(self, *args)


    def Select(self, *args):
        """
        Select(Handle_AIS_InteractiveContext self, Standard_Integer const theXPMin, Standard_Integer const theYPMin, Standard_Integer const theXPMax, Standard_Integer const theYPMax, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        Select(Handle_AIS_InteractiveContext self, NCollection_Array1_gp_Pnt2d thePolyline, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        Select(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick

        Stores and hilights the previous detected; Unhilights the previous picked.
        @sa MoveTo().

        :type theToUpdateViewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.Handle_AIS_InteractiveContext_Select(self, *args)


    def ShiftSelect(self, *args):
        """
        ShiftSelect(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        ShiftSelect(Handle_AIS_InteractiveContext self, NCollection_Array1_gp_Pnt2d thePolyline, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick
        ShiftSelect(Handle_AIS_InteractiveContext self, Standard_Integer const theXPMin, Standard_Integer const theYPMin, Standard_Integer const theXPMax, Standard_Integer const theYPMax, Handle_V3d_View theView, Standard_Boolean const theToUpdateViewer) -> AIS_StatusOfPick

        Rectangle of selection; adds new detected entities into the picked list,
        removes the detected entities that were already stored.

        :type theXPMin: int
        :type theYPMin: int
        :type theXPMax: int
        :type theYPMax: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToUpdateViewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.Handle_AIS_InteractiveContext_ShiftSelect(self, *args)


    def FitSelected(self, *args):
        """
        FitSelected(Handle_AIS_InteractiveContext self, Handle_V3d_View theView, Standard_Real const theMargin, Standard_Boolean const theToUpdate)
        FitSelected(Handle_AIS_InteractiveContext self, Handle_V3d_View theView)

        Fits the view correspondingly to the bounds of selected objects.
        Infinite objects are ignored if infinite state of AIS_InteractiveObject is set to true.

        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.Handle_AIS_InteractiveContext_FitSelected(self, *args)


    def SetToHilightSelected(self, *args):
        """
        SetToHilightSelected(Handle_AIS_InteractiveContext self, Standard_Boolean const toHilight)

        Specify whether selected object must be hilighted when mouse cursor is moved above it (in MoveTo method).
        By default this value is false and selected object is not hilighted in this case.

        :type toHilight: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetToHilightSelected(self, *args)


    def ToHilightSelected(self, *args):
        """
        ToHilightSelected(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Return value specified whether selected object must be hilighted when mouse cursor is moved above it

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_ToHilightSelected(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwners, Standard_Boolean const theToUpdateViewer)
        SetSelected(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const theToUpdateViewer)

        Puts the interactive object aniObj in the list of selected objects.
        Performs selection filters check.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetSelected(self, *args)


    def AddOrRemoveSelected(self, *args):
        """
        AddOrRemoveSelected(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const theToUpdateViewer)
        AddOrRemoveSelected(Handle_AIS_InteractiveContext self, TopoDS_Shape theShape, Standard_Boolean const theToUpdateViewer)
        AddOrRemoveSelected(Handle_AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwner, Standard_Boolean const theToUpdateViewer)

        Allows to highlight or unhighlight the owner given depending on its selection status

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_AddOrRemoveSelected(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Highlights selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_HilightSelected(self, *args)


    def UnhilightSelected(self, *args):
        """
        UnhilightSelected(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes highlighting from selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnhilightSelected(self, *args)


    def UpdateSelected(self, *args):
        """
        UpdateSelected(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Updates the list of selected objects:
        i.e. highlights the newly selected ones and unhighlights previously selected objects.
        @sa HilightSelected().

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UpdateSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Empties previous selected objects in order to get the selected objects detected by the selector using UpdateSelected.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_ClearSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_AIS_InteractiveContext self, Handle_SelectMgr_EntityOwner theOwner) -> Standard_Boolean
        IsSelected(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj) -> Standard_Boolean

        Returns true is the object given is selected

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsSelected(self, *args)


    def FirstSelectedObject(self, *args):
        """
        FirstSelectedObject(Handle_AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Returns the first selected object in the list of current selected.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_FirstSelectedObject(self, *args)


    def NbSelected(self, *args):
        """
        NbSelected(Handle_AIS_InteractiveContext self) -> Standard_Integer

        Count a number of selected entities using InitSelected()+MoreSelected()+NextSelected() iterator.
        @sa SelectedOwner()/InitSelected()/MoreSelected()/NextSelected().

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_NbSelected(self, *args)


    def InitSelected(self, *args):
        """
        InitSelected(Handle_AIS_InteractiveContext self)

        Initializes a scan of the selected objects.
        @sa SelectedOwner()/MoreSelected()/NextSelected().


        """
        return _AIS.Handle_AIS_InteractiveContext_InitSelected(self, *args)


    def MoreSelected(self, *args):
        """
        MoreSelected(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is another object found by the scan of the list of selected objects.
        @sa SelectedOwner()/InitSelected()/NextSelected().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_MoreSelected(self, *args)


    def NextSelected(self, *args):
        """
        NextSelected(Handle_AIS_InteractiveContext self)

        Continues the scan to the next object in the list of selected objects.
        @sa SelectedOwner()/InitSelected()/MoreSelected().


        """
        return _AIS.Handle_AIS_InteractiveContext_NextSelected(self, *args)


    def SelectedOwner(self, *args):
        """
        SelectedOwner(Handle_AIS_InteractiveContext self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of the selected entity.
        @sa InitSelected()/MoreSelected()/NextSelected().

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_InteractiveContext_SelectedOwner(self, *args)


    def SelectedInteractive(self, *args):
        """
        SelectedInteractive(Handle_AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Return Handle(AIS_InteractiveObject)::DownCast (SelectedOwner()->Selectable()).
        @sa SelectedOwner().

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_SelectedInteractive(self, *args)


    def HasSelectedShape(self, *args):
        """
        HasSelectedShape(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns TRUE if the interactive context has a shape selected.
        @sa SelectedShape().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasSelectedShape(self, *args)


    def SelectedShape(self, *args):
        """
        SelectedShape(Handle_AIS_InteractiveContext self) -> TopoDS_Shape

        Returns the selected shape.
        Basically it is just a shape returned stored by StdSelect_BRepOwner with graphic transformation being applied:
        @code
        const Handle(StdSelect_BRepOwner) aBRepOwner = Handle(StdSelect_BRepOwner)::DownCast (SelectedOwner());
        TopoDS_Shape aSelShape     = aBRepOwner->Shape();
        TopoDS_Shape aLocatedShape = aSelShape.Located (aBRepOwner->Location() * aSelShape.Location());
        @endcode
        @sa SelectedOwner()/HasSelectedShape().

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_InteractiveContext_SelectedShape(self, *args)


    def HasApplicative(self, *args):
        """
        HasApplicative(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns SelectedInteractive()->HasOwner().
        @sa SelectedOwner().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasApplicative(self, *args)


    def Applicative(self, *args):
        """
        Applicative(Handle_AIS_InteractiveContext self) -> Handle_Standard_Transient

        Returns SelectedInteractive()->GetOwner().
        @sa SelectedOwner().

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_InteractiveContext_Applicative(self, *args)


    def BeginImmediateDraw(self, *args):
        """
        BeginImmediateDraw(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        initializes the list of presentations to be displayed
        returns False if no local context is opened.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_BeginImmediateDraw(self, *args)


    def ImmediateAdd(self, *args):
        """
        ImmediateAdd(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode=0) -> Standard_Boolean

        returns True if <anIObj> has been stored in the list.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_ImmediateAdd(self, *args)


    def EndImmediateDraw(self, *args):
        """
        EndImmediateDraw(Handle_AIS_InteractiveContext self, Handle_V3d_View theView) -> Standard_Boolean
        EndImmediateDraw(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Uses the First Active View of Main Viewer!
        returns True if the immediate display has been done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_EndImmediateDraw(self, *args)


    def IsImmediateModeOn(self, *args):
        """
        IsImmediateModeOn(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsImmediateModeOn(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(Handle_AIS_InteractiveContext self, Handle_V3d_Viewer theViewer)

        Redraws immediate structures in all views of the viewer given taking into account its visibility.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        return _AIS.Handle_AIS_InteractiveContext_RedrawImmediate(self, *args)


    def SetSelectionModeActive(self, *args):
        """
        SetSelectionModeActive(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode, Standard_Boolean const theToActivate, AIS_SelectionModesConcurrency const theConcurrency=AIS_SelectionModesConcurrency_Multiple, Standard_Boolean const theIsForce)

        Activates or deactivates the selection mode for specified object.
        Has no effect if selection mode was already active/deactivated.
        @param theObj         object to activate/deactivate selection mode
        @param theMode        selection mode to activate/deactivate;
        deactivation of -1 selection mode will effectively deactivate all selection modes;
        activation of -1 selection mode with AIS_SelectionModesConcurrency_Single
        will deactivate all selection modes, and will has no effect otherwise
        @param theToActivate  activation/deactivation flag
        @param theConcurrency specifies how to handle already activated selection modes;
        default value (AIS_SelectionModesConcurrency_Multiple) means active selection modes should be left as is,
        AIS_SelectionModesConcurrency_Single can be used if only one selection mode is expected to be active
        and AIS_SelectionModesConcurrency_GlobalOrLocal can be used if either AIS_InteractiveObject::GlobalSelectionMode()
        or any combination of Local selection modes is acceptable;
        this value is considered only if theToActivate set to TRUE
        @param theIsForce     when set to TRUE, the display status will be ignored while activating selection mode

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theToActivate: bool
        :type theConcurrency: OCC.wrapper.AIS.AIS_SelectionModesConcurrency
        :type theIsForce: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetSelectionModeActive(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode=0, Standard_Boolean const theIsForce)
        Activate(Handle_AIS_InteractiveContext self, Standard_Integer const theMode, Standard_Boolean const theIsForce)

        Activates the given selection mode for the all displayed objects.

        :type theMode: int
        :type theIsForce: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_Activate(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj)
        Deactivate(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode)
        Deactivate(Handle_AIS_InteractiveContext self, Standard_Integer const theMode)
        Deactivate(Handle_AIS_InteractiveContext self)

        Deactivates all the activated selection mode at all displayed objects.


        """
        return _AIS.Handle_AIS_InteractiveContext_Deactivate(self, *args)


    def ActivatedModes(self, *args):
        """
        ActivatedModes(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj, NCollection_List_Standard_Integer theList)

        Returns the list of activated selection modes.

        :type anIobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theList: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_InteractiveContext_ActivatedModes(self, *args)


    def EntityOwners(self, *args):
        """
        EntityOwners(Handle_AIS_InteractiveContext self, opencascade::handle< SelectMgr_IndexedMapOfOwner > & theOwners, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode=-1)

        Returns a collection containing all entity owners created for the interactive object in specified selection mode (in all active modes if the Mode == -1)

        :type theOwners: OCC.wrapper.AIS.Handle_SelectMgr_IndexedMapOfOwner
        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int

        """
        return _AIS.Handle_AIS_InteractiveContext_EntityOwners(self, *args)


    def Filters(self, *args):
        """
        Returns the list of filters active in a local context.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _AIS.Handle_AIS_InteractiveContext_Filters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddFilter(self, *args):
        """
        AddFilter(Handle_AIS_InteractiveContext self, Handle_SelectMgr_Filter theFilter)

        Allows you to add the filter.

        :type theFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.Handle_AIS_InteractiveContext_AddFilter(self, *args)


    def RemoveFilter(self, *args):
        """
        RemoveFilter(Handle_AIS_InteractiveContext self, Handle_SelectMgr_Filter theFilter)

        Removes a filter from context.

        :type theFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.Handle_AIS_InteractiveContext_RemoveFilter(self, *args)


    def RemoveFilters(self, *args):
        """
        RemoveFilters(Handle_AIS_InteractiveContext self)

        Remove all filters from context.


        """
        return _AIS.Handle_AIS_InteractiveContext_RemoveFilters(self, *args)


    def PickingStrategy(self, *args):
        """
        PickingStrategy(Handle_AIS_InteractiveContext self) -> SelectMgr_PickingStrategy

        Return picking strategy; SelectMgr_PickingStrategy_FirstAcceptable by default.
        @sa MoveTo()/Filters()

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_PickingStrategy

        """
        return _AIS.Handle_AIS_InteractiveContext_PickingStrategy(self, *args)


    def SetPickingStrategy(self, *args):
        """
        SetPickingStrategy(Handle_AIS_InteractiveContext self, SelectMgr_PickingStrategy const theStrategy)

        Setup picking strategy - which entities detected by picking line will be accepted, considering Selection Filters.
        By default (SelectMgr_PickingStrategy_FirstAcceptable), Selection Filters reduce the list of entities
        so that the context accepts topmost in remaining.

        This means that entities behind non-selectable (by filters) parts can be picked by user.
        If this behavior is undesirable, and user wants that non-selectable (by filters) parts
        should remain an obstacle for picking, SelectMgr_PickingStrategy_OnlyTopmost can be set instead.

        Notice, that since Selection Manager operates only objects registered in it,
        SelectMgr_PickingStrategy_OnlyTopmost will NOT prevent picking entities behind
        visible by unregistered in Selection Manager presentations (e.g. deactivated).
        Hence, SelectMgr_PickingStrategy_OnlyTopmost changes behavior only with Selection Filters enabled.

        :type theStrategy: OCC.wrapper.SelectMgr.SelectMgr_PickingStrategy

        """
        return _AIS.Handle_AIS_InteractiveContext_SetPickingStrategy(self, *args)


    def DefaultDrawer(self, *args):
        """
        Returns the default attribute manager.
        This contains all the color and line attributes which can be used by interactive objects which do not have their own attributes.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_InteractiveContext_DefaultDrawer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentViewer(self, *args):
        """
        Returns the current viewer.

        :rtype: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        res = _AIS.Handle_AIS_InteractiveContext_CurrentViewer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SelectionManager(self, *args):
        """
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectionManager

        """
        res = _AIS.Handle_AIS_InteractiveContext_SelectionManager(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MainPrsMgr(self, *args):
        """
        :rtype: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d

        """
        res = _AIS.Handle_AIS_InteractiveContext_MainPrsMgr(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MainSelector(self, *args):
        """
        :rtype: OCC.wrapper.StdSelect.Handle_StdSelect_ViewerSelector3d

        """
        res = _AIS.Handle_AIS_InteractiveContext_MainSelector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateCurrentViewer(self, *args):
        """
        UpdateCurrentViewer(Handle_AIS_InteractiveContext self)

        Updates the current viewer.


        """
        return _AIS.Handle_AIS_InteractiveContext_UpdateCurrentViewer(self, *args)


    def DisplayedObjects(self, *args):
        """
        DisplayedObjects(Handle_AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject aListOfIO, Standard_Boolean const OnlyFromNeutral)
        DisplayedObjects(Handle_AIS_InteractiveContext self, AIS_KindOfInteractive const WhichKind, Standard_Integer const WhichSignature, NCollection_List_Handle_AIS_InteractiveObject aListOfIO, Standard_Boolean const OnlyFromNeutral)

        gives the list of displayed objects of a particular Type and signature.
        by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int
        :type aListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive
        :type OnlyFromNeutral: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_DisplayedObjects(self, *args)


    def ErasedObjects(self, *args):
        """
        ErasedObjects(Handle_AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)
        ErasedObjects(Handle_AIS_InteractiveContext self, AIS_KindOfInteractive const WhichKind, Standard_Integer const WhichSignature, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)

        gives the list of erased objects (hidden objects)
        Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int
        :type theListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive

        """
        return _AIS.Handle_AIS_InteractiveContext_ErasedObjects(self, *args)


    def ObjectsByDisplayStatus(self, *args):
        """
        ObjectsByDisplayStatus(Handle_AIS_InteractiveContext self, AIS_DisplayStatus const theStatus, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)
        ObjectsByDisplayStatus(Handle_AIS_InteractiveContext self, AIS_KindOfInteractive const WhichKind, Standard_Integer const WhichSignature, AIS_DisplayStatus const theStatus, NCollection_List_Handle_AIS_InteractiveObject theListOfIO)

        gives the list of objects with indicated display status
        Type and signature by Default, <WhichSignature> = -1 means control only on <WhichKind>.

        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int
        :type theStatus: OCC.wrapper.AIS.AIS_DisplayStatus
        :type theListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive

        """
        return _AIS.Handle_AIS_InteractiveContext_ObjectsByDisplayStatus(self, *args)


    def ObjectsInside(self, *args):
        """
        ObjectsInside(Handle_AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject aListOfIO, AIS_KindOfInteractive const WhichKind=AIS_KOI_None, Standard_Integer const WhichSignature=-1)

        fills <aListOfIO> with objects of a particular Type and Signature with no consideration of display status.
        by Default, <WhichSignature> = -1 means control only on <WhichKind>.
        if <WhichKind> = AIS_KOI_None and <WhichSignature> = -1, all the objects are put into the list.

        :type aListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive
        :type WhichKind: OCC.wrapper.AIS.AIS_KindOfInteractive
        :type WhichSignature: int

        """
        return _AIS.Handle_AIS_InteractiveContext_ObjectsInside(self, *args)


    def RebuildSelectionStructs(self, *args):
        """
        RebuildSelectionStructs(Handle_AIS_InteractiveContext self)

        Rebuilds 1st level of BVH selection forcibly


        """
        return _AIS.Handle_AIS_InteractiveContext_RebuildSelectionStructs(self, *args)


    def Disconnect(self, *args):
        """
        Disconnect(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theAssembly, Handle_AIS_InteractiveObject theObjToDisconnect=0)

        Disconnects theObjToDisconnect from theAssembly and removes dependent selection structures

        :type theAssembly: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theObjToDisconnect: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_Disconnect(self, *args)


    def ObjectsForView(self, *args):
        """
        ObjectsForView(Handle_AIS_InteractiveContext self, NCollection_List_Handle_AIS_InteractiveObject theListOfIO, Handle_V3d_View theView, Standard_Boolean const theIsVisibleInView, AIS_DisplayStatus const theStatus=AIS_DS_None)

        Query objects visible or hidden in specified view due to affinity mask.

        :type theListOfIO: OCC.wrapper.AIS.AIS_ListOfInteractive
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theIsVisibleInView: bool
        :type theStatus: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.Handle_AIS_InteractiveContext_ObjectsForView(self, *args)


    def PurgeDisplay(self, *args):
        """
        PurgeDisplay(Handle_AIS_InteractiveContext self) -> Standard_Integer

        Clears all the structures which don't belong to objects displayed at neutral point
        only effective when no Local Context is opened...
        returns the number of removed  structures from the viewers.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_PurgeDisplay(self, *args)


    def DisplayActiveSensitive(self, *args):
        """
        DisplayActiveSensitive(Handle_AIS_InteractiveContext self, Handle_V3d_View aView)
        DisplayActiveSensitive(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObject, Handle_V3d_View aView)

        Visualization of sensitives - for debugging purposes!

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.Handle_AIS_InteractiveContext_DisplayActiveSensitive(self, *args)


    def ClearActiveSensitive(self, *args):
        """
        ClearActiveSensitive(Handle_AIS_InteractiveContext self, Handle_V3d_View aView)

        Clear visualization of sensitives.

        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.Handle_AIS_InteractiveContext_ClearActiveSensitive(self, *args)


    def SetLocalAttributes(self, *args):
        """
        SetLocalAttributes(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theToUpdateViewer)

        Sets the graphic attributes of the interactive object, such as visualization mode, color, and material.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetLocalAttributes(self, *args)


    def UnsetLocalAttributes(self, *args):
        """
        UnsetLocalAttributes(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the settings for local attributes of the Object and returns to defaults.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnsetLocalAttributes(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for SetColor(), SetTransparency(), SetMaterial() methods default facing model is Aspect_TOFM_TWO_SIDE.
        This mean that attributes is applying both on the front and back face.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_InteractiveContext_SetCurrentFacingModel(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj) -> Standard_Boolean

        Returns true if a view of the Interactive Object has color.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj, Quantity_Color acolor)

        Returns the color of the Object in the interactive context.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type acolor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_InteractiveContext_Color(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Quantity_Color theColor, Standard_Boolean const theToUpdateViewer)

        Sets the color of the selected entity.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the color selection for the selected entity.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnsetColor(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject aniobj) -> Standard_Real

        Returns the width of the Interactive Object in the interactive context.

        :type aniobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveContext_Width(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theValue, Standard_Boolean const theToUpdateViewer)

        Sets the width of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theValue: float
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the width setting of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnsetWidth(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Graphic3d_MaterialAspect theMaterial, Standard_Boolean const theToUpdateViewer)

        Provides the type of material setting for the view of the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMaterial: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the type of material setting for viewing the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theValue, Standard_Boolean const theToUpdateViewer)

        Provides the transparency settings for viewing the Object.
        The transparency value aValue may be between 0.0, opaque, and 1.0, fully transparent.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theValue: float
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Removes the transparency settings for viewing the Object.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnsetTransparency(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Integer const theMode, Standard_ShortReal const theFactor, Standard_ShortReal const theUnits, Standard_Boolean const theToUpdateViewer)

        Sets up polygon offsets for the given AIS_InteractiveObject.
        It simply calls AIS_InteractiveObject::SetPolygonOffsets().

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theFactor: float
        :type theUnits: float
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObj) -> Standard_Boolean

        Simply calls AIS_InteractiveObject::HasPolygonOffsets().

        :type anObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObj)

        Retrieves current polygon offsets settings for Object.

        :type anObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_InteractiveContext_PolygonOffsets(self, *args)


    def SetTrihedronSize(self, *args):
        """
        SetTrihedronSize(Handle_AIS_InteractiveContext self, Standard_Real const theSize, Standard_Boolean const theToUpdateViewer)

        Sets the size aSize of the trihedron.
        Is used to change the default value 100 mm for display of trihedra.
        Use of this function in one of your own interactive objects requires a call to the Compute function of the new class.
        This will recalculate the presentation for every trihedron displayed.

        :type theSize: float
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetTrihedronSize(self, *args)


    def TrihedronSize(self, *args):
        """
        TrihedronSize(Handle_AIS_InteractiveContext self) -> Standard_Real

        returns the current value of trihedron size.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveContext_TrihedronSize(self, *args)


    def SetPlaneSize(self, *args):
        """
        SetPlaneSize(Handle_AIS_InteractiveContext self, Standard_Real const theSizeX, Standard_Real const theSizeY, Standard_Boolean const theToUpdateViewer)
        SetPlaneSize(Handle_AIS_InteractiveContext self, Standard_Real const theSize, Standard_Boolean const theToUpdateViewer)

        Sets the plane size aSize.

        :type theSize: float
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetPlaneSize(self, *args)


    def PlaneSize(self, *args):
        """
        PlaneSize(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if the length in the X direction XSize is the same as that in the Y direction YSize.

        :type XSize: float
        :type YSize: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_PlaneSize(self, *args)


    def SetDeviationCoefficient(self, *args):
        """
        SetDeviationCoefficient(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theCoefficient, Standard_Boolean const theToUpdateViewer)
        SetDeviationCoefficient(Handle_AIS_InteractiveContext self, Standard_Real const theCoefficient)

        Sets the deviation coefficient theCoefficient.
        Drawings of curves or patches are made with respect to a maximal chordal deviation.
        A Deviation coefficient is used in the shading display mode.
        The shape is seen decomposed into triangles.
        These are used to calculate reflection of light from the surface of the object.
        The triangles are formed from chords of the curves in the shape.
        The deviation coefficient theCoefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve.
        If this limit is reached, a new triangle is begun.
        This deviation is absolute and is set through the method: SetMaximalChordialDeviation.
        The default value is 0.001.
        In drawing shapes, however, you are allowed to ask for a relative deviation.
        This deviation will be: SizeOfObject * DeviationCoefficient.

        :type theCoefficient: float

        """
        return _AIS.Handle_AIS_InteractiveContext_SetDeviationCoefficient(self, *args)


    def SetDeviationAngle(self, *args):
        """
        SetDeviationAngle(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)
        SetDeviationAngle(Handle_AIS_InteractiveContext self, Standard_Real const anAngle)

        default 12 degrees

        :type anAngle: float

        """
        return _AIS.Handle_AIS_InteractiveContext_SetDeviationAngle(self, *args)


    def SetAngleAndDeviation(self, *args):
        """
        SetAngleAndDeviation(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)

        Calls the AIS_Shape SetAngleAndDeviation to set both Angle and Deviation coefficients

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theAngle: float
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetAngleAndDeviation(self, *args)


    def SetHLRDeviationCoefficient(self, *args):
        """
        SetHLRDeviationCoefficient(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theCoefficient, Standard_Boolean const theToUpdateViewer)
        SetHLRDeviationCoefficient(Handle_AIS_InteractiveContext self, Standard_Real const aCoefficient)

        Sets the deviation coefficient aCoefficient for removal of hidden lines created by different viewpoints in different presentations.
        The Default value is 0.02.

        :type aCoefficient: float

        """
        return _AIS.Handle_AIS_InteractiveContext_SetHLRDeviationCoefficient(self, *args)


    def SetHLRDeviationAngle(self, *args):
        """
        SetHLRDeviationAngle(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theAngle: float
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetHLRDeviationAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args):
        """
        SetHLRAngleAndDeviation(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Real const theAngle, Standard_Boolean const theToUpdateViewer)
        SetHLRAngleAndDeviation(Handle_AIS_InteractiveContext self, Standard_Real const theAngle)

        compute with theAngle a HLRAngle and a HLRDeviationCoefficient
        and set them in myHLRAngle and in myHLRDeviationCoefficient of myDefaultDrawer;
        theAngle is in radian; ( 1 deg < angle in deg < 20 deg)

        :type theAngle: float

        """
        return _AIS.Handle_AIS_InteractiveContext_SetHLRAngleAndDeviation(self, *args)


    def DeviationCoefficient(self, *args):
        """
        DeviationCoefficient(Handle_AIS_InteractiveContext self) -> Standard_Real

        Returns the deviation coefficient.
        Drawings of curves or patches are made with respect to a maximal chordal deviation.
        A Deviation coefficient is used in the shading display mode.
        The shape is seen decomposed into triangles.
        These are used to calculate reflection of light from the surface of the object.
        The triangles are formed from chords of the curves in the shape.
        The deviation coefficient gives the highest value of the angle with which a chord can deviate from a tangent to a curve.
        If this limit is reached, a new triangle is begun.
        This deviation is absolute and is set through Prs3d_Drawer::SetMaximalChordialDeviation.
        The default value is 0.001.
        In drawing shapes, however, you are allowed to ask for a relative deviation.
        This deviation will be: SizeOfObject * DeviationCoefficient.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveContext_DeviationCoefficient(self, *args)


    def DeviationAngle(self, *args):
        """
        DeviationAngle(Handle_AIS_InteractiveContext self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveContext_DeviationAngle(self, *args)


    def HLRDeviationCoefficient(self, *args):
        """
        HLRDeviationCoefficient(Handle_AIS_InteractiveContext self) -> Standard_Real

        Returns the real number value of the hidden line removal deviation coefficient.
        A Deviation coefficient is used in the shading display mode.
        The shape is seen decomposed into triangles.
        These are used to calculate reflection of light from the surface of the object.
        The triangles are formed from chords of the curves in the shape.
        The deviation coefficient give the highest value of the angle with which a chord can deviate from a tangent to a curve.
        If this limit is reached, a new triangle is begun.
        To find the hidden lines, hidden line display mode entails recalculation of the view at each different projector perspective.
        Because hidden lines entail calculations of more than usual complexity to decompose them into these triangles,
        a deviation coefficient allowing greater tolerance is used.
        This increases efficiency in calculation.
        The Default value is 0.02.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveContext_HLRDeviationCoefficient(self, *args)


    def SetHLRAngle(self, *args):
        """
        SetHLRAngle(Handle_AIS_InteractiveContext self, Standard_Real const theAngle)

        Sets the HLR angle.

        :type theAngle: float

        """
        return _AIS.Handle_AIS_InteractiveContext_SetHLRAngle(self, *args)


    def HLRAngle(self, *args):
        """
        HLRAngle(Handle_AIS_InteractiveContext self) -> Standard_Real

        Returns the real number value of the deviation angle in hidden line removal views in this interactive context.
        The default value is 20*PI/180.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_InteractiveContext_HLRAngle(self, *args)


    def HiddenLineAspect(self, *args):
        """
        HiddenLineAspect(Handle_AIS_InteractiveContext self) -> Handle_Prs3d_LineAspect

        Initializes hidden line aspect in the default drawing tool, or Drawer.
        The default values are:
        Color: Quantity_NOC_YELLOW
        Type of line: Aspect_TOL_DASH
        Width: 1.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_InteractiveContext_HiddenLineAspect(self, *args)


    def SetHiddenLineAspect(self, *args):
        """
        SetHiddenLineAspect(Handle_AIS_InteractiveContext self, Handle_Prs3d_LineAspect anAspect)

        Sets the hidden line aspect anAspect.
        Aspect defines display attributes for hidden lines in HLR projections.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_InteractiveContext_SetHiddenLineAspect(self, *args)


    def DrawHiddenLine(self, *args):
        """
        DrawHiddenLine(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        returns Standard_True if the hidden lines are to be drawn.
        By default the hidden lines are not drawn.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_DrawHiddenLine(self, *args)


    def EnableDrawHiddenLine(self, *args):
        """EnableDrawHiddenLine(Handle_AIS_InteractiveContext self)"""
        return _AIS.Handle_AIS_InteractiveContext_EnableDrawHiddenLine(self, *args)


    def DisableDrawHiddenLine(self, *args):
        """DisableDrawHiddenLine(Handle_AIS_InteractiveContext self)"""
        return _AIS.Handle_AIS_InteractiveContext_DisableDrawHiddenLine(self, *args)


    def SetIsoNumber(self, *args):
        """
        SetIsoNumber(Handle_AIS_InteractiveContext self, Standard_Integer const NbIsos, AIS_TypeOfIso const WhichIsos=AIS_TOI_Both)

        Sets the number of U and V isoparameters displayed.

        :type NbIsos: int
        :type WhichIsos: OCC.wrapper.AIS.AIS_TypeOfIso

        """
        return _AIS.Handle_AIS_InteractiveContext_SetIsoNumber(self, *args)


    def IsoNumber(self, *args):
        """
        IsoNumber(Handle_AIS_InteractiveContext self, AIS_TypeOfIso const WhichIsos=AIS_TOI_Both) -> Standard_Integer

        Returns the number of U and V isoparameters displayed.

        :type WhichIsos: OCC.wrapper.AIS.AIS_TypeOfIso
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_IsoNumber(self, *args)


    def IsoOnPlane(self, *args):
        """
        IsoOnPlane(Handle_AIS_InteractiveContext self, Standard_Boolean const SwitchOn)
        IsoOnPlane(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns True if drawing isoparameters on planes is enabled.
        if <forUIsos> = False,

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsoOnPlane(self, *args)


    def IsoOnTriangulation(self, *args):
        """
        IsoOnTriangulation(Handle_AIS_InteractiveContext self, Standard_Boolean const theIsEnabled, Handle_AIS_InteractiveObject theObject)
        IsoOnTriangulation(Handle_AIS_InteractiveContext self, Standard_Boolean const theToSwitchOn)
        IsoOnTriangulation(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if drawing isolines on triangulation algorithm is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsoOnTriangulation(self, *args)


    def HasOpenedContext(self, *args):
        """
        HasOpenedContext(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is an open context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_HasOpenedContext(self, *args)


    def HighestIndex(self, *args):
        """
        HighestIndex(Handle_AIS_InteractiveContext self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_HighestIndex(self, *args)


    def LocalContext(self, *args):
        """
        LocalContext(Handle_AIS_InteractiveContext self) -> Handle_AIS_LocalContext

        For advanced usage! You should use other (non-internal) methods of class AIS_InteractiveContext without trying to obtain an instance of AIS_LocalContext.

        :rtype: OCC.wrapper.AIS.Handle_AIS_LocalContext

        """
        return _AIS.Handle_AIS_InteractiveContext_LocalContext(self, *args)


    def LocalSelector(self, *args):
        """
        LocalSelector(Handle_AIS_InteractiveContext self) -> Handle_StdSelect_ViewerSelector3d

        :rtype: OCC.wrapper.StdSelect.Handle_StdSelect_ViewerSelector3d

        """
        return _AIS.Handle_AIS_InteractiveContext_LocalSelector(self, *args)


    def OpenLocalContext(self, *args):
        """
        OpenLocalContext(Handle_AIS_InteractiveContext self, Standard_Boolean const UseDisplayedObjects, Standard_Boolean const AllowShapeDecomposition, Standard_Boolean const AcceptEraseOfObjects, Standard_Boolean const BothViewers) -> Standard_Integer

        Opens local contexts and specifies how this is to be done.
        The options listed above function in the following manner:
        - UseDisplayedObjects - allows you to load or not load the interactive objects visualized at Neutral Point in the local context which you open.
        If false, the local context is empty after being opened. If true, the objects at Neutral Point are loaded by their default selection mode.
        - AllowShapeDecomposition - AIS_Shape allows or prevents decomposition in standard shape location mode of objects at Neutral Point which are type-"privileged".
        This Flag is only taken into account when UseDisplayedObjects is true.
        - AcceptEraseOfObjects - authorises other local contexts to erase the interactive objects present in this context. This option is rarely used.
        - BothViewers - Has no use currently defined.
        This method returns the index of the created local context.
        It should be kept and used to close the context.
        Opening a local context allows you to prepare an environment for temporary presentations and selections which will disappear once the local context is closed.
        You can open several local contexts, but only the last one will be active.

        :type UseDisplayedObjects: bool
        :type AllowShapeDecomposition: bool
        :type AcceptEraseOfObjects: bool
        :type BothViewers: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_OpenLocalContext(self, *args)


    def CloseLocalContext(self, *args):
        """
        CloseLocalContext(Handle_AIS_InteractiveContext self, Standard_Integer const theIndex=-1, Standard_Boolean const theToUpdateViewer)

        Allows you to close local contexts. For greater security, you should close the context with the index Index given on opening.
        When you close a local context, the one before, which is still on the stack, reactivates.
        If none is left, you return to Neutral Point.
        If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode;
        the object is displayed but no viewer will be updated.
        Warning
        When the index isn't specified, the current context is closed.
        This option can be dangerous, as other Interactive Functions can open local contexts without necessarily warning the user.

        :type theIndex: int
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_CloseLocalContext(self, *args)


    def IndexOfCurrentLocal(self, *args):
        """
        IndexOfCurrentLocal(Handle_AIS_InteractiveContext self) -> Standard_Integer

        returns -1 if no opened local context.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_IndexOfCurrentLocal(self, *args)


    def CloseAllContexts(self, *args):
        """
        CloseAllContexts(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Allows you to close all local contexts at one go and return to Neutral Point.
        If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode;
        the object is displayed but no viewer will be updated.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_CloseAllContexts(self, *args)


    def ResetOriginalState(self, *args):
        """
        ResetOriginalState(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        to be used only with no opened local context..
        displays and activates objects in their original state before local contexts were opened...

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_ResetOriginalState(self, *args)


    def ClearLocalContext(self, *args):
        """
        ClearLocalContext(Handle_AIS_InteractiveContext self, AIS_ClearMode const TheMode=AIS_CM_All)

        clears Objects/Filters/Activated Modes list in the current opened local context.

        :type TheMode: OCC.wrapper.AIS.AIS_ClearMode

        """
        return _AIS.Handle_AIS_InteractiveContext_ClearLocalContext(self, *args)


    def UseDisplayedObjects(self, *args):
        """UseDisplayedObjects(Handle_AIS_InteractiveContext self)"""
        return _AIS.Handle_AIS_InteractiveContext_UseDisplayedObjects(self, *args)


    def NotUseDisplayedObjects(self, *args):
        """
        NotUseDisplayedObjects(Handle_AIS_InteractiveContext self)

        when a local Context is opened, one is able to use/not use the displayed objects at neutral point at anytime.


        """
        return _AIS.Handle_AIS_InteractiveContext_NotUseDisplayedObjects(self, *args)


    def SetShapeDecomposition(self, *args):
        """
        SetShapeDecomposition(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIobj, Standard_Boolean const aStatus)

        to be Used only with opened local context and
        if <anIobj> is of type shape...
        if <aStatus> = True <anIobj> will be sensitive to
        shape selection modes activation.
        = False, <anIobj> will not be sensitive any more.

        :type anIobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aStatus: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetShapeDecomposition(self, *args)


    def SetTemporaryAttributes(self, *args):
        """
        SetTemporaryAttributes(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theToUpdateViewer)

        Sets the temporary graphic attributes of the entity anObj.
        These are provided by the attribute manager aDrawer and are valid for a particular local context only.
        If a local context is open and if updateviewer equals Standard_False, the presentation of the Interactive Object activates the selection mode;
        the object is displayed but no viewer will be updated.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetTemporaryAttributes(self, *args)


    def ActivateStandardMode(self, *args):
        """
        ActivateStandardMode(Handle_AIS_InteractiveContext self, TopAbs_ShapeEnum const aStandardActivation)

        Provides an alternative to the Display methods when activating specific selection modes.
        This has the effect of activating the corresponding selection mode aStandardActivation for all objects
        in Local Context which accept decomposition into sub-shapes.
        Every new Object which has been loaded into the interactive context and which answers these decomposition criteria
        is automatically activated according to these modes.
        Warning
        If you have opened a local context by loading an object with the default options (<AllowShapeDecomposition >= Standard_True),
        all objects of the "Shape" type are also activated with the same modes.
        You can act on the state of these "Standard" objects by using SetShapeDecomposition(Status).

        :type aStandardActivation: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.Handle_AIS_InteractiveContext_ActivateStandardMode(self, *args)


    def DeactivateStandardMode(self, *args):
        """
        DeactivateStandardMode(Handle_AIS_InteractiveContext self, TopAbs_ShapeEnum const aStandardActivation)

        Provides an alternative to the Display methods when deactivating specific selection modes.
        This has the effect of deactivating the corresponding selection mode aStandardActivation for all objects
        in Local Context which accept decomposition into sub-shapes.

        :type aStandardActivation: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.Handle_AIS_InteractiveContext_DeactivateStandardMode(self, *args)


    def ActivatedStandardModes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.Handle_AIS_InteractiveContext_ActivatedStandardModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInLocal(self, *args):
        """
        IsInLocal(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean

        returns if possible, the first local context where the object is seen

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type TheIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsInLocal(self, *args)


    def SetAutomaticHilight(self, *args):
        """
        SetAutomaticHilight(Handle_AIS_InteractiveContext self, Standard_Boolean const aStatus)

        Sets the highlighting status aStatus of detected and selected entities.
        Whether you are in Neutral Point or local context, this is automatically managed by the Interactive Context.
        This function allows you to disconnect the automatic mode.

        :type aStatus: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetAutomaticHilight(self, *args)


    def AutomaticHilight(self, *args):
        """
        AutomaticHilight(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if the automatic highlight mode is active in an open context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_AutomaticHilight(self, *args)


    def KeepTemporary(self, *args):
        """
        KeepTemporary(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject anIObj, Standard_Integer const InWhichLocal=-1) -> Standard_Boolean

        Changes the status of a temporary object.
        It will be kept at the neutral point, i.e. put in the list of displayed objects along with its temporary attributes.
        These include display mode and selection mode, for example.
        Returns true if done.
        inWhichLocal gives the local context in which anIObj is displayed.
        By default, the index -1 refers to the last Local Context opened.

        :type anIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type InWhichLocal: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_KeepTemporary(self, *args)


    def SetCurrentObject(self, *args):
        """
        SetCurrentObject(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)

        Updates the view of the current object in open context.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SetCurrentObject(self, *args)


    def AddOrRemoveCurrentObject(self, *args):
        """
        AddOrRemoveCurrentObject(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObj, Standard_Boolean const theIsToUpdateViewer)

        Allows to add or remove the object given to the list of current and highlight/unhighlight it correspondingly.
        Is valid for global context only; for local context use method AddOrRemoveSelected.
        Since this method makes sence only for neutral point selection of a whole object,
        if 0 selection of the object is empty this method simply does nothing.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theIsToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_AddOrRemoveCurrentObject(self, *args)


    def UpdateCurrent(self, *args):
        """
        UpdateCurrent(Handle_AIS_InteractiveContext self)

        Updates the list of current objects, i.e. hilights new current objects, removes hilighting from former current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.


        """
        return _AIS.Handle_AIS_InteractiveContext_UpdateCurrent(self, *args)


    def IsCurrent(self, *args):
        """
        IsCurrent(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theObject) -> Standard_Boolean

        Returns true if there is a non-null interactive object in Neutral Point.
        Objects selected when there is no open local context are called current objects;
        those selected in open local context, selected objects.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsCurrent(self, *args)


    def InitCurrent(self, *args):
        """
        InitCurrent(Handle_AIS_InteractiveContext self)

        Initializes a scan of the current selected objects in Neutral Point.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.


        """
        return _AIS.Handle_AIS_InteractiveContext_InitCurrent(self, *args)


    def MoreCurrent(self, *args):
        """
        MoreCurrent(Handle_AIS_InteractiveContext self) -> Standard_Boolean

        Returns true if there is another object found by the scan of the list of current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_MoreCurrent(self, *args)


    def NextCurrent(self, *args):
        """
        NextCurrent(Handle_AIS_InteractiveContext self)

        Continues the scan to the next object in the list of current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.


        """
        return _AIS.Handle_AIS_InteractiveContext_NextCurrent(self, *args)


    def Current(self, *args):
        """
        Current(Handle_AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        Returns the current interactive object.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_Current(self, *args)


    def NbCurrents(self, *args):
        """
        NbCurrents(Handle_AIS_InteractiveContext self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_NbCurrents(self, *args)


    def HilightCurrents(self, *args):
        """
        HilightCurrents(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Highlights current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_HilightCurrents(self, *args)


    def UnhilightCurrents(self, *args):
        """
        UnhilightCurrents(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes highlighting from current objects.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_UnhilightCurrents(self, *args)


    def ClearCurrents(self, *args):
        """
        ClearCurrents(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Empties previous current objects in order to get the current objects detected by the selector using UpdateCurrent.
        Objects selected when there is no open local context are called current objects; those selected in open local context, selected objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_ClearCurrents(self, *args)


    def DetectedCurrentShape(self, *args):
        """
        @return current mouse-detected shape or empty (null) shape, if current interactive object
        is not a shape (AIS_Shape) or there is no current mouse-detected interactive object at all.
        @sa DetectedCurrentOwner()/InitDetected()/MoreDetected()/NextDetected().

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_InteractiveContext_DetectedCurrentShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DetectedCurrentObject(self, *args):
        """
        DetectedCurrentObject(Handle_AIS_InteractiveContext self) -> Handle_AIS_InteractiveObject

        @return current mouse-detected interactive object or null object, if there is no currently detected interactives
        @sa DetectedCurrentOwner()/InitDetected()/MoreDetected()/NextDetected().

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_InteractiveContext_DetectedCurrentObject(self, *args)


    def SubIntensityColor(self, *args):
        """
        Sub-intensity allows temporary highlighting of particular objects with specified color in a manner of selection highlight,
        but without actual selection (e.g., global status and owner's selection state will not be updated).
        The method returns the color of such highlighting.
        By default, it is Quantity_NOC_GRAY40.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _AIS.Handle_AIS_InteractiveContext_SubIntensityColor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSubIntensityColor(self, *args):
        """
        SetSubIntensityColor(Handle_AIS_InteractiveContext self, Quantity_Color theColor)

        Sub-intensity allows temporary highlighting of particular objects with specified color in a manner of selection highlight,
        but without actual selection (e.g., global status and owner's selection state will not be updated).
        The method sets up the color for such highlighting.
        By default, this is Quantity_NOC_GRAY40.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_InteractiveContext_SetSubIntensityColor(self, *args)


    def SubIntensityOn(self, *args):
        """
        SubIntensityOn(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)
        SubIntensityOn(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        hilights/unhilights displayed objects which are displayed at neutral state with subintensity color.
        Available only for active local context.
        No effect if no local context.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """
        SubIntensityOff(Handle_AIS_InteractiveContext self, Handle_AIS_InteractiveObject theIObj, Standard_Boolean const theToUpdateViewer)
        SubIntensityOff(Handle_AIS_InteractiveContext self, Standard_Boolean const theToUpdateViewer)

        Removes subintensity option for all objects.

        :type theToUpdateViewer: bool

        """
        return _AIS.Handle_AIS_InteractiveContext_SubIntensityOff(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_InteractiveContext self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_InteractiveContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_InteractiveContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_InteractiveContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_InteractiveContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_InteractiveContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_InteractiveContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_InteractiveContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_InteractiveContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_InteractiveContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_InteractiveContext self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_InteractiveContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_InteractiveContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_InteractiveContext_DecrementRefCounter(self, *args)

Handle_AIS_InteractiveContext_swigregister = _AIS.Handle_AIS_InteractiveContext_swigregister
Handle_AIS_InteractiveContext_swigregister(Handle_AIS_InteractiveContext)

def Handle_AIS_InteractiveContext_DownCast(thing):
    return _AIS.Handle_AIS_InteractiveContext_DownCast(thing)
Handle_AIS_InteractiveContext_DownCast = _AIS.Handle_AIS_InteractiveContext_DownCast

class Handle_AIS_SymmetricRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_SymmetricRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_SymmetricRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_SymmetricRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_SymmetricRelation self, AIS_SymmetricRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_SymmetricRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_SymmetricRelation self, Handle_AIS_SymmetricRelation theHandle) -> Handle_AIS_SymmetricRelation
        assign(Handle_AIS_SymmetricRelation self, AIS_SymmetricRelation thePtr) -> Handle_AIS_SymmetricRelation
        assign(Handle_AIS_SymmetricRelation self, Handle_AIS_SymmetricRelation theHandle) -> Handle_AIS_SymmetricRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_SymmetricRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_SymmetricRelation self) -> AIS_SymmetricRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_SymmetricRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_SymmetricRelation self) -> AIS_SymmetricRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_SymmetricRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_SymmetricRelation self) -> AIS_SymmetricRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_SymmetricRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_SymmetricRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_SymmetricRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_SymmetricRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_SymmetricRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_SymmetricRelation

    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the symmetric constraint display is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsMovable(self, *args)


    def SetTool(self, *args):
        """
        SetTool(Handle_AIS_SymmetricRelation self, TopoDS_Shape aSymmetricTool)

        Sets the tool aSymmetricTool composed of a first
        shape, a second shape, and a plane.
        This tool is initially created at construction time.

        :type aSymmetricTool: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetTool(self, *args)


    def GetTool(self, *args):
        """
        Returns the tool composed of a first shape, a second
        shape, and a plane. This tool is created at construction time.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_SymmetricRelation_GetTool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_AIS_SymmetricRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_SymmetricRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_SymmetricRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_SymmetricRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_SymmetricRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_SymmetricRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_SymmetricRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_SymmetricRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_SymmetricRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_SymmetricRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_SymmetricRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_SymmetricRelation_KindOfDimension(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_SymmetricRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_SymmetricRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_SymmetricRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_SymmetricRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_SymmetricRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_SymmetricRelation self)"""
        return _AIS.Handle_AIS_SymmetricRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_SymmetricRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_SymmetricRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_SymmetricRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_SymmetricRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_SymmetricRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_SymmetricRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_SymmetricRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_SymmetricRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_SymmetricRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_SymmetricRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_SymmetricRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_SymmetricRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_SymmetricRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_SymmetricRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_SymmetricRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_SymmetricRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_SymmetricRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_SymmetricRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_SymmetricRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_SymmetricRelation self)"""
        return _AIS.Handle_AIS_SymmetricRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_SymmetricRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_SymmetricRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_SymmetricRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_SymmetricRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_SymmetricRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_SymmetricRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_SymmetricRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_SymmetricRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_SymmetricRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_SymmetricRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_SymmetricRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_SymmetricRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_SymmetricRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_SymmetricRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_SymmetricRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_SymmetricRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_SymmetricRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_SymmetricRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_SymmetricRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_SymmetricRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_SymmetricRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_SymmetricRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_SymmetricRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_SymmetricRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_SymmetricRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_SymmetricRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_SymmetricRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_SymmetricRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_SymmetricRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_SymmetricRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_SymmetricRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_SymmetricRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_SymmetricRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_SymmetricRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_SymmetricRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_SymmetricRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_SymmetricRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_SymmetricRelation self)
        RecomputePrimitives(Handle_AIS_SymmetricRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_SymmetricRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_SymmetricRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_SymmetricRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_SymmetricRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_SymmetricRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_SymmetricRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_SymmetricRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_SymmetricRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_SymmetricRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_SymmetricRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_SymmetricRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_SymmetricRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_SymmetricRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_SymmetricRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_SymmetricRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_SymmetricRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_SymmetricRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_SymmetricRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_SymmetricRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_SymmetricRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_SymmetricRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_SymmetricRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_SymmetricRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_SymmetricRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_SymmetricRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_SymmetricRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_SymmetricRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_SymmetricRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_SymmetricRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_SymmetricRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_SymmetricRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_SymmetricRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_SymmetricRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_SymmetricRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_SymmetricRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_SymmetricRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_SymmetricRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_SymmetricRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_SymmetricRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_SymmetricRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_SymmetricRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_SymmetricRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_SymmetricRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_SymmetricRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_SymmetricRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_SymmetricRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_SymmetricRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_SymmetricRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_SymmetricRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_SymmetricRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_SymmetricRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_SymmetricRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_SymmetricRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_SymmetricRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_SymmetricRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_SymmetricRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_SymmetricRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_SymmetricRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_SymmetricRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_SymmetricRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_SymmetricRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_SymmetricRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_SymmetricRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_SymmetricRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_SymmetricRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_SymmetricRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_SymmetricRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_SymmetricRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_SymmetricRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_SymmetricRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_SymmetricRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_SymmetricRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_SymmetricRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_SymmetricRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_SymmetricRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_SymmetricRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_SymmetricRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_SymmetricRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_SymmetricRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_SymmetricRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_SymmetricRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_SymmetricRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_SymmetricRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_SymmetricRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_SymmetricRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_SymmetricRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_SymmetricRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_SymmetricRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_SymmetricRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_SymmetricRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_SymmetricRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_SymmetricRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_SymmetricRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_SymmetricRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_SymmetricRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_SymmetricRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_SymmetricRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_SymmetricRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_SymmetricRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_SymmetricRelation_DecrementRefCounter(self, *args)

Handle_AIS_SymmetricRelation_swigregister = _AIS.Handle_AIS_SymmetricRelation_swigregister
Handle_AIS_SymmetricRelation_swigregister(Handle_AIS_SymmetricRelation)

def Handle_AIS_SymmetricRelation_DownCast(thing):
    return _AIS.Handle_AIS_SymmetricRelation_DownCast(thing)
Handle_AIS_SymmetricRelation_DownCast = _AIS.Handle_AIS_SymmetricRelation_DownCast

class Handle_AIS_BadEdgeFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_BadEdgeFilter self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_BadEdgeFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_BadEdgeFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_BadEdgeFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_BadEdgeFilter self, AIS_BadEdgeFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_BadEdgeFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_BadEdgeFilter self, Handle_AIS_BadEdgeFilter theHandle) -> Handle_AIS_BadEdgeFilter
        assign(Handle_AIS_BadEdgeFilter self, AIS_BadEdgeFilter thePtr) -> Handle_AIS_BadEdgeFilter
        assign(Handle_AIS_BadEdgeFilter self, Handle_AIS_BadEdgeFilter theHandle) -> Handle_AIS_BadEdgeFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_BadEdgeFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_BadEdgeFilter self) -> AIS_BadEdgeFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_BadEdgeFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_BadEdgeFilter self) -> AIS_BadEdgeFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_BadEdgeFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_BadEdgeFilter self) -> AIS_BadEdgeFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_BadEdgeFilter___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_BadEdgeFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_BadEdgeFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_BadEdgeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_BadEdgeFilter_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_BadEdgeFilter

    def ActsOn(self, *args):
        """
        ActsOn(Handle_AIS_BadEdgeFilter self, TopAbs_ShapeEnum const aType) -> Standard_Boolean

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_BadEdgeFilter_ActsOn(self, *args)


    def IsOk(self, *args):
        """
        IsOk(Handle_AIS_BadEdgeFilter self, Handle_SelectMgr_EntityOwner EO) -> Standard_Boolean

        :type EO: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_BadEdgeFilter_IsOk(self, *args)


    def SetContour(self, *args):
        """
        SetContour(Handle_AIS_BadEdgeFilter self, Standard_Integer const Index)

        sets  <myContour> with  current  contour. used  by
        IsOk.

        :type Index: int

        """
        return _AIS.Handle_AIS_BadEdgeFilter_SetContour(self, *args)


    def AddEdge(self, *args):
        """
        AddEdge(Handle_AIS_BadEdgeFilter self, TopoDS_Edge anEdge, Standard_Integer const Index)

        Adds an  edge  to the list  of non-selectionnable
        edges.

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Index: int

        """
        return _AIS.Handle_AIS_BadEdgeFilter_AddEdge(self, *args)


    def RemoveEdges(self, *args):
        """
        RemoveEdges(Handle_AIS_BadEdgeFilter self, Standard_Integer const Index)

        removes from the  list of non-selectionnable edges
        all edges in the contour <Index>.

        :type Index: int

        """
        return _AIS.Handle_AIS_BadEdgeFilter_RemoveEdges(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_BadEdgeFilter self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_BadEdgeFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_BadEdgeFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_BadEdgeFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AIS_BadEdgeFilter self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_BadEdgeFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_BadEdgeFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_BadEdgeFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_BadEdgeFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_BadEdgeFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_BadEdgeFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_BadEdgeFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_BadEdgeFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_BadEdgeFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_BadEdgeFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_BadEdgeFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_BadEdgeFilter self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_BadEdgeFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_BadEdgeFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_BadEdgeFilter_DecrementRefCounter(self, *args)

Handle_AIS_BadEdgeFilter_swigregister = _AIS.Handle_AIS_BadEdgeFilter_swigregister
Handle_AIS_BadEdgeFilter_swigregister(Handle_AIS_BadEdgeFilter)

def Handle_AIS_BadEdgeFilter_DownCast(thing):
    return _AIS.Handle_AIS_BadEdgeFilter_DownCast(thing)
Handle_AIS_BadEdgeFilter_DownCast = _AIS.Handle_AIS_BadEdgeFilter_DownCast


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_AIS_Animation(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_AIS_Animation self) -> NCollection_Sequence< opencascade::handle< AIS_Animation > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_AIS_Animation self) -> NCollection_Sequence< opencascade::handle< AIS_Animation > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_AIS_Animation self) -> NCollection_Sequence< opencascade::handle< AIS_Animation > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_AIS_Animation self) -> NCollection_Sequence< opencascade::handle< AIS_Animation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _AIS.new_NCollection_Sequence_Handle_AIS_Animation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_AIS_Animation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_AIS_Animation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_AIS_Animation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_AIS_Animation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_AIS_Animation self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_AIS_Animation self)

        Reverse sequence


        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_AIS_Animation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_AIS_Animation self, NCollection_Sequence_Handle_AIS_Animation theOther) -> NCollection_Sequence_Handle_AIS_Animation

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_AIS_Animation self, NCollection_Sequence_Handle_AIS_Animation theOther) -> NCollection_Sequence_Handle_AIS_Animation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_AIS_Animation self, NCollection_Sequence< opencascade::handle< AIS_Animation > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_AIS_Animation self, Handle_AIS_Animation theItem)
        Append(NCollection_Sequence_Handle_AIS_Animation self, NCollection_Sequence_Handle_AIS_Animation theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_AIS_Animation self, Handle_AIS_Animation theItem)
        Prepend(NCollection_Sequence_Handle_AIS_Animation self, NCollection_Sequence_Handle_AIS_Animation theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex, Handle_AIS_Animation theItem)
        InsertBefore(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_Animation theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_AIS_Animation self, NCollection_Sequence< opencascade::handle< AIS_Animation > >::Iterator & thePosition, Handle_AIS_Animation theItem)
        InsertAfter(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_Animation theSeq)
        InsertAfter(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex, Handle_AIS_Animation theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_AIS_Animation theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Animation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_AIS_Animation self) -> Handle_AIS_Animation

        First item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Animation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_AIS_Animation self) -> Handle_AIS_Animation

        Last item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Animation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex) -> Handle_AIS_Animation

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Handle_AIS_Animation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_AIS_Animation self, Standard_Integer const theIndex, Handle_AIS_Animation theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_SetValue(self, *args)


    def __iter__(self):
        return _AIS.NCollection_Sequence_Handle_AIS_Animation___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Handle_AIS_Animation
NCollection_Sequence_Handle_AIS_Animation_swigregister = _AIS.NCollection_Sequence_Handle_AIS_Animation_swigregister
NCollection_Sequence_Handle_AIS_Animation_swigregister(NCollection_Sequence_Handle_AIS_Animation)

def NCollection_Sequence_Handle_AIS_Animation_delNode(*args):
    """
    NCollection_Sequence_Handle_AIS_Animation_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _AIS.NCollection_Sequence_Handle_AIS_Animation_delNode(*args)

class NCollection_Sequence_Handle_AIS_Animation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_Sequence_Handle_AIS_Animation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Handle_AIS_Animation_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_Sequence_Handle_AIS_Animation_IteratorHelper___next__(self)
NCollection_Sequence_Handle_AIS_Animation_IteratorHelper_swigregister = _AIS.NCollection_Sequence_Handle_AIS_Animation_IteratorHelper_swigregister
NCollection_Sequence_Handle_AIS_Animation_IteratorHelper_swigregister(NCollection_Sequence_Handle_AIS_Animation_IteratorHelper)

class Handle_AIS_TextLabel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_TextLabel self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_TextLabel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_TextLabel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_TextLabel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_TextLabel self, AIS_TextLabel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_TextLabel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_TextLabel self, Handle_AIS_TextLabel theHandle) -> Handle_AIS_TextLabel
        assign(Handle_AIS_TextLabel self, AIS_TextLabel thePtr) -> Handle_AIS_TextLabel
        assign(Handle_AIS_TextLabel self, Handle_AIS_TextLabel theHandle) -> Handle_AIS_TextLabel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_TextLabel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_TextLabel self) -> AIS_TextLabel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_TextLabel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_TextLabel self) -> AIS_TextLabel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_TextLabel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_TextLabel self) -> AIS_TextLabel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_TextLabel___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_TextLabel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_TextLabel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_TextLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_TextLabel_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_TextLabel

    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_TextLabel self, Quantity_Color theColor)

        Setup color of entire text.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_TextLabel_SetColor(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_TextLabel self, Standard_Real const theValue)

        Setup transparency within [0, 1] range.

        :type theValue: float

        """
        return _AIS.Handle_AIS_TextLabel_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_TextLabel self)

        Removes the transparency setting.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetTransparency(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_TextLabel self, Graphic3d_MaterialAspect arg2)

        Material has no effect for text label.

        :type : OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_TextLabel_SetMaterial(self, *args)


    def SetText(self, *args):
        """
        SetText(Handle_AIS_TextLabel self, TCollection_ExtendedString theText)

        Setup text.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_TextLabel_SetText(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_TextLabel self, gp_Pnt thePosition)

        Setup position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TextLabel_SetPosition(self, *args)


    def SetHJustification(self, *args):
        """
        SetHJustification(Handle_AIS_TextLabel self, Graphic3d_HorizontalTextAlignment const theHJust)

        Setup horizontal justification.

        :type theHJust: OCC.wrapper.Graphic3d.Graphic3d_HorizontalTextAlignment

        """
        return _AIS.Handle_AIS_TextLabel_SetHJustification(self, *args)


    def SetVJustification(self, *args):
        """
        SetVJustification(Handle_AIS_TextLabel self, Graphic3d_VerticalTextAlignment const theVJust)

        Setup vertical justification.

        :type theVJust: OCC.wrapper.Graphic3d.Graphic3d_VerticalTextAlignment

        """
        return _AIS.Handle_AIS_TextLabel_SetVJustification(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_AIS_TextLabel self, Standard_Real const theAngle)

        Setup angle.

        :type theAngle: float

        """
        return _AIS.Handle_AIS_TextLabel_SetAngle(self, *args)


    def SetZoomable(self, *args):
        """
        SetZoomable(Handle_AIS_TextLabel self, Standard_Boolean const theIsZoomable)

        Setup zoomable property.

        :type theIsZoomable: bool

        """
        return _AIS.Handle_AIS_TextLabel_SetZoomable(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(Handle_AIS_TextLabel self, Standard_Real const theHeight)

        Setup height.

        :type theHeight: float

        """
        return _AIS.Handle_AIS_TextLabel_SetHeight(self, *args)


    def SetFontAspect(self, *args):
        """
        SetFontAspect(Handle_AIS_TextLabel self, Font_FontAspect const theFontAspect)

        Setup font aspect.

        :type theFontAspect: OCC.wrapper.Font.Font_FontAspect

        """
        return _AIS.Handle_AIS_TextLabel_SetFontAspect(self, *args)


    def SetFont(self, *args):
        """
        SetFont(Handle_AIS_TextLabel self, Standard_CString theFont)

        Setup font.

        :type theFont: OCC.wrapper.Standard.Standard_CString

        """
        return _AIS.Handle_AIS_TextLabel_SetFont(self, *args)


    def SetOrientation3D(self, *args):
        """
        SetOrientation3D(Handle_AIS_TextLabel self, gp_Ax2 theOrientation)

        Setup label orientation in the model 3D space.

        :type theOrientation: OCC.wrapper.gp.gp_Ax2

        """
        return _AIS.Handle_AIS_TextLabel_SetOrientation3D(self, *args)


    def UnsetOrientation3D(self, *args):
        """
        UnsetOrientation3D(Handle_AIS_TextLabel self)

        Reset label orientation in the model 3D space.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetOrientation3D(self, *args)


    def Position(self, *args):
        """
        Returns position.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_TextLabel_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Orientation3D(self, *args):
        """
        Returns label orientation in the model 3D space.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _AIS.Handle_AIS_TextLabel_Orientation3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOrientation3D(self, *args):
        """
        HasOrientation3D(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the current text placement mode uses text orientation in the model 3D space.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasOrientation3D(self, *args)


    def SetFlipping(self, *args):
        """
        SetFlipping(Handle_AIS_TextLabel self, Standard_Boolean const theIsFlipping)

        :type theIsFlipping: bool

        """
        return _AIS.Handle_AIS_TextLabel_SetFlipping(self, *args)


    def HasFlipping(self, *args):
        """
        HasFlipping(Handle_AIS_TextLabel self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasFlipping(self, *args)


    def SetDisplayType(self, *args):
        """
        SetDisplayType(Handle_AIS_TextLabel self, Aspect_TypeOfDisplayText const theDisplayType)

        Define the display type of the text.

        TODT_NORMAL     Default display. Text only.
        TODT_SUBTITLE   There is a subtitle under the text.
        TODT_DEKALE     The text is displayed with a 3D style.
        TODT_BLEND      The text is displayed in XOR.
        TODT_DIMENSION  Dimension line under text will be invisible.

        :type theDisplayType: OCC.wrapper.Aspect.Aspect_TypeOfDisplayText

        """
        return _AIS.Handle_AIS_TextLabel_SetDisplayType(self, *args)


    def SetColorSubTitle(self, *args):
        """
        SetColorSubTitle(Handle_AIS_TextLabel self, Quantity_Color theColor)

        Modifies the colour of the subtitle for the TODT_SUBTITLE TextDisplayType
        and the colour of backgroubd for the TODT_DEKALE TextDisplayType.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_TextLabel_SetColorSubTitle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_TextLabel self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_TextLabel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TextLabel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TextLabel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_AIS_TextLabel self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_TextLabel_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_TextLabel self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TextLabel_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_TextLabel self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_TextLabel self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_TextLabel_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_TextLabel self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_TextLabel_CurrentFacingModel(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_TextLabel self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_TextLabel self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_TextLabel_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_TextLabel self)"""
        return _AIS.Handle_AIS_TextLabel_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_TextLabel self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_TextLabel self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TextLabel_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_TextLabel self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_TextLabel_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_TextLabel self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_TextLabel_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_TextLabel self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_TextLabel self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_TextLabel_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_TextLabel self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_TextLabel_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_TextLabel_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_TextLabel self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_TextLabel_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_TextLabel self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_TextLabel_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_TextLabel self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_TextLabel_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_TextLabel self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_TextLabel self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TextLabel_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_TextLabel self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TextLabel_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_TextLabel self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TextLabel_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_TextLabel self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_TextLabel self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_TextLabel_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_TextLabel self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TextLabel_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_TextLabel self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_TextLabel_Material(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_TextLabel self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetMaterial(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_TextLabel self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TextLabel_Transparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_TextLabel self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_TextLabel self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TextLabel_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_TextLabel self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_TextLabel_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_TextLabel self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_TextLabel_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_TextLabel self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_TextLabel_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_TextLabel self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_TextLabel_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_TextLabel self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_TextLabel_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_TextLabel self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_TextLabel_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_TextLabel self)
        RecomputePrimitives(Handle_AIS_TextLabel self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TextLabel_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_TextLabel self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_TextLabel_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_TextLabel self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_TextLabel_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_TextLabel_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_TextLabel self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_TextLabel_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_TextLabel self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_TextLabel_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_TextLabel self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_TextLabel self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_TextLabel_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_TextLabel_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_TextLabel self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_TextLabel_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_TextLabel self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_TextLabel_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_TextLabel self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_TextLabel_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_TextLabel self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_TextLabel_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_TextLabel self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_TextLabel_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_TextLabel self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_TextLabel_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_TextLabel self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_TextLabel_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_TextLabel self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_TextLabel self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_TextLabel_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_TextLabel self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TextLabel_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_TextLabel self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TextLabel_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_TextLabel self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_TextLabel_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_TextLabel self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_TextLabel_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_TextLabel self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TextLabel_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_TextLabel self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_TextLabel_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_TextLabel self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_TextLabel_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_TextLabel self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TextLabel_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_TextLabel self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_TextLabel_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_TextLabel_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_TextLabel self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_TextLabel_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_TextLabel self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_TextLabel_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_TextLabel_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_TextLabel self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_TextLabel self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TextLabel_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_TextLabel self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_TextLabel_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_TextLabel self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TextLabel_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_TextLabel self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_TextLabel_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_TextLabel self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_TextLabel self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_TextLabel_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_TextLabel self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_TextLabel_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_TextLabel_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_TextLabel self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_TextLabel self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_TextLabel_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_TextLabel_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_TextLabel_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_TextLabel_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_TextLabel_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_TextLabel self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_TextLabel_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_TextLabel self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_TextLabel_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_TextLabel self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_TextLabel_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_TextLabel self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_TextLabel self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_TextLabel_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_TextLabel_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_TextLabel self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_TextLabel_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_TextLabel self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_TextLabel_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_TextLabel self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_TextLabel_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_TextLabel_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_TextLabel self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_TextLabel self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_TextLabel_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_TextLabel self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TextLabel_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TextLabel_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TextLabel_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_TextLabel self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TextLabel_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TextLabel_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_TextLabel self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TextLabel_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_TextLabel self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_TextLabel_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_TextLabel self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_TextLabel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_TextLabel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_TextLabel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_TextLabel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_TextLabel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TextLabel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_TextLabel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_TextLabel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_TextLabel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TextLabel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_TextLabel self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_TextLabel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_TextLabel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TextLabel_DecrementRefCounter(self, *args)

Handle_AIS_TextLabel_swigregister = _AIS.Handle_AIS_TextLabel_swigregister
Handle_AIS_TextLabel_swigregister(Handle_AIS_TextLabel)

def Handle_AIS_TextLabel_DownCast(thing):
    return _AIS.Handle_AIS_TextLabel_DownCast(thing)
Handle_AIS_TextLabel_DownCast = _AIS.Handle_AIS_TextLabel_DownCast

class AIS_Circle(AIS_InteractiveObject):
    """
    Constructs circle datums to be used in construction of
    composite shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Circle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Circle(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Circle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Circle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Circle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Circle self, Handle_Geom_Circle aCircle) -> AIS_Circle
        __init__(AIS_Circle self, Handle_Geom_Circle theCircle, Standard_Real const theUStart, Standard_Real const theUEnd, Standard_Boolean const theIsFilledCircleSens) -> AIS_Circle

        Initializes this algorithm for constructing AIS circle datums.
        Initializes the circle theCircle, the arc
        starting point theUStart, the arc ending point theUEnd,
        and the type of sensitivity theIsFilledCircleSens.

        :type theCircle: OCC.wrapper.Geom.Handle_Geom_Circle
        :type theUStart: float
        :type theUEnd: float
        :type theIsFilledCircleSens: bool

        """
        this = _AIS.new_AIS_Circle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(AIS_Circle self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_Circle_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_Circle self) -> Standard_Integer

        Returns index 6 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Circle_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Circle self) -> AIS_KindOfInteractive

        Indicates that the type of Interactive Object is a datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Circle_Type(self, *args)


    def Circle(self, *args):
        """
        Returns the circle component defined in SetCircle.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Circle

        """
        res = _AIS.AIS_Circle_Circle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameters(self, *args):
        """
        Parameters(AIS_Circle self)

        Constructs instances of the starting point and the end
        point parameters, theU1 and theU2.

        :type theU1: float
        :type theU2: float

        """
        return _AIS.AIS_Circle_Parameters(self, *args)


    def SetCircle(self, *args):
        """
        SetCircle(AIS_Circle self, Handle_Geom_Circle theCircle)

        Allows you to provide settings for the circle datum aCircle.

        :type theCircle: OCC.wrapper.Geom.Handle_Geom_Circle

        """
        return _AIS.AIS_Circle_SetCircle(self, *args)


    def SetFirstParam(self, *args):
        """
        SetFirstParam(AIS_Circle self, Standard_Real const theU)

        Allows you to set the parameter theU for the starting point of an arc.

        :type theU: float

        """
        return _AIS.AIS_Circle_SetFirstParam(self, *args)


    def SetLastParam(self, *args):
        """
        SetLastParam(AIS_Circle self, Standard_Real const theU)

        Allows you to provide the parameter theU for the end point of an arc.

        :type theU: float

        """
        return _AIS.AIS_Circle_SetLastParam(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_Circle self, Quantity_Color aColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Circle_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_Circle self, Standard_Real const aValue)

        Assigns the width aValue to the solid line boundary of the circle datum.

        :type aValue: float

        """
        return _AIS.AIS_Circle_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Circle self)

        Removes color from the solid line boundary of the circle datum.


        """
        return _AIS.AIS_Circle_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(AIS_Circle self)

        Removes width settings from the solid line boundary of the circle datum.


        """
        return _AIS.AIS_Circle_UnsetWidth(self, *args)


    def IsFilledCircleSens(self, *args):
        """
        IsFilledCircleSens(AIS_Circle self) -> Standard_Boolean

        Returns the type of sensitivity for the circle;

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Circle_IsFilledCircleSens(self, *args)


    def SetFilledCircleSens(self, *args):
        """
        SetFilledCircleSens(AIS_Circle self, Standard_Boolean const theIsFilledCircleSens)

        Sets the type of sensitivity for the circle. If theIsFilledCircleSens set to Standard_True
        then the whole circle will be detectable, otherwise only the boundary of the circle.

        :type theIsFilledCircleSens: bool

        """
        return _AIS.AIS_Circle_SetFilledCircleSens(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Circle
AIS_Circle_swigregister = _AIS.AIS_Circle_swigregister
AIS_Circle_swigregister(AIS_Circle)

def AIS_Circle_get_type_name(*args):
    """
    AIS_Circle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Circle_get_type_name(*args)

def AIS_Circle_get_type_descriptor(*args):
    """
    AIS_Circle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Circle_get_type_descriptor(*args)

class Handle_AIS_Circle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Circle self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Circle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Circle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Circle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Circle self, AIS_Circle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Circle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Circle self, Handle_AIS_Circle theHandle) -> Handle_AIS_Circle
        assign(Handle_AIS_Circle self, AIS_Circle thePtr) -> Handle_AIS_Circle
        assign(Handle_AIS_Circle self, Handle_AIS_Circle theHandle) -> Handle_AIS_Circle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Circle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Circle self) -> AIS_Circle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Circle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Circle self) -> AIS_Circle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Circle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Circle self) -> AIS_Circle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Circle___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Circle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Circle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Circle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Circle_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Circle

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Circle self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Circle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Circle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Circle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_AIS_Circle self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Circle_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Circle self) -> Standard_Integer

        Returns index 6 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Circle_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Circle self) -> AIS_KindOfInteractive

        Indicates that the type of Interactive Object is a datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Circle_Type(self, *args)


    def Circle(self, *args):
        """
        Returns the circle component defined in SetCircle.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Circle

        """
        res = _AIS.Handle_AIS_Circle_Circle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameters(self, *args):
        """
        Parameters(Handle_AIS_Circle self)

        Constructs instances of the starting point and the end
        point parameters, theU1 and theU2.

        :type theU1: float
        :type theU2: float

        """
        return _AIS.Handle_AIS_Circle_Parameters(self, *args)


    def SetCircle(self, *args):
        """
        SetCircle(Handle_AIS_Circle self, Handle_Geom_Circle theCircle)

        Allows you to provide settings for the circle datum aCircle.

        :type theCircle: OCC.wrapper.Geom.Handle_Geom_Circle

        """
        return _AIS.Handle_AIS_Circle_SetCircle(self, *args)


    def SetFirstParam(self, *args):
        """
        SetFirstParam(Handle_AIS_Circle self, Standard_Real const theU)

        Allows you to set the parameter theU for the starting point of an arc.

        :type theU: float

        """
        return _AIS.Handle_AIS_Circle_SetFirstParam(self, *args)


    def SetLastParam(self, *args):
        """
        SetLastParam(Handle_AIS_Circle self, Standard_Real const theU)

        Allows you to provide the parameter theU for the end point of an arc.

        :type theU: float

        """
        return _AIS.Handle_AIS_Circle_SetLastParam(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Circle self, Quantity_Color aColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Circle_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Circle self, Standard_Real const aValue)

        Assigns the width aValue to the solid line boundary of the circle datum.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Circle_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Circle self)

        Removes color from the solid line boundary of the circle datum.


        """
        return _AIS.Handle_AIS_Circle_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_AIS_Circle self)

        Removes width settings from the solid line boundary of the circle datum.


        """
        return _AIS.Handle_AIS_Circle_UnsetWidth(self, *args)


    def IsFilledCircleSens(self, *args):
        """
        IsFilledCircleSens(Handle_AIS_Circle self) -> Standard_Boolean

        Returns the type of sensitivity for the circle;

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_IsFilledCircleSens(self, *args)


    def SetFilledCircleSens(self, *args):
        """
        SetFilledCircleSens(Handle_AIS_Circle self, Standard_Boolean const theIsFilledCircleSens)

        Sets the type of sensitivity for the circle. If theIsFilledCircleSens set to Standard_True
        then the whole circle will be detectable, otherwise only the boundary of the circle.

        :type theIsFilledCircleSens: bool

        """
        return _AIS.Handle_AIS_Circle_SetFilledCircleSens(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Circle self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Circle self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Circle_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Circle self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Circle_CurrentFacingModel(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Circle self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Circle self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Circle_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Circle self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Circle_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Circle self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Circle_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Circle self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Circle self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Circle_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Circle self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Circle_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Circle_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Circle self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Circle_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Circle self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Circle_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Circle self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Circle_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Circle self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Circle_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Circle self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Circle_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Circle self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Circle_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Circle self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Circle_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Circle self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Circle_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Circle self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Circle_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Circle self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Circle_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Circle self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Circle_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Circle self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Circle_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Circle self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Circle_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Circle self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Circle_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Circle self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Circle_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Circle self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Circle_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Circle self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Circle_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Circle self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Circle self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Circle_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Circle self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Circle_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Circle self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Circle_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Circle self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Circle self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Circle_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Circle self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Circle_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Circle self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Circle_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Circle self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Circle_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Circle self)
        RecomputePrimitives(Handle_AIS_Circle self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Circle_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Circle self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Circle_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Circle self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Circle_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Circle_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Circle self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Circle_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Circle self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Circle_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Circle self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Circle self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Circle_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Circle_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Circle self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Circle_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Circle self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Circle_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Circle self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Circle_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Circle self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Circle_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Circle self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Circle_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Circle self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Circle_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Circle self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Circle_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Circle self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Circle self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Circle_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Circle self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Circle_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Circle self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Circle_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Circle self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Circle_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Circle self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Circle_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Circle self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Circle_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Circle self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Circle_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Circle self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Circle_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Circle self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Circle_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Circle self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Circle_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Circle_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Circle self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Circle_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Circle self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Circle_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Circle_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Circle self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Circle self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Circle_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Circle self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Circle_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Circle self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Circle_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Circle self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Circle_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Circle self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Circle self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Circle_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Circle self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Circle_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Circle_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Circle self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Circle self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Circle_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Circle_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Circle_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Circle_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Circle_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Circle self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Circle_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Circle self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Circle_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Circle self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Circle_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Circle self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Circle self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Circle_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Circle_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Circle self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Circle_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Circle self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Circle_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Circle self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Circle_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Circle_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Circle self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Circle self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Circle_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Circle self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Circle_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Circle_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Circle_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Circle self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Circle_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Circle_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Circle self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Circle_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Circle self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Circle_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Circle self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Circle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Circle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Circle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Circle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Circle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Circle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Circle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Circle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Circle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Circle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Circle self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Circle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Circle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Circle_DecrementRefCounter(self, *args)

Handle_AIS_Circle_swigregister = _AIS.Handle_AIS_Circle_swigregister
Handle_AIS_Circle_swigregister(Handle_AIS_Circle)

def Handle_AIS_Circle_DownCast(thing):
    return _AIS.Handle_AIS_Circle_DownCast(thing)
Handle_AIS_Circle_DownCast = _AIS.Handle_AIS_Circle_DownCast

class AIS_EqualDistanceRelation(AIS_Relation):
    """
    A framework to display equivalent distances between
    shapes and a given plane.
    The distance is the length of a projection from the
    shape to the plane.
    These distances are used to compare shapes by this vector alone.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_EqualDistanceRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_EqualDistanceRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_EqualDistanceRelation self, TopoDS_Shape aShape1, TopoDS_Shape aShape2, TopoDS_Shape aShape3, TopoDS_Shape aShape4, Handle_Geom_Plane aPlane) -> AIS_EqualDistanceRelation

        Constructs a framework to display equivalent
        distances between the shapes aShape1, aShape2,
        aShape3, aShape4 and the plane aPlane.
        The distance is the length of a projection from the
        shape to the plane.

        :type aShape1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aShape2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aShape3: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aShape4: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        this = _AIS.new_AIS_EqualDistanceRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetShape3(self, *args):
        """
        SetShape3(AIS_EqualDistanceRelation self, TopoDS_Shape aShape)

        Sets the shape aShape to be used as the shape
        aShape3 in the framework created at construction time.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_EqualDistanceRelation_SetShape3(self, *args)


    def Shape3(self, *args):
        """
        Returns the shape aShape3 from the framework
        created at construction time.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_EqualDistanceRelation_Shape3(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape4(self, *args):
        """
        SetShape4(AIS_EqualDistanceRelation self, TopoDS_Shape aShape)

        Sets the shape aShape to be used as the shape
        aShape4 in the framework created at construction time.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.AIS_EqualDistanceRelation_SetShape4(self, *args)


    def Shape4(self, *args):
        """
        Returns the shape aShape4 from the framework
        created at construction time.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.AIS_EqualDistanceRelation_Shape4(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(AIS_EqualDistanceRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        Computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_EqualDistanceRelation_Compute(self, *args)


    def ComputeTwoEdgesLength(*args):
        """
        ComputeTwoEdgesLength(Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Edge FirstEdge, TopoDS_Edge SecondEdge, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

        Computes the location of an intreval between
        between two edges. FirstAttach , SecondAttach
        are the returned extreme points of the interval.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type ArrowSize: float
        :type FirstEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type SecondEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type AutomaticPos: bool
        :type IsSetBndBox: bool
        :type BndBox: OCC.wrapper.Bnd.Bnd_Box
        :type Position: OCC.wrapper.gp.gp_Pnt
        :type FirstAttach: OCC.wrapper.gp.gp_Pnt
        :type SecondAttach: OCC.wrapper.gp.gp_Pnt
        :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
        :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
        :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.AIS_EqualDistanceRelation_ComputeTwoEdgesLength(*args)

    ComputeTwoEdgesLength = staticmethod(ComputeTwoEdgesLength)

    def ComputeTwoVerticesLength(*args):
        """
        ComputeTwoVerticesLength(Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Vertex FirstVertex, TopoDS_Vertex SecondVertex, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, AIS_TypeOfDist const TypeDist, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

        Computes the interval position between two vertexs. FirstAttach,
        SecondAttach are the returned extreme points of the interval.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type ArrowSize: float
        :type FirstVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type SecondVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type AutomaticPos: bool
        :type IsSetBndBox: bool
        :type BndBox: OCC.wrapper.Bnd.Bnd_Box
        :type TypeDist: OCC.wrapper.AIS.AIS_TypeOfDist
        :type Position: OCC.wrapper.gp.gp_Pnt
        :type FirstAttach: OCC.wrapper.gp.gp_Pnt
        :type SecondAttach: OCC.wrapper.gp.gp_Pnt
        :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
        :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
        :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.AIS_EqualDistanceRelation_ComputeTwoVerticesLength(*args)

    ComputeTwoVerticesLength = staticmethod(ComputeTwoVerticesLength)

    def ComputeOneEdgeOneVertexLength(*args):
        """
        ComputeOneEdgeOneVertexLength(Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Shape FirstShape, TopoDS_Shape SecondShape, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

        Compute the interval location between a vertex and an edge. Edge may be
        a line or a circle.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type ArrowSize: float
        :type FirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SecondShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type AutomaticPos: bool
        :type IsSetBndBox: bool
        :type BndBox: OCC.wrapper.Bnd.Bnd_Box
        :type Position: OCC.wrapper.gp.gp_Pnt
        :type FirstAttach: OCC.wrapper.gp.gp_Pnt
        :type SecondAttach: OCC.wrapper.gp.gp_Pnt
        :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
        :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
        :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(*args)

    ComputeOneEdgeOneVertexLength = staticmethod(ComputeOneEdgeOneVertexLength)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_EqualDistanceRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_EqualDistanceRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_EqualDistanceRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_EqualDistanceRelation
AIS_EqualDistanceRelation_swigregister = _AIS.AIS_EqualDistanceRelation_swigregister
AIS_EqualDistanceRelation_swigregister(AIS_EqualDistanceRelation)

def AIS_EqualDistanceRelation_ComputeTwoEdgesLength(*args):
    """
    AIS_EqualDistanceRelation_ComputeTwoEdgesLength(Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Edge FirstEdge, TopoDS_Edge SecondEdge, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

    Computes the location of an intreval between
    between two edges. FirstAttach , SecondAttach
    are the returned extreme points of the interval.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type ArrowSize: float
    :type FirstEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type SecondEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
    :type AutomaticPos: bool
    :type IsSetBndBox: bool
    :type BndBox: OCC.wrapper.Bnd.Bnd_Box
    :type Position: OCC.wrapper.gp.gp_Pnt
    :type FirstAttach: OCC.wrapper.gp.gp_Pnt
    :type SecondAttach: OCC.wrapper.gp.gp_Pnt
    :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
    :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
    :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

    """
    return _AIS.AIS_EqualDistanceRelation_ComputeTwoEdgesLength(*args)

def AIS_EqualDistanceRelation_ComputeTwoVerticesLength(*args):
    """
    AIS_EqualDistanceRelation_ComputeTwoVerticesLength(Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Vertex FirstVertex, TopoDS_Vertex SecondVertex, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, AIS_TypeOfDist const TypeDist, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

    Computes the interval position between two vertexs. FirstAttach,
    SecondAttach are the returned extreme points of the interval.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type ArrowSize: float
    :type FirstVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type SecondVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
    :type AutomaticPos: bool
    :type IsSetBndBox: bool
    :type BndBox: OCC.wrapper.Bnd.Bnd_Box
    :type TypeDist: OCC.wrapper.AIS.AIS_TypeOfDist
    :type Position: OCC.wrapper.gp.gp_Pnt
    :type FirstAttach: OCC.wrapper.gp.gp_Pnt
    :type SecondAttach: OCC.wrapper.gp.gp_Pnt
    :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
    :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
    :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

    """
    return _AIS.AIS_EqualDistanceRelation_ComputeTwoVerticesLength(*args)

def AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(*args):
    """
    AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Shape FirstShape, TopoDS_Shape SecondShape, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

    Compute the interval location between a vertex and an edge. Edge may be
    a line or a circle.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type ArrowSize: float
    :type FirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type SecondShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
    :type AutomaticPos: bool
    :type IsSetBndBox: bool
    :type BndBox: OCC.wrapper.Bnd.Bnd_Box
    :type Position: OCC.wrapper.gp.gp_Pnt
    :type FirstAttach: OCC.wrapper.gp.gp_Pnt
    :type SecondAttach: OCC.wrapper.gp.gp_Pnt
    :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
    :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
    :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

    """
    return _AIS.AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(*args)

def AIS_EqualDistanceRelation_get_type_name(*args):
    """
    AIS_EqualDistanceRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_EqualDistanceRelation_get_type_name(*args)

def AIS_EqualDistanceRelation_get_type_descriptor(*args):
    """
    AIS_EqualDistanceRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_EqualDistanceRelation_get_type_descriptor(*args)

class Handle_AIS_Line(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Line self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Line_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Line self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Line_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Line self, AIS_Line thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Line_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Line self, Handle_AIS_Line theHandle) -> Handle_AIS_Line
        assign(Handle_AIS_Line self, AIS_Line thePtr) -> Handle_AIS_Line
        assign(Handle_AIS_Line self, Handle_AIS_Line theHandle) -> Handle_AIS_Line

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Line_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Line self) -> AIS_Line

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Line_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Line self) -> AIS_Line

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Line___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Line self) -> AIS_Line

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Line___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Line___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Line___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Line_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Line

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Line self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Line_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Line_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_AIS_Line self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Line_Compute(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Line self) -> Standard_Integer

        Returns the signature 5.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Line_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Line self) -> AIS_KindOfInteractive

        Returns the type Datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Line_Type(self, *args)


    def Line(self, *args):
        """
        Constructs an infinite line.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Line

        """
        res = _AIS.Handle_AIS_Line_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Points(self, *args):
        """
        Points(Handle_AIS_Line self, Handle_Geom_Point thePStart, Handle_Geom_Point thePEnd)

        Returns the starting point thePStart and the end point thePEnd of the line set by SetPoints.

        :type thePStart: OCC.wrapper.Geom.Handle_Geom_Point
        :type thePEnd: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.Handle_AIS_Line_Points(self, *args)


    def SetLine(self, *args):
        """
        SetLine(Handle_AIS_Line self, Handle_Geom_Line theLine)

        instantiates an infinite line.

        :type theLine: OCC.wrapper.Geom.Handle_Geom_Line

        """
        return _AIS.Handle_AIS_Line_SetLine(self, *args)


    def SetPoints(self, *args):
        """
        SetPoints(Handle_AIS_Line self, Handle_Geom_Point thePStart, Handle_Geom_Point thePEnd)

        Sets the starting point thePStart and ending point thePEnd of the
        infinite line to create a finite line segment.

        :type thePStart: OCC.wrapper.Geom.Handle_Geom_Point
        :type thePEnd: OCC.wrapper.Geom.Handle_Geom_Point

        """
        return _AIS.Handle_AIS_Line_SetPoints(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Line self, Quantity_Color aColor)

        Provides a new color setting aColor for the line in the drawing tool, or "Drawer".

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Line_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Line self, Standard_Real const aValue)

        Provides the new width setting aValue for the line in
        the drawing tool, or "Drawer".

        :type aValue: float

        """
        return _AIS.Handle_AIS_Line_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Line self)

        Removes the color setting and returns the original color.


        """
        return _AIS.Handle_AIS_Line_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_AIS_Line self)

        Removes the width setting and returns the original width.


        """
        return _AIS.Handle_AIS_Line_UnsetWidth(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Line self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Line self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Line_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Line self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Line_CurrentFacingModel(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Line self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Line self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Line_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Line self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Line_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Line self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Line_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Line self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Line self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Line_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Line self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Line_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Line_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Line self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Line_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Line self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Line_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Line self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Line_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Line self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Line_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Line self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Line_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Line self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Line_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Line self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Line_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Line self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Line_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Line self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Line_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Line self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Line_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Line self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Line_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Line self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Line_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Line self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Line_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Line self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Line_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Line self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Line_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Line self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Line_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Line self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Line_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Line self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Line self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Line_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Line self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Line_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Line self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Line_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Line self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Line self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Line_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Line self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Line_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Line self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Line_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Line self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Line_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Line self)
        RecomputePrimitives(Handle_AIS_Line self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Line_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Line self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Line_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Line self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Line_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Line_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Line self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Line_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Line self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Line_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Line self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Line self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Line_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Line_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Line self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Line_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Line self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Line_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Line self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Line_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Line self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Line_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Line self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Line_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Line self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Line_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Line self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Line_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Line self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Line self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Line_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Line self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Line_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Line self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Line_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Line self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Line_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Line self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Line_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Line self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Line_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Line self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Line_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Line self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Line_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Line self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Line_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Line self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Line_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Line_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Line self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Line_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Line self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Line_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Line_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Line self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Line self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Line_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Line self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Line_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Line self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Line_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Line self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Line_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Line self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Line self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Line_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Line self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Line_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Line_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Line self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Line self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Line_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Line_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Line_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Line_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Line_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Line self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Line_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Line self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Line_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Line self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Line_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Line self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Line self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Line_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Line_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Line self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Line_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Line self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Line_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Line self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Line_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Line_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Line self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Line self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Line_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Line self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Line_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Line_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Line_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Line self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Line_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Line_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Line self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Line_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Line self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Line_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Line self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Line_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Line_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Line self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Line_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Line self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Line_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Line self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Line_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Line self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Line_DecrementRefCounter(self, *args)

Handle_AIS_Line_swigregister = _AIS.Handle_AIS_Line_swigregister
Handle_AIS_Line_swigregister(Handle_AIS_Line)

def Handle_AIS_Line_DownCast(thing):
    return _AIS.Handle_AIS_Line_DownCast(thing)
Handle_AIS_Line_DownCast = _AIS.Handle_AIS_Line_DownCast

class Handle_AIS_Trihedron(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Trihedron self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Trihedron_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Trihedron self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Trihedron_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Trihedron self, AIS_Trihedron thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Trihedron_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Trihedron self, Handle_AIS_Trihedron theHandle) -> Handle_AIS_Trihedron
        assign(Handle_AIS_Trihedron self, AIS_Trihedron thePtr) -> Handle_AIS_Trihedron
        assign(Handle_AIS_Trihedron self, Handle_AIS_Trihedron theHandle) -> Handle_AIS_Trihedron

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Trihedron_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Trihedron self) -> AIS_Trihedron

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Trihedron_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Trihedron self) -> AIS_Trihedron

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Trihedron___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Trihedron self) -> AIS_Trihedron

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Trihedron___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Trihedron___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Trihedron___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Trihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Trihedron_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Trihedron

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Trihedron self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Trihedron_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Trihedron_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Trihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDatumDisplayMode(self, *args):
        """
        SetDatumDisplayMode(Handle_AIS_Trihedron self, Prs3d_DatumMode theMode)

        Sets Shading or Wireframe display mode, triangle or segment graphic group is used relatively.

        :type theMode: OCC.wrapper.Prs3d.Prs3d_DatumMode

        """
        return _AIS.Handle_AIS_Trihedron_SetDatumDisplayMode(self, *args)


    def DatumDisplayMode(self, *args):
        """
        DatumDisplayMode(Handle_AIS_Trihedron self) -> Prs3d_DatumMode

        Returns datum display mode.

        :rtype: OCC.wrapper.Prs3d.Prs3d_DatumMode

        """
        return _AIS.Handle_AIS_Trihedron_DatumDisplayMode(self, *args)


    def Component(self, *args):
        """
        Returns the right-handed coordinate system set in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        res = _AIS.Handle_AIS_Trihedron_Component(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetComponent(self, *args):
        """
        SetComponent(Handle_AIS_Trihedron self, Handle_Geom_Axis2Placement theComponent)

        Constructs the right-handed coordinate system aComponent.

        :type theComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        return _AIS.Handle_AIS_Trihedron_SetComponent(self, *args)


    def HasOwnSize(self, *args):
        """
        HasOwnSize(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the trihedron object has a size other
        than the default size of 100 mm. along each axis.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasOwnSize(self, *args)


    def SetSize(self, *args):
        """
        SetSize(Handle_AIS_Trihedron self, Standard_Real const theValue)

        Sets the size aValue for the trihedron object.
        The default value is 100 mm.

        :type theValue: float

        """
        return _AIS.Handle_AIS_Trihedron_SetSize(self, *args)


    def UnsetSize(self, *args):
        """
        UnsetSize(Handle_AIS_Trihedron self)

        Removes any non-default settings for size of this trihedron object.
        If the object has 1 color, the default size of the
        drawer is reproduced, otherwise DatumAspect becomes null.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetSize(self, *args)


    def Size(self, *args):
        """
        Size(Handle_AIS_Trihedron self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Trihedron_Size(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Trihedron self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the display mode selected, aMode, is valid for trihedron datums.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_AcceptDisplayMode(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Trihedron self) -> Standard_Integer

        Returns index 3, selection of the planes XOY, YOZ, XOZ.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Trihedron self) -> AIS_KindOfInteractive

        Indicates that the type of Interactive Object is datum.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Trihedron_Type(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Sets the color theColor for this trihedron object, it changes color of axes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetColor(self, *args)


    def SetTextColor(self, *args):
        """
        SetTextColor(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Sets color of label of trihedron axes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetTextColor(self, *args)


    def HasTextColor(self, *args):
        """
        HasTextColor(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if trihedron has own text color

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasTextColor(self, *args)


    def TextColor(self, *args):
        """
        TextColor(Handle_AIS_Trihedron self) -> Quantity_Color

        Returns trihedron text color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_TextColor(self, *args)


    def SetArrowColor(self, *args):
        """
        SetArrowColor(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Sets color of arrow of trihedron axes. Used only in wireframe mode

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetArrowColor(self, *args)


    def HasArrowColor(self, *args):
        """
        HasArrowColor(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if trihedron has own arrow color

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasArrowColor(self, *args)


    def ArrowColor(self, *args):
        """
        ArrowColor(Handle_AIS_Trihedron self) -> Quantity_Color

        Returns trihedron arrow color

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_ArrowColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Trihedron self)

        Removes the settings for color.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetColor(self, *args)


    def SetDatumPartColor(self, *args):
        """
        SetDatumPartColor(Handle_AIS_Trihedron self, Prs3d_DatumParts const thePart, Quantity_Color theColor)

        Sets color of datum part: origin or some of trihedron axes.
        If presentation is shading mode, this color is set for both sides of facing model

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetDatumPartColor(self, *args)


    def DatumPartColor(self, *args):
        """
        DatumPartColor(Handle_AIS_Trihedron self, Prs3d_DatumParts thePart) -> Quantity_Color

        Returns color of datum part: origin or some of trihedron axes.

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_DatumPartColor(self, *args)


    def SetOriginColor(self, *args):
        """
        SetOriginColor(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Sets color of origin.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetOriginColor(self, *args)


    def SetXAxisColor(self, *args):
        """
        SetXAxisColor(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Sets color of x-axis.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetXAxisColor(self, *args)


    def SetYAxisColor(self, *args):
        """
        SetYAxisColor(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Sets color of y-axis.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetYAxisColor(self, *args)


    def SetAxisColor(self, *args):
        """
        SetAxisColor(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Sets color of z-axis.
        Standard_DEPRECATED("This method is deprecated - SetColor() should be called instead")

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_SetAxisColor(self, *args)


    def ToDrawArrows(self, *args):
        """
        ToDrawArrows(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if arrows are to be drawn

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_ToDrawArrows(self, *args)


    def SetDrawArrows(self, *args):
        """
        SetDrawArrows(Handle_AIS_Trihedron self, Standard_Boolean const theToDraw)

        Sets whether to draw the arrows in visualization

        :type theToDraw: bool

        """
        return _AIS.Handle_AIS_Trihedron_SetDrawArrows(self, *args)


    def SetSelectionPriority(self, *args):
        """
        SetSelectionPriority(Handle_AIS_Trihedron self, Prs3d_DatumParts thePart, Standard_Integer thePriority)

        Sets priority of selection for owner of the given type

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :type thePriority: int

        """
        return _AIS.Handle_AIS_Trihedron_SetSelectionPriority(self, *args)


    def SelectionPriority(self, *args):
        """
        SelectionPriority(Handle_AIS_Trihedron self, Prs3d_DatumParts thePart) -> Standard_Integer

        Sets priority of selection for owner of the given type

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_SelectionPriority(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_AIS_Trihedron self, Prs3d_DatumParts const thePart, TCollection_ExtendedString thePriority)

        Sets text label for trihedron axis. Parameter thePart should be XAxis, YAxis or ZAxis

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :type thePriority: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_Trihedron_SetLabel(self, *args)


    def Label(self, *args):
        """
        Returns text of axis. Parameter thePart should be XAxis, YAxis or ZAxis

        :type thePart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_Trihedron_Label(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Trihedron self) -> Standard_Boolean

        Disables auto highlighting to use HilightSelected() and HilightOwnerWithColor() overridden methods.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_IsAutoHilight(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Trihedron self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw ).


        """
        return _AIS.Handle_AIS_Trihedron_ClearSelected(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Trihedron self, Handle_PrsMgr_PresentationManager thePM, NCollection_Sequence_Handle_SelectMgr_EntityOwner theOwners)

        Method which draws selected owners ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theOwners: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Trihedron_HilightSelected(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Trihedron self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Trihedron_HilightOwnerWithColor(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Trihedron self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Trihedron self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Trihedron_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Trihedron self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Trihedron_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Trihedron self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Trihedron_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Trihedron self)"""
        return _AIS.Handle_AIS_Trihedron_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Trihedron self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Trihedron self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Trihedron_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Trihedron self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Trihedron_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Trihedron self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Trihedron self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Trihedron_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Trihedron self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Trihedron_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Trihedron_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Trihedron self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Trihedron_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Trihedron self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Trihedron_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Trihedron self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Trihedron_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Trihedron self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Trihedron self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Trihedron self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Trihedron self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Trihedron_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Trihedron self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Trihedron self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Trihedron_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Trihedron self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Trihedron_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Trihedron self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Trihedron_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Trihedron self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Trihedron_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Trihedron self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Trihedron self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Trihedron_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Trihedron self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Trihedron_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Trihedron self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Trihedron self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Trihedron self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Trihedron_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Trihedron self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Trihedron_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Trihedron self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Trihedron_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Trihedron self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Trihedron_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Trihedron self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Trihedron_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Trihedron self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Trihedron_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Trihedron self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Trihedron_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Trihedron self)
        RecomputePrimitives(Handle_AIS_Trihedron self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Trihedron_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Trihedron self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Trihedron_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Trihedron self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Trihedron_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Trihedron_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Trihedron self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Trihedron_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Trihedron self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Trihedron_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Trihedron self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Trihedron self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Trihedron_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Trihedron_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Trihedron self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Trihedron_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Trihedron self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Trihedron_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Trihedron self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Trihedron_UpdateTransformations(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Trihedron self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Trihedron_ClearDynamicHighlight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Trihedron self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Trihedron_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Trihedron self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Trihedron_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Trihedron self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Trihedron_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Trihedron self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Trihedron_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Trihedron self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Trihedron_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Trihedron self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Trihedron_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Trihedron self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Trihedron_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Trihedron self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Trihedron_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Trihedron self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Trihedron self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Trihedron_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Trihedron_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Trihedron self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Trihedron_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Trihedron self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Trihedron_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Trihedron_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Trihedron self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Trihedron self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Trihedron_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Trihedron self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Trihedron_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Trihedron self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Trihedron_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Trihedron self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Trihedron_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Trihedron self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Trihedron self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Trihedron_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Trihedron self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Trihedron_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Trihedron_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Trihedron self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Trihedron self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Trihedron_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Trihedron_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Trihedron_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Trihedron_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Trihedron_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Trihedron self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Trihedron_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Trihedron self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Trihedron_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Trihedron self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Trihedron_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Trihedron self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Trihedron self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Trihedron_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Trihedron_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Trihedron self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Trihedron_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Trihedron self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Trihedron_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Trihedron self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Trihedron_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Trihedron_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Trihedron self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Trihedron self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Trihedron_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Trihedron self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Trihedron_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Trihedron_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Trihedron_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Trihedron self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Trihedron_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Trihedron_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Trihedron self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Trihedron_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Trihedron self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Trihedron_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Trihedron self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Trihedron_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Trihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Trihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Trihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Trihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Trihedron_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Trihedron self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Trihedron_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Trihedron self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Trihedron self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Trihedron_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Trihedron self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Trihedron_DecrementRefCounter(self, *args)

Handle_AIS_Trihedron_swigregister = _AIS.Handle_AIS_Trihedron_swigregister
Handle_AIS_Trihedron_swigregister(Handle_AIS_Trihedron)

def Handle_AIS_Trihedron_DownCast(thing):
    return _AIS.Handle_AIS_Trihedron_DownCast(thing)
Handle_AIS_Trihedron_DownCast = _AIS.Handle_AIS_Trihedron_DownCast

class AIS_RubberBand(AIS_InteractiveObject):
    """
    Presentation for drawing rubber band selection.
    It supports rectangle and polygonal selection.
    It is constructed in 2d overlay.
    Default configaration is built without filling.
    For rectangle selection use SetRectangle() method.
    For polygonal selection use AddPoint() and GetPoints() methods.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_RubberBand
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_RubberBand(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_RubberBand_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_RubberBand_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_RubberBand_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_RubberBand self) -> AIS_RubberBand
        __init__(AIS_RubberBand self, Quantity_Color theLineColor, Aspect_TypeOfLine const theType, Standard_Real const theLineWidth=1.0, Standard_Boolean const theIsPolygonClosed) -> AIS_RubberBand
        __init__(AIS_RubberBand self, Quantity_Color theLineColor, Aspect_TypeOfLine const theType, Quantity_Color theFillColor, Standard_Real const theTransparency=1.0, Standard_Real const theLineWidth=1.0, Standard_Boolean const theIsPolygonClosed) -> AIS_RubberBand

        Constructs the rubber band with defined filling and line parameters.
        @param theLineColor [in] color of rubber band lines
        @param theType [in] type of rubber band lines
        @param theFillColor [in] color of rubber band filling
        @param theTransparency [in] transparency of the filling. 0 is for opaque filling. By default it is transparent.
        @param theLineWidth [in] width of rubber band line. By default it is 1.
        @warning It binds this object with Graphic3d_ZLayerId_TopOSD layer.

        :type theLineColor: OCC.wrapper.Quantity.Quantity_Color
        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfLine
        :type theFillColor: OCC.wrapper.Quantity.Quantity_Color
        :type theTransparency: float
        :type theLineWidth: float
        :type theIsPolygonClosed: bool

        """
        this = _AIS.new_AIS_RubberBand(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetRectangle(self, *args):
        """
        SetRectangle(AIS_RubberBand self, Standard_Integer const theMinX, Standard_Integer const theMinY, Standard_Integer const theMaxX, Standard_Integer const theMaxY)

        Sets rectangle bounds.

        :type theMinX: int
        :type theMinY: int
        :type theMaxX: int
        :type theMaxY: int

        """
        return _AIS.AIS_RubberBand_SetRectangle(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(AIS_RubberBand self, NCollection_Vec2_Standard_Integer thePoint)

        Adds last point to the list of points. They are used to build polygon for rubber band.
        @sa RemoveLastPoint(), GetPoints()

        :type thePoint: OCC.wrapper.Graphic3d.Graphic3d_Vec2i

        """
        return _AIS.AIS_RubberBand_AddPoint(self, *args)


    def RemoveLastPoint(self, *args):
        """
        RemoveLastPoint(AIS_RubberBand self)

        Remove last point from the list of points for the rubber band polygon.
        @sa AddPoint(), GetPoints()


        """
        return _AIS.AIS_RubberBand_RemoveLastPoint(self, *args)


    def Points(self, *args):
        """
        @return points for the rubber band polygon.

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Graphic3d_Vec2i

        """
        res = _AIS.AIS_RubberBand_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClearPoints(self, *args):
        """
        ClearPoints(AIS_RubberBand self)

        Remove all points for the rubber band polygon.


        """
        return _AIS.AIS_RubberBand_ClearPoints(self, *args)


    def LineColor(self, *args):
        """
        LineColor(AIS_RubberBand self) -> Quantity_Color

        @return the Color attributes.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_RubberBand_LineColor(self, *args)


    def SetLineColor(self, *args):
        """
        SetLineColor(AIS_RubberBand self, Quantity_Color theColor)

        Sets color of lines for rubber band presentation.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_RubberBand_SetLineColor(self, *args)


    def FillColor(self, *args):
        """
        FillColor(AIS_RubberBand self) -> Quantity_Color

        @return the color of rubber band filling.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_RubberBand_FillColor(self, *args)


    def SetFillColor(self, *args):
        """
        SetFillColor(AIS_RubberBand self, Quantity_Color theColor)

        Sets color of rubber band filling.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_RubberBand_SetFillColor(self, *args)


    def SetLineWidth(self, *args):
        """
        SetLineWidth(AIS_RubberBand self, Standard_Real const theWidth)

        Sets width of line for rubber band presentation.

        :type theWidth: float

        """
        return _AIS.AIS_RubberBand_SetLineWidth(self, *args)


    def LineWidth(self, *args):
        """
        LineWidth(AIS_RubberBand self) -> Standard_Real

        @return width of lines.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_RubberBand_LineWidth(self, *args)


    def SetLineType(self, *args):
        """
        SetLineType(AIS_RubberBand self, Aspect_TypeOfLine const theType)

        Sets type of line for rubber band presentation.

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.AIS_RubberBand_SetLineType(self, *args)


    def LineType(self, *args):
        """
        LineType(AIS_RubberBand self) -> Aspect_TypeOfLine

        @return type of lines.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.AIS_RubberBand_LineType(self, *args)


    def SetFillTransparency(self, *args):
        """
        SetFillTransparency(AIS_RubberBand self, Standard_Real const theValue)

        Sets fill transparency.
        @param theValue [in] the transparency value. 1.0 is for transparent background

        :type theValue: float

        """
        return _AIS.AIS_RubberBand_SetFillTransparency(self, *args)


    def FillTransparency(self, *args):
        """
        FillTransparency(AIS_RubberBand self) -> Standard_Real

        @return fill transparency.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_RubberBand_FillTransparency(self, *args)


    def SetFilling(self, *args):
        """
        SetFilling(AIS_RubberBand self, Standard_Boolean const theIsFilling)
        SetFilling(AIS_RubberBand self, Quantity_Color theColor, Standard_Real const theTransparency)

        Enable filling of rubber band with defined parameters.
        @param theColor [in] color of filling
        @param theTransparency [in] transparency of the filling. 0 is for opaque filling.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theTransparency: float

        """
        return _AIS.AIS_RubberBand_SetFilling(self, *args)


    def IsFilling(self, *args):
        """
        IsFilling(AIS_RubberBand self) -> Standard_Boolean

        @return true if filling of rubber band is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_RubberBand_IsFilling(self, *args)


    def IsPolygonClosed(self, *args):
        """
        IsPolygonClosed(AIS_RubberBand self) -> Standard_Boolean

        @return true if automatic closing of rubber band is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_RubberBand_IsPolygonClosed(self, *args)


    def SetPolygonClosed(self, *args):
        """
        SetPolygonClosed(AIS_RubberBand self, Standard_Boolean theIsPolygonClosed)

        Automatically create an additional line connecting the first and 
        the last screen points to close the boundary polyline

        :type theIsPolygonClosed: bool

        """
        return _AIS.AIS_RubberBand_SetPolygonClosed(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_RubberBand
AIS_RubberBand_swigregister = _AIS.AIS_RubberBand_swigregister
AIS_RubberBand_swigregister(AIS_RubberBand)

def AIS_RubberBand_get_type_name(*args):
    """
    AIS_RubberBand_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_RubberBand_get_type_name(*args)

def AIS_RubberBand_get_type_descriptor(*args):
    """
    AIS_RubberBand_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_RubberBand_get_type_descriptor(*args)

class Handle_AIS_RadiusDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_RadiusDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_RadiusDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_RadiusDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_RadiusDimension self, AIS_RadiusDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_RadiusDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_RadiusDimension self, Handle_AIS_RadiusDimension theHandle) -> Handle_AIS_RadiusDimension
        assign(Handle_AIS_RadiusDimension self, AIS_RadiusDimension thePtr) -> Handle_AIS_RadiusDimension
        assign(Handle_AIS_RadiusDimension self, Handle_AIS_RadiusDimension theHandle) -> Handle_AIS_RadiusDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_RadiusDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_RadiusDimension self) -> AIS_RadiusDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_RadiusDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_RadiusDimension self) -> AIS_RadiusDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_RadiusDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_RadiusDimension self) -> AIS_RadiusDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_RadiusDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_RadiusDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_RadiusDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_RadiusDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_RadiusDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_RadiusDimension

    def Circle(self, *args):
        """
        @return measured geometry circle.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        res = _AIS.Handle_AIS_RadiusDimension_Circle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AnchorPoint(self, *args):
        """
        @return anchor point on circle for radius dimension.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_RadiusDimension_AnchorPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        @return the measured shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_RadiusDimension_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMeasuredGeometry(self, *args):
        """
        SetMeasuredGeometry(Handle_AIS_RadiusDimension self, gp_Circ theCircle)
        SetMeasuredGeometry(Handle_AIS_RadiusDimension self, gp_Circ theCircle, gp_Pnt theAnchorPoint, Standard_Boolean const theHasAnchor)
        SetMeasuredGeometry(Handle_AIS_RadiusDimension self, TopoDS_Shape theShape)
        SetMeasuredGeometry(Handle_AIS_RadiusDimension self, TopoDS_Shape theShape, gp_Pnt theAnchorPoint, Standard_Boolean const theHasAnchor)

        Measure radius on the passed shape, if applicable.
        The dimension will become invalid if the passed shape is not
        measurable or if measured diameter value is less than Precision::Confusion().
        @param theShape [in] the shape to measure.
        @param theAnchorPoint [in] the point to attach the dimension lines, should be on the circle
        @param theHasAnchor   [in] should be set TRUE if theAnchorPoint should be used

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theAnchorPoint: OCC.wrapper.gp.gp_Pnt
        :type theHasAnchor: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_SetMeasuredGeometry(self, *args)


    def GetDisplayUnits(self, *args):
        """
        @return the display units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_RadiusDimension_GetDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModelUnits(self, *args):
        """
        @return the model units string.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_RadiusDimension_GetModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayUnits(self, *args):
        """
        SetDisplayUnits(Handle_AIS_RadiusDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_RadiusDimension_SetDisplayUnits(self, *args)


    def SetModelUnits(self, *args):
        """
        SetModelUnits(Handle_AIS_RadiusDimension self, TCollection_AsciiString theUnits)

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_RadiusDimension_SetModelUnits(self, *args)


    def SetTextPosition(self, *args):
        """
        SetTextPosition(Handle_AIS_RadiusDimension self, gp_Pnt theTextPos)

        :type theTextPos: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_RadiusDimension_SetTextPosition(self, *args)


    def GetTextPosition(self, *args):
        """
        GetTextPosition(Handle_AIS_RadiusDimension self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_RadiusDimension_GetTextPosition(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_RadiusDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_RadiusDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_RadiusDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_RadiusDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetValue(self, *args):
        """
        GetValue(Handle_AIS_RadiusDimension self) -> Standard_Real

        Gets dimension measurement value. If the value to display is not
        specified by user, then the dimension object is responsible to
        compute it on its own in model space coordinates.
        @return the dimension value (in model units) which is used
        during display of the presentation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RadiusDimension_GetValue(self, *args)


    def SetComputedValue(self, *args):
        """
        SetComputedValue(Handle_AIS_RadiusDimension self)

        Sets computed dimension value. Resets custom value mode if it was set.


        """
        return _AIS.Handle_AIS_RadiusDimension_SetComputedValue(self, *args)


    def SetCustomValue(self, *args):
        """
        SetCustomValue(Handle_AIS_RadiusDimension self, Standard_Real const theValue)
        SetCustomValue(Handle_AIS_RadiusDimension self, TCollection_ExtendedString theValue)

        Sets user-defined dimension value.
        Unit conversion during the display is not applyed.
        @param theValue [in] the user-defined value to display.

        :type theValue: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_RadiusDimension_SetCustomValue(self, *args)


    def GetCustomValue(self, *args):
        """
        Gets user-defined dimension value.
        @return dimension value string.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_RadiusDimension_GetCustomValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPlane(self, *args):
        """
        Get the dimension plane in which the 2D dimension presentation is computed.
        By default, if plane is not defined by user, it is computed automatically
        after dimension geometry is computed.
        If computed dimension geometry (points) can't be placed on the user-defined
        plane, dimension geometry was set as invalid (validity flag is set to false)
        and dimension presentation will not be computed.
        If user-defined plane allow geometry placement on it, it will be used for
        computing of the dimension presentation.
        @return dimension plane used for presentation computing.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _AIS.Handle_AIS_RadiusDimension_GetPlane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetGeometryType(self, *args):
        """
        GetGeometryType(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Geometry type defines type of shapes on which the dimension is to be built. 
        @return type of geometry on which the dimension will be built.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_GetGeometryType(self, *args)


    def SetCustomPlane(self, *args):
        """
        SetCustomPlane(Handle_AIS_RadiusDimension self, gp_Pln thePlane)

        Sets user-defined plane where the 2D dimension presentation will be placed.
        Checks validity of this plane if geometry has been set already.
        Validity of the plane is checked according to the geometry set
        and has different criteria for different kinds of dimensions.

        :type thePlane: OCC.wrapper.gp.gp_Pln

        """
        return _AIS.Handle_AIS_RadiusDimension_SetCustomPlane(self, *args)


    def UnsetCustomPlane(self, *args):
        """
        UnsetCustomPlane(Handle_AIS_RadiusDimension self)

        Unsets user-defined plane. Therefore the plane for dimension will be
        computed automatically.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetCustomPlane(self, *args)


    def IsTextPositionCustom(self, *args):
        """
        IsTextPositionCustom(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        @return TRUE if text position is set by user with method SetTextPosition().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsTextPositionCustom(self, *args)


    def DimensionAspect(self, *args):
        """
        DimensionAspect(Handle_AIS_RadiusDimension self) -> Handle_Prs3d_DimensionAspect

        Gets the dimension aspect from AIS object drawer.
        Dimension aspect contains aspects of line, text and arrows for dimension presentation.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_RadiusDimension_DimensionAspect(self, *args)


    def SetDimensionAspect(self, *args):
        """
        SetDimensionAspect(Handle_AIS_RadiusDimension self, Handle_Prs3d_DimensionAspect theDimensionAspect)

        Sets new dimension aspect for the interactive object drawer.
        The dimension aspect provides dynamic properties which are generally
        used during computation of dimension presentations.

        :type theDimensionAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_RadiusDimension_SetDimensionAspect(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_RadiusDimension self) -> AIS_KindOfDimension

        @return the kind of dimension.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_RadiusDimension_KindOfDimension(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_RadiusDimension self) -> AIS_KindOfInteractive

        @return the kind of interactive.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_RadiusDimension_Type(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_RadiusDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode theMode.
        The interactive context can have a default mode of representation for
        the set of Interactive Objects. This mode may not be accepted by object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_AcceptDisplayMode(self, *args)


    def DisplaySpecialSymbol(self, *args):
        """
        DisplaySpecialSymbol(Handle_AIS_RadiusDimension self) -> AIS_DisplaySpecialSymbol

        @return dimension special symbol display options.

        :rtype: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_RadiusDimension_DisplaySpecialSymbol(self, *args)


    def SetDisplaySpecialSymbol(self, *args):
        """
        SetDisplaySpecialSymbol(Handle_AIS_RadiusDimension self, AIS_DisplaySpecialSymbol const theDisplaySpecSymbol)

        Specifies whether to display special symbol or not.

        :type theDisplaySpecSymbol: OCC.wrapper.AIS.AIS_DisplaySpecialSymbol

        """
        return _AIS.Handle_AIS_RadiusDimension_SetDisplaySpecialSymbol(self, *args)


    def SpecialSymbol(self, *args):
        """
        SpecialSymbol(Handle_AIS_RadiusDimension self) -> Standard_ExtCharacter

        @return special symbol.

        :rtype: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_RadiusDimension_SpecialSymbol(self, *args)


    def SetSpecialSymbol(self, *args):
        """
        SetSpecialSymbol(Handle_AIS_RadiusDimension self, Standard_ExtCharacter const theSpecialSymbol)

        Specifies special symbol.

        :type theSpecialSymbol: OCC.wrapper.Standard.Standard_ExtCharacter

        """
        return _AIS.Handle_AIS_RadiusDimension_SetSpecialSymbol(self, *args)


    def UnsetFixedTextPosition(self, *args):
        """
        UnsetFixedTextPosition(Handle_AIS_RadiusDimension self)

        Unsets user defined text positioning and enables text positioning
        by other parameters: text alignment, extension size, flyout and custom plane.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetFixedTextPosition(self, *args)


    def SelToleranceForText2d(self, *args):
        """
        SelToleranceForText2d(Handle_AIS_RadiusDimension self) -> Standard_Real

        Returns selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        Important! Only for 2d text.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RadiusDimension_SelToleranceForText2d(self, *args)


    def SetSelToleranceForText2d(self, *args):
        """
        SetSelToleranceForText2d(Handle_AIS_RadiusDimension self, Standard_Real const theTol)

        Sets selection tolerance for text2d:
        For 2d text selection detection sensitive point with tolerance is used
        to change this tolerance use this method
        Important! Only for 2d text.

        :type theTol: float

        """
        return _AIS.Handle_AIS_RadiusDimension_SetSelToleranceForText2d(self, *args)


    def GetFlyout(self, *args):
        """
        GetFlyout(Handle_AIS_RadiusDimension self) -> Standard_Real

        @return flyout value for dimension.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RadiusDimension_GetFlyout(self, *args)


    def SetFlyout(self, *args):
        """
        SetFlyout(Handle_AIS_RadiusDimension self, Standard_Real const theFlyout)

        Sets flyout value for dimension.

        :type theFlyout: float

        """
        return _AIS.Handle_AIS_RadiusDimension_SetFlyout(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Check that the input geometry for dimension is valid and the
        presentation can be successfully computed.
        @return TRUE if dimension geometry is ok.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsValid(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_RadiusDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_RadiusDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_RadiusDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_RadiusDimension_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_RadiusDimension self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RadiusDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_RadiusDimension self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_RadiusDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_RadiusDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_RadiusDimension self)"""
        return _AIS.Handle_AIS_RadiusDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_RadiusDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_RadiusDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_RadiusDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_RadiusDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_RadiusDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_RadiusDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_RadiusDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_RadiusDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_RadiusDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_RadiusDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_RadiusDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_RadiusDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_RadiusDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_RadiusDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_RadiusDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_RadiusDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_RadiusDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_RadiusDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RadiusDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_RadiusDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RadiusDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_RadiusDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_RadiusDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_RadiusDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_RadiusDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_RadiusDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_RadiusDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_RadiusDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_RadiusDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RadiusDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_RadiusDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_RadiusDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_RadiusDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_RadiusDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_RadiusDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_RadiusDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_RadiusDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_RadiusDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_RadiusDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_RadiusDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_RadiusDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_RadiusDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_RadiusDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_RadiusDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_RadiusDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_RadiusDimension self)
        RecomputePrimitives(Handle_AIS_RadiusDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_RadiusDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_RadiusDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_RadiusDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_RadiusDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_RadiusDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_RadiusDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_RadiusDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_RadiusDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_RadiusDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_RadiusDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_RadiusDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_RadiusDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_RadiusDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_RadiusDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_RadiusDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_RadiusDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_RadiusDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_RadiusDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_RadiusDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_RadiusDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_RadiusDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_RadiusDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_RadiusDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_RadiusDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_RadiusDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_RadiusDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_RadiusDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_RadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_RadiusDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_RadiusDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_RadiusDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_RadiusDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_RadiusDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_RadiusDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_RadiusDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_RadiusDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_RadiusDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_RadiusDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_RadiusDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_RadiusDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_RadiusDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_RadiusDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_RadiusDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_RadiusDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_RadiusDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_RadiusDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_RadiusDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_RadiusDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_RadiusDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_RadiusDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_RadiusDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_RadiusDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_RadiusDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_RadiusDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_RadiusDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_RadiusDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_RadiusDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_RadiusDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_RadiusDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_RadiusDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_RadiusDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_RadiusDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_RadiusDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_RadiusDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_RadiusDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_RadiusDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_RadiusDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_RadiusDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_RadiusDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_RadiusDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_RadiusDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_RadiusDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_RadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_RadiusDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_RadiusDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_RadiusDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_RadiusDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_RadiusDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_RadiusDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_RadiusDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_RadiusDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_RadiusDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_RadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_RadiusDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_RadiusDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_RadiusDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_RadiusDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_RadiusDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_RadiusDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_RadiusDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_RadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_RadiusDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_RadiusDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_RadiusDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_RadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_RadiusDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_RadiusDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_RadiusDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_RadiusDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_RadiusDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_RadiusDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_RadiusDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_RadiusDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_RadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_RadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_RadiusDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_RadiusDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RadiusDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_RadiusDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_RadiusDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_RadiusDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_RadiusDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_RadiusDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RadiusDimension_DecrementRefCounter(self, *args)

Handle_AIS_RadiusDimension_swigregister = _AIS.Handle_AIS_RadiusDimension_swigregister
Handle_AIS_RadiusDimension_swigregister(Handle_AIS_RadiusDimension)

def Handle_AIS_RadiusDimension_DownCast(thing):
    return _AIS.Handle_AIS_RadiusDimension_DownCast(thing)
Handle_AIS_RadiusDimension_DownCast = _AIS.Handle_AIS_RadiusDimension_DownCast

class NCollection_List_Handle_SelectMgr_EntityOwner(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_SelectMgr_EntityOwner self) -> NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_SelectMgr_EntityOwner self) -> NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_SelectMgr_EntityOwner self) -> NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_SelectMgr_EntityOwner self) -> NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _AIS.new_NCollection_List_Handle_SelectMgr_EntityOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_SelectMgr_EntityOwner self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_SelectMgr_EntityOwner self, NCollection_List_Handle_SelectMgr_EntityOwner theOther) -> NCollection_List_Handle_SelectMgr_EntityOwner

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_SelectMgr_EntityOwner self, NCollection_List_Handle_SelectMgr_EntityOwner theOther) -> NCollection_List_Handle_SelectMgr_EntityOwner

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_SelectMgr_EntityOwner self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theItem) -> Handle_SelectMgr_EntityOwner
        Append(NCollection_List_Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theItem, NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & theIter)
        Append(NCollection_List_Handle_SelectMgr_EntityOwner self, NCollection_List_Handle_SelectMgr_EntityOwner theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theItem) -> Handle_SelectMgr_EntityOwner
        Prepend(NCollection_List_Handle_SelectMgr_EntityOwner self, NCollection_List_Handle_SelectMgr_EntityOwner theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_SelectMgr_EntityOwner self)

        RemoveFirst item


        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_SelectMgr_EntityOwner self, NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theItem, NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & theIter) -> Handle_SelectMgr_EntityOwner
        InsertBefore(NCollection_List_Handle_SelectMgr_EntityOwner self, NCollection_List_Handle_SelectMgr_EntityOwner theOther, NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_SelectMgr_EntityOwner self, Handle_SelectMgr_EntityOwner theItem, NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & theIter) -> Handle_SelectMgr_EntityOwner
        InsertAfter(NCollection_List_Handle_SelectMgr_EntityOwner self, NCollection_List_Handle_SelectMgr_EntityOwner theOther, NCollection_List< opencascade::handle< SelectMgr_EntityOwner > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_SelectMgr_EntityOwner self)

        Reverse the list


        """
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_Reverse(self, *args)


    def __iter__(self):
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_List_Handle_SelectMgr_EntityOwner
NCollection_List_Handle_SelectMgr_EntityOwner_swigregister = _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_swigregister
NCollection_List_Handle_SelectMgr_EntityOwner_swigregister(NCollection_List_Handle_SelectMgr_EntityOwner)

class NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper___next__(self)
NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper_swigregister = _AIS.NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper_swigregister
NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper_swigregister(NCollection_List_Handle_SelectMgr_EntityOwner_IteratorHelper)


try:
	AIS_NListOfEntityOwner = NCollection_List_Handle_SelectMgr_EntityOwner
except NameError:
	pass # does not exist, probably ignored

class AIS_TangentRelation(AIS_Relation):
    """
    A framework to display tangency constraints between
    two or more Interactive Objects of the datum type.
    The datums are normally faces or edges.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_TangentRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_TangentRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_TangentRelation self, TopoDS_Shape aFShape, TopoDS_Shape aSShape, Handle_Geom_Plane aPlane, Standard_Integer const anExternRef=0) -> AIS_TangentRelation

        TwoFacesTangent or TwoEdgesTangent relation
        Constructs an object to display tangency constraints.
        This object is defined by the first shape aFShape, the
        second shape aSShape, the plane aPlane and the index anExternRef.
        aPlane serves as an optional axis.
        anExternRef set to 0 indicates that there is no relation.

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type anExternRef: int

        """
        this = _AIS.new_AIS_TangentRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ExternRef(self, *args):
        """
        ExternRef(AIS_TangentRelation self) -> Standard_Integer

        Returns the external reference for tangency.
        The values are as follows:
        -   0 - there is no connection;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.
        This reference is defined at construction time.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_TangentRelation_ExternRef(self, *args)


    def SetExternRef(self, *args):
        """
        SetExternRef(AIS_TangentRelation self, Standard_Integer const aRef)

        Sets the external reference for tangency, aRef.
        The values are as follows:
        -   0 - there is no connection;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.
        This reference is initially defined at construction time.

        :type aRef: int

        """
        return _AIS.AIS_TangentRelation_SetExternRef(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_TangentRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_TangentRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_TangentRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_TangentRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_TangentRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_TangentRelation
AIS_TangentRelation_swigregister = _AIS.AIS_TangentRelation_swigregister
AIS_TangentRelation_swigregister(AIS_TangentRelation)

def AIS_TangentRelation_get_type_name(*args):
    """
    AIS_TangentRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_TangentRelation_get_type_name(*args)

def AIS_TangentRelation_get_type_descriptor(*args):
    """
    AIS_TangentRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_TangentRelation_get_type_descriptor(*args)

class Handle_AIS_MidPointRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_MidPointRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_MidPointRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_MidPointRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_MidPointRelation self, AIS_MidPointRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_MidPointRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_MidPointRelation self, Handle_AIS_MidPointRelation theHandle) -> Handle_AIS_MidPointRelation
        assign(Handle_AIS_MidPointRelation self, AIS_MidPointRelation thePtr) -> Handle_AIS_MidPointRelation
        assign(Handle_AIS_MidPointRelation self, Handle_AIS_MidPointRelation theHandle) -> Handle_AIS_MidPointRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_MidPointRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_MidPointRelation self) -> AIS_MidPointRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_MidPointRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_MidPointRelation self) -> AIS_MidPointRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_MidPointRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_MidPointRelation self) -> AIS_MidPointRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_MidPointRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_MidPointRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_MidPointRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_MidPointRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_MidPointRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_MidPointRelation

    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_IsMovable(self, *args)


    def SetTool(self, *args):
        """
        SetTool(Handle_AIS_MidPointRelation self, TopoDS_Shape aMidPointTool)

        :type aMidPointTool: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_MidPointRelation_SetTool(self, *args)


    def GetTool(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_MidPointRelation_GetTool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_AIS_MidPointRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        Computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MidPointRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_MidPointRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_MidPointRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MidPointRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_MidPointRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_MidPointRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MidPointRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_MidPointRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_MidPointRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_MidPointRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_MidPointRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_MidPointRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_MidPointRelation_KindOfDimension(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_MidPointRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_MidPointRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_MidPointRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_MidPointRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_MidPointRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_MidPointRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_MidPointRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_MidPointRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_MidPointRelation self)"""
        return _AIS.Handle_AIS_MidPointRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_MidPointRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_MidPointRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_MidPointRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_MidPointRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MidPointRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_MidPointRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_MidPointRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_MidPointRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_MidPointRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MidPointRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_MidPointRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_MidPointRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_MidPointRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_MidPointRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MidPointRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_MidPointRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_MidPointRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_MidPointRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_MidPointRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_MidPointRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_MidPointRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_MidPointRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_MidPointRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_MidPointRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_MidPointRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_MidPointRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MidPointRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_MidPointRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_MidPointRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_MidPointRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MidPointRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_MidPointRelation self)"""
        return _AIS.Handle_AIS_MidPointRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_MidPointRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_MidPointRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_MidPointRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MidPointRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_MidPointRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_MidPointRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_MidPointRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_MidPointRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_MidPointRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_MidPointRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_MidPointRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_MidPointRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_MidPointRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_MidPointRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_MidPointRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_MidPointRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MidPointRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_MidPointRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_MidPointRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_MidPointRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_MidPointRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_MidPointRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MidPointRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_MidPointRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_MidPointRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_MidPointRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_MidPointRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_MidPointRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_MidPointRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_MidPointRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_MidPointRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_MidPointRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_MidPointRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_MidPointRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_MidPointRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_MidPointRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_MidPointRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_MidPointRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MidPointRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_MidPointRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_MidPointRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_MidPointRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MidPointRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_MidPointRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_MidPointRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_MidPointRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MidPointRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_MidPointRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_MidPointRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_MidPointRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_MidPointRelation self)
        RecomputePrimitives(Handle_AIS_MidPointRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MidPointRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_MidPointRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_MidPointRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_MidPointRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MidPointRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_MidPointRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_MidPointRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_MidPointRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MidPointRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_MidPointRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_MidPointRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_MidPointRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_MidPointRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_MidPointRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_MidPointRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_MidPointRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_MidPointRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_MidPointRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_MidPointRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_MidPointRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_MidPointRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_MidPointRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_MidPointRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_MidPointRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_MidPointRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MidPointRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_MidPointRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_MidPointRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MidPointRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_MidPointRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_MidPointRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_MidPointRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_MidPointRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MidPointRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_MidPointRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_MidPointRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_MidPointRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_MidPointRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_MidPointRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_MidPointRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_MidPointRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_MidPointRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_MidPointRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_MidPointRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_MidPointRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_MidPointRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MidPointRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_MidPointRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_MidPointRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_MidPointRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MidPointRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_MidPointRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_MidPointRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_MidPointRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_MidPointRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_MidPointRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_MidPointRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_MidPointRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_MidPointRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_MidPointRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_MidPointRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_MidPointRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MidPointRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_MidPointRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_MidPointRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_MidPointRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_MidPointRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MidPointRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_MidPointRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_MidPointRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_MidPointRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_MidPointRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_MidPointRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MidPointRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_MidPointRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_MidPointRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_MidPointRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_MidPointRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_MidPointRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_MidPointRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_MidPointRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_MidPointRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_MidPointRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MidPointRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_MidPointRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_MidPointRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_MidPointRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_MidPointRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_MidPointRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_MidPointRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_MidPointRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MidPointRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MidPointRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MidPointRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_MidPointRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MidPointRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_MidPointRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_MidPointRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_MidPointRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_MidPointRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_MidPointRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_MidPointRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_MidPointRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_MidPointRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_MidPointRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_MidPointRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_MidPointRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_MidPointRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_MidPointRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_MidPointRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_MidPointRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_MidPointRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_MidPointRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_MidPointRelation_DecrementRefCounter(self, *args)

Handle_AIS_MidPointRelation_swigregister = _AIS.Handle_AIS_MidPointRelation_swigregister
Handle_AIS_MidPointRelation_swigregister(Handle_AIS_MidPointRelation)

def Handle_AIS_MidPointRelation_DownCast(thing):
    return _AIS.Handle_AIS_MidPointRelation_DownCast(thing)
Handle_AIS_MidPointRelation_DownCast = _AIS.Handle_AIS_MidPointRelation_DownCast

class AIS_Plane(AIS_InteractiveObject):
    """
    Constructs plane datums to be used in construction of
    composite shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Plane
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Plane(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Plane_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Plane_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Plane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_Plane self, Handle_Geom_Plane aComponent, Standard_Boolean const aCurrentMode) -> AIS_Plane
        __init__(AIS_Plane self, Handle_Geom_Plane aComponent, gp_Pnt aCenter, Standard_Boolean const aCurrentMode) -> AIS_Plane
        __init__(AIS_Plane self, Handle_Geom_Plane aComponent, gp_Pnt aCenter, gp_Pnt aPmin, gp_Pnt aPmax, Standard_Boolean const aCurrentMode) -> AIS_Plane
        __init__(AIS_Plane self, Handle_Geom_Axis2Placement aComponent, AIS_TypeOfPlane const aPlaneType, Standard_Boolean const aCurrentMode) -> AIS_Plane

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement
        :type aPlaneType: OCC.wrapper.AIS.AIS_TypeOfPlane
        :type aCurrentMode: bool

        """
        this = _AIS.new_AIS_Plane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetSize(self, *args):
        """
        SetSize(AIS_Plane self, Standard_Real const aValue)
        SetSize(AIS_Plane self, Standard_Real const Xval, Standard_Real const YVal)

        Sets the size defined by the length along the X axis
        XVal and the length along the Y axis YVal.

        :type Xval: float
        :type YVal: float

        """
        return _AIS.AIS_Plane_SetSize(self, *args)


    def UnsetSize(self, *args):
        """UnsetSize(AIS_Plane self)"""
        return _AIS.AIS_Plane_UnsetSize(self, *args)


    def Size(self, *args):
        """
        Size(AIS_Plane self) -> Standard_Boolean

        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Plane_Size(self, *args)


    def HasOwnSize(self, *args):
        """
        HasOwnSize(AIS_Plane self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Plane_HasOwnSize(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_Plane self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_Plane_Signature(self, *args)


    def Type(self, *args):
        """
        Type(AIS_Plane self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_Plane_Type(self, *args)


    def Component(self, *args):
        """
        Returns the component specified in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.AIS_Plane_Component(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetComponent(self, *args):
        """
        SetComponent(AIS_Plane self, Handle_Geom_Plane aComponent)

        Creates an instance of the plane aComponent.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.AIS_Plane_SetComponent(self, *args)


    def PlaneAttributes(self, *args):
        """
        PlaneAttributes(AIS_Plane self, Handle_Geom_Plane aComponent, gp_Pnt aCenter, gp_Pnt aPmin, gp_Pnt aPmax) -> Standard_Boolean

        Returns the settings for the selected plane
        aComponent, provided in SetPlaneAttributes.
        These include the points aCenter, aPmin, and aPmax

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Plane
        :type aCenter: OCC.wrapper.gp.gp_Pnt
        :type aPmin: OCC.wrapper.gp.gp_Pnt
        :type aPmax: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Plane_PlaneAttributes(self, *args)


    def SetPlaneAttributes(self, *args):
        """
        SetPlaneAttributes(AIS_Plane self, Handle_Geom_Plane aComponent, gp_Pnt aCenter, gp_Pnt aPmin, gp_Pnt aPmax)

        Allows you to provide settings other than default ones
        for the selected plane. These include: center point
        aCenter, maximum aPmax and minimum aPmin.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Plane
        :type aCenter: OCC.wrapper.gp.gp_Pnt
        :type aPmin: OCC.wrapper.gp.gp_Pnt
        :type aPmax: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_Plane_SetPlaneAttributes(self, *args)


    def Center(self, *args):
        """
        Returns the coordinates of the center point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.AIS_Plane_Center(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCenter(self, *args):
        """
        SetCenter(AIS_Plane self, gp_Pnt theCenter)

        Provides settings for the center theCenter other than (0, 0, 0).

        :type theCenter: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.AIS_Plane_SetCenter(self, *args)


    def SetAxis2Placement(self, *args):
        """
        SetAxis2Placement(AIS_Plane self, Handle_Geom_Axis2Placement aComponent, AIS_TypeOfPlane const aPlaneType)

        Allows you to provide settings for the position and
        direction of one of the plane's axes, aComponent, in
        3D space. The coordinate system used is
        right-handed, and the type of plane aPlaneType is one of:
        -   AIS_ TOPL_Unknown
        -   AIS_ TOPL_XYPlane
        -   AIS_ TOPL_XZPlane
        -   AIS_ TOPL_YZPlane}.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement
        :type aPlaneType: OCC.wrapper.AIS.AIS_TypeOfPlane

        """
        return _AIS.AIS_Plane_SetAxis2Placement(self, *args)


    def Axis2Placement(self, *args):
        """
        Axis2Placement(AIS_Plane self) -> Handle_Geom_Axis2Placement

        Returns the position of the plane's axis2 system
        identifying the x, y, or z axis and giving the plane a
        direction in 3D space. An axis2 system is a right-handed coordinate system.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        return _AIS.AIS_Plane_Axis2Placement(self, *args)


    def TypeOfPlane(self, *args):
        """
        TypeOfPlane(AIS_Plane self) -> AIS_TypeOfPlane

        Returns the type of plane - xy, yz, xz or unknown.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfPlane

        """
        return _AIS.AIS_Plane_TypeOfPlane(self, *args)


    def IsXYZPlane(self, *args):
        """
        IsXYZPlane(AIS_Plane self) -> Standard_Boolean

        Returns the type of plane - xy, yz, or xz.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Plane_IsXYZPlane(self, *args)


    def CurrentMode(self, *args):
        """
        CurrentMode(AIS_Plane self) -> Standard_Boolean

        Returns the non-default current display mode set by SetCurrentMode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Plane_CurrentMode(self, *args)


    def SetCurrentMode(self, *args):
        """
        SetCurrentMode(AIS_Plane self, Standard_Boolean const theCurrentMode)

        Allows you to provide settings for a non-default
        current display mode.

        :type theCurrentMode: bool

        """
        return _AIS.AIS_Plane_SetCurrentMode(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_Plane self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode selected, aMode, is valid for planes.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Plane_AcceptDisplayMode(self, *args)


    def SetContext(self, *args):
        """
        SetContext(AIS_Plane self, Handle_AIS_InteractiveContext aCtx)

        connection to <aCtx> default drawer implies a recomputation of Frame values.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.AIS_Plane_SetContext(self, *args)


    def TypeOfSensitivity(self, *args):
        """
        TypeOfSensitivity(AIS_Plane self) -> Select3D_TypeOfSensitivity

        Returns the type of sensitivity for the plane;

        :rtype: OCC.wrapper.Select3D.Select3D_TypeOfSensitivity

        """
        return _AIS.AIS_Plane_TypeOfSensitivity(self, *args)


    def SetTypeOfSensitivity(self, *args):
        """
        SetTypeOfSensitivity(AIS_Plane self, Select3D_TypeOfSensitivity theTypeOfSensitivity)

        Sets the type of sensitivity for the plane.

        :type theTypeOfSensitivity: OCC.wrapper.Select3D.Select3D_TypeOfSensitivity

        """
        return _AIS.AIS_Plane_SetTypeOfSensitivity(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_Plane self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_Plane_Compute(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_Plane self, Quantity_Color aColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_Plane_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_Plane self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.AIS_Plane_UnsetColor(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_Plane
AIS_Plane_swigregister = _AIS.AIS_Plane_swigregister
AIS_Plane_swigregister(AIS_Plane)

def AIS_Plane_get_type_name(*args):
    """
    AIS_Plane_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Plane_get_type_name(*args)

def AIS_Plane_get_type_descriptor(*args):
    """
    AIS_Plane_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Plane_get_type_descriptor(*args)

class Handle_AIS_Plane(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Plane self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Plane_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Plane self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Plane_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Plane self, AIS_Plane thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Plane_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Plane self, Handle_AIS_Plane theHandle) -> Handle_AIS_Plane
        assign(Handle_AIS_Plane self, AIS_Plane thePtr) -> Handle_AIS_Plane
        assign(Handle_AIS_Plane self, Handle_AIS_Plane theHandle) -> Handle_AIS_Plane

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Plane_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Plane self) -> AIS_Plane

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Plane_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Plane self) -> AIS_Plane

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Plane___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Plane self) -> AIS_Plane

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Plane___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Plane___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Plane___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Plane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Plane_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Plane

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Plane self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Plane_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Plane_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Plane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSize(self, *args):
        """
        SetSize(Handle_AIS_Plane self, Standard_Real const aValue)
        SetSize(Handle_AIS_Plane self, Standard_Real const Xval, Standard_Real const YVal)

        Sets the size defined by the length along the X axis
        XVal and the length along the Y axis YVal.

        :type Xval: float
        :type YVal: float

        """
        return _AIS.Handle_AIS_Plane_SetSize(self, *args)


    def UnsetSize(self, *args):
        """UnsetSize(Handle_AIS_Plane self)"""
        return _AIS.Handle_AIS_Plane_UnsetSize(self, *args)


    def Size(self, *args):
        """
        Size(Handle_AIS_Plane self) -> Standard_Boolean

        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_Size(self, *args)


    def HasOwnSize(self, *args):
        """
        HasOwnSize(Handle_AIS_Plane self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasOwnSize(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Plane self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Plane_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Plane self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Plane_Type(self, *args)


    def Component(self, *args):
        """
        Returns the component specified in SetComponent.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_Plane_Component(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetComponent(self, *args):
        """
        SetComponent(Handle_AIS_Plane self, Handle_Geom_Plane aComponent)

        Creates an instance of the plane aComponent.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_Plane_SetComponent(self, *args)


    def PlaneAttributes(self, *args):
        """
        PlaneAttributes(Handle_AIS_Plane self, Handle_Geom_Plane aComponent, gp_Pnt aCenter, gp_Pnt aPmin, gp_Pnt aPmax) -> Standard_Boolean

        Returns the settings for the selected plane
        aComponent, provided in SetPlaneAttributes.
        These include the points aCenter, aPmin, and aPmax

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Plane
        :type aCenter: OCC.wrapper.gp.gp_Pnt
        :type aPmin: OCC.wrapper.gp.gp_Pnt
        :type aPmax: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_PlaneAttributes(self, *args)


    def SetPlaneAttributes(self, *args):
        """
        SetPlaneAttributes(Handle_AIS_Plane self, Handle_Geom_Plane aComponent, gp_Pnt aCenter, gp_Pnt aPmin, gp_Pnt aPmax)

        Allows you to provide settings other than default ones
        for the selected plane. These include: center point
        aCenter, maximum aPmax and minimum aPmin.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Plane
        :type aCenter: OCC.wrapper.gp.gp_Pnt
        :type aPmin: OCC.wrapper.gp.gp_Pnt
        :type aPmax: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Plane_SetPlaneAttributes(self, *args)


    def Center(self, *args):
        """
        Returns the coordinates of the center point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_Plane_Center(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCenter(self, *args):
        """
        SetCenter(Handle_AIS_Plane self, gp_Pnt theCenter)

        Provides settings for the center theCenter other than (0, 0, 0).

        :type theCenter: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Plane_SetCenter(self, *args)


    def SetAxis2Placement(self, *args):
        """
        SetAxis2Placement(Handle_AIS_Plane self, Handle_Geom_Axis2Placement aComponent, AIS_TypeOfPlane const aPlaneType)

        Allows you to provide settings for the position and
        direction of one of the plane's axes, aComponent, in
        3D space. The coordinate system used is
        right-handed, and the type of plane aPlaneType is one of:
        -   AIS_ TOPL_Unknown
        -   AIS_ TOPL_XYPlane
        -   AIS_ TOPL_XZPlane
        -   AIS_ TOPL_YZPlane}.

        :type aComponent: OCC.wrapper.Geom.Handle_Geom_Axis2Placement
        :type aPlaneType: OCC.wrapper.AIS.AIS_TypeOfPlane

        """
        return _AIS.Handle_AIS_Plane_SetAxis2Placement(self, *args)


    def Axis2Placement(self, *args):
        """
        Axis2Placement(Handle_AIS_Plane self) -> Handle_Geom_Axis2Placement

        Returns the position of the plane's axis2 system
        identifying the x, y, or z axis and giving the plane a
        direction in 3D space. An axis2 system is a right-handed coordinate system.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Axis2Placement

        """
        return _AIS.Handle_AIS_Plane_Axis2Placement(self, *args)


    def TypeOfPlane(self, *args):
        """
        TypeOfPlane(Handle_AIS_Plane self) -> AIS_TypeOfPlane

        Returns the type of plane - xy, yz, xz or unknown.

        :rtype: OCC.wrapper.AIS.AIS_TypeOfPlane

        """
        return _AIS.Handle_AIS_Plane_TypeOfPlane(self, *args)


    def IsXYZPlane(self, *args):
        """
        IsXYZPlane(Handle_AIS_Plane self) -> Standard_Boolean

        Returns the type of plane - xy, yz, or xz.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_IsXYZPlane(self, *args)


    def CurrentMode(self, *args):
        """
        CurrentMode(Handle_AIS_Plane self) -> Standard_Boolean

        Returns the non-default current display mode set by SetCurrentMode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_CurrentMode(self, *args)


    def SetCurrentMode(self, *args):
        """
        SetCurrentMode(Handle_AIS_Plane self, Standard_Boolean const theCurrentMode)

        Allows you to provide settings for a non-default
        current display mode.

        :type theCurrentMode: bool

        """
        return _AIS.Handle_AIS_Plane_SetCurrentMode(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Plane self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode selected, aMode, is valid for planes.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_AcceptDisplayMode(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Plane self, Handle_AIS_InteractiveContext aCtx)

        connection to <aCtx> default drawer implies a recomputation of Frame values.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Plane_SetContext(self, *args)


    def TypeOfSensitivity(self, *args):
        """
        TypeOfSensitivity(Handle_AIS_Plane self) -> Select3D_TypeOfSensitivity

        Returns the type of sensitivity for the plane;

        :rtype: OCC.wrapper.Select3D.Select3D_TypeOfSensitivity

        """
        return _AIS.Handle_AIS_Plane_TypeOfSensitivity(self, *args)


    def SetTypeOfSensitivity(self, *args):
        """
        SetTypeOfSensitivity(Handle_AIS_Plane self, Select3D_TypeOfSensitivity theTypeOfSensitivity)

        Sets the type of sensitivity for the plane.

        :type theTypeOfSensitivity: OCC.wrapper.Select3D.Select3D_TypeOfSensitivity

        """
        return _AIS.Handle_AIS_Plane_SetTypeOfSensitivity(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_Plane self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Plane_Compute(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Plane self, Quantity_Color aColor)

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Plane_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Plane self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_Plane_UnsetColor(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Plane self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Plane self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Plane_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Plane self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Plane_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Plane self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Plane_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Plane self)"""
        return _AIS.Handle_AIS_Plane_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Plane self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Plane_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Plane self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Plane_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Plane self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Plane_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Plane self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Plane self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Plane_GetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Plane_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Plane self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Plane_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Plane self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Plane_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Plane self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Plane_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Plane self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Plane_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Plane self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Plane_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Plane self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Plane_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Plane self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Plane_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Plane self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Plane_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Plane self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Plane_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Plane self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Plane_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Plane self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Plane_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Plane self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Plane_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Plane self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Plane_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Plane self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Plane_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Plane self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Plane_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Plane self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Plane_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Plane self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Plane_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Plane self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Plane self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Plane_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Plane self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Plane_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Plane self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Plane_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Plane self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Plane self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Plane_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Plane self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Plane_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Plane self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Plane_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Plane self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Plane_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Plane self)
        RecomputePrimitives(Handle_AIS_Plane self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Plane_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Plane self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Plane_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Plane self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Plane_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Plane_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Plane self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Plane_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Plane self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Plane_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Plane self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Plane self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Plane_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Plane_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Plane self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Plane_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Plane self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Plane_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Plane self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Plane_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Plane self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Plane_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Plane self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Plane_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Plane self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Plane_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Plane self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Plane_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Plane self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Plane self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Plane_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Plane self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Plane_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Plane self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Plane_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Plane self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Plane_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Plane self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Plane_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Plane self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Plane_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Plane self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Plane_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Plane self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Plane_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Plane self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Plane_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Plane self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Plane_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Plane_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Plane self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Plane_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Plane self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Plane_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Plane_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Plane self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Plane self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Plane_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Plane self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Plane_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Plane self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Plane_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Plane self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Plane_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Plane self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Plane self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Plane_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Plane self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Plane_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Plane_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Plane self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Plane self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Plane_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Plane_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Plane_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Plane_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Plane_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Plane self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Plane_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Plane self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Plane_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Plane self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Plane_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Plane self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Plane self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Plane_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Plane_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Plane self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Plane_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Plane self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Plane_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Plane self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Plane_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Plane_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Plane self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Plane self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Plane_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Plane self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Plane_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Plane_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Plane_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Plane self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Plane_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Plane_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Plane self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Plane_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Plane self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Plane_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Plane self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Plane_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Plane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Plane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Plane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Plane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Plane_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Plane self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Plane_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Plane self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Plane_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Plane self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Plane_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Plane self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Plane_DecrementRefCounter(self, *args)

Handle_AIS_Plane_swigregister = _AIS.Handle_AIS_Plane_swigregister
Handle_AIS_Plane_swigregister(Handle_AIS_Plane)

def Handle_AIS_Plane_DownCast(thing):
    return _AIS.Handle_AIS_Plane_DownCast(thing)
Handle_AIS_Plane_DownCast = _AIS.Handle_AIS_Plane_DownCast


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored


try:
	Graphic3d_Vec2i = Graphic3d.NCollection_Vec2_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class Handle_AIS_ManipulatorObjectSequence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ManipulatorObjectSequence self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ManipulatorObjectSequence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ManipulatorObjectSequence self, AIS_ManipulatorObjectSequence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ManipulatorObjectSequence self, Handle_AIS_ManipulatorObjectSequence theHandle) -> Handle_AIS_ManipulatorObjectSequence
        assign(Handle_AIS_ManipulatorObjectSequence self, AIS_ManipulatorObjectSequence thePtr) -> Handle_AIS_ManipulatorObjectSequence
        assign(Handle_AIS_ManipulatorObjectSequence self, Handle_AIS_ManipulatorObjectSequence theHandle) -> Handle_AIS_ManipulatorObjectSequence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ManipulatorObjectSequence self) -> AIS_ManipulatorObjectSequence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ManipulatorObjectSequence self) -> AIS_ManipulatorObjectSequence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ManipulatorObjectSequence self) -> AIS_ManipulatorObjectSequence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ManipulatorObjectSequence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ManipulatorObjectSequence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ManipulatorObjectSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ManipulatorObjectSequence_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ManipulatorObjectSequence

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject

        """
        res = _AIS.Handle_AIS_ManipulatorObjectSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_AIS_ManipulatorObjectSequence self, Handle_AIS_InteractiveObject theItem)
        Append(Handle_AIS_ManipulatorObjectSequence self, NCollection_Sequence_Handle_AIS_InteractiveObject theSequence)

        :type theSequence: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_AIS_ManipulatorObjectSequence self) -> NCollection_Sequence_Handle_AIS_InteractiveObject

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ManipulatorObjectSequence self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ManipulatorObjectSequence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ManipulatorObjectSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AIS_ManipulatorObjectSequence self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ManipulatorObjectSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ManipulatorObjectSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ManipulatorObjectSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ManipulatorObjectSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ManipulatorObjectSequence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ManipulatorObjectSequence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ManipulatorObjectSequence self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ManipulatorObjectSequence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ManipulatorObjectSequence_DecrementRefCounter(self, *args)

Handle_AIS_ManipulatorObjectSequence_swigregister = _AIS.Handle_AIS_ManipulatorObjectSequence_swigregister
Handle_AIS_ManipulatorObjectSequence_swigregister(Handle_AIS_ManipulatorObjectSequence)

def Handle_AIS_ManipulatorObjectSequence_DownCast(thing):
    return _AIS.Handle_AIS_ManipulatorObjectSequence_DownCast(thing)
Handle_AIS_ManipulatorObjectSequence_DownCast = _AIS.Handle_AIS_ManipulatorObjectSequence_DownCast

class Handle_AIS_LocalContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_LocalContext self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_LocalContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_LocalContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_LocalContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_LocalContext self, AIS_LocalContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_LocalContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_LocalContext self, Handle_AIS_LocalContext theHandle) -> Handle_AIS_LocalContext
        assign(Handle_AIS_LocalContext self, AIS_LocalContext thePtr) -> Handle_AIS_LocalContext
        assign(Handle_AIS_LocalContext self, Handle_AIS_LocalContext theHandle) -> Handle_AIS_LocalContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_LocalContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_LocalContext self) -> AIS_LocalContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_LocalContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_LocalContext self) -> AIS_LocalContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_LocalContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_LocalContext self) -> AIS_LocalContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_LocalContext___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_LocalContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_LocalContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_LocalContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_LocalContext_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_LocalContext

    def AcceptErase(self, *args):
        """
        AcceptErase(Handle_AIS_LocalContext self, Standard_Boolean const aStatus)
        AcceptErase(Handle_AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_AcceptErase(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_LocalContext self, Handle_AIS_InteractiveContext aCtx)

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_LocalContext_SetContext(self, *args)


    def Selection(self, *args):
        """
        :rtype: OCC.wrapper.AIS.Handle_AIS_Selection

        """
        res = _AIS.Handle_AIS_LocalContext_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Terminate(self, *args):
        """
        Terminate(Handle_AIS_LocalContext self, Standard_Boolean const updateviewer)

        :type updateviewer: bool

        """
        return _AIS.Handle_AIS_LocalContext_Terminate(self, *args)


    def Display(self, *args):
        """
        Display(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive, Standard_Integer const DisplayMode=0, Standard_Boolean const AllowShapeDecomposition, Standard_Integer const ActivationMode=0) -> Standard_Boolean

        returns true if done...

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type DisplayMode: int
        :type AllowShapeDecomposition: bool
        :type ActivationMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_Display(self, *args)


    def Load(self, *args):
        """
        Load(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive, Standard_Boolean const AllowShapeDecomposition, Standard_Integer const ActivationMode=0) -> Standard_Boolean

        loads <anInteractive> with nodisplay...
        returns true if done

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type AllowShapeDecomposition: bool
        :type ActivationMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_Load(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive) -> Standard_Boolean

        returns true if done...

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_Erase(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject aSelectable) -> Standard_Boolean

        :type aSelectable: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_Remove(self, *args)


    def ClearPrs(self, *args):
        """
        ClearPrs(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anInteractive, Standard_Integer const aMode) -> Standard_Boolean

        :type anInteractive: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_ClearPrs(self, *args)


    def SetShapeDecomposition(self, *args):
        """
        SetShapeDecomposition(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject aStoredObject, Standard_Boolean const aStatus)

        allows  or  forbids   the   shape  decomposition  into
        Activated Standard   Mode  for   <aStoredObject>
        does nothing if the object doesn't inherits
        BasicShape from AIS

        :type aStoredObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aStatus: bool

        """
        return _AIS.Handle_AIS_LocalContext_SetShapeDecomposition(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_AIS_LocalContext self, AIS_ClearMode const atype=AIS_CM_All)

        according to <atype>  , clears the  different parts of
        the selector (filters, modeof activation, objects...)

        :type atype: OCC.wrapper.AIS.AIS_ClearMode

        """
        return _AIS.Handle_AIS_LocalContext_Clear(self, *args)


    def SetSelectionModeActive(self, *args):
        """
        SetSelectionModeActive(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode, Standard_Boolean const theIsActive, AIS_SelectionModesConcurrency const theActiveFilter)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theIsActive: bool
        :type theActiveFilter: OCC.wrapper.AIS.AIS_SelectionModesConcurrency

        """
        return _AIS.Handle_AIS_LocalContext_SetSelectionModeActive(self, *args)


    def ActivateMode(self, *args):
        """
        ActivateMode(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode)

        optional : activation of a mode which is not 0 for a selectable...

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int

        """
        return _AIS.Handle_AIS_LocalContext_ActivateMode(self, *args)


    def DeactivateMode(self, *args):
        """
        DeactivateMode(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int

        """
        return _AIS.Handle_AIS_LocalContext_DeactivateMode(self, *args)


    def Deactivate(self, *args):
        """
        Deactivate(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObj)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_LocalContext_Deactivate(self, *args)


    def ActivateStandardMode(self, *args):
        """
        ActivateStandardMode(Handle_AIS_LocalContext self, TopAbs_ShapeEnum const aType)

        decomposition of shapes into <aType>

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.Handle_AIS_LocalContext_ActivateStandardMode(self, *args)


    def DeactivateStandardMode(self, *args):
        """
        DeactivateStandardMode(Handle_AIS_LocalContext self, TopAbs_ShapeEnum const aType)

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.Handle_AIS_LocalContext_DeactivateStandardMode(self, *args)


    def StandardModes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.Handle_AIS_LocalContext_StandardModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddFilter(self, *args):
        """
        AddFilter(Handle_AIS_LocalContext self, Handle_SelectMgr_Filter aFilter)

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.Handle_AIS_LocalContext_AddFilter(self, *args)


    def RemoveFilter(self, *args):
        """
        RemoveFilter(Handle_AIS_LocalContext self, Handle_SelectMgr_Filter aFilter)

        :type aFilter: OCC.wrapper.SelectMgr.Handle_SelectMgr_Filter

        """
        return _AIS.Handle_AIS_LocalContext_RemoveFilter(self, *args)


    def ListOfFilter(self, *args):
        """
        :rtype: OCC.wrapper.SelectMgr.SelectMgr_ListOfFilter

        """
        res = _AIS.Handle_AIS_LocalContext_ListOfFilter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Filter(self, *args):
        """
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_OrFilter

        """
        res = _AIS.Handle_AIS_LocalContext_Filter(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAutomaticHilight(self, *args):
        """
        SetAutomaticHilight(Handle_AIS_LocalContext self, Standard_Boolean const aStatus)

        if <aStatus> = True , the shapes or subshapes detected
        by the selector will be automatically hilighted in the
        main viewer.
        Else the user has to manage the detected shape outside the
        Shape Selector....

        :type aStatus: bool

        """
        return _AIS.Handle_AIS_LocalContext_SetAutomaticHilight(self, *args)


    def AutomaticHilight(self, *args):
        """
        AutomaticHilight(Handle_AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_AutomaticHilight(self, *args)


    def MoveTo(self, *args):
        """
        MoveTo(Handle_AIS_LocalContext self, Standard_Integer const theXpix, Standard_Integer const theYpix, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> AIS_StatusOfDetection

        :type theXpix: int
        :type theYpix: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfDetection

        """
        return _AIS.Handle_AIS_LocalContext_MoveTo(self, *args)


    def HasNextDetected(self, *args):
        """
        HasNextDetected(Handle_AIS_LocalContext self) -> Standard_Boolean

        returns True if more than one entity
        was detected at the last Mouse position.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_HasNextDetected(self, *args)


    def HilightNextDetected(self, *args):
        """
        HilightNextDetected(Handle_AIS_LocalContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        returns True if  last detected. the next detected will
        be first one (endless loop)

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalContext_HilightNextDetected(self, *args)


    def HilightPreviousDetected(self, *args):
        """
        HilightPreviousDetected(Handle_AIS_LocalContext self, Handle_V3d_View theView, Standard_Boolean const theToRedrawImmediate) -> Standard_Integer

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theToRedrawImmediate: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalContext_HilightPreviousDetected(self, *args)


    def UnhilightLastDetected(self, *args):
        """
        UnhilightLastDetected(Handle_AIS_LocalContext self, Handle_V3d_Viewer theViewer) -> Standard_Boolean
        UnhilightLastDetected(Handle_AIS_LocalContext self, Handle_V3d_View theView) -> Standard_Boolean

        returns True if something was done...

        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_UnhilightLastDetected(self, *args)


    def AddSelect(self, *args):
        """
        AddSelect(Handle_AIS_LocalContext self, Handle_SelectMgr_EntityOwner theObject) -> AIS_StatusOfPick

        returns the number of selected

        :type theObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.Handle_AIS_LocalContext_AddSelect(self, *args)


    def Select(self, *args):
        """
        Select(Handle_AIS_LocalContext self, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        Select(Handle_AIS_LocalContext self, Standard_Integer const XPMin, Standard_Integer const YPMin, Standard_Integer const XPMax, Standard_Integer const YPMax, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        Select(Handle_AIS_LocalContext self, NCollection_Array1_gp_Pnt2d Polyline, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick

        :type Polyline: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type aView: OCC.wrapper.V3d.Handle_V3d_View
        :type updateviewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.Handle_AIS_LocalContext_Select(self, *args)


    def ShiftSelect(self, *args):
        """
        ShiftSelect(Handle_AIS_LocalContext self, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        ShiftSelect(Handle_AIS_LocalContext self, Standard_Integer const XPMin, Standard_Integer const YPMin, Standard_Integer const XPMax, Standard_Integer const YPMax, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick
        ShiftSelect(Handle_AIS_LocalContext self, NCollection_Array1_gp_Pnt2d Polyline, Handle_V3d_View aView, Standard_Boolean const updateviewer) -> AIS_StatusOfPick

        :type Polyline: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type aView: OCC.wrapper.V3d.Handle_V3d_View
        :type updateviewer: bool
        :rtype: OCC.wrapper.AIS.AIS_StatusOfPick

        """
        return _AIS.Handle_AIS_LocalContext_ShiftSelect(self, *args)


    def HilightPicked(self, *args):
        """
        HilightPicked(Handle_AIS_LocalContext self, Standard_Boolean const updateviewer)

        :type updateviewer: bool

        """
        return _AIS.Handle_AIS_LocalContext_HilightPicked(self, *args)


    def UnhilightPicked(self, *args):
        """
        UnhilightPicked(Handle_AIS_LocalContext self, Standard_Boolean const updateviewer)

        :type updateviewer: bool

        """
        return _AIS.Handle_AIS_LocalContext_UnhilightPicked(self, *args)


    def UpdateSelected(self, *args):
        """
        UpdateSelected(Handle_AIS_LocalContext self, Standard_Boolean const updateviewer)
        UpdateSelected(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anobj, Standard_Boolean const updateviewer)

        Part of advanced selection highlighting mechanism.
        If no owners belonging to anobj are selected, calls anobj->ClearSelected(),
        otherwise calls anobj->HilightSelected(). This method can be used to avoid
        redrawing the whole selection belonging to several Selectable Objects.

        :type anobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type updateviewer: bool

        """
        return _AIS.Handle_AIS_LocalContext_UpdateSelected(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anobj, Standard_Boolean const updateviewer)

        useful  to  update selection with objects  coming from
        Collector or stack

        :type anobj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type updateviewer: bool

        """
        return _AIS.Handle_AIS_LocalContext_SetSelected(self, *args)


    def AddOrRemoveSelected(self, *args):
        """
        AddOrRemoveSelected(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anobj, Standard_Boolean const updateviewer)
        AddOrRemoveSelected(Handle_AIS_LocalContext self, TopoDS_Shape aShape, Standard_Boolean const updateviewer)
        AddOrRemoveSelected(Handle_AIS_LocalContext self, Handle_SelectMgr_EntityOwner theOwner, Standard_Boolean const toUpdateViewer)

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type toUpdateViewer: bool

        """
        return _AIS.Handle_AIS_LocalContext_AddOrRemoveSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_LocalContext self, Standard_Boolean const toUpdateViewer)

        Clears local context selection.
        @param toUpdateViewer [in] if TRUE the viewer will be updated.

        :type toUpdateViewer: bool

        """
        return _AIS.Handle_AIS_LocalContext_ClearSelected(self, *args)


    def ClearOutdatedSelection(self, *args):
        """
        ClearOutdatedSelection(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theIO, Standard_Boolean const toClearDeactivated)

        Clears outdated selection and detection of owners for the
        interactive object. Use this method if selection structures
        of the interactive object have changed. The method unhilights
        and removes outdated entity owners from lists of selected
        and detected owners.
        @param theIO [in] the interactive object.
        @param toClearDeactivated [in] pass TRUE to treat deactivated
        entity owners as 'outdated' when clearing the selection.

        :type theIO: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type toClearDeactivated: bool

        """
        return _AIS.Handle_AIS_LocalContext_ClearOutdatedSelection(self, *args)


    def HasDetected(self, *args):
        """
        HasDetected(Handle_AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_HasDetected(self, *args)


    def InitDetected(self, *args):
        """
        InitDetected(Handle_AIS_LocalContext self)

        Initialization for iteration through mouse-detected objects in local context.


        """
        return _AIS.Handle_AIS_LocalContext_InitDetected(self, *args)


    def MoreDetected(self, *args):
        """
        MoreDetected(Handle_AIS_LocalContext self) -> Standard_Boolean

        @return true if there is more mouse-detected objects after the current one
        during iteration through mouse-detected interactive objects.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_MoreDetected(self, *args)


    def NextDetected(self, *args):
        """
        NextDetected(Handle_AIS_LocalContext self)

        Gets next current object during iteration through mouse-detected
        interactive objects.


        """
        return _AIS.Handle_AIS_LocalContext_NextDetected(self, *args)


    def DetectedCurrentOwner(self, *args):
        """
        DetectedCurrentOwner(Handle_AIS_LocalContext self) -> Handle_SelectMgr_EntityOwner

        @return current mouse-detected Owner or null object if there is no current detected.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_LocalContext_DetectedCurrentOwner(self, *args)


    def DetectedCurrentShape(self, *args):
        """
        @return current mouse-detected shape or empty (null) shape, if current interactive object
        is not a shape (AIS_Shape) or there is no current mouse-detected interactive object at all.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_LocalContext_DetectedCurrentShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DetectedCurrentObject(self, *args):
        """
        DetectedCurrentObject(Handle_AIS_LocalContext self) -> Handle_AIS_InteractiveObject

        @return current mouse-detected interactive object or null object if there is no current detected.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_LocalContext_DetectedCurrentObject(self, *args)


    def HasDetectedShape(self, *args):
        """
        HasDetectedShape(Handle_AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_HasDetectedShape(self, *args)


    def DetectedShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_LocalContext_DetectedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DetectedInteractive(self, *args):
        """
        DetectedInteractive(Handle_AIS_LocalContext self) -> Handle_AIS_InteractiveObject

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_LocalContext_DetectedInteractive(self, *args)


    def DetectedOwner(self, *args):
        """
        DetectedOwner(Handle_AIS_LocalContext self) -> Handle_SelectMgr_EntityOwner

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_LocalContext_DetectedOwner(self, *args)


    def InitSelected(self, *args):
        """InitSelected(Handle_AIS_LocalContext self)"""
        return _AIS.Handle_AIS_LocalContext_InitSelected(self, *args)


    def MoreSelected(self, *args):
        """
        MoreSelected(Handle_AIS_LocalContext self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_MoreSelected(self, *args)


    def NextSelected(self, *args):
        """NextSelected(Handle_AIS_LocalContext self)"""
        return _AIS.Handle_AIS_LocalContext_NextSelected(self, *args)


    def HasShape(self, *args):
        """
        HasShape(Handle_AIS_LocalContext self) -> Standard_Boolean

        returns TRUE if the detected entity is a shape
        coming from a Decomposition of an element.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_HasShape(self, *args)


    def HasSelectedShape(self, *args):
        """
        HasSelectedShape(Handle_AIS_LocalContext self) -> Standard_Boolean

        returns true if current selection is not empty
        and the owner of selected object contains a shape.
        This method does not take into account decomposition
        status of detected shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_HasSelectedShape(self, *args)


    def SelectedShape(self, *args):
        """
        SelectedShape(Handle_AIS_LocalContext self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_LocalContext_SelectedShape(self, *args)


    def SelectedOwner(self, *args):
        """
        SelectedOwner(Handle_AIS_LocalContext self) -> Handle_SelectMgr_EntityOwner

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_LocalContext_SelectedOwner(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject aniobj) -> Standard_Boolean
        IsSelected(Handle_AIS_LocalContext self, Handle_SelectMgr_EntityOwner anOwner) -> Standard_Boolean

        :type anOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_IsSelected(self, *args)


    def SelectedInteractive(self, *args):
        """
        SelectedInteractive(Handle_AIS_LocalContext self) -> Handle_AIS_InteractiveObject

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_LocalContext_SelectedInteractive(self, *args)


    def HasApplicative(self, *args):
        """
        HasApplicative(Handle_AIS_LocalContext self) -> Standard_Boolean

        returns TRUE if an interactive element
        was associated with the current picked entity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_HasApplicative(self, *args)


    def SelectedApplicative(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_LocalContext_SelectedApplicative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDisplayPriority(self, *args):
        """
        SetDisplayPriority(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject, Standard_Integer const Prior)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type Prior: int

        """
        return _AIS.Handle_AIS_LocalContext_SetDisplayPriority(self, *args)


    def DisplayedObjects(self, *args):
        """
        DisplayedObjects(Handle_AIS_LocalContext self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theMapToFill) -> Standard_Integer

        :type theMapToFill: OCC.wrapper.TColStd.TColStd_MapOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalContext_DisplayedObjects(self, *args)


    def IsIn(self, *args):
        """
        IsIn(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_IsIn(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean
        IsDisplayed(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject, Standard_Integer const aMode) -> Standard_Boolean

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_IsDisplayed(self, *args)


    def SelectionModes(self, *args):
        """
        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.Handle_AIS_LocalContext_SelectionModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntensityOn(self, *args):
        """
        SubIntensityOn(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_LocalContext_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """
        SubIntensityOff(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_LocalContext_SubIntensityOff(self, *args)


    def Hilight(self, *args):
        """
        Hilight(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)
        Hilight(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Handle_Prs3d_Drawer theStyle)

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_LocalContext_Hilight(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject)

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_LocalContext_Unhilight(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anObject) -> Standard_Boolean

        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_IsHilighted(self, *args)


    def HighlightStyle(self, *args):
        """
        HighlightStyle(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObject, Handle_Prs3d_Drawer theStyle) -> Standard_Boolean

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_HighlightStyle(self, *args)


    def SetPixelTolerance(self, *args):
        """
        SetPixelTolerance(Handle_AIS_LocalContext self, Standard_Integer const aPrecision=2)

        Define the current selection sensitivity for
        this local context according to the view size.

        :type aPrecision: int

        """
        return _AIS.Handle_AIS_LocalContext_SetPixelTolerance(self, *args)


    def PixelTolerance(self, *args):
        """
        PixelTolerance(Handle_AIS_LocalContext self) -> Standard_Integer

        Returns the pixel tolerance.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalContext_PixelTolerance(self, *args)


    def SetSelectionSensitivity(self, *args):
        """
        SetSelectionSensitivity(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObject, Standard_Integer const theMode, Standard_Integer const theNewSensitivity)

        Allows to manage sensitivity of a particular selection of interactive object theObject
        and changes previous sensitivity value of all sensitive entities in selection with theMode
        to the given theNewSensitivity.

        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :type theNewSensitivity: int

        """
        return _AIS.Handle_AIS_LocalContext_SetSelectionSensitivity(self, *args)


    def BeginImmediateDraw(self, *args):
        """
        BeginImmediateDraw(Handle_AIS_LocalContext self) -> Standard_Boolean

        Resets the transient list of presentations previously displayed in immediate mode
        and begins accumulation of new list by following AddToImmediateList()/Color()/Highlight() calls.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_BeginImmediateDraw(self, *args)


    def ClearImmediateDraw(self, *args):
        """
        ClearImmediateDraw(Handle_AIS_LocalContext self)

        Resets the transient list of presentations previously displayed in immediate mode.


        """
        return _AIS.Handle_AIS_LocalContext_ClearImmediateDraw(self, *args)


    def ImmediateAdd(self, *args):
        """
        ImmediateAdd(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject theObj, Standard_Integer const theMode=0) -> Standard_Boolean

        Stores presentation theMode of object theObj in the transient list of presentations to be displayed in immediate mode.
        Will be taken in account in EndImmediateDraw method.

        :type theObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_ImmediateAdd(self, *args)


    def EndImmediateDraw(self, *args):
        """
        EndImmediateDraw(Handle_AIS_LocalContext self, Handle_V3d_Viewer theViewer) -> Standard_Boolean

        Allows rapid drawing of the view theView by avoiding an update of the whole background.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_EndImmediateDraw(self, *args)


    def IsImmediateModeOn(self, *args):
        """
        IsImmediateModeOn(Handle_AIS_LocalContext self) -> Standard_Boolean

        Returns true if Presentation Manager is accumulating transient list of presentations to be displayed in immediate mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_IsImmediateModeOn(self, *args)


    def Status(self, *args):
        """
        :type anObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.AIS.Handle_AIS_LocalStatus

        """
        res = _AIS.Handle_AIS_LocalContext_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LoadContextObjects(self, *args):
        """LoadContextObjects(Handle_AIS_LocalContext self)"""
        return _AIS.Handle_AIS_LocalContext_LoadContextObjects(self, *args)


    def UnloadContextObjects(self, *args):
        """UnloadContextObjects(Handle_AIS_LocalContext self)"""
        return _AIS.Handle_AIS_LocalContext_UnloadContextObjects(self, *args)


    def DisplaySensitive(self, *args):
        """
        DisplaySensitive(Handle_AIS_LocalContext self, Handle_V3d_View aView)

        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.Handle_AIS_LocalContext_DisplaySensitive(self, *args)


    def ClearSensitive(self, *args):
        """
        ClearSensitive(Handle_AIS_LocalContext self, Handle_V3d_View aView)

        :type aView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.Handle_AIS_LocalContext_ClearSensitive(self, *args)


    def MainSelector(self, *args):
        """
        :rtype: OCC.wrapper.StdSelect.Handle_StdSelect_ViewerSelector3d

        """
        res = _AIS.Handle_AIS_LocalContext_MainSelector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindSelectedOwnerFromIO(self, *args):
        """
        FindSelectedOwnerFromIO(Handle_AIS_LocalContext self, Handle_AIS_InteractiveObject anIObj) -> Handle_SelectMgr_EntityOwner

        :type anIObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_LocalContext_FindSelectedOwnerFromIO(self, *args)


    def FindSelectedOwnerFromShape(self, *args):
        """
        FindSelectedOwnerFromShape(Handle_AIS_LocalContext self, TopoDS_Shape aShape) -> Handle_SelectMgr_EntityOwner

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_LocalContext_FindSelectedOwnerFromShape(self, *args)


    def RestoreActivatedModes(self, *args):
        """
        RestoreActivatedModes(Handle_AIS_LocalContext self)

        Iterates through all interactive objects of local context and activates selection modes
        stored in local status


        """
        return _AIS.Handle_AIS_LocalContext_RestoreActivatedModes(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_LocalContext self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_LocalContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_LocalContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_LocalContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AIS_LocalContext self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_LocalContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_LocalContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_LocalContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_LocalContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_LocalContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_LocalContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_LocalContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_LocalContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_LocalContext self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_LocalContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_LocalContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalContext_DecrementRefCounter(self, *args)

Handle_AIS_LocalContext_swigregister = _AIS.Handle_AIS_LocalContext_swigregister
Handle_AIS_LocalContext_swigregister(Handle_AIS_LocalContext)

def Handle_AIS_LocalContext_DownCast(thing):
    return _AIS.Handle_AIS_LocalContext_DownCast(thing)
Handle_AIS_LocalContext_DownCast = _AIS.Handle_AIS_LocalContext_DownCast

class Handle_AIS_PerpendicularRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_PerpendicularRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_PerpendicularRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_PerpendicularRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_PerpendicularRelation self, AIS_PerpendicularRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_PerpendicularRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_PerpendicularRelation self, Handle_AIS_PerpendicularRelation theHandle) -> Handle_AIS_PerpendicularRelation
        assign(Handle_AIS_PerpendicularRelation self, AIS_PerpendicularRelation thePtr) -> Handle_AIS_PerpendicularRelation
        assign(Handle_AIS_PerpendicularRelation self, Handle_AIS_PerpendicularRelation theHandle) -> Handle_AIS_PerpendicularRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_PerpendicularRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_PerpendicularRelation self) -> AIS_PerpendicularRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_PerpendicularRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_PerpendicularRelation self) -> AIS_PerpendicularRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_PerpendicularRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_PerpendicularRelation self) -> AIS_PerpendicularRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_PerpendicularRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_PerpendicularRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_PerpendicularRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_PerpendicularRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_PerpendicularRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_PerpendicularRelation

    def Compute(self, *args):
        """
        Compute(Handle_AIS_PerpendicularRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_PerpendicularRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_PerpendicularRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_PerpendicularRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_PerpendicularRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_PerpendicularRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_PerpendicularRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_PerpendicularRelation_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsMovable(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_PerpendicularRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_PerpendicularRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_PerpendicularRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_PerpendicularRelation self)"""
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_PerpendicularRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_PerpendicularRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_PerpendicularRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_PerpendicularRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_PerpendicularRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_PerpendicularRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PerpendicularRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_PerpendicularRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_PerpendicularRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_PerpendicularRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_PerpendicularRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_PerpendicularRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_PerpendicularRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_PerpendicularRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_PerpendicularRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_PerpendicularRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_PerpendicularRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_PerpendicularRelation self)"""
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_PerpendicularRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_PerpendicularRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_PerpendicularRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_PerpendicularRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_PerpendicularRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_PerpendicularRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_PerpendicularRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_PerpendicularRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_PerpendicularRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_PerpendicularRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_PerpendicularRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_PerpendicularRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_PerpendicularRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_PerpendicularRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_PerpendicularRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_PerpendicularRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_PerpendicularRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_PerpendicularRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_PerpendicularRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_PerpendicularRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_PerpendicularRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_PerpendicularRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_PerpendicularRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_PerpendicularRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_PerpendicularRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_PerpendicularRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_PerpendicularRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_PerpendicularRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_PerpendicularRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_PerpendicularRelation self)
        RecomputePrimitives(Handle_AIS_PerpendicularRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PerpendicularRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_PerpendicularRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_PerpendicularRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_PerpendicularRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_PerpendicularRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_PerpendicularRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_PerpendicularRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_PerpendicularRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_PerpendicularRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_PerpendicularRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_PerpendicularRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_PerpendicularRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_PerpendicularRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_PerpendicularRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_PerpendicularRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_PerpendicularRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_PerpendicularRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_PerpendicularRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_PerpendicularRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_PerpendicularRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_PerpendicularRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_PerpendicularRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_PerpendicularRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PerpendicularRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_PerpendicularRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_PerpendicularRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_PerpendicularRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_PerpendicularRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_PerpendicularRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_PerpendicularRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_PerpendicularRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_PerpendicularRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_PerpendicularRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_PerpendicularRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_PerpendicularRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_PerpendicularRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_PerpendicularRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_PerpendicularRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_PerpendicularRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_PerpendicularRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_PerpendicularRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_PerpendicularRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_PerpendicularRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_PerpendicularRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_PerpendicularRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_PerpendicularRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_PerpendicularRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_PerpendicularRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_PerpendicularRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_PerpendicularRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_PerpendicularRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_PerpendicularRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_PerpendicularRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_PerpendicularRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_PerpendicularRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_PerpendicularRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_PerpendicularRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_PerpendicularRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_PerpendicularRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PerpendicularRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_PerpendicularRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_PerpendicularRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_PerpendicularRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_PerpendicularRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_PerpendicularRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_PerpendicularRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_PerpendicularRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_PerpendicularRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_PerpendicularRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PerpendicularRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_PerpendicularRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_PerpendicularRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_PerpendicularRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_PerpendicularRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_PerpendicularRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PerpendicularRelation_DecrementRefCounter(self, *args)

Handle_AIS_PerpendicularRelation_swigregister = _AIS.Handle_AIS_PerpendicularRelation_swigregister
Handle_AIS_PerpendicularRelation_swigregister(Handle_AIS_PerpendicularRelation)

def Handle_AIS_PerpendicularRelation_DownCast(thing):
    return _AIS.Handle_AIS_PerpendicularRelation_DownCast(thing)
Handle_AIS_PerpendicularRelation_DownCast = _AIS.Handle_AIS_PerpendicularRelation_DownCast

class Handle_AIS_TangentRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_TangentRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_TangentRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_TangentRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_TangentRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_TangentRelation self, AIS_TangentRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_TangentRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_TangentRelation self, Handle_AIS_TangentRelation theHandle) -> Handle_AIS_TangentRelation
        assign(Handle_AIS_TangentRelation self, AIS_TangentRelation thePtr) -> Handle_AIS_TangentRelation
        assign(Handle_AIS_TangentRelation self, Handle_AIS_TangentRelation theHandle) -> Handle_AIS_TangentRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_TangentRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_TangentRelation self) -> AIS_TangentRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_TangentRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_TangentRelation self) -> AIS_TangentRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_TangentRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_TangentRelation self) -> AIS_TangentRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_TangentRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_TangentRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_TangentRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_TangentRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_TangentRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_TangentRelation

    def ExternRef(self, *args):
        """
        ExternRef(Handle_AIS_TangentRelation self) -> Standard_Integer

        Returns the external reference for tangency.
        The values are as follows:
        -   0 - there is no connection;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.
        This reference is defined at construction time.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_ExternRef(self, *args)


    def SetExternRef(self, *args):
        """
        SetExternRef(Handle_AIS_TangentRelation self, Standard_Integer const aRef)

        Sets the external reference for tangency, aRef.
        The values are as follows:
        -   0 - there is no connection;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.
        This reference is initially defined at construction time.

        :type aRef: int

        """
        return _AIS.Handle_AIS_TangentRelation_SetExternRef(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_TangentRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TangentRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_TangentRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_TangentRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TangentRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TangentRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_TangentRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_TangentRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_TangentRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_TangentRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_TangentRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_TangentRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_TangentRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_TangentRelation_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_IsMovable(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_TangentRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_TangentRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_TangentRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_TangentRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_TangentRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_TangentRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_TangentRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_TangentRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_TangentRelation self)"""
        return _AIS.Handle_AIS_TangentRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_TangentRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_TangentRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_TangentRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_TangentRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TangentRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_TangentRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_TangentRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_TangentRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_TangentRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TangentRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_TangentRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_TangentRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_TangentRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_TangentRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TangentRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_TangentRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_TangentRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_TangentRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_TangentRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_TangentRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_TangentRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_TangentRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_TangentRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_TangentRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_TangentRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_TangentRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_TangentRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_TangentRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_TangentRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_TangentRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_TangentRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_TangentRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_TangentRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_TangentRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_TangentRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_TangentRelation self)"""
        return _AIS.Handle_AIS_TangentRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_TangentRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_TangentRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_TangentRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_TangentRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_TangentRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_TangentRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_TangentRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_TangentRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_TangentRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_TangentRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_TangentRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_TangentRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_TangentRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_TangentRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_TangentRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_TangentRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_TangentRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_TangentRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_TangentRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_TangentRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_TangentRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TangentRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_TangentRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_TangentRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_TangentRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_TangentRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_TangentRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TangentRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_TangentRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_TangentRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_TangentRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_TangentRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_TangentRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_TangentRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_TangentRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_TangentRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_TangentRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TangentRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_TangentRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_TangentRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_TangentRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_TangentRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_TangentRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TangentRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_TangentRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_TangentRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_TangentRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_TangentRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_TangentRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_TangentRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_TangentRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_TangentRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_TangentRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_TangentRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_TangentRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_TangentRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_TangentRelation self)
        RecomputePrimitives(Handle_AIS_TangentRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TangentRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_TangentRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_TangentRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_TangentRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_TangentRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_TangentRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_TangentRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_TangentRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_TangentRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_TangentRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_TangentRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_TangentRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_TangentRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_TangentRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_TangentRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_TangentRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_TangentRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_TangentRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_TangentRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_TangentRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_TangentRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_TangentRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_TangentRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_TangentRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_TangentRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_TangentRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_TangentRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_TangentRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_TangentRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_TangentRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_TangentRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TangentRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_TangentRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TangentRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_TangentRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_TangentRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_TangentRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_TangentRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_TangentRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TangentRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_TangentRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_TangentRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_TangentRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_TangentRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_TangentRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_TangentRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_TangentRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_TangentRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_TangentRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_TangentRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_TangentRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_TangentRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_TangentRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_TangentRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_TangentRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TangentRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_TangentRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_TangentRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_TangentRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TangentRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_TangentRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_TangentRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_TangentRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_TangentRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_TangentRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_TangentRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_TangentRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_TangentRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_TangentRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_TangentRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_TangentRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_TangentRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_TangentRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_TangentRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_TangentRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_TangentRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_TangentRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_TangentRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_TangentRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_TangentRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_TangentRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_TangentRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_TangentRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_TangentRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_TangentRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_TangentRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_TangentRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_TangentRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_TangentRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_TangentRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_TangentRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_TangentRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_TangentRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_TangentRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_TangentRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_TangentRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TangentRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TangentRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TangentRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_TangentRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TangentRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TangentRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_TangentRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TangentRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_TangentRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_TangentRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_TangentRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_TangentRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_TangentRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_TangentRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_TangentRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_TangentRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TangentRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_TangentRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_TangentRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_TangentRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_TangentRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_TangentRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_TangentRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TangentRelation_DecrementRefCounter(self, *args)

Handle_AIS_TangentRelation_swigregister = _AIS.Handle_AIS_TangentRelation_swigregister
Handle_AIS_TangentRelation_swigregister(Handle_AIS_TangentRelation)

def Handle_AIS_TangentRelation_DownCast(thing):
    return _AIS.Handle_AIS_TangentRelation_DownCast(thing)
Handle_AIS_TangentRelation_DownCast = _AIS.Handle_AIS_TangentRelation_DownCast

class AIS_TrihedronOwner(SelectMgr.SelectMgr_EntityOwner):
    """Entity owner for selection management of AIS_Trihedron object."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_TrihedronOwner
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_TrihedronOwner(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_TrihedronOwner_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_TrihedronOwner_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_TrihedronOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_TrihedronOwner self, Handle_SelectMgr_SelectableObject theSelObject, Prs3d_DatumParts const theDatumPart, Standard_Integer const thePriority) -> AIS_TrihedronOwner

        Creates an owner of AIS_Trihedron object.

        :type theSelObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theDatumPart: OCC.wrapper.Prs3d.Prs3d_DatumParts
        :type thePriority: int

        """
        this = _AIS.new_AIS_TrihedronOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def DatumPart(self, *args):
        """
        DatumPart(AIS_TrihedronOwner self) -> Prs3d_DatumParts

        Returns the datum part identifier.

        :rtype: OCC.wrapper.Prs3d.Prs3d_DatumParts

        """
        return _AIS.AIS_TrihedronOwner_DatumPart(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(AIS_TrihedronOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode)

        Highlights selectable object's presentation.

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _AIS.AIS_TrihedronOwner_HilightWithColor(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(AIS_TrihedronOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the presentation manager thePM
        highlights selections corresponding to the selection mode aMode.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_TrihedronOwner_IsHilighted(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(AIS_TrihedronOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode)

        Removes highlighting from the owner of a detected
        selectable object in the presentation manager thePM.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _AIS.AIS_TrihedronOwner_Unhilight(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_TrihedronOwner
AIS_TrihedronOwner_swigregister = _AIS.AIS_TrihedronOwner_swigregister
AIS_TrihedronOwner_swigregister(AIS_TrihedronOwner)

def AIS_TrihedronOwner_get_type_name(*args):
    """
    AIS_TrihedronOwner_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_TrihedronOwner_get_type_name(*args)

def AIS_TrihedronOwner_get_type_descriptor(*args):
    """
    AIS_TrihedronOwner_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_TrihedronOwner_get_type_descriptor(*args)

class Handle_AIS_Chamf3dDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Chamf3dDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Chamf3dDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Chamf3dDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Chamf3dDimension self, AIS_Chamf3dDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Chamf3dDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Chamf3dDimension self, Handle_AIS_Chamf3dDimension theHandle) -> Handle_AIS_Chamf3dDimension
        assign(Handle_AIS_Chamf3dDimension self, AIS_Chamf3dDimension thePtr) -> Handle_AIS_Chamf3dDimension
        assign(Handle_AIS_Chamf3dDimension self, Handle_AIS_Chamf3dDimension theHandle) -> Handle_AIS_Chamf3dDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Chamf3dDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Chamf3dDimension self) -> AIS_Chamf3dDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Chamf3dDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Chamf3dDimension self) -> AIS_Chamf3dDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Chamf3dDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Chamf3dDimension self) -> AIS_Chamf3dDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Chamf3dDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Chamf3dDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Chamf3dDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Chamf3dDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Chamf3dDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Chamf3dDimension

    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_Chamf3dDimension self) -> AIS_KindOfDimension

        Indicates that we are concerned with a 3d length.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_Chamf3dDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the 3d chamfer dimension is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_Chamf3dDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Chamf3dDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Chamf3dDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Chamf3dDimension self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Chamf3dDimension self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Chamf3dDimension self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Type(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_Chamf3dDimension self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_Chamf3dDimension self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_Chamf3dDimension self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_Chamf3dDimension self)"""
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_Chamf3dDimension self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_Chamf3dDimension self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_Chamf3dDimension self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_Chamf3dDimension self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_Chamf3dDimension self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_Chamf3dDimension self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf3dDimension_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_Chamf3dDimension self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_Chamf3dDimension self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_Chamf3dDimension self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_Chamf3dDimension self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Chamf3dDimension self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_Chamf3dDimension self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Chamf3dDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Chamf3dDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Chamf3dDimension_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Chamf3dDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Chamf3dDimension self)"""
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Chamf3dDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Chamf3dDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Chamf3dDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Chamf3dDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Chamf3dDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Chamf3dDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Chamf3dDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Chamf3dDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Chamf3dDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Chamf3dDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Chamf3dDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Chamf3dDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Chamf3dDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Chamf3dDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Chamf3dDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Chamf3dDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Chamf3dDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Chamf3dDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Chamf3dDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Chamf3dDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Chamf3dDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Chamf3dDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Chamf3dDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Chamf3dDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Chamf3dDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Chamf3dDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Chamf3dDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Chamf3dDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Chamf3dDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Chamf3dDimension self)
        RecomputePrimitives(Handle_AIS_Chamf3dDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf3dDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Chamf3dDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Chamf3dDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Chamf3dDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Chamf3dDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Chamf3dDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Chamf3dDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Chamf3dDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Chamf3dDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Chamf3dDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Chamf3dDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Chamf3dDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Chamf3dDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Chamf3dDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Chamf3dDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Chamf3dDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Chamf3dDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Chamf3dDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Chamf3dDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Chamf3dDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Chamf3dDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Chamf3dDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Chamf3dDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf3dDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Chamf3dDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Chamf3dDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Chamf3dDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Chamf3dDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Chamf3dDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Chamf3dDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Chamf3dDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Chamf3dDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Chamf3dDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Chamf3dDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Chamf3dDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Chamf3dDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Chamf3dDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Chamf3dDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Chamf3dDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Chamf3dDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Chamf3dDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Chamf3dDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Chamf3dDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Chamf3dDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Chamf3dDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Chamf3dDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Chamf3dDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Chamf3dDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Chamf3dDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Chamf3dDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Chamf3dDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Chamf3dDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Chamf3dDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Chamf3dDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Chamf3dDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Chamf3dDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Chamf3dDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Chamf3dDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Chamf3dDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Chamf3dDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Chamf3dDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Chamf3dDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Chamf3dDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Chamf3dDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Chamf3dDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Chamf3dDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Chamf3dDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Chamf3dDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Chamf3dDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf3dDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Chamf3dDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Chamf3dDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Chamf3dDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Chamf3dDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Chamf3dDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf3dDimension_DecrementRefCounter(self, *args)

Handle_AIS_Chamf3dDimension_swigregister = _AIS.Handle_AIS_Chamf3dDimension_swigregister
Handle_AIS_Chamf3dDimension_swigregister(Handle_AIS_Chamf3dDimension)

def Handle_AIS_Chamf3dDimension_DownCast(thing):
    return _AIS.Handle_AIS_Chamf3dDimension_DownCast(thing)
Handle_AIS_Chamf3dDimension_DownCast = _AIS.Handle_AIS_Chamf3dDimension_DownCast

class Handle_AIS_EqualRadiusRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_EqualRadiusRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_EqualRadiusRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_EqualRadiusRelation self, AIS_EqualRadiusRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_EqualRadiusRelation self, Handle_AIS_EqualRadiusRelation theHandle) -> Handle_AIS_EqualRadiusRelation
        assign(Handle_AIS_EqualRadiusRelation self, AIS_EqualRadiusRelation thePtr) -> Handle_AIS_EqualRadiusRelation
        assign(Handle_AIS_EqualRadiusRelation self, Handle_AIS_EqualRadiusRelation theHandle) -> Handle_AIS_EqualRadiusRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_EqualRadiusRelation self) -> AIS_EqualRadiusRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_EqualRadiusRelation self) -> AIS_EqualRadiusRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_EqualRadiusRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_EqualRadiusRelation self) -> AIS_EqualRadiusRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_EqualRadiusRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_EqualRadiusRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_EqualRadiusRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_EqualRadiusRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_EqualRadiusRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_EqualRadiusRelation

    def Compute(self, *args):
        """
        Compute(Handle_AIS_EqualRadiusRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_EqualRadiusRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_EqualRadiusRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_EqualRadiusRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_EqualRadiusRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_EqualRadiusRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsMovable(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_EqualRadiusRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_EqualRadiusRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_EqualRadiusRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_EqualRadiusRelation self)"""
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_EqualRadiusRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_EqualRadiusRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_EqualRadiusRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_EqualRadiusRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_EqualRadiusRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_EqualRadiusRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_EqualRadiusRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_EqualRadiusRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_EqualRadiusRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_EqualRadiusRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_EqualRadiusRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_EqualRadiusRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_EqualRadiusRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_EqualRadiusRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_EqualRadiusRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_EqualRadiusRelation self)"""
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_EqualRadiusRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_EqualRadiusRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_EqualRadiusRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_EqualRadiusRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_EqualRadiusRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_EqualRadiusRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_EqualRadiusRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_EqualRadiusRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_EqualRadiusRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_EqualRadiusRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_EqualRadiusRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_EqualRadiusRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_EqualRadiusRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_EqualRadiusRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_EqualRadiusRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_EqualRadiusRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_EqualRadiusRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_EqualRadiusRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_EqualRadiusRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_EqualRadiusRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_EqualRadiusRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_EqualRadiusRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_EqualRadiusRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_EqualRadiusRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_EqualRadiusRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_EqualRadiusRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_EqualRadiusRelation self)
        RecomputePrimitives(Handle_AIS_EqualRadiusRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_EqualRadiusRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_EqualRadiusRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_EqualRadiusRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_EqualRadiusRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_EqualRadiusRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_EqualRadiusRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_EqualRadiusRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_EqualRadiusRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_EqualRadiusRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_EqualRadiusRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_EqualRadiusRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_EqualRadiusRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_EqualRadiusRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_EqualRadiusRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_EqualRadiusRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_EqualRadiusRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_EqualRadiusRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_EqualRadiusRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_EqualRadiusRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_EqualRadiusRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_EqualRadiusRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_EqualRadiusRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_EqualRadiusRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_EqualRadiusRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_EqualRadiusRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_EqualRadiusRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_EqualRadiusRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_EqualRadiusRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_EqualRadiusRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_EqualRadiusRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_EqualRadiusRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_EqualRadiusRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_EqualRadiusRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_EqualRadiusRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_EqualRadiusRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_EqualRadiusRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_EqualRadiusRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_EqualRadiusRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_EqualRadiusRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_EqualRadiusRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_EqualRadiusRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_EqualRadiusRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_EqualRadiusRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_EqualRadiusRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_EqualRadiusRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EqualRadiusRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_EqualRadiusRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_EqualRadiusRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_EqualRadiusRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_EqualRadiusRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_EqualRadiusRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_EqualRadiusRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_EqualRadiusRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_EqualRadiusRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_EqualRadiusRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_EqualRadiusRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_EqualRadiusRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualRadiusRelation_DecrementRefCounter(self, *args)

Handle_AIS_EqualRadiusRelation_swigregister = _AIS.Handle_AIS_EqualRadiusRelation_swigregister
Handle_AIS_EqualRadiusRelation_swigregister(Handle_AIS_EqualRadiusRelation)

def Handle_AIS_EqualRadiusRelation_DownCast(thing):
    return _AIS.Handle_AIS_EqualRadiusRelation_DownCast(thing)
Handle_AIS_EqualRadiusRelation_DownCast = _AIS.Handle_AIS_EqualRadiusRelation_DownCast

class Handle_AIS_RubberBand(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_RubberBand self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_RubberBand_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_RubberBand self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_RubberBand_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_RubberBand self, AIS_RubberBand thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_RubberBand_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_RubberBand self, Handle_AIS_RubberBand theHandle) -> Handle_AIS_RubberBand
        assign(Handle_AIS_RubberBand self, AIS_RubberBand thePtr) -> Handle_AIS_RubberBand
        assign(Handle_AIS_RubberBand self, Handle_AIS_RubberBand theHandle) -> Handle_AIS_RubberBand

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_RubberBand_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_RubberBand self) -> AIS_RubberBand

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_RubberBand_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_RubberBand self) -> AIS_RubberBand

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_RubberBand___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_RubberBand self) -> AIS_RubberBand

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_RubberBand___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_RubberBand___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_RubberBand___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_RubberBand(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_RubberBand_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_RubberBand

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_RubberBand self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_RubberBand_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_RubberBand_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_RubberBand_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRectangle(self, *args):
        """
        SetRectangle(Handle_AIS_RubberBand self, Standard_Integer const theMinX, Standard_Integer const theMinY, Standard_Integer const theMaxX, Standard_Integer const theMaxY)

        Sets rectangle bounds.

        :type theMinX: int
        :type theMinY: int
        :type theMaxX: int
        :type theMaxY: int

        """
        return _AIS.Handle_AIS_RubberBand_SetRectangle(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(Handle_AIS_RubberBand self, NCollection_Vec2_Standard_Integer thePoint)

        Adds last point to the list of points. They are used to build polygon for rubber band.
        @sa RemoveLastPoint(), GetPoints()

        :type thePoint: OCC.wrapper.Graphic3d.Graphic3d_Vec2i

        """
        return _AIS.Handle_AIS_RubberBand_AddPoint(self, *args)


    def RemoveLastPoint(self, *args):
        """
        RemoveLastPoint(Handle_AIS_RubberBand self)

        Remove last point from the list of points for the rubber band polygon.
        @sa AddPoint(), GetPoints()


        """
        return _AIS.Handle_AIS_RubberBand_RemoveLastPoint(self, *args)


    def Points(self, *args):
        """
        @return points for the rubber band polygon.

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Graphic3d_Vec2i

        """
        res = _AIS.Handle_AIS_RubberBand_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClearPoints(self, *args):
        """
        ClearPoints(Handle_AIS_RubberBand self)

        Remove all points for the rubber band polygon.


        """
        return _AIS.Handle_AIS_RubberBand_ClearPoints(self, *args)


    def LineColor(self, *args):
        """
        LineColor(Handle_AIS_RubberBand self) -> Quantity_Color

        @return the Color attributes.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RubberBand_LineColor(self, *args)


    def SetLineColor(self, *args):
        """
        SetLineColor(Handle_AIS_RubberBand self, Quantity_Color theColor)

        Sets color of lines for rubber band presentation.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RubberBand_SetLineColor(self, *args)


    def FillColor(self, *args):
        """
        FillColor(Handle_AIS_RubberBand self) -> Quantity_Color

        @return the color of rubber band filling.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RubberBand_FillColor(self, *args)


    def SetFillColor(self, *args):
        """
        SetFillColor(Handle_AIS_RubberBand self, Quantity_Color theColor)

        Sets color of rubber band filling.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RubberBand_SetFillColor(self, *args)


    def SetLineWidth(self, *args):
        """
        SetLineWidth(Handle_AIS_RubberBand self, Standard_Real const theWidth)

        Sets width of line for rubber band presentation.

        :type theWidth: float

        """
        return _AIS.Handle_AIS_RubberBand_SetLineWidth(self, *args)


    def LineWidth(self, *args):
        """
        LineWidth(Handle_AIS_RubberBand self) -> Standard_Real

        @return width of lines.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RubberBand_LineWidth(self, *args)


    def SetLineType(self, *args):
        """
        SetLineType(Handle_AIS_RubberBand self, Aspect_TypeOfLine const theType)

        Sets type of line for rubber band presentation.

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.Handle_AIS_RubberBand_SetLineType(self, *args)


    def LineType(self, *args):
        """
        LineType(Handle_AIS_RubberBand self) -> Aspect_TypeOfLine

        @return type of lines.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.Handle_AIS_RubberBand_LineType(self, *args)


    def SetFillTransparency(self, *args):
        """
        SetFillTransparency(Handle_AIS_RubberBand self, Standard_Real const theValue)

        Sets fill transparency.
        @param theValue [in] the transparency value. 1.0 is for transparent background

        :type theValue: float

        """
        return _AIS.Handle_AIS_RubberBand_SetFillTransparency(self, *args)


    def FillTransparency(self, *args):
        """
        FillTransparency(Handle_AIS_RubberBand self) -> Standard_Real

        @return fill transparency.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RubberBand_FillTransparency(self, *args)


    def SetFilling(self, *args):
        """
        SetFilling(Handle_AIS_RubberBand self, Standard_Boolean const theIsFilling)
        SetFilling(Handle_AIS_RubberBand self, Quantity_Color theColor, Standard_Real const theTransparency)

        Enable filling of rubber band with defined parameters.
        @param theColor [in] color of filling
        @param theTransparency [in] transparency of the filling. 0 is for opaque filling.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theTransparency: float

        """
        return _AIS.Handle_AIS_RubberBand_SetFilling(self, *args)


    def IsFilling(self, *args):
        """
        IsFilling(Handle_AIS_RubberBand self) -> Standard_Boolean

        @return true if filling of rubber band is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsFilling(self, *args)


    def IsPolygonClosed(self, *args):
        """
        IsPolygonClosed(Handle_AIS_RubberBand self) -> Standard_Boolean

        @return true if automatic closing of rubber band is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsPolygonClosed(self, *args)


    def SetPolygonClosed(self, *args):
        """
        SetPolygonClosed(Handle_AIS_RubberBand self, Standard_Boolean theIsPolygonClosed)

        Automatically create an additional line connecting the first and 
        the last screen points to close the boundary polyline

        :type theIsPolygonClosed: bool

        """
        return _AIS.Handle_AIS_RubberBand_SetPolygonClosed(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_RubberBand self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_RubberBand_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_RubberBand self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RubberBand_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_RubberBand self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_RubberBand self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_RubberBand_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_RubberBand self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_RubberBand_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_RubberBand self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RubberBand_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_RubberBand self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_RubberBand_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_RubberBand self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_RubberBand_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_RubberBand self)"""
        return _AIS.Handle_AIS_RubberBand_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_RubberBand self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_RubberBand self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RubberBand_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_RubberBand self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_RubberBand_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_RubberBand self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_RubberBand_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_RubberBand self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_RubberBand self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_RubberBand_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_RubberBand self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_RubberBand_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_RubberBand_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_RubberBand self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_RubberBand_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_RubberBand self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_RubberBand_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_RubberBand self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_RubberBand_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_RubberBand self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_RubberBand_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_RubberBand self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RubberBand_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_RubberBand self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RubberBand_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_RubberBand self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_RubberBand_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_RubberBand self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_RubberBand_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_RubberBand self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_RubberBand_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_RubberBand self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RubberBand_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_RubberBand self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_RubberBand_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_RubberBand self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_RubberBand_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_RubberBand self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_RubberBand_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_RubberBand self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_RubberBand_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_RubberBand self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_RubberBand_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_RubberBand self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_RubberBand_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_RubberBand self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_RubberBand_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_RubberBand self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_RubberBand_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_RubberBand self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_RubberBand_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_RubberBand self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_RubberBand_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_RubberBand self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_RubberBand_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_RubberBand self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_RubberBand_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_RubberBand self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_RubberBand_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_RubberBand self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_RubberBand_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_RubberBand self)
        RecomputePrimitives(Handle_AIS_RubberBand self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_RubberBand_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_RubberBand self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_RubberBand_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_RubberBand self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_RubberBand_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_RubberBand_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_RubberBand self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_RubberBand_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_RubberBand self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_RubberBand_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_RubberBand self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_RubberBand self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_RubberBand_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_RubberBand_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_RubberBand self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_RubberBand_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_RubberBand self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_RubberBand_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_RubberBand self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_RubberBand_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_RubberBand self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_RubberBand_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_RubberBand self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_RubberBand_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_RubberBand self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_RubberBand_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_RubberBand self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_RubberBand_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_RubberBand self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_RubberBand self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_RubberBand_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_RubberBand self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_RubberBand_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_RubberBand self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_RubberBand_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_RubberBand self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_RubberBand_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_RubberBand self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_RubberBand_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_RubberBand self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_RubberBand_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_RubberBand self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_RubberBand_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_RubberBand self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_RubberBand_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_RubberBand self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RubberBand_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_RubberBand self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_RubberBand_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_RubberBand_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_RubberBand self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_RubberBand_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_RubberBand self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_RubberBand_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_RubberBand_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_RubberBand self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_RubberBand self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_RubberBand_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_RubberBand self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_RubberBand_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_RubberBand self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_RubberBand_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_RubberBand self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_RubberBand_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_RubberBand self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_RubberBand self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_RubberBand_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_RubberBand self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_RubberBand_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_RubberBand_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_RubberBand self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_RubberBand self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_RubberBand_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_RubberBand_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_RubberBand_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_RubberBand_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_RubberBand_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_RubberBand self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_RubberBand_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_RubberBand self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_RubberBand_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_RubberBand self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_RubberBand_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_RubberBand self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_RubberBand self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_RubberBand_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_RubberBand_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_RubberBand self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_RubberBand_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_RubberBand self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_RubberBand_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_RubberBand self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_RubberBand_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_RubberBand_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_RubberBand self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_RubberBand self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_RubberBand_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_RubberBand self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_RubberBand_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_RubberBand_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_RubberBand_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_RubberBand self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_RubberBand_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_RubberBand_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_RubberBand self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_RubberBand_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_RubberBand self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_RubberBand_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_RubberBand self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_RubberBand_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_RubberBand self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_RubberBand self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_RubberBand self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_RubberBand self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_RubberBand_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_RubberBand self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_RubberBand_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_RubberBand self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RubberBand_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_RubberBand self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_RubberBand_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_RubberBand self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_RubberBand_DecrementRefCounter(self, *args)

Handle_AIS_RubberBand_swigregister = _AIS.Handle_AIS_RubberBand_swigregister
Handle_AIS_RubberBand_swigregister(Handle_AIS_RubberBand)

def Handle_AIS_RubberBand_DownCast(thing):
    return _AIS.Handle_AIS_RubberBand_DownCast(thing)
Handle_AIS_RubberBand_DownCast = _AIS.Handle_AIS_RubberBand_DownCast

class AIS_AttributeFilter(SelectMgr.SelectMgr_Filter):
    """
    Selects Interactive Objects, which have the desired width or color.
    The filter questions each Interactive Object in local
    context to determine whether it has an non-null
    owner, and if so, whether it has the required color
    and width attributes. If the object returns true in each
    case, it is kept. If not, it is rejected.
    This filter is used only in an open local context.
    In the Collector viewer, you can only locate
    Interactive Objects, which answer positively to the
    filters, which are in position when a local context is open.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_AttributeFilter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_AttributeFilter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_AttributeFilter self) -> AIS_AttributeFilter
        __init__(AIS_AttributeFilter self, Quantity_NameOfColor const aCol) -> AIS_AttributeFilter
        __init__(AIS_AttributeFilter self, Standard_Real const aWidth) -> AIS_AttributeFilter

        Constructs an attribute filter object defined by the line
        width attribute aWidth.

        :type aWidth: float

        """
        this = _AIS.new_AIS_AttributeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasColor(self, *args):
        """
        HasColor(AIS_AttributeFilter self) -> Standard_Boolean

        Indicates that the Interactive Object has the color
        setting specified by the argument aCol at construction time.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_AttributeFilter_HasColor(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(AIS_AttributeFilter self) -> Standard_Boolean

        Indicates that the Interactive Object has the width
        setting specified by the argument aWidth at
        construction time.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_AttributeFilter_HasWidth(self, *args)


    def SetColor(self, *args):
        """
        SetColor(AIS_AttributeFilter self, Quantity_NameOfColor const aCol)

        Sets the color aCol.
        This must be chosen from the list of colors in Quantity_NameOfColor.

        :type aCol: OCC.wrapper.Quantity.Quantity_NameOfColor

        """
        return _AIS.AIS_AttributeFilter_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(AIS_AttributeFilter self, Standard_Real const aWidth)

        Sets the line width aWidth.

        :type aWidth: float

        """
        return _AIS.AIS_AttributeFilter_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(AIS_AttributeFilter self)

        Removes the setting for color from the filter.


        """
        return _AIS.AIS_AttributeFilter_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(AIS_AttributeFilter self)

        Removes the setting for width from the filter.


        """
        return _AIS.AIS_AttributeFilter_UnsetWidth(self, *args)


    def IsOk(self, *args):
        """
        IsOk(AIS_AttributeFilter self, Handle_SelectMgr_EntityOwner anObj) -> Standard_Boolean

        Indicates that the selected Interactive Object passes
        the filter. The owner, anObj, can be either direct or
        user. A direct owner is the corresponding
        construction element, whereas a user is the
        compound shape of which the entity forms a part.
        If the Interactive Object returns Standard_True
        when detected by the Local Context selector through
        the mouse, the object is kept; if not, it is rejected.

        :type anObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_AttributeFilter_IsOk(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_AttributeFilter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_AttributeFilter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_AttributeFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_AttributeFilter
AIS_AttributeFilter_swigregister = _AIS.AIS_AttributeFilter_swigregister
AIS_AttributeFilter_swigregister(AIS_AttributeFilter)

def AIS_AttributeFilter_get_type_name(*args):
    """
    AIS_AttributeFilter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_AttributeFilter_get_type_name(*args)

def AIS_AttributeFilter_get_type_descriptor(*args):
    """
    AIS_AttributeFilter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_AttributeFilter_get_type_descriptor(*args)

class Handle_AIS_ColorScale(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ColorScale self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ColorScale_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ColorScale self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ColorScale_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ColorScale self, AIS_ColorScale thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ColorScale_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ColorScale self, Handle_AIS_ColorScale theHandle) -> Handle_AIS_ColorScale
        assign(Handle_AIS_ColorScale self, AIS_ColorScale thePtr) -> Handle_AIS_ColorScale
        assign(Handle_AIS_ColorScale self, Handle_AIS_ColorScale theHandle) -> Handle_AIS_ColorScale

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ColorScale_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ColorScale self) -> AIS_ColorScale

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ColorScale_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ColorScale self) -> AIS_ColorScale

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ColorScale___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ColorScale self) -> AIS_ColorScale

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ColorScale___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ColorScale___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ColorScale___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ColorScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ColorScale_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ColorScale

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ColorScale self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ColorScale_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ColorScale_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ColorScale_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindColor(self, *args):
        """
        FindColor(Handle_AIS_ColorScale self, Standard_Real const theValue, Standard_Real const theMin, Standard_Real const theMax, Standard_Integer const theColorsCount, NCollection_Vec3_Standard_Real theColorHlsMin, NCollection_Vec3_Standard_Real theColorHlsMax, Quantity_Color theColor) -> Standard_Boolean
        FindColor(Handle_AIS_ColorScale self, Standard_Real const theValue, Standard_Real const theMin, Standard_Real const theMax, Standard_Integer const theColorsCount, Quantity_Color theColor) -> Standard_Boolean
        FindColor(Handle_AIS_ColorScale self, Standard_Real const theValue, Quantity_Color theColor) -> Standard_Boolean

        Calculate color according passed value; returns true if value is in range or false, if isn't

        :type theValue: float
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_FindColor(self, *args)


    def hueToValidRange(self, *args):
        """
        hueToValidRange(Handle_AIS_ColorScale self, Standard_Real const theHue) -> Standard_Real

        Shift hue into valid range.
        Lightness and Saturation should be specified in valid range [0.0, 1.0],
        however Hue might be given out of Quantity_Color range to specify desired range for interpolation.

        :type theHue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColorScale_hueToValidRange(self, *args)


    def GetMin(self, *args):
        """
        GetMin(Handle_AIS_ColorScale self) -> Standard_Real

        Returns minimal value of color scale, 0.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColorScale_GetMin(self, *args)


    def SetMin(self, *args):
        """
        SetMin(Handle_AIS_ColorScale self, Standard_Real const theMin)

        Sets the minimal value of color scale.

        :type theMin: float

        """
        return _AIS.Handle_AIS_ColorScale_SetMin(self, *args)


    def GetMax(self, *args):
        """
        GetMax(Handle_AIS_ColorScale self) -> Standard_Real

        Returns maximal value of color scale, 1.0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColorScale_GetMax(self, *args)


    def SetMax(self, *args):
        """
        SetMax(Handle_AIS_ColorScale self, Standard_Real const theMax)

        Sets the maximal value of color scale.

        :type theMax: float

        """
        return _AIS.Handle_AIS_ColorScale_SetMax(self, *args)


    def GetRange(self, *args):
        """
        GetRange(Handle_AIS_ColorScale self)

        Returns minimal and maximal values of color scale, 0.0 to 1.0 by default.

        :type theMin: float
        :type theMax: float

        """
        return _AIS.Handle_AIS_ColorScale_GetRange(self, *args)


    def SetRange(self, *args):
        """
        SetRange(Handle_AIS_ColorScale self, Standard_Real const theMin, Standard_Real const theMax)

        Sets the minimal and maximal value of color scale.
        Note that values order will be ignored - the minimum and maximum values will be swapped if needed.
        ::SetReversed() should be called to swap displaying order.

        :type theMin: float
        :type theMax: float

        """
        return _AIS.Handle_AIS_ColorScale_SetRange(self, *args)


    def HueMin(self, *args):
        """
        HueMin(Handle_AIS_ColorScale self) -> Standard_Real

        Returns the hue angle corresponding to minimum value, 230 by default (blue).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColorScale_HueMin(self, *args)


    def HueMax(self, *args):
        """
        HueMax(Handle_AIS_ColorScale self) -> Standard_Real

        Returns the hue angle corresponding to maximum value, 0 by default (red).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColorScale_HueMax(self, *args)


    def HueRange(self, *args):
        """
        HueRange(Handle_AIS_ColorScale self)

        Returns the hue angle range corresponding to minimum and maximum values, 230 to 0 by default (blue to red).

        :type theMinAngle: float
        :type theMaxAngle: float

        """
        return _AIS.Handle_AIS_ColorScale_HueRange(self, *args)


    def SetHueRange(self, *args):
        """
        SetHueRange(Handle_AIS_ColorScale self, Standard_Real const theMinAngle, Standard_Real const theMaxAngle)

        Sets hue angle range corresponding to minimum and maximum values.
        The valid angle range is [0, 360], see Quantity_Color and Quantity_TOC_HLS for more details.

        :type theMinAngle: float
        :type theMaxAngle: float

        """
        return _AIS.Handle_AIS_ColorScale_SetHueRange(self, *args)


    def ColorRange(self, *args):
        """
        ColorRange(Handle_AIS_ColorScale self, Quantity_Color theMinColor, Quantity_Color theMaxColor)

        Returns color range corresponding to minimum and maximum values, blue to red by default.

        :type theMinColor: OCC.wrapper.Quantity.Quantity_Color
        :type theMaxColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColorScale_ColorRange(self, *args)


    def SetColorRange(self, *args):
        """
        SetColorRange(Handle_AIS_ColorScale self, Quantity_Color theMinColor, Quantity_Color theMaxColor)

        Sets color range corresponding to minimum and maximum values.

        :type theMinColor: OCC.wrapper.Quantity.Quantity_Color
        :type theMaxColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColorScale_SetColorRange(self, *args)


    def GetLabelType(self, *args):
        """
        GetLabelType(Handle_AIS_ColorScale self) -> Aspect_TypeOfColorScaleData

        Returns the type of labels, Aspect_TOCSD_AUTO by default.
        Aspect_TOCSD_AUTO - labels as boundary values for intervals
        Aspect_TOCSD_USER - user specified label is used

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.Handle_AIS_ColorScale_GetLabelType(self, *args)


    def SetLabelType(self, *args):
        """
        SetLabelType(Handle_AIS_ColorScale self, Aspect_TypeOfColorScaleData const theType)

        Sets the type of labels.
        Aspect_TOCSD_AUTO - labels as boundary values for intervals
        Aspect_TOCSD_USER - user specified label is used

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.Handle_AIS_ColorScale_SetLabelType(self, *args)


    def GetColorType(self, *args):
        """
        GetColorType(Handle_AIS_ColorScale self) -> Aspect_TypeOfColorScaleData

        Returns the type of colors, Aspect_TOCSD_AUTO by default.
        Aspect_TOCSD_AUTO - value between Red and Blue
        Aspect_TOCSD_USER - user specified color from color map

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.Handle_AIS_ColorScale_GetColorType(self, *args)


    def SetColorType(self, *args):
        """
        SetColorType(Handle_AIS_ColorScale self, Aspect_TypeOfColorScaleData const theType)

        Sets the type of colors.
        Aspect_TOCSD_AUTO - value between Red and Blue
        Aspect_TOCSD_USER - user specified color from color map

        :type theType: OCC.wrapper.Aspect.Aspect_TypeOfColorScaleData

        """
        return _AIS.Handle_AIS_ColorScale_SetColorType(self, *args)


    def GetNumberOfIntervals(self, *args):
        """
        GetNumberOfIntervals(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the number of color scale intervals, 10 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GetNumberOfIntervals(self, *args)


    def SetNumberOfIntervals(self, *args):
        """
        SetNumberOfIntervals(Handle_AIS_ColorScale self, Standard_Integer const theNum)

        Sets the number of color scale intervals.

        :type theNum: int

        """
        return _AIS.Handle_AIS_ColorScale_SetNumberOfIntervals(self, *args)


    def GetTitle(self, *args):
        """
        Returns the color scale title string, empty string by default.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_ColorScale_GetTitle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTitle(self, *args):
        """
        SetTitle(Handle_AIS_ColorScale self, TCollection_ExtendedString theTitle)

        Sets the color scale title string.

        :type theTitle: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_ColorScale_SetTitle(self, *args)


    def GetFormat(self, *args):
        """
        Returns the format for numbers, "%.4g" by default.
        The same like format for function printf().
        Used if GetLabelType() is TOCSD_AUTO;

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_ColorScale_GetFormat(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Format(self, *args):
        """
        Returns the format of text.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_ColorScale_Format(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFormat(self, *args):
        """
        SetFormat(Handle_AIS_ColorScale self, TCollection_AsciiString theFormat)

        Sets the color scale auto label format specification.

        :type theFormat: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_ColorScale_SetFormat(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_AIS_ColorScale self, Standard_Integer const theIndex) -> TCollection_ExtendedString

        Returns the user specified label with index theIndex.
        Index is in range from 1 to GetNumberOfIntervals() or to
        GetNumberOfIntervals() + 1 if IsLabelAtBorder() is true.
        Returns empty string if label not defined.

        :type theIndex: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_ColorScale_GetLabel(self, *args)


    def GetIntervalColor(self, *args):
        """
        GetIntervalColor(Handle_AIS_ColorScale self, Standard_Integer const theIndex) -> Quantity_Color

        Returns the user specified color from color map with index (starts at 1).
        Returns default color if index is out of range in color map.

        :type theIndex: int
        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColorScale_GetIntervalColor(self, *args)


    def SetIntervalColor(self, *args):
        """
        SetIntervalColor(Handle_AIS_ColorScale self, Quantity_Color theColor, Standard_Integer const theIndex)

        Sets the color of the specified interval. 
        Note that list is automatically resized to include specified index.
        @param theColor color value to set
        @param theIndex index in range [1, GetNumberOfIntervals()];
        appended to the end of list if -1 is specified

        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :type theIndex: int

        """
        return _AIS.Handle_AIS_ColorScale_SetIntervalColor(self, *args)


    def GetLabels(self, *args):
        """
        GetLabels(Handle_AIS_ColorScale self, NCollection_Sequence_TCollection_ExtendedString theLabels)

        Returns the user specified labels.

        :type theLabels: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _AIS.Handle_AIS_ColorScale_GetLabels(self, *args)


    def Labels(self, *args):
        """
        Returns the user specified labels.

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _AIS.Handle_AIS_ColorScale_Labels(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLabels(self, *args):
        """
        SetLabels(Handle_AIS_ColorScale self, NCollection_Sequence_TCollection_ExtendedString theSeq)

        Sets the color scale labels.
        The length of the sequence should be equal to GetNumberOfIntervals() or to GetNumberOfIntervals() + 1 if IsLabelAtBorder() is true.
        If length of the sequence does not much the number of intervals,
        then these labels will be considered as "free" and will be located
        at the virtual intervals corresponding to the number of labels
        (with flag IsLabelAtBorder() having the same effect as in normal case).

        :type theSeq: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _AIS.Handle_AIS_ColorScale_SetLabels(self, *args)


    def GetColors(self, *args):
        """
        Returns the user specified colors.

        :rtype: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        res = _AIS.Handle_AIS_ColorScale_GetColors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(Handle_AIS_ColorScale self, NCollection_Sequence_Quantity_Color theSeq)

        Sets the color scale colors.
        The length of the sequence should be equal to GetNumberOfIntervals().

        :type theSeq: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        return _AIS.Handle_AIS_ColorScale_SetColors(self, *args)


    def GetLabelPosition(self, *args):
        """
        GetLabelPosition(Handle_AIS_ColorScale self) -> Aspect_TypeOfColorScalePosition

        Returns the position of labels concerning color filled rectangles, Aspect_TOCSP_RIGHT by default.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.Handle_AIS_ColorScale_GetLabelPosition(self, *args)


    def SetLabelPosition(self, *args):
        """
        SetLabelPosition(Handle_AIS_ColorScale self, Aspect_TypeOfColorScalePosition const thePos)

        Sets the color scale labels position relative to color bar.

        :type thePos: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.Handle_AIS_ColorScale_SetLabelPosition(self, *args)


    def GetTitlePosition(self, *args):
        """
        GetTitlePosition(Handle_AIS_ColorScale self) -> Aspect_TypeOfColorScalePosition

        Returns the position of color scale title, Aspect_TOCSP_LEFT by default.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.Handle_AIS_ColorScale_GetTitlePosition(self, *args)


    def SetTitlePosition(self, *args):
        """
        SetTitlePosition(Handle_AIS_ColorScale self, Aspect_TypeOfColorScalePosition const thePos)

        Sets the color scale title position.

        :type thePos: OCC.wrapper.Aspect.Aspect_TypeOfColorScalePosition

        """
        return _AIS.Handle_AIS_ColorScale_SetTitlePosition(self, *args)


    def IsReversed(self, *args):
        """
        IsReversed(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns TRUE if the labels and colors used in reversed order, FALSE by default.
        - Normal,   bottom-up order with Minimal value on the Bottom and Maximum value on Top.
        - Reversed, top-down  order with Maximum value on the Bottom and Minimum value on Top.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsReversed(self, *args)


    def SetReversed(self, *args):
        """
        SetReversed(Handle_AIS_ColorScale self, Standard_Boolean const theReverse)

        Sets true if the labels and colors used in reversed order.

        :type theReverse: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetReversed(self, *args)


    def IsSmoothTransition(self, *args):
        """
        IsSmoothTransition(Handle_AIS_ColorScale self) -> Standard_Boolean

        Return TRUE if color transition between neighbor intervals
        should be linearly interpolated, FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsSmoothTransition(self, *args)


    def SetSmoothTransition(self, *args):
        """
        SetSmoothTransition(Handle_AIS_ColorScale self, Standard_Boolean const theIsSmooth)

        Setup smooth color transition.

        :type theIsSmooth: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetSmoothTransition(self, *args)


    def IsLabelAtBorder(self, *args):
        """
        IsLabelAtBorder(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns TRUE if the labels are placed at border of color intervals, TRUE by default.
        The automatically generated label will show value exactly on the current position:
        - value connecting two neighbor intervals (TRUE)
        - value in the middle of interval (FALSE)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsLabelAtBorder(self, *args)


    def SetLabelAtBorder(self, *args):
        """
        SetLabelAtBorder(Handle_AIS_ColorScale self, Standard_Boolean const theOn)

        Sets true if the labels are placed at border of color intervals (TRUE by default).
        If set to False, labels will be drawn at color intervals rather than at borders.

        :type theOn: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetLabelAtBorder(self, *args)


    def IsLogarithmic(self, *args):
        """
        IsLogarithmic(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns TRUE if the color scale has logarithmic intervals, FALSE by default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsLogarithmic(self, *args)


    def SetLogarithmic(self, *args):
        """
        SetLogarithmic(Handle_AIS_ColorScale self, Standard_Boolean const isLogarithmic)

        Sets true if the color scale has logarithmic intervals.

        :type isLogarithmic: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetLogarithmic(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_AIS_ColorScale self, TCollection_ExtendedString theLabel, Standard_Integer const theIndex)

        Sets the color scale label at index.
        Note that list is automatically resized to include specified index.
        @param theLabel new label text
        @param theIndex index in range [1, GetNumberOfIntervals()] or [1, GetNumberOfIntervals() + 1] if IsLabelAtBorder() is true;
        label is appended to the end of list if negative index is specified

        :type theLabel: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theIndex: int

        """
        return _AIS.Handle_AIS_ColorScale_SetLabel(self, *args)


    def GetSize(self, *args):
        """
        GetSize(Handle_AIS_ColorScale self)

        Returns the size of color bar, 0 and 0 by default
        (e.g. should be set by user explicitly before displaying).

        :type theBreadth: int
        :type theHeight: int

        """
        return _AIS.Handle_AIS_ColorScale_GetSize(self, *args)


    def SetSize(self, *args):
        """
        SetSize(Handle_AIS_ColorScale self, Standard_Integer const theBreadth, Standard_Integer const theHeight)

        Sets the size of color bar.

        :type theBreadth: int
        :type theHeight: int

        """
        return _AIS.Handle_AIS_ColorScale_SetSize(self, *args)


    def GetBreadth(self, *args):
        """
        GetBreadth(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the breadth of color bar, 0 by default
        (e.g. should be set by user explicitly before displaying).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GetBreadth(self, *args)


    def SetBreadth(self, *args):
        """
        SetBreadth(Handle_AIS_ColorScale self, Standard_Integer const theBreadth)

        Sets the width of color bar.

        :type theBreadth: int

        """
        return _AIS.Handle_AIS_ColorScale_SetBreadth(self, *args)


    def GetHeight(self, *args):
        """
        GetHeight(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the height of color bar, 0 by default
        (e.g. should be set by user explicitly before displaying).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GetHeight(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(Handle_AIS_ColorScale self, Standard_Integer const theHeight)

        Sets the height of color bar.

        :type theHeight: int

        """
        return _AIS.Handle_AIS_ColorScale_SetHeight(self, *args)


    def GetPosition(self, *args):
        """
        GetPosition(Handle_AIS_ColorScale self)

        Returns the bottom-left position of color scale, 0x0 by default.

        :type theX: float
        :type theY: float

        """
        return _AIS.Handle_AIS_ColorScale_GetPosition(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_ColorScale self, Standard_Integer const theX, Standard_Integer const theY)

        Sets the position of color scale.

        :type theX: int
        :type theY: int

        """
        return _AIS.Handle_AIS_ColorScale_SetPosition(self, *args)


    def GetXPosition(self, *args):
        """
        GetXPosition(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the left position of color scale, 0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GetXPosition(self, *args)


    def SetXPosition(self, *args):
        """
        SetXPosition(Handle_AIS_ColorScale self, Standard_Integer const theX)

        Sets the left position of color scale.

        :type theX: int

        """
        return _AIS.Handle_AIS_ColorScale_SetXPosition(self, *args)


    def GetYPosition(self, *args):
        """
        GetYPosition(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the bottom position of color scale, 0 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GetYPosition(self, *args)


    def SetYPosition(self, *args):
        """
        SetYPosition(Handle_AIS_ColorScale self, Standard_Integer const theY)

        Sets the bottom position of color scale.

        :type theY: int

        """
        return _AIS.Handle_AIS_ColorScale_SetYPosition(self, *args)


    def GetTextHeight(self, *args):
        """
        GetTextHeight(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the font height of text labels, 20 by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GetTextHeight(self, *args)


    def SetTextHeight(self, *args):
        """
        SetTextHeight(Handle_AIS_ColorScale self, Standard_Integer const theHeight)

        Sets the height of text of color scale.

        :type theHeight: int

        """
        return _AIS.Handle_AIS_ColorScale_SetTextHeight(self, *args)


    def TextWidth(self, *args):
        """
        TextWidth(Handle_AIS_ColorScale self, TCollection_ExtendedString theText) -> Standard_Integer

        Returns the width of text.
        @param theText [in] the text of which to calculate width.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_TextWidth(self, *args)


    def TextHeight(self, *args):
        """
        TextHeight(Handle_AIS_ColorScale self, TCollection_ExtendedString theText) -> Standard_Integer

        Returns the height of text.
        @param theText [in] the text of which to calculate height.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_TextHeight(self, *args)


    def TextSize(self, *args):
        """
        TextSize(Handle_AIS_ColorScale self, TCollection_ExtendedString theText, Standard_Integer const theHeight)

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theHeight: int
        :type theWidth: int
        :type theAscent: int
        :type theDescent: int

        """
        return _AIS.Handle_AIS_ColorScale_TextSize(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_ColorScale self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if specified display mode is supported.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentationManager thePresentationManager, Handle_Prs3d_Presentation thePresentation, Standard_Integer const theMode)

        Compute presentation.

        :type thePresentationManager: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theMode: int

        """
        return _AIS.Handle_AIS_ColorScale_Compute(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_ColorScale self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_ColorScale_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_ColorScale self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_ColorScale self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_ColorScale self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ColorScale_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_ColorScale self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ColorScale_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_ColorScale self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColorScale_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_ColorScale self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_ColorScale_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_ColorScale self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ColorScale_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_ColorScale self)"""
        return _AIS.Handle_AIS_ColorScale_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_ColorScale self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_ColorScale_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_ColorScale self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_ColorScale self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_ColorScale self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ColorScale_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_ColorScale self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ColorScale_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_ColorScale_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_ColorScale self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_ColorScale_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_ColorScale self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_ColorScale_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_ColorScale self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_ColorScale_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_ColorScale self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_ColorScale_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_ColorScale self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ColorScale_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_ColorScale self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_ColorScale_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_ColorScale self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColorScale_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_ColorScale self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColorScale_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_ColorScale self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_ColorScale_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_ColorScale self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_ColorScale_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_ColorScale self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_ColorScale_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_ColorScale self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ColorScale_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_ColorScale self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColorScale_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_ColorScale self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_ColorScale_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_ColorScale self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_ColorScale_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_ColorScale self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ColorScale_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_ColorScale self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_ColorScale_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_ColorScale self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ColorScale_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_ColorScale self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ColorScale_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_ColorScale self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ColorScale_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_ColorScale self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_ColorScale self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_ColorScale_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_ColorScale self)
        RecomputePrimitives(Handle_AIS_ColorScale self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ColorScale_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_ColorScale self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_ColorScale_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_ColorScale self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_ColorScale_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ColorScale_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_ColorScale self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_ColorScale_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_ColorScale self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ColorScale_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_ColorScale self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_ColorScale self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ColorScale_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ColorScale_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_ColorScale self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_ColorScale_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_ColorScale self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_ColorScale_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_ColorScale self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_ColorScale_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_ColorScale_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_ColorScale self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_ColorScale_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_ColorScale_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ColorScale_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_ColorScale self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_ColorScale self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ColorScale_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ColorScale_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_ColorScale self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_ColorScale_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_ColorScale self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ColorScale_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_ColorScale self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ColorScale_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_ColorScale self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_ColorScale_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_ColorScale self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ColorScale_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_ColorScale self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_ColorScale self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ColorScale_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_ColorScale_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_ColorScale self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_ColorScale_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_ColorScale self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ColorScale_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_ColorScale_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_ColorScale self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_ColorScale self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ColorScale_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_ColorScale self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_ColorScale_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_ColorScale self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ColorScale_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_ColorScale self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ColorScale_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_ColorScale self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_ColorScale self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_ColorScale_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_ColorScale self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_ColorScale_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ColorScale_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_ColorScale self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_ColorScale self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_ColorScale_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ColorScale_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ColorScale_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ColorScale_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_ColorScale_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_ColorScale self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ColorScale_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_ColorScale self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ColorScale_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_ColorScale self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ColorScale_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_ColorScale self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_ColorScale self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_ColorScale_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_ColorScale_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_ColorScale self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_ColorScale_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ColorScale_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_ColorScale self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ColorScale_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_ColorScale_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_ColorScale self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_ColorScale self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_ColorScale_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_ColorScale self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColorScale_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ColorScale_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ColorScale_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_ColorScale self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColorScale_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ColorScale_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_ColorScale self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColorScale_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_ColorScale self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_ColorScale_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ColorScale self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ColorScale_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ColorScale self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ColorScale self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ColorScale self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ColorScale self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColorScale_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ColorScale self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ColorScale_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ColorScale self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ColorScale self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ColorScale_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ColorScale self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColorScale_DecrementRefCounter(self, *args)

Handle_AIS_ColorScale_swigregister = _AIS.Handle_AIS_ColorScale_swigregister
Handle_AIS_ColorScale_swigregister(Handle_AIS_ColorScale)

def Handle_AIS_ColorScale_DownCast(thing):
    return _AIS.Handle_AIS_ColorScale_DownCast(thing)
Handle_AIS_ColorScale_DownCast = _AIS.Handle_AIS_ColorScale_DownCast

class AIS_ConnectedInteractive(AIS_InteractiveObject):
    """
    Creates an arbitrary located instance of another Interactive Object,
    which serves as a reference.
    This allows you to use the Connected Interactive
    Object without having to recalculate presentation,
    selection or graphic structure. These are deduced
    from your reference object.
    The relation between the connected interactive object
    and its source is generally one of geometric transformation.
    AIS_ConnectedInteractive class supports selection mode 0 for any InteractiveObject and
    all standard modes if its reference based on AIS_Shape.
    Descendants may redefine ComputeSelection() though.
    Also ConnectedInteractive will handle HLR if its reference based on AIS_Shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ConnectedInteractive
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ConnectedInteractive(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ConnectedInteractive_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ConnectedInteractive_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ConnectedInteractive_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_ConnectedInteractive self, PrsMgr_TypeOfPresentation3d const aTypeOfPresentation3d=PrsMgr_TOP_AllView) -> AIS_ConnectedInteractive

        Disconnects the previous view and sets highlight
        mode to 0. This highlights the wireframe presentation
        aTypeOfPresentation3d.
        Top_AllView deactivates hidden line removal.

        :type aTypeOfPresentation3d: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        this = _AIS.new_AIS_ConnectedInteractive(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Type(self, *args):
        """
        Type(AIS_ConnectedInteractive self) -> AIS_KindOfInteractive

        Returns KOI_Object

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.AIS_ConnectedInteractive_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(AIS_ConnectedInteractive self) -> Standard_Integer

        Returns 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ConnectedInteractive_Signature(self, *args)


    def Connect(self, *args):
        """
        Connect(AIS_ConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj)
        Connect(AIS_ConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, gp_Trsf theLocation)
        Connect(AIS_ConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, Handle_Geom_Transformation theLocation)

        Establishes the connection between the Connected
        Interactive Object, anotherIobj, and its reference.
        Locates instance in aLocation.

        :type theAnotherObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLocation: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.AIS_ConnectedInteractive_Connect(self, *args)


    def HasConnection(self, *args):
        """
        HasConnection(AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if there is a connection established
        between the presentation and its source reference.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ConnectedInteractive_HasConnection(self, *args)


    def ConnectedTo(self, *args):
        """
        Returns the connection with the reference Interactive Object.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        res = _AIS.AIS_ConnectedInteractive_ConnectedTo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Disconnect(self, *args):
        """
        Disconnect(AIS_ConnectedInteractive self)

        Clears the connection with a source reference. The
        presentation will no longer be displayed.
        Warning Must be done before deleting the presentation.


        """
        return _AIS.AIS_ConnectedInteractive_Disconnect(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(AIS_ConnectedInteractive self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ConnectedInteractive_AcceptShapeDecomposition(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(AIS_ConnectedInteractive self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if reference presentation accepts specified display mode.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ConnectedInteractive_AcceptDisplayMode(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_ConnectedInteractive
AIS_ConnectedInteractive_swigregister = _AIS.AIS_ConnectedInteractive_swigregister
AIS_ConnectedInteractive_swigregister(AIS_ConnectedInteractive)

def AIS_ConnectedInteractive_get_type_name(*args):
    """
    AIS_ConnectedInteractive_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ConnectedInteractive_get_type_name(*args)

def AIS_ConnectedInteractive_get_type_descriptor(*args):
    """
    AIS_ConnectedInteractive_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ConnectedInteractive_get_type_descriptor(*args)

class Handle_AIS_DimensionOwner(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_DimensionOwner self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_DimensionOwner_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_DimensionOwner self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_DimensionOwner_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_DimensionOwner self, AIS_DimensionOwner thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_DimensionOwner_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_DimensionOwner self, Handle_AIS_DimensionOwner theHandle) -> Handle_AIS_DimensionOwner
        assign(Handle_AIS_DimensionOwner self, AIS_DimensionOwner thePtr) -> Handle_AIS_DimensionOwner
        assign(Handle_AIS_DimensionOwner self, Handle_AIS_DimensionOwner theHandle) -> Handle_AIS_DimensionOwner

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_DimensionOwner_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_DimensionOwner self) -> AIS_DimensionOwner

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_DimensionOwner_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_DimensionOwner self) -> AIS_DimensionOwner

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_DimensionOwner___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_DimensionOwner self) -> AIS_DimensionOwner

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_DimensionOwner___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_DimensionOwner___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_DimensionOwner___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_DimensionOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_DimensionOwner_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_DimensionOwner

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_DimensionOwner self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_DimensionOwner_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_DimensionOwner_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_DimensionOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SelectionMode(self, *args):
        """
        SelectionMode(Handle_AIS_DimensionOwner self) -> AIS_DimensionSelectionMode

        :rtype: OCC.wrapper.AIS.AIS_DimensionSelectionMode

        """
        return _AIS.Handle_AIS_DimensionOwner_SelectionMode(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(Handle_AIS_DimensionOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode=0)

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _AIS.Handle_AIS_DimensionOwner_HilightWithColor(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_AIS_DimensionOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode=0) -> Standard_Boolean

        Returns true if an object with the selection mode
        aMode is highlighted in the presentation manager aPM.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_IsHilighted(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_AIS_DimensionOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode=0)

        Removes highlighting from the selected part of dimension.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _AIS.Handle_AIS_DimensionOwner_Unhilight(self, *args)


    def HasSelectable(self, *args):
        """
        HasSelectable(Handle_AIS_DimensionOwner self) -> Standard_Boolean

        Returns true if there is a selectable object to serve as an owner.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_HasSelectable(self, *args)


    def Selectable(self, *args):
        """
        Selectable(Handle_AIS_DimensionOwner self) -> Handle_SelectMgr_SelectableObject

        Returns a selectable object detected in the working context.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_DimensionOwner_Selectable(self, *args)


    def SetSelectable(self, *args):
        """
        SetSelectable(Handle_AIS_DimensionOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_DimensionOwner_SetSelectable(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_AIS_DimensionOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0)

        Clears the owners matching the value of the selection
        mode aMode from the presentation manager object aPM.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int

        """
        return _AIS.Handle_AIS_DimensionOwner_Clear(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(Handle_AIS_DimensionOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_HasLocation(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_AIS_DimensionOwner self, TopLoc_Location aLoc)

        :type aLoc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_DimensionOwner_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """ResetLocation(Handle_AIS_DimensionOwner self)"""
        return _AIS.Handle_AIS_DimensionOwner_ResetLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_AIS_DimensionOwner self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_DimensionOwner_Location(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_AIS_DimensionOwner self, Standard_Boolean const theIsSelected)

        Set the state of the owner.
        @param theIsSelected [in] shows if owner is selected.

        :type theIsSelected: bool

        """
        return _AIS.Handle_AIS_DimensionOwner_SetSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_AIS_DimensionOwner self) -> Standard_Boolean

        @return Standard_True if the owner is selected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_IsSelected(self, *args)


    def State(self, *args):
        """
        State(Handle_AIS_DimensionOwner self, Standard_Integer const theStatus)
        State(Handle_AIS_DimensionOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DimensionOwner_State(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_DimensionOwner self) -> Standard_Boolean

        if owner is not auto hilighted, for group contains many such owners
        will be called one method HilightSelected of SelectableObject

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_IsAutoHilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(Handle_AIS_DimensionOwner self) -> Standard_Boolean

        if this method returns TRUE the owner will allways call method
        Hilight for SelectableObject when the owner is detected. By default
        it always return FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_IsForcedHilight(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_DimensionOwner self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_DimensionOwner_SetZLayer(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(Handle_AIS_DimensionOwner self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentationManager theManager, Standard_Integer const theDispMode)

        Implements immediate application of location transformation of parent object to dynamic highlight structure

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theManager: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theDispMode: int

        """
        return _AIS.Handle_AIS_DimensionOwner_UpdateHighlightTrsf(self, *args)


    def IsSameSelectable(self, *args):
        """
        IsSameSelectable(Handle_AIS_DimensionOwner self, Handle_SelectMgr_SelectableObject theOther) -> Standard_Boolean

        Returns true if pointer to selectable object of this owner is equal to the given one

        :type theOther: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_IsSameSelectable(self, *args)


    def ComesFromDecomposition(self, *args):
        """
        ComesFromDecomposition(Handle_AIS_DimensionOwner self) -> Standard_Boolean

        Returns TRUE if this owner points to a part of object and FALSE for entire object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_ComesFromDecomposition(self, *args)


    def SetComesFromDecomposition(self, *args):
        """
        SetComesFromDecomposition(Handle_AIS_DimensionOwner self, Standard_Boolean const theIsFromDecomposition)

        Sets flag indicating this owner points to a part of object (TRUE) or to entire object (FALSE).

        :type theIsFromDecomposition: bool

        """
        return _AIS.Handle_AIS_DimensionOwner_SetComesFromDecomposition(self, *args)


    def Set(self, *args):
        """
        Set(Handle_AIS_DimensionOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_DimensionOwner_Set(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(Handle_AIS_DimensionOwner self, Standard_Integer const thePriority)

        sets the selectable priority of the owner

        :type thePriority: int

        """
        return _AIS.Handle_AIS_DimensionOwner_SetPriority(self, *args)


    def Priority(self, *args):
        """
        Priority(Handle_AIS_DimensionOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DimensionOwner_Priority(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_DimensionOwner self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_DimensionOwner_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_DimensionOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_DimensionOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_DimensionOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_DimensionOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_DimensionOwner_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_DimensionOwner self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_DimensionOwner_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_DimensionOwner self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DimensionOwner_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_DimensionOwner self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_DimensionOwner_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_DimensionOwner self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_DimensionOwner_DecrementRefCounter(self, *args)

Handle_AIS_DimensionOwner_swigregister = _AIS.Handle_AIS_DimensionOwner_swigregister
Handle_AIS_DimensionOwner_swigregister(Handle_AIS_DimensionOwner)

def Handle_AIS_DimensionOwner_DownCast(thing):
    return _AIS.Handle_AIS_DimensionOwner_DownCast(thing)
Handle_AIS_DimensionOwner_DownCast = _AIS.Handle_AIS_DimensionOwner_DownCast

class AIS_AnimationObject(AIS_Animation):
    """Animation defining object transformation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_AnimationObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_AnimationObject(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_AnimationObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_AnimationObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_AnimationObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_AnimationObject self, TCollection_AsciiString theAnimationName, Handle_AIS_InteractiveContext theContext, Handle_AIS_InteractiveObject theObject, gp_Trsf theTrsfStart, gp_Trsf theTrsfEnd) -> AIS_AnimationObject

        Constructor with initialization.
        Note that start/end transformations specify exactly local transformation of the object,
        not the transformation to be applied to existing local transformation.
        @param theAnimationName animation identifier
        @param theContext       interactive context where object have been displayed
        @param theObject        object to apply local transformation
        @param theTrsfStart     local transformation at the start of animation (e.g. theObject->LocalTransformation())
        @param theTrsfEnd       local transformation at the end   of animation

        :type theAnimationName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theContext: OCC.wrapper.AIS.Handle_AIS_InteractiveContext
        :type theObject: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theTrsfStart: OCC.wrapper.gp.gp_Trsf
        :type theTrsfEnd: OCC.wrapper.gp.gp_Trsf

        """
        this = _AIS.new_AIS_AnimationObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _AIS.delete_AIS_AnimationObject
AIS_AnimationObject_swigregister = _AIS.AIS_AnimationObject_swigregister
AIS_AnimationObject_swigregister(AIS_AnimationObject)

def AIS_AnimationObject_get_type_name(*args):
    """
    AIS_AnimationObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_AnimationObject_get_type_name(*args)

def AIS_AnimationObject_get_type_descriptor(*args):
    """
    AIS_AnimationObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_AnimationObject_get_type_descriptor(*args)

class NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< AIS_LocalContext >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< AIS_LocalContext >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< AIS_LocalContext >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< AIS_LocalContext >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _AIS.new_NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, int const & theKey, Handle_AIS_LocalContext theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, int const & theKey, Handle_AIS_LocalContext theItem) -> Handle_AIS_LocalContext

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_AIS_LocalContext

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_AIS_LocalContext

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_AIS_LocalContext

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_swigregister = _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _AIS.NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher_IteratorHelper)


try:
	AIS_DataMapOfILC = NCollection_DataMap_Standard_Integer_Handle_AIS_LocalContext_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_TexturedShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_TexturedShape self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_TexturedShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_TexturedShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_TexturedShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_TexturedShape self, AIS_TexturedShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_TexturedShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_TexturedShape self, Handle_AIS_TexturedShape theHandle) -> Handle_AIS_TexturedShape
        assign(Handle_AIS_TexturedShape self, AIS_TexturedShape thePtr) -> Handle_AIS_TexturedShape
        assign(Handle_AIS_TexturedShape self, Handle_AIS_TexturedShape theHandle) -> Handle_AIS_TexturedShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_TexturedShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_TexturedShape self) -> AIS_TexturedShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_TexturedShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_TexturedShape self) -> AIS_TexturedShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_TexturedShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_TexturedShape self) -> AIS_TexturedShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_TexturedShape___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_TexturedShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_TexturedShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_TexturedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_TexturedShape_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_TexturedShape

    def SetTextureFileName(self, *args):
        """
        SetTextureFileName(Handle_AIS_TexturedShape self, TCollection_AsciiString theTextureFileName)

        Sets the texture source. <theTextureFileName> can specify path to texture image or one of the standard predefined textures.
        The accepted file types are those used in Image_AlienPixMap with extensions such as rgb, png, jpg and more.
        To specify the standard predefined texture, the <theTextureFileName> should contain integer - the Graphic3d_NameOfTexture2D enumeration index.
        Setting texture source using this method resets the source pixmap (if was set previously).

        :type theTextureFileName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureFileName(self, *args)


    def SetTexturePixMap(self, *args):
        """
        SetTexturePixMap(Handle_AIS_TexturedShape self, Handle_Image_PixMap theTexturePixMap)

        Sets the texture source. <theTexturePixMap> specifies image data.
        Please note that the data should be in Bottom-Up order, the flag of Image_PixMap::IsTopDown() will be ignored by graphic driver.
        Setting texture source using this method resets the source by filename (if was set previously).

        :type theTexturePixMap: OCC.wrapper.Image.Handle_Image_PixMap

        """
        return _AIS.Handle_AIS_TexturedShape_SetTexturePixMap(self, *args)


    def TextureMapState(self, *args):
        """
        TextureMapState(Handle_AIS_TexturedShape self) -> Standard_Boolean

        @return flag to control texture mapping (for presentation mode 3)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_TextureMapState(self, *args)


    def SetTextureMapOn(self, *args):
        """
        SetTextureMapOn(Handle_AIS_TexturedShape self)

        Enables texture mapping


        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureMapOn(self, *args)


    def SetTextureMapOff(self, *args):
        """
        SetTextureMapOff(Handle_AIS_TexturedShape self)

        Disables texture mapping


        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureMapOff(self, *args)


    def TextureFile(self, *args):
        """
        TextureFile(Handle_AIS_TexturedShape self) -> Standard_CString

        @return path to the texture file

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _AIS.Handle_AIS_TexturedShape_TextureFile(self, *args)


    def TexturePixMap(self, *args):
        """
        @return the source pixmap for texture map

        :rtype: OCC.wrapper.Image.Handle_Image_PixMap

        """
        res = _AIS.Handle_AIS_TexturedShape_TexturePixMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateAttributes(self, *args):
        """
        UpdateAttributes(Handle_AIS_TexturedShape self)

        Use this method to display the textured shape without recomputing the whole presentation.
        Use this method when ONLY the texture content has been changed.
        If other parameters (ie: scale factors, texture origin, texture repeat...) have changed, the whole presentation has to be recomputed:
        @code
        if (myShape->DisplayMode() == 3)
        {
        myAISContext->RecomputePrsOnly (myShape);
        }
        else
        {
        myAISContext->SetDisplayMode (myShape, 3, Standard_False);
        myAISContext->Display        (myShape, Standard_True);
        }
        @endcode


        """
        return _AIS.Handle_AIS_TexturedShape_UpdateAttributes(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_TexturedShape self, Quantity_Color theColor)

        Sets the color.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_TexturedShape_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_TexturedShape self)

        Removes settings for the color.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetColor(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_TexturedShape self, Graphic3d_MaterialAspect theAspect)

        Sets the material aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_TexturedShape_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_TexturedShape self)

        Removes settings for material aspect.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetMaterial(self, *args)


    def EnableTextureModulate(self, *args):
        """
        EnableTextureModulate(Handle_AIS_TexturedShape self)

        Enables texture modulation


        """
        return _AIS.Handle_AIS_TexturedShape_EnableTextureModulate(self, *args)


    def DisableTextureModulate(self, *args):
        """
        DisableTextureModulate(Handle_AIS_TexturedShape self)

        Disables texture modulation


        """
        return _AIS.Handle_AIS_TexturedShape_DisableTextureModulate(self, *args)


    def TextureRepeat(self, *args):
        """
        TextureRepeat(Handle_AIS_TexturedShape self) -> Standard_Boolean

        @return texture repeat flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_TextureRepeat(self, *args)


    def URepeat(self, *args):
        """
        URepeat(Handle_AIS_TexturedShape self) -> Standard_Real

        @return texture repeat U value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_URepeat(self, *args)


    def VRepeat(self, *args):
        """
        VRepeat(Handle_AIS_TexturedShape self) -> Standard_Real

        @return texture repeat V value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_VRepeat(self, *args)


    def SetTextureRepeat(self, *args):
        """
        SetTextureRepeat(Handle_AIS_TexturedShape self, Standard_Boolean const theToRepeat, Standard_Real const theURepeat=1.0, Standard_Real const theVRepeat=1.0)

        Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1).
        Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax).
        If RepeatYN is set to false, texture coordinates are clamped in the range (0,1)x(0,1) of the face.

        :type theToRepeat: bool
        :type theURepeat: float
        :type theVRepeat: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureRepeat(self, *args)


    def TextureOrigin(self, *args):
        """
        TextureOrigin(Handle_AIS_TexturedShape self) -> Standard_Boolean

        @return true if texture UV origin has been modified

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_TextureOrigin(self, *args)


    def TextureUOrigin(self, *args):
        """
        TextureUOrigin(Handle_AIS_TexturedShape self) -> Standard_Real

        @return texture origin U position (0.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_TextureUOrigin(self, *args)


    def TextureVOrigin(self, *args):
        """
        TextureVOrigin(Handle_AIS_TexturedShape self) -> Standard_Real

        @return texture origin V position (0.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_TextureVOrigin(self, *args)


    def SetTextureOrigin(self, *args):
        """
        SetTextureOrigin(Handle_AIS_TexturedShape self, Standard_Boolean const theToSetTextureOrigin, Standard_Real const theUOrigin=0.0, Standard_Real const theVOrigin=0.0)

        Use this method to change the origin of the texture. The texel (0,0) will be mapped to the surface (UOrigin,VOrigin)

        :type theToSetTextureOrigin: bool
        :type theUOrigin: float
        :type theVOrigin: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureOrigin(self, *args)


    def TextureScale(self, *args):
        """
        TextureScale(Handle_AIS_TexturedShape self) -> Standard_Boolean

        @return true if scale factor should be applied to texture mapping

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_TextureScale(self, *args)


    def TextureScaleU(self, *args):
        """
        TextureScaleU(Handle_AIS_TexturedShape self) -> Standard_Real

        @return scale factor for U coordinate (1.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_TextureScaleU(self, *args)


    def TextureScaleV(self, *args):
        """
        TextureScaleV(Handle_AIS_TexturedShape self) -> Standard_Real

        @return scale factor for V coordinate (1.0 by default)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_TextureScaleV(self, *args)


    def SetTextureScale(self, *args):
        """
        SetTextureScale(Handle_AIS_TexturedShape self, Standard_Boolean const theToSetTextureScale, Standard_Real const theScaleU=1.0, Standard_Real const theScaleV=1.0)

        Use this method to scale the texture (percent of the face).
        You can specify a scale factor for both U and V.
        Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat,
        the texture will appear twice on the face in each direction.

        :type theToSetTextureScale: bool
        :type theScaleU: float
        :type theScaleV: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureScale(self, *args)


    def ShowTriangles(self, *args):
        """
        ShowTriangles(Handle_AIS_TexturedShape self) -> Standard_Boolean
        ShowTriangles(Handle_AIS_TexturedShape self, Standard_Boolean const theToShowTriangles)

        Use this method to show the triangulation of the shape (for debugging etc.).

        :type theToShowTriangles: bool

        """
        return _AIS.Handle_AIS_TexturedShape_ShowTriangles(self, *args)


    def TextureModulate(self, *args):
        """
        TextureModulate(Handle_AIS_TexturedShape self) -> Standard_Boolean

        @return true if texture color modulation is turned on

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_TextureModulate(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_TexturedShape self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_TexturedShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TexturedShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TexturedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Signature(self, *args):
        """
        Signature(Handle_AIS_TexturedShape self) -> Standard_Integer

        Returns index 0. This value refers to SHAPE from TopAbs_ShapeEnum

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_TexturedShape self) -> AIS_KindOfInteractive

        Returns Object as the type of Interactive Object.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_TexturedShape_Type(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the Interactive Object accepts shape decomposition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_AcceptShapeDecomposition(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_TexturedShape self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if specified display mode is supported.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_AcceptDisplayMode(self, *args)


    def Shape(self, *args):
        """
        Returns this shape object.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_TexturedShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape(self, *args):
        """
        SetShape(Handle_AIS_TexturedShape self, TopoDS_Shape theShape)

        Constructs an instance of the shape object theShape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_TexturedShape_SetShape(self, *args)


    def Set(self, *args):
        """
        Set(Handle_AIS_TexturedShape self, TopoDS_Shape theShape)

        Alias for ::SetShape().

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_TexturedShape_Set(self, *args)


    def SetOwnDeviationCoefficient(self, *args):
        """
        SetOwnDeviationCoefficient(Handle_AIS_TexturedShape self) -> Standard_Boolean
        SetOwnDeviationCoefficient(Handle_AIS_TexturedShape self, Standard_Real const aCoefficient)

        Sets a local value for deviation coefficient for this specific shape.

        :type aCoefficient: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetOwnDeviationCoefficient(self, *args)


    def SetOwnHLRDeviationCoefficient(self, *args):
        """
        SetOwnHLRDeviationCoefficient(Handle_AIS_TexturedShape self) -> Standard_Boolean
        SetOwnHLRDeviationCoefficient(Handle_AIS_TexturedShape self, Standard_Real const aCoefficient)

        sets myOwnHLRDeviationCoefficient field in Prs3d_Drawer &
        recomputes presentation

        :type aCoefficient: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetOwnHLRDeviationCoefficient(self, *args)


    def SetOwnDeviationAngle(self, *args):
        """
        SetOwnDeviationAngle(Handle_AIS_TexturedShape self) -> Standard_Boolean
        SetOwnDeviationAngle(Handle_AIS_TexturedShape self, Standard_Real const anAngle)

        sets myOwnDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetOwnDeviationAngle(self, *args)


    def SetOwnHLRDeviationAngle(self, *args):
        """
        SetOwnHLRDeviationAngle(Handle_AIS_TexturedShape self) -> Standard_Boolean
        SetOwnHLRDeviationAngle(Handle_AIS_TexturedShape self, Standard_Real const anAngle)

        sets myOwnHLRDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetOwnHLRDeviationAngle(self, *args)


    def SetAngleAndDeviation(self, *args):
        """
        SetAngleAndDeviation(Handle_AIS_TexturedShape self, Standard_Real const anAngle)

        this compute a new angle and Deviation from the value anAngle
        and set the values stored in myDrawer with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetAngleAndDeviation(self, *args)


    def UserAngle(self, *args):
        """
        UserAngle(Handle_AIS_TexturedShape self) -> Standard_Real

        gives back the angle initial value put by the User.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_UserAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args):
        """
        SetHLRAngleAndDeviation(Handle_AIS_TexturedShape self, Standard_Real const anAngle)

        this compute a new Angle and Deviation from the value anAngle for HLR
        and set the values stored in myDrawer for with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetHLRAngleAndDeviation(self, *args)


    def OwnDeviationCoefficient(self, *args):
        """
        OwnDeviationCoefficient(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true and the values of the deviation
        coefficient aCoefficient and the previous deviation
        coefficient aPreviousCoefficient. If these values are
        not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_OwnDeviationCoefficient(self, *args)


    def OwnHLRDeviationCoefficient(self, *args):
        """
        OwnHLRDeviationCoefficient(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns   true and the values of the HLR deviation
        coefficient aCoefficient and the previous HLR
        deviation coefficient aPreviousCoefficient. If these
        values are not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_OwnHLRDeviationCoefficient(self, *args)


    def OwnDeviationAngle(self, *args):
        """
        OwnDeviationAngle(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true and the values of the deviation angle
        anAngle and the previous deviation angle aPreviousAngle.
        If these values are not already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_OwnDeviationAngle(self, *args)


    def OwnHLRDeviationAngle(self, *args):
        """
        OwnHLRDeviationAngle(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true and the values   of the HLR deviation
        angle anAngle and of the previous HLR deviation
        angle aPreviousAngle. If these values are not
        already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_OwnHLRDeviationAngle(self, *args)


    def SetTypeOfHLR(self, *args):
        """
        SetTypeOfHLR(Handle_AIS_TexturedShape self, Prs3d_TypeOfHLR const theTypeOfHLR)

        Sets the type of HLR algorithm used by the shape

        :type theTypeOfHLR: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_TexturedShape_SetTypeOfHLR(self, *args)


    def TypeOfHLR(self, *args):
        """
        TypeOfHLR(Handle_AIS_TexturedShape self) -> Prs3d_TypeOfHLR

        Gets the type of HLR algorithm

        :rtype: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_TexturedShape_TypeOfHLR(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_TexturedShape self, Standard_Real const aValue)

        Sets the value aValue for line width in the reconstructed compound shape.
        Changes line aspects for lines-only presentation modes like Wireframe and Bounding Box.
        Doesn't change face boundary line aspect.

        :type aValue: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_AIS_TexturedShape self)

        Removes the setting for line width in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetWidth(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_TexturedShape self, Standard_Real const aValue=0.6)

        Sets the value aValue for transparency in the reconstructed compound shape.

        :type aValue: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_TexturedShape self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetTransparency(self, *args)


    def BoundingBox(self, *args):
        """
        Constructs a bounding box with which to reconstruct
        compound topological shapes for presentation.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _AIS.Handle_AIS_TexturedShape_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Color(self, *args):
        """
        Color(Handle_AIS_TexturedShape self, Quantity_Color aColor)

        Returns the Color attributes of the shape accordingly to
        the current facing model;

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_TexturedShape_Color(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_TexturedShape self) -> Graphic3d_NameOfMaterial

        Returns the NameOfMaterial attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_TexturedShape_Material(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_TexturedShape self) -> Standard_Real

        Returns the transparency attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_Transparency(self, *args)


    def SelectionType(self, *args):
        """
        SelectionType(Handle_AIS_TexturedShape self, Standard_Integer const theSelMode) -> TopAbs_ShapeEnum

        Return shape type for specified selection mode.

        :type theSelMode: int
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.Handle_AIS_TexturedShape_SelectionType(self, *args)


    def SelectionMode(self, *args):
        """
        SelectionMode(Handle_AIS_TexturedShape self, TopAbs_ShapeEnum const theShapeType) -> Standard_Integer

        Return selection mode for specified shape type.

        :type theShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_SelectionMode(self, *args)


    def TextureRepeatUV(self, *args):
        """
        Return texture repeat UV values; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_TexturedShape_TextureRepeatUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureRepeatUV(self, *args):
        """
        SetTextureRepeatUV(Handle_AIS_TexturedShape self, gp_Pnt2d theRepeatUV)

        Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1).
        Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax).

        :type theRepeatUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureRepeatUV(self, *args)


    def TextureOriginUV(self, *args):
        """
        Return texture origin UV position; (0, 0) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_TexturedShape_TextureOriginUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureOriginUV(self, *args):
        """
        SetTextureOriginUV(Handle_AIS_TexturedShape self, gp_Pnt2d theOriginUV)

        Use this method to change the origin of the texture.
        The texel (0,0) will be mapped to the surface (myUVOrigin.X(), myUVOrigin.Y()).

        :type theOriginUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureOriginUV(self, *args)


    def TextureScaleUV(self, *args):
        """
        Return scale factor for UV coordinates; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_TexturedShape_TextureScaleUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureScaleUV(self, *args):
        """
        SetTextureScaleUV(Handle_AIS_TexturedShape self, gp_Pnt2d theScaleUV)

        Use this method to scale the texture (percent of the face).
        You can specify a scale factor for both U and V.
        Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat,
        the texture will appear twice on the face in each direction.

        :type theScaleUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_TexturedShape_SetTextureScaleUV(self, *args)


    def computeHlrPresentation(self, *args):
        """
        computeHlrPresentation(Handle_AIS_TexturedShape self, Handle_Prs3d_Projector theProjector, Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

        Compute HLR presentation for specified shape.

        :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TexturedShape_computeHlrPresentation(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_TexturedShape self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_TexturedShape_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_TexturedShape self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_TexturedShape_CurrentFacingModel(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_TexturedShape self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_TexturedShape self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_TexturedShape_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_TexturedShape self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_TexturedShape_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_TexturedShape self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_TexturedShape_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_TexturedShape self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_TexturedShape_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_TexturedShape_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_TexturedShape self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_TexturedShape_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_TexturedShape self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_TexturedShape_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_TexturedShape self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_TexturedShape_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_TexturedShape self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_TexturedShape self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_TexturedShape self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_TexturedShape self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TexturedShape_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_TexturedShape self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasColor(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_TexturedShape self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_TexturedShape_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasMaterial(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_IsTransparent(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_TexturedShape self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_TexturedShape self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TexturedShape_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_TexturedShape self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_TexturedShape_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_TexturedShape self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_TexturedShape_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_TexturedShape self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_TexturedShape_PolygonOffsets(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_TexturedShape self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_TexturedShape_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_TexturedShape self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_TexturedShape_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_TexturedShape self)
        RecomputePrimitives(Handle_AIS_TexturedShape self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TexturedShape_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_TexturedShape self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_TexturedShape_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_TexturedShape self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_TexturedShape_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_TexturedShape_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_TexturedShape self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_TexturedShape_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_TexturedShape self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_TexturedShape_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_TexturedShape self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_TexturedShape_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_TexturedShape_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_TexturedShape self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_TexturedShape_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_TexturedShape self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_TexturedShape_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_TexturedShape self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_TexturedShape_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_TexturedShape self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_TexturedShape_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_TexturedShape self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_TexturedShape_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_TexturedShape self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_TexturedShape_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_TexturedShape self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_TexturedShape_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_TexturedShape self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_TexturedShape self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_TexturedShape_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_TexturedShape self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TexturedShape_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_TexturedShape self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_TexturedShape_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_TexturedShape self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_TexturedShape_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_TexturedShape self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_TexturedShape_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_TexturedShape self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_TexturedShape_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_TexturedShape self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_TexturedShape_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_TexturedShape self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_TexturedShape_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_TexturedShape self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_TexturedShape self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_TexturedShape_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_TexturedShape_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_TexturedShape self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_TexturedShape_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_TexturedShape self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_TexturedShape_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_TexturedShape_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_TexturedShape self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_TexturedShape self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TexturedShape_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_TexturedShape self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_TexturedShape_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_TexturedShape self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_TexturedShape_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_TexturedShape self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_TexturedShape_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_TexturedShape self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_TexturedShape self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_TexturedShape_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_TexturedShape self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_TexturedShape_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_TexturedShape_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_TexturedShape self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_TexturedShape self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_TexturedShape_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_TexturedShape_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_TexturedShape_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_TexturedShape_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_TexturedShape_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_TexturedShape self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_TexturedShape_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_TexturedShape self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_TexturedShape_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_TexturedShape self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_TexturedShape_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_TexturedShape self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_TexturedShape self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_TexturedShape_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_TexturedShape_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_TexturedShape self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_TexturedShape_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_TexturedShape self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_TexturedShape_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_TexturedShape self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_TexturedShape_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_TexturedShape_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_TexturedShape self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_TexturedShape self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_TexturedShape_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_TexturedShape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TexturedShape_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TexturedShape_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TexturedShape_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_TexturedShape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TexturedShape_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_TexturedShape_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_TexturedShape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_TexturedShape_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_TexturedShape self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_TexturedShape_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_TexturedShape self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_TexturedShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_TexturedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_TexturedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_TexturedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_TexturedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TexturedShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_TexturedShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_TexturedShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_TexturedShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_TexturedShape self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_TexturedShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_TexturedShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TexturedShape_DecrementRefCounter(self, *args)

Handle_AIS_TexturedShape_swigregister = _AIS.Handle_AIS_TexturedShape_swigregister
Handle_AIS_TexturedShape_swigregister(Handle_AIS_TexturedShape)

def Handle_AIS_TexturedShape_DownCast(thing):
    return _AIS.Handle_AIS_TexturedShape_DownCast(thing)
Handle_AIS_TexturedShape_DownCast = _AIS.Handle_AIS_TexturedShape_DownCast

class Handle_AIS_Chamf2dDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Chamf2dDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Chamf2dDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Chamf2dDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Chamf2dDimension self, AIS_Chamf2dDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Chamf2dDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Chamf2dDimension self, Handle_AIS_Chamf2dDimension theHandle) -> Handle_AIS_Chamf2dDimension
        assign(Handle_AIS_Chamf2dDimension self, AIS_Chamf2dDimension thePtr) -> Handle_AIS_Chamf2dDimension
        assign(Handle_AIS_Chamf2dDimension self, Handle_AIS_Chamf2dDimension theHandle) -> Handle_AIS_Chamf2dDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Chamf2dDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Chamf2dDimension self) -> AIS_Chamf2dDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Chamf2dDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Chamf2dDimension self) -> AIS_Chamf2dDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Chamf2dDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Chamf2dDimension self) -> AIS_Chamf2dDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Chamf2dDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Chamf2dDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Chamf2dDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Chamf2dDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Chamf2dDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Chamf2dDimension

    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_Chamf2dDimension self) -> AIS_KindOfDimension

        Indicates that we are concerned with a 2d length.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_Chamf2dDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the 2d chamfer dimension is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_Chamf2dDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Chamf2dDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Chamf2dDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Chamf2dDimension self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Chamf2dDimension self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Chamf2dDimension self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Type(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_Chamf2dDimension self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_Chamf2dDimension self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_Chamf2dDimension self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_Chamf2dDimension self)"""
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_Chamf2dDimension self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_Chamf2dDimension self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_Chamf2dDimension self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_Chamf2dDimension self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_Chamf2dDimension self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_Chamf2dDimension self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf2dDimension_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_Chamf2dDimension self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_Chamf2dDimension self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_Chamf2dDimension self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_Chamf2dDimension self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Chamf2dDimension self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_Chamf2dDimension self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Chamf2dDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Chamf2dDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Chamf2dDimension_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Chamf2dDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Chamf2dDimension self)"""
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Chamf2dDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Chamf2dDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Chamf2dDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Chamf2dDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Chamf2dDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Chamf2dDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Chamf2dDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Chamf2dDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Chamf2dDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Chamf2dDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Chamf2dDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Chamf2dDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Chamf2dDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Chamf2dDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Chamf2dDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Chamf2dDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Chamf2dDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Chamf2dDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Chamf2dDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Chamf2dDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Chamf2dDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Chamf2dDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Chamf2dDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Chamf2dDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Chamf2dDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Chamf2dDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Chamf2dDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Chamf2dDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Chamf2dDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Chamf2dDimension self)
        RecomputePrimitives(Handle_AIS_Chamf2dDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf2dDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Chamf2dDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Chamf2dDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Chamf2dDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Chamf2dDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Chamf2dDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Chamf2dDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Chamf2dDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Chamf2dDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Chamf2dDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Chamf2dDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Chamf2dDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Chamf2dDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Chamf2dDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Chamf2dDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Chamf2dDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Chamf2dDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Chamf2dDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Chamf2dDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Chamf2dDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Chamf2dDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Chamf2dDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Chamf2dDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf2dDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Chamf2dDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Chamf2dDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Chamf2dDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Chamf2dDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Chamf2dDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Chamf2dDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Chamf2dDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Chamf2dDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Chamf2dDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Chamf2dDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Chamf2dDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Chamf2dDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Chamf2dDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Chamf2dDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Chamf2dDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Chamf2dDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Chamf2dDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Chamf2dDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Chamf2dDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Chamf2dDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Chamf2dDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Chamf2dDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Chamf2dDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Chamf2dDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Chamf2dDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Chamf2dDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Chamf2dDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Chamf2dDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Chamf2dDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Chamf2dDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Chamf2dDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Chamf2dDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Chamf2dDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Chamf2dDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Chamf2dDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Chamf2dDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Chamf2dDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Chamf2dDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Chamf2dDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Chamf2dDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Chamf2dDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Chamf2dDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Chamf2dDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Chamf2dDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Chamf2dDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Chamf2dDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Chamf2dDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Chamf2dDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Chamf2dDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Chamf2dDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Chamf2dDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Chamf2dDimension_DecrementRefCounter(self, *args)

Handle_AIS_Chamf2dDimension_swigregister = _AIS.Handle_AIS_Chamf2dDimension_swigregister
Handle_AIS_Chamf2dDimension_swigregister(Handle_AIS_Chamf2dDimension)

def Handle_AIS_Chamf2dDimension_DownCast(thing):
    return _AIS.Handle_AIS_Chamf2dDimension_DownCast(thing)
Handle_AIS_Chamf2dDimension_DownCast = _AIS.Handle_AIS_Chamf2dDimension_DownCast

class AIS_ManipulatorOwner(SelectMgr.SelectMgr_EntityOwner):
    """Entity owner for selection management of AIS_Manipulator object."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_ManipulatorOwner
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_ManipulatorOwner(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_ManipulatorOwner_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_ManipulatorOwner_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_ManipulatorOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_ManipulatorOwner self, Handle_SelectMgr_SelectableObject theSelObject, Standard_Integer const theIndex, AIS_ManipulatorMode const theMode, Standard_Integer const thePriority=0) -> AIS_ManipulatorOwner

        :type theSelObject: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :type theIndex: int
        :type theMode: OCC.wrapper.AIS.AIS_ManipulatorMode
        :type thePriority: int

        """
        this = _AIS.new_AIS_ManipulatorOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HilightWithColor(self, *args):
        """
        HilightWithColor(AIS_ManipulatorOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode)

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _AIS.AIS_ManipulatorOwner_HilightWithColor(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(AIS_ManipulatorOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode) -> Standard_Boolean

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_ManipulatorOwner_IsHilighted(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(AIS_ManipulatorOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode)

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _AIS.AIS_ManipulatorOwner_Unhilight(self, *args)


    def Mode(self, *args):
        """
        Mode(AIS_ManipulatorOwner self) -> AIS_ManipulatorMode

        :rtype: OCC.wrapper.AIS.AIS_ManipulatorMode

        """
        return _AIS.AIS_ManipulatorOwner_Mode(self, *args)


    def Index(self, *args):
        """
        Index(AIS_ManipulatorOwner self) -> Standard_Integer

        @return index of manipulator axis.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_ManipulatorOwner_Index(self, *args)

    __swig_destroy__ = _AIS.delete_AIS_ManipulatorOwner
AIS_ManipulatorOwner_swigregister = _AIS.AIS_ManipulatorOwner_swigregister
AIS_ManipulatorOwner_swigregister(AIS_ManipulatorOwner)

def AIS_ManipulatorOwner_get_type_name(*args):
    """
    AIS_ManipulatorOwner_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_ManipulatorOwner_get_type_name(*args)

def AIS_ManipulatorOwner_get_type_descriptor(*args):
    """
    AIS_ManipulatorOwner_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_ManipulatorOwner_get_type_descriptor(*args)

class Handle_AIS_ManipulatorOwner(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ManipulatorOwner self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ManipulatorOwner_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ManipulatorOwner self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ManipulatorOwner self, AIS_ManipulatorOwner thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ManipulatorOwner_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ManipulatorOwner self, Handle_AIS_ManipulatorOwner theHandle) -> Handle_AIS_ManipulatorOwner
        assign(Handle_AIS_ManipulatorOwner self, AIS_ManipulatorOwner thePtr) -> Handle_AIS_ManipulatorOwner
        assign(Handle_AIS_ManipulatorOwner self, Handle_AIS_ManipulatorOwner theHandle) -> Handle_AIS_ManipulatorOwner

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ManipulatorOwner_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ManipulatorOwner self) -> AIS_ManipulatorOwner

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ManipulatorOwner_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ManipulatorOwner self) -> AIS_ManipulatorOwner

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ManipulatorOwner___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ManipulatorOwner self) -> AIS_ManipulatorOwner

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ManipulatorOwner___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ManipulatorOwner___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ManipulatorOwner___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ManipulatorOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ManipulatorOwner_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ManipulatorOwner

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ManipulatorOwner self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ManipulatorOwner_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ManipulatorOwner_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ManipulatorOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightWithColor(self, *args):
        """
        HilightWithColor(Handle_AIS_ManipulatorOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode)

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _AIS.Handle_AIS_ManipulatorOwner_HilightWithColor(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_AIS_ManipulatorOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode) -> Standard_Boolean

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsHilighted(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_AIS_ManipulatorOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode)

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Unhilight(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_AIS_ManipulatorOwner self) -> AIS_ManipulatorMode

        :rtype: OCC.wrapper.AIS.AIS_ManipulatorMode

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Mode(self, *args)


    def Index(self, *args):
        """
        Index(Handle_AIS_ManipulatorOwner self) -> Standard_Integer

        @return index of manipulator axis.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Index(self, *args)


    def HasSelectable(self, *args):
        """
        HasSelectable(Handle_AIS_ManipulatorOwner self) -> Standard_Boolean

        Returns true if there is a selectable object to serve as an owner.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_HasSelectable(self, *args)


    def Selectable(self, *args):
        """
        Selectable(Handle_AIS_ManipulatorOwner self) -> Handle_SelectMgr_SelectableObject

        Returns a selectable object detected in the working context.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Selectable(self, *args)


    def SetSelectable(self, *args):
        """
        SetSelectable(Handle_AIS_ManipulatorOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_ManipulatorOwner_SetSelectable(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_AIS_ManipulatorOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0)

        Clears the owners matching the value of the selection
        mode aMode from the presentation manager object aPM.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Clear(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(Handle_AIS_ManipulatorOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_HasLocation(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_AIS_ManipulatorOwner self, TopLoc_Location aLoc)

        :type aLoc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_ManipulatorOwner_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """ResetLocation(Handle_AIS_ManipulatorOwner self)"""
        return _AIS.Handle_AIS_ManipulatorOwner_ResetLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_AIS_ManipulatorOwner self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Location(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_AIS_ManipulatorOwner self, Standard_Boolean const theIsSelected)

        Set the state of the owner.
        @param theIsSelected [in] shows if owner is selected.

        :type theIsSelected: bool

        """
        return _AIS.Handle_AIS_ManipulatorOwner_SetSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_AIS_ManipulatorOwner self) -> Standard_Boolean

        @return Standard_True if the owner is selected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsSelected(self, *args)


    def State(self, *args):
        """
        State(Handle_AIS_ManipulatorOwner self, Standard_Integer const theStatus)
        State(Handle_AIS_ManipulatorOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ManipulatorOwner_State(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_ManipulatorOwner self) -> Standard_Boolean

        if owner is not auto hilighted, for group contains many such owners
        will be called one method HilightSelected of SelectableObject

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsAutoHilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(Handle_AIS_ManipulatorOwner self) -> Standard_Boolean

        if this method returns TRUE the owner will allways call method
        Hilight for SelectableObject when the owner is detected. By default
        it always return FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsForcedHilight(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_ManipulatorOwner self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ManipulatorOwner_SetZLayer(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(Handle_AIS_ManipulatorOwner self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentationManager theManager, Standard_Integer const theDispMode)

        Implements immediate application of location transformation of parent object to dynamic highlight structure

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theManager: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theDispMode: int

        """
        return _AIS.Handle_AIS_ManipulatorOwner_UpdateHighlightTrsf(self, *args)


    def IsSameSelectable(self, *args):
        """
        IsSameSelectable(Handle_AIS_ManipulatorOwner self, Handle_SelectMgr_SelectableObject theOther) -> Standard_Boolean

        Returns true if pointer to selectable object of this owner is equal to the given one

        :type theOther: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsSameSelectable(self, *args)


    def ComesFromDecomposition(self, *args):
        """
        ComesFromDecomposition(Handle_AIS_ManipulatorOwner self) -> Standard_Boolean

        Returns TRUE if this owner points to a part of object and FALSE for entire object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_ComesFromDecomposition(self, *args)


    def SetComesFromDecomposition(self, *args):
        """
        SetComesFromDecomposition(Handle_AIS_ManipulatorOwner self, Standard_Boolean const theIsFromDecomposition)

        Sets flag indicating this owner points to a part of object (TRUE) or to entire object (FALSE).

        :type theIsFromDecomposition: bool

        """
        return _AIS.Handle_AIS_ManipulatorOwner_SetComesFromDecomposition(self, *args)


    def Set(self, *args):
        """
        Set(Handle_AIS_ManipulatorOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Set(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(Handle_AIS_ManipulatorOwner self, Standard_Integer const thePriority)

        sets the selectable priority of the owner

        :type thePriority: int

        """
        return _AIS.Handle_AIS_ManipulatorOwner_SetPriority(self, *args)


    def Priority(self, *args):
        """
        Priority(Handle_AIS_ManipulatorOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ManipulatorOwner_Priority(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ManipulatorOwner self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ManipulatorOwner_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ManipulatorOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ManipulatorOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ManipulatorOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ManipulatorOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ManipulatorOwner_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ManipulatorOwner self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ManipulatorOwner_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ManipulatorOwner self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ManipulatorOwner_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ManipulatorOwner self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ManipulatorOwner_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ManipulatorOwner self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ManipulatorOwner_DecrementRefCounter(self, *args)

Handle_AIS_ManipulatorOwner_swigregister = _AIS.Handle_AIS_ManipulatorOwner_swigregister
Handle_AIS_ManipulatorOwner_swigregister(Handle_AIS_ManipulatorOwner)

def Handle_AIS_ManipulatorOwner_DownCast(thing):
    return _AIS.Handle_AIS_ManipulatorOwner_DownCast(thing)
Handle_AIS_ManipulatorOwner_DownCast = _AIS.Handle_AIS_ManipulatorOwner_DownCast

class AIS_FixRelation(AIS_Relation):
    """
    Constructs and manages a constraint by a fixed
    relation between two or more interactive datums. This
    constraint is represented by a wire from a shape -
    point, vertex, or edge - in the first datum and a
    corresponding shape in the second.
    Warning: This relation is not bound with any kind of parametric
    constraint : it represents the "status" of an parametric
    object.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_FixRelation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_FixRelation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_FixRelation self, TopoDS_Shape aShape, Handle_Geom_Plane aPlane, TopoDS_Wire aWire) -> AIS_FixRelation
        __init__(AIS_FixRelation self, TopoDS_Shape aShape, Handle_Geom_Plane aPlane, TopoDS_Wire aWire, gp_Pnt aPosition, Standard_Real const anArrowSize=0.01) -> AIS_FixRelation
        __init__(AIS_FixRelation self, TopoDS_Shape aShape, Handle_Geom_Plane aPlane) -> AIS_FixRelation
        __init__(AIS_FixRelation self, TopoDS_Shape aShape, Handle_Geom_Plane aPlane, gp_Pnt aPosition, Standard_Real const anArrowSize=0.01) -> AIS_FixRelation

        initializes the edge aShape, the
        plane aPlane, the position aPosition and the arrow
        size anArrowSize.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aPlane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type aPosition: OCC.wrapper.gp.gp_Pnt
        :type anArrowSize: float

        """
        this = _AIS.new_AIS_FixRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Wire(self, *args):
        """
        Wire(AIS_FixRelation self) -> TopoDS_Wire

        Returns the wire which connects vertices in a fixed relation.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _AIS.AIS_FixRelation_Wire(self, *args)


    def SetWire(self, *args):
        """
        SetWire(AIS_FixRelation self, TopoDS_Wire aWire)

        Constructs the wire aWire. This connects vertices
        which are in a fixed relation.

        :type aWire: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _AIS.AIS_FixRelation_SetWire(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(AIS_FixRelation self) -> Standard_Boolean

        Returns true if the Interactive Objects in the relation
        are movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_FixRelation_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(AIS_FixRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.AIS_FixRelation_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_FixRelation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_FixRelation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_FixRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_FixRelation
AIS_FixRelation_swigregister = _AIS.AIS_FixRelation_swigregister
AIS_FixRelation_swigregister(AIS_FixRelation)

def AIS_FixRelation_get_type_name(*args):
    """
    AIS_FixRelation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_FixRelation_get_type_name(*args)

def AIS_FixRelation_get_type_descriptor(*args):
    """
    AIS_FixRelation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_FixRelation_get_type_descriptor(*args)

class Handle_AIS_TypeFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_TypeFilter self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_TypeFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_TypeFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_TypeFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_TypeFilter self, AIS_TypeFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_TypeFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_TypeFilter self, Handle_AIS_TypeFilter theHandle) -> Handle_AIS_TypeFilter
        assign(Handle_AIS_TypeFilter self, AIS_TypeFilter thePtr) -> Handle_AIS_TypeFilter
        assign(Handle_AIS_TypeFilter self, Handle_AIS_TypeFilter theHandle) -> Handle_AIS_TypeFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_TypeFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_TypeFilter self) -> AIS_TypeFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_TypeFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_TypeFilter self) -> AIS_TypeFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_TypeFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_TypeFilter self) -> AIS_TypeFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_TypeFilter___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_TypeFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_TypeFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_TypeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_TypeFilter_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_TypeFilter

    def IsOk(self, *args):
        """
        IsOk(Handle_AIS_TypeFilter self, Handle_SelectMgr_EntityOwner anobj) -> Standard_Boolean

        Returns False if the transient is not an Interactive
        Object, or if the type of the Interactive Object is not
        the same as that stored in the filter.

        :type anobj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TypeFilter_IsOk(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_TypeFilter self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_TypeFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TypeFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TypeFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ActsOn(self, *args):
        """
        ActsOn(Handle_AIS_TypeFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        Returns true in an AIS local context, if this filter
        operates on a type of subshape defined in a filter
        class inheriting this framework.
        This function completes IsOk in an AIS local context.

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TypeFilter_ActsOn(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_TypeFilter self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_TypeFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_TypeFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_TypeFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TypeFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_TypeFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_TypeFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TypeFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_TypeFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_TypeFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_TypeFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TypeFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_TypeFilter self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_TypeFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_TypeFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TypeFilter_DecrementRefCounter(self, *args)

Handle_AIS_TypeFilter_swigregister = _AIS.Handle_AIS_TypeFilter_swigregister
Handle_AIS_TypeFilter_swigregister(Handle_AIS_TypeFilter)

def Handle_AIS_TypeFilter_DownCast(thing):
    return _AIS.Handle_AIS_TypeFilter_DownCast(thing)
Handle_AIS_TypeFilter_DownCast = _AIS.Handle_AIS_TypeFilter_DownCast

class Handle_AIS_ColoredShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ColoredShape self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ColoredShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ColoredShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ColoredShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ColoredShape self, AIS_ColoredShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ColoredShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ColoredShape self, Handle_AIS_ColoredShape theHandle) -> Handle_AIS_ColoredShape
        assign(Handle_AIS_ColoredShape self, AIS_ColoredShape thePtr) -> Handle_AIS_ColoredShape
        assign(Handle_AIS_ColoredShape self, Handle_AIS_ColoredShape theHandle) -> Handle_AIS_ColoredShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ColoredShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ColoredShape self) -> AIS_ColoredShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ColoredShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ColoredShape self) -> AIS_ColoredShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ColoredShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ColoredShape self) -> AIS_ColoredShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ColoredShape___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ColoredShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ColoredShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ColoredShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ColoredShape_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ColoredShape

    def CustomAspects(self, *args):
        """
        CustomAspects(Handle_AIS_ColoredShape self, TopoDS_Shape theShape) -> Handle_AIS_ColoredDrawer

        Customize properties of specified sub-shape.
        The shape will be stored in the map but ignored, if it is not sub-shape of main Shape!
        This method can be used to mark sub-shapes with customizable properties.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.AIS.Handle_AIS_ColoredDrawer

        """
        return _AIS.Handle_AIS_ColoredShape_CustomAspects(self, *args)


    def ClearCustomAspects(self, *args):
        """
        ClearCustomAspects(Handle_AIS_ColoredShape self)

        Reset the map of custom sub-shape aspects.


        """
        return _AIS.Handle_AIS_ColoredShape_ClearCustomAspects(self, *args)


    def UnsetCustomAspects(self, *args):
        """
        UnsetCustomAspects(Handle_AIS_ColoredShape self, TopoDS_Shape theShape, Standard_Boolean const theToUnregister)

        Reset custom properties of specified sub-shape.
        @param theToUnregister unregister or not sub-shape from the map

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theToUnregister: bool

        """
        return _AIS.Handle_AIS_ColoredShape_UnsetCustomAspects(self, *args)


    def SetCustomColor(self, *args):
        """
        SetCustomColor(Handle_AIS_ColoredShape self, TopoDS_Shape theShape, Quantity_Color theColor)

        Customize color of specified sub-shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColoredShape_SetCustomColor(self, *args)


    def SetCustomWidth(self, *args):
        """
        SetCustomWidth(Handle_AIS_ColoredShape self, TopoDS_Shape theShape, Standard_Real const theLineWidth)

        Customize line width of specified sub-shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theLineWidth: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetCustomWidth(self, *args)


    def CustomAspectsMap(self, *args):
        """
        Return the map of custom aspects.

        :rtype: OCC.wrapper.AIS.AIS_DataMapOfShapeDrawer

        """
        res = _AIS.Handle_AIS_ColoredShape_CustomAspectsMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCustomAspectsMap(self, *args):
        """
        ChangeCustomAspectsMap(Handle_AIS_ColoredShape self) -> NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher

        Return the map of custom aspects.

        :rtype: OCC.wrapper.AIS.AIS_DataMapOfShapeDrawer

        """
        return _AIS.Handle_AIS_ColoredShape_ChangeCustomAspectsMap(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_ColoredShape self, Quantity_Color theColor)

        Setup color of entire shape.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColoredShape_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_ColoredShape self, Standard_Real const theLineWidth)

        Setup line width of entire shape.

        :type theLineWidth: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetWidth(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_ColoredShape self, Standard_Real const theValue)

        Sets transparency value.

        :type theValue: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_ColoredShape self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetTransparency(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_ColoredShape self, Graphic3d_MaterialAspect theAspect)

        Sets the material aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_ColoredShape_SetMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ColoredShape self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ColoredShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ColoredShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ColoredShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Signature(self, *args):
        """
        Signature(Handle_AIS_ColoredShape self) -> Standard_Integer

        Returns index 0. This value refers to SHAPE from TopAbs_ShapeEnum

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_ColoredShape self) -> AIS_KindOfInteractive

        Returns Object as the type of Interactive Object.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_ColoredShape_Type(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the Interactive Object accepts shape decomposition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_AcceptShapeDecomposition(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_ColoredShape self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if specified display mode is supported.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_AcceptDisplayMode(self, *args)


    def Shape(self, *args):
        """
        Returns this shape object.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_ColoredShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape(self, *args):
        """
        SetShape(Handle_AIS_ColoredShape self, TopoDS_Shape theShape)

        Constructs an instance of the shape object theShape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_ColoredShape_SetShape(self, *args)


    def Set(self, *args):
        """
        Set(Handle_AIS_ColoredShape self, TopoDS_Shape theShape)

        Alias for ::SetShape().

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_ColoredShape_Set(self, *args)


    def SetOwnDeviationCoefficient(self, *args):
        """
        SetOwnDeviationCoefficient(Handle_AIS_ColoredShape self) -> Standard_Boolean
        SetOwnDeviationCoefficient(Handle_AIS_ColoredShape self, Standard_Real const aCoefficient)

        Sets a local value for deviation coefficient for this specific shape.

        :type aCoefficient: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetOwnDeviationCoefficient(self, *args)


    def SetOwnHLRDeviationCoefficient(self, *args):
        """
        SetOwnHLRDeviationCoefficient(Handle_AIS_ColoredShape self) -> Standard_Boolean
        SetOwnHLRDeviationCoefficient(Handle_AIS_ColoredShape self, Standard_Real const aCoefficient)

        sets myOwnHLRDeviationCoefficient field in Prs3d_Drawer &
        recomputes presentation

        :type aCoefficient: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetOwnHLRDeviationCoefficient(self, *args)


    def SetOwnDeviationAngle(self, *args):
        """
        SetOwnDeviationAngle(Handle_AIS_ColoredShape self) -> Standard_Boolean
        SetOwnDeviationAngle(Handle_AIS_ColoredShape self, Standard_Real const anAngle)

        sets myOwnDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetOwnDeviationAngle(self, *args)


    def SetOwnHLRDeviationAngle(self, *args):
        """
        SetOwnHLRDeviationAngle(Handle_AIS_ColoredShape self) -> Standard_Boolean
        SetOwnHLRDeviationAngle(Handle_AIS_ColoredShape self, Standard_Real const anAngle)

        sets myOwnHLRDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetOwnHLRDeviationAngle(self, *args)


    def SetAngleAndDeviation(self, *args):
        """
        SetAngleAndDeviation(Handle_AIS_ColoredShape self, Standard_Real const anAngle)

        this compute a new angle and Deviation from the value anAngle
        and set the values stored in myDrawer with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetAngleAndDeviation(self, *args)


    def UserAngle(self, *args):
        """
        UserAngle(Handle_AIS_ColoredShape self) -> Standard_Real

        gives back the angle initial value put by the User.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredShape_UserAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args):
        """
        SetHLRAngleAndDeviation(Handle_AIS_ColoredShape self, Standard_Real const anAngle)

        this compute a new Angle and Deviation from the value anAngle for HLR
        and set the values stored in myDrawer for with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetHLRAngleAndDeviation(self, *args)


    def OwnDeviationCoefficient(self, *args):
        """
        OwnDeviationCoefficient(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true and the values of the deviation
        coefficient aCoefficient and the previous deviation
        coefficient aPreviousCoefficient. If these values are
        not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_OwnDeviationCoefficient(self, *args)


    def OwnHLRDeviationCoefficient(self, *args):
        """
        OwnHLRDeviationCoefficient(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns   true and the values of the HLR deviation
        coefficient aCoefficient and the previous HLR
        deviation coefficient aPreviousCoefficient. If these
        values are not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_OwnHLRDeviationCoefficient(self, *args)


    def OwnDeviationAngle(self, *args):
        """
        OwnDeviationAngle(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true and the values of the deviation angle
        anAngle and the previous deviation angle aPreviousAngle.
        If these values are not already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_OwnDeviationAngle(self, *args)


    def OwnHLRDeviationAngle(self, *args):
        """
        OwnHLRDeviationAngle(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true and the values   of the HLR deviation
        angle anAngle and of the previous HLR deviation
        angle aPreviousAngle. If these values are not
        already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_OwnHLRDeviationAngle(self, *args)


    def SetTypeOfHLR(self, *args):
        """
        SetTypeOfHLR(Handle_AIS_ColoredShape self, Prs3d_TypeOfHLR const theTypeOfHLR)

        Sets the type of HLR algorithm used by the shape

        :type theTypeOfHLR: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_ColoredShape_SetTypeOfHLR(self, *args)


    def TypeOfHLR(self, *args):
        """
        TypeOfHLR(Handle_AIS_ColoredShape self) -> Prs3d_TypeOfHLR

        Gets the type of HLR algorithm

        :rtype: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_ColoredShape_TypeOfHLR(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_ColoredShape self)

        Removes settings for color in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_AIS_ColoredShape self)

        Removes the setting for line width in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetWidth(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_ColoredShape self)

        Removes settings for material in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetMaterial(self, *args)


    def BoundingBox(self, *args):
        """
        Constructs a bounding box with which to reconstruct
        compound topological shapes for presentation.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _AIS.Handle_AIS_ColoredShape_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Color(self, *args):
        """
        Color(Handle_AIS_ColoredShape self, Quantity_Color aColor)

        Returns the Color attributes of the shape accordingly to
        the current facing model;

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColoredShape_Color(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_ColoredShape self) -> Graphic3d_NameOfMaterial

        Returns the NameOfMaterial attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_ColoredShape_Material(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_ColoredShape self) -> Standard_Real

        Returns the transparency attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredShape_Transparency(self, *args)


    def SelectionType(self, *args):
        """
        SelectionType(Handle_AIS_ColoredShape self, Standard_Integer const theSelMode) -> TopAbs_ShapeEnum

        Return shape type for specified selection mode.

        :type theSelMode: int
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.Handle_AIS_ColoredShape_SelectionType(self, *args)


    def SelectionMode(self, *args):
        """
        SelectionMode(Handle_AIS_ColoredShape self, TopAbs_ShapeEnum const theShapeType) -> Standard_Integer

        Return selection mode for specified shape type.

        :type theShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_SelectionMode(self, *args)


    def TextureRepeatUV(self, *args):
        """
        Return texture repeat UV values; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_ColoredShape_TextureRepeatUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureRepeatUV(self, *args):
        """
        SetTextureRepeatUV(Handle_AIS_ColoredShape self, gp_Pnt2d theRepeatUV)

        Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1).
        Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax).

        :type theRepeatUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_ColoredShape_SetTextureRepeatUV(self, *args)


    def TextureOriginUV(self, *args):
        """
        Return texture origin UV position; (0, 0) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_ColoredShape_TextureOriginUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureOriginUV(self, *args):
        """
        SetTextureOriginUV(Handle_AIS_ColoredShape self, gp_Pnt2d theOriginUV)

        Use this method to change the origin of the texture.
        The texel (0,0) will be mapped to the surface (myUVOrigin.X(), myUVOrigin.Y()).

        :type theOriginUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_ColoredShape_SetTextureOriginUV(self, *args)


    def TextureScaleUV(self, *args):
        """
        Return scale factor for UV coordinates; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_ColoredShape_TextureScaleUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureScaleUV(self, *args):
        """
        SetTextureScaleUV(Handle_AIS_ColoredShape self, gp_Pnt2d theScaleUV)

        Use this method to scale the texture (percent of the face).
        You can specify a scale factor for both U and V.
        Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat,
        the texture will appear twice on the face in each direction.

        :type theScaleUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_ColoredShape_SetTextureScaleUV(self, *args)


    def computeHlrPresentation(self, *args):
        """
        computeHlrPresentation(Handle_AIS_ColoredShape self, Handle_Prs3d_Projector theProjector, Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

        Compute HLR presentation for specified shape.

        :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColoredShape_computeHlrPresentation(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_ColoredShape self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ColoredShape_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_ColoredShape self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ColoredShape_CurrentFacingModel(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_ColoredShape self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_ColoredShape self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_ColoredShape_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_ColoredShape self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_ColoredShape_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_ColoredShape self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ColoredShape_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_ColoredShape self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ColoredShape_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_ColoredShape_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_ColoredShape self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_ColoredShape_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_ColoredShape self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_ColoredShape_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_ColoredShape self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_ColoredShape_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_ColoredShape self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_ColoredShape self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_ColoredShape self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_ColoredShape self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ColoredShape_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_ColoredShape self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasColor(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_ColoredShape self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredShape_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasMaterial(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_IsTransparent(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_ColoredShape self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_ColoredShape self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ColoredShape_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_ColoredShape self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_ColoredShape_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_ColoredShape self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ColoredShape_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_ColoredShape self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ColoredShape_PolygonOffsets(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_ColoredShape self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredShape_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_ColoredShape self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_ColoredShape_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_ColoredShape self)
        RecomputePrimitives(Handle_AIS_ColoredShape self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ColoredShape_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_ColoredShape self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_ColoredShape_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_ColoredShape self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_ColoredShape_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ColoredShape_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_ColoredShape self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_ColoredShape_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_ColoredShape self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ColoredShape_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_ColoredShape self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ColoredShape_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ColoredShape_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_ColoredShape self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_ColoredShape_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_ColoredShape self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_ColoredShape_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_ColoredShape self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_ColoredShape_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_ColoredShape self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_ColoredShape_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_ColoredShape self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_ColoredShape_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_ColoredShape self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_ColoredShape_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_ColoredShape self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ColoredShape_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_ColoredShape self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_ColoredShape self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_ColoredShape_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_ColoredShape self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ColoredShape_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_ColoredShape self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ColoredShape_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_ColoredShape self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_ColoredShape_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_ColoredShape self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ColoredShape_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_ColoredShape self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ColoredShape_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_ColoredShape self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_ColoredShape_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_ColoredShape self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ColoredShape_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_ColoredShape self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_ColoredShape self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ColoredShape_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_ColoredShape_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_ColoredShape self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_ColoredShape_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_ColoredShape self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ColoredShape_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_ColoredShape_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_ColoredShape self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_ColoredShape self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ColoredShape_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_ColoredShape self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_ColoredShape_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_ColoredShape self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ColoredShape_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_ColoredShape self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ColoredShape_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_ColoredShape self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_ColoredShape self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_ColoredShape_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_ColoredShape self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_ColoredShape_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ColoredShape_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_ColoredShape self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_ColoredShape self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_ColoredShape_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ColoredShape_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ColoredShape_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ColoredShape_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_ColoredShape_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_ColoredShape self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ColoredShape_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_ColoredShape self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ColoredShape_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_ColoredShape self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ColoredShape_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_ColoredShape self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_ColoredShape self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_ColoredShape_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_ColoredShape_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_ColoredShape self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_ColoredShape_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_ColoredShape self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ColoredShape_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_ColoredShape self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ColoredShape_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_ColoredShape_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_ColoredShape self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_ColoredShape self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_ColoredShape_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_ColoredShape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColoredShape_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ColoredShape_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ColoredShape_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_ColoredShape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColoredShape_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ColoredShape_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_ColoredShape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColoredShape_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_ColoredShape self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_ColoredShape_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ColoredShape self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ColoredShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ColoredShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ColoredShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ColoredShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ColoredShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ColoredShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ColoredShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ColoredShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ColoredShape self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ColoredShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ColoredShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredShape_DecrementRefCounter(self, *args)

Handle_AIS_ColoredShape_swigregister = _AIS.Handle_AIS_ColoredShape_swigregister
Handle_AIS_ColoredShape_swigregister(Handle_AIS_ColoredShape)

def Handle_AIS_ColoredShape_DownCast(thing):
    return _AIS.Handle_AIS_ColoredShape_DownCast(thing)
Handle_AIS_ColoredShape_DownCast = _AIS.Handle_AIS_ColoredShape_DownCast

class Handle_AIS_GlobalStatus(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_GlobalStatus self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_GlobalStatus_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_GlobalStatus self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_GlobalStatus_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_GlobalStatus self, AIS_GlobalStatus thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_GlobalStatus_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_GlobalStatus self, Handle_AIS_GlobalStatus theHandle) -> Handle_AIS_GlobalStatus
        assign(Handle_AIS_GlobalStatus self, AIS_GlobalStatus thePtr) -> Handle_AIS_GlobalStatus
        assign(Handle_AIS_GlobalStatus self, Handle_AIS_GlobalStatus theHandle) -> Handle_AIS_GlobalStatus

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_GlobalStatus_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_GlobalStatus self) -> AIS_GlobalStatus

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_GlobalStatus_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_GlobalStatus self) -> AIS_GlobalStatus

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_GlobalStatus___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_GlobalStatus self) -> AIS_GlobalStatus

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_GlobalStatus___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_GlobalStatus___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_GlobalStatus___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_GlobalStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_GlobalStatus_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_GlobalStatus

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_GlobalStatus self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_GlobalStatus_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_GlobalStatus_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_GlobalStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetGraphicStatus(self, *args):
        """
        SetGraphicStatus(Handle_AIS_GlobalStatus self, AIS_DisplayStatus const theStatus)

        :type theStatus: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.Handle_AIS_GlobalStatus_SetGraphicStatus(self, *args)


    def AddSelectionMode(self, *args):
        """
        AddSelectionMode(Handle_AIS_GlobalStatus self, Standard_Integer const theMode)

        :type theMode: int

        """
        return _AIS.Handle_AIS_GlobalStatus_AddSelectionMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_GlobalStatus self, Standard_Integer const theMode)

        Sets display mode.

        :type theMode: int

        """
        return _AIS.Handle_AIS_GlobalStatus_SetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_GlobalStatus self) -> Standard_Integer

        Returns the display mode.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_GlobalStatus_DisplayMode(self, *args)


    def SetLayerIndex(self, *args):
        """
        SetLayerIndex(Handle_AIS_GlobalStatus self, Standard_Integer const theIndex)

        :type theIndex: int

        """
        return _AIS.Handle_AIS_GlobalStatus_SetLayerIndex(self, *args)


    def SetHilightStatus(self, *args):
        """
        SetHilightStatus(Handle_AIS_GlobalStatus self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_GlobalStatus_SetHilightStatus(self, *args)


    def SetHilightStyle(self, *args):
        """
        SetHilightStyle(Handle_AIS_GlobalStatus self, Handle_Prs3d_Drawer theStyle)

        Changes applied highlight style for a particular object

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_GlobalStatus_SetHilightStyle(self, *args)


    def HilightStyle(self, *args):
        """
        Returns applied highlight style for a particular object

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_GlobalStatus_HilightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsSubIntensityOn(self, *args):
        """
        IsSubIntensityOn(Handle_AIS_GlobalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_GlobalStatus_IsSubIntensityOn(self, *args)


    def SubIntensityOn(self, *args):
        """SubIntensityOn(Handle_AIS_GlobalStatus self)"""
        return _AIS.Handle_AIS_GlobalStatus_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """SubIntensityOff(Handle_AIS_GlobalStatus self)"""
        return _AIS.Handle_AIS_GlobalStatus_SubIntensityOff(self, *args)


    def RemoveSelectionMode(self, *args):
        """
        RemoveSelectionMode(Handle_AIS_GlobalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.Handle_AIS_GlobalStatus_RemoveSelectionMode(self, *args)


    def ClearSelectionModes(self, *args):
        """ClearSelectionModes(Handle_AIS_GlobalStatus self)"""
        return _AIS.Handle_AIS_GlobalStatus_ClearSelectionModes(self, *args)


    def GraphicStatus(self, *args):
        """
        GraphicStatus(Handle_AIS_GlobalStatus self) -> AIS_DisplayStatus

        :rtype: OCC.wrapper.AIS.AIS_DisplayStatus

        """
        return _AIS.Handle_AIS_GlobalStatus_GraphicStatus(self, *args)


    def SelectionModes(self, *args):
        """
        keeps the active selection modes of the object
        in the main viewer.

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.Handle_AIS_GlobalStatus_SelectionModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_AIS_GlobalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_GlobalStatus_IsHilighted(self, *args)


    def IsSModeIn(self, *args):
        """
        IsSModeIn(Handle_AIS_GlobalStatus self, Standard_Integer const aMode) -> Standard_Boolean

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_GlobalStatus_IsSModeIn(self, *args)


    def GetLayerIndex(self, *args):
        """
        GetLayerIndex(Handle_AIS_GlobalStatus self) -> Standard_Integer

        Returns layer index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_GlobalStatus_GetLayerIndex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_GlobalStatus self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_GlobalStatus_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_GlobalStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_GlobalStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_GlobalStatus_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_GlobalStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_GlobalStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_GlobalStatus_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_GlobalStatus self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_GlobalStatus_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_GlobalStatus self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_GlobalStatus_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_GlobalStatus self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_GlobalStatus_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_GlobalStatus self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_GlobalStatus_DecrementRefCounter(self, *args)

Handle_AIS_GlobalStatus_swigregister = _AIS.Handle_AIS_GlobalStatus_swigregister
Handle_AIS_GlobalStatus_swigregister(Handle_AIS_GlobalStatus)

def Handle_AIS_GlobalStatus_DownCast(thing):
    return _AIS.Handle_AIS_GlobalStatus_DownCast(thing)
Handle_AIS_GlobalStatus_DownCast = _AIS.Handle_AIS_GlobalStatus_DownCast

class Handle_AIS_FixRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_FixRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_FixRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_FixRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_FixRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_FixRelation self, AIS_FixRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_FixRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_FixRelation self, Handle_AIS_FixRelation theHandle) -> Handle_AIS_FixRelation
        assign(Handle_AIS_FixRelation self, AIS_FixRelation thePtr) -> Handle_AIS_FixRelation
        assign(Handle_AIS_FixRelation self, Handle_AIS_FixRelation theHandle) -> Handle_AIS_FixRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_FixRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_FixRelation self) -> AIS_FixRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_FixRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_FixRelation self) -> AIS_FixRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_FixRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_FixRelation self) -> AIS_FixRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_FixRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_FixRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_FixRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_FixRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_FixRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_FixRelation

    def Wire(self, *args):
        """
        Wire(Handle_AIS_FixRelation self) -> TopoDS_Wire

        Returns the wire which connects vertices in a fixed relation.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _AIS.Handle_AIS_FixRelation_Wire(self, *args)


    def SetWire(self, *args):
        """
        SetWire(Handle_AIS_FixRelation self, TopoDS_Wire aWire)

        Constructs the wire aWire. This connects vertices
        which are in a fixed relation.

        :type aWire: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _AIS.Handle_AIS_FixRelation_SetWire(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the Interactive Objects in the relation
        are movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_IsMovable(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_AIS_FixRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_FixRelation_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_FixRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_FixRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_FixRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_FixRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_FixRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_FixRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_FixRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_FixRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_FixRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_FixRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_FixRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_FixRelation_KindOfDimension(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_FixRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_FixRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_FixRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_FixRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_FixRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_FixRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_FixRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_FixRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_FixRelation self)"""
        return _AIS.Handle_AIS_FixRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_FixRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_FixRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_FixRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_FixRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_FixRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_FixRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_FixRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_FixRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_FixRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_FixRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_FixRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_FixRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_FixRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_FixRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_FixRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_FixRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_FixRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_FixRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_FixRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_FixRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_FixRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_FixRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_FixRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_FixRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_FixRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_FixRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_FixRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_FixRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_FixRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_FixRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_FixRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_FixRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_FixRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_FixRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_FixRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_FixRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_FixRelation self)"""
        return _AIS.Handle_AIS_FixRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_FixRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_FixRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_FixRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_FixRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_FixRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_FixRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_FixRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_FixRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_FixRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_FixRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_FixRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_FixRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_FixRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_FixRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_FixRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_FixRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_FixRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_FixRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_FixRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_FixRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_FixRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_FixRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_FixRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_FixRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_FixRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_FixRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_FixRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_FixRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_FixRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_FixRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_FixRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_FixRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_FixRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_FixRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_FixRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_FixRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_FixRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_FixRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_FixRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_FixRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_FixRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_FixRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_FixRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_FixRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_FixRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_FixRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_FixRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_FixRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_FixRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_FixRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_FixRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_FixRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_FixRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_FixRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_FixRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_FixRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_FixRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_FixRelation self)
        RecomputePrimitives(Handle_AIS_FixRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_FixRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_FixRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_FixRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_FixRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_FixRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_FixRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_FixRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_FixRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_FixRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_FixRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_FixRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_FixRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_FixRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_FixRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_FixRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_FixRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_FixRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_FixRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_FixRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_FixRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_FixRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_FixRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_FixRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_FixRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_FixRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_FixRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_FixRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_FixRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_FixRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_FixRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_FixRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_FixRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_FixRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_FixRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_FixRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_FixRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_FixRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_FixRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_FixRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_FixRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_FixRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_FixRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_FixRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_FixRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_FixRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_FixRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_FixRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_FixRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_FixRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_FixRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_FixRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_FixRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_FixRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_FixRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_FixRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_FixRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_FixRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_FixRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_FixRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_FixRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_FixRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_FixRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_FixRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_FixRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_FixRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_FixRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_FixRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_FixRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_FixRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_FixRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_FixRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_FixRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_FixRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_FixRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_FixRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_FixRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_FixRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_FixRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_FixRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_FixRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_FixRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_FixRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_FixRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_FixRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_FixRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_FixRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_FixRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_FixRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_FixRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_FixRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_FixRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_FixRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_FixRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_FixRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_FixRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_FixRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_FixRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_FixRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_FixRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_FixRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_FixRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_FixRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_FixRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_FixRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_FixRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_FixRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_FixRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_FixRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_FixRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_FixRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_FixRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_FixRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_FixRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_FixRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_FixRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_FixRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_FixRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_FixRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_FixRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_FixRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_FixRelation_DecrementRefCounter(self, *args)

Handle_AIS_FixRelation_swigregister = _AIS.Handle_AIS_FixRelation_swigregister
Handle_AIS_FixRelation_swigregister(Handle_AIS_FixRelation)

def Handle_AIS_FixRelation_DownCast(thing):
    return _AIS.Handle_AIS_FixRelation_DownCast(thing)
Handle_AIS_FixRelation_DownCast = _AIS.Handle_AIS_FixRelation_DownCast

class NCollection_Sequence_Graphic3d_Vec2i(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Graphic3d_Vec2i self) -> NCollection_Sequence< Graphic3d_Vec2i >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Graphic3d_Vec2i self) -> NCollection_Sequence< Graphic3d_Vec2i >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Graphic3d_Vec2i self) -> NCollection_Sequence< Graphic3d_Vec2i >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Graphic3d_Vec2i self) -> NCollection_Sequence< Graphic3d_Vec2i >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _AIS.new_NCollection_Sequence_Graphic3d_Vec2i(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Graphic3d_Vec2i self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Graphic3d_Vec2i self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Graphic3d_Vec2i self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Graphic3d_Vec2i self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Graphic3d_Vec2i self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Graphic3d_Vec2i self)

        Reverse sequence


        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Graphic3d_Vec2i self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Sequence_Graphic3d_Vec2i theOther) -> NCollection_Sequence_Graphic3d_Vec2i

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Sequence_Graphic3d_Vec2i theOther) -> NCollection_Sequence_Graphic3d_Vec2i

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Sequence< Graphic3d_Vec2i >::Iterator & thePosition)
        Remove(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Vec2_Standard_Integer theItem)
        Append(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Sequence_Graphic3d_Vec2i theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Vec2_Standard_Integer theItem)
        Prepend(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Sequence_Graphic3d_Vec2i theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex, NCollection_Vec2_Standard_Integer theItem)
        InsertBefore(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex, NCollection_Sequence_Graphic3d_Vec2i theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Graphic3d_Vec2i self, NCollection_Sequence< Graphic3d_Vec2i >::Iterator & thePosition, NCollection_Vec2_Standard_Integer theItem)
        InsertAfter(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex, NCollection_Sequence_Graphic3d_Vec2i theSeq)
        InsertAfter(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex, NCollection_Vec2_Standard_Integer theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex, NCollection_Sequence_Graphic3d_Vec2i theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Graphic3d_Vec2i_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Graphic3d_Vec2i self) -> NCollection_Vec2_Standard_Integer

        First item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Graphic3d_Vec2i_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Graphic3d_Vec2i self) -> NCollection_Vec2_Standard_Integer

        Last item access

        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Graphic3d_Vec2i_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex) -> NCollection_Vec2_Standard_Integer

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_Sequence_Graphic3d_Vec2i___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Graphic3d_Vec2i self, Standard_Integer const theIndex, NCollection_Vec2_Standard_Integer theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_SetValue(self, *args)


    def __iter__(self):
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Graphic3d_Vec2i
NCollection_Sequence_Graphic3d_Vec2i_swigregister = _AIS.NCollection_Sequence_Graphic3d_Vec2i_swigregister
NCollection_Sequence_Graphic3d_Vec2i_swigregister(NCollection_Sequence_Graphic3d_Vec2i)

def NCollection_Sequence_Graphic3d_Vec2i_delNode(*args):
    """
    NCollection_Sequence_Graphic3d_Vec2i_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _AIS.NCollection_Sequence_Graphic3d_Vec2i_delNode(*args)

class NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper___next__(self)
NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper_swigregister = _AIS.NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper_swigregister
NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper_swigregister(NCollection_Sequence_Graphic3d_Vec2i_IteratorHelper)

class Handle_AIS_AttributeFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_AttributeFilter self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_AttributeFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_AttributeFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_AttributeFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_AttributeFilter self, AIS_AttributeFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_AttributeFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_AttributeFilter self, Handle_AIS_AttributeFilter theHandle) -> Handle_AIS_AttributeFilter
        assign(Handle_AIS_AttributeFilter self, AIS_AttributeFilter thePtr) -> Handle_AIS_AttributeFilter
        assign(Handle_AIS_AttributeFilter self, Handle_AIS_AttributeFilter theHandle) -> Handle_AIS_AttributeFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_AttributeFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_AttributeFilter self) -> AIS_AttributeFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_AttributeFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_AttributeFilter self) -> AIS_AttributeFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_AttributeFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_AttributeFilter self) -> AIS_AttributeFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_AttributeFilter___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_AttributeFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_AttributeFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_AttributeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_AttributeFilter_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_AttributeFilter

    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_AttributeFilter self) -> Standard_Boolean

        Indicates that the Interactive Object has the color
        setting specified by the argument aCol at construction time.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AttributeFilter_HasColor(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_AttributeFilter self) -> Standard_Boolean

        Indicates that the Interactive Object has the width
        setting specified by the argument aWidth at
        construction time.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AttributeFilter_HasWidth(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_AttributeFilter self, Quantity_NameOfColor const aCol)

        Sets the color aCol.
        This must be chosen from the list of colors in Quantity_NameOfColor.

        :type aCol: OCC.wrapper.Quantity.Quantity_NameOfColor

        """
        return _AIS.Handle_AIS_AttributeFilter_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_AttributeFilter self, Standard_Real const aWidth)

        Sets the line width aWidth.

        :type aWidth: float

        """
        return _AIS.Handle_AIS_AttributeFilter_SetWidth(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_AttributeFilter self)

        Removes the setting for color from the filter.


        """
        return _AIS.Handle_AIS_AttributeFilter_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_AIS_AttributeFilter self)

        Removes the setting for width from the filter.


        """
        return _AIS.Handle_AIS_AttributeFilter_UnsetWidth(self, *args)


    def IsOk(self, *args):
        """
        IsOk(Handle_AIS_AttributeFilter self, Handle_SelectMgr_EntityOwner anObj) -> Standard_Boolean

        Indicates that the selected Interactive Object passes
        the filter. The owner, anObj, can be either direct or
        user. A direct owner is the corresponding
        construction element, whereas a user is the
        compound shape of which the entity forms a part.
        If the Interactive Object returns Standard_True
        when detected by the Local Context selector through
        the mouse, the object is kept; if not, it is rejected.

        :type anObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AttributeFilter_IsOk(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_AttributeFilter self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_AttributeFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AttributeFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AttributeFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ActsOn(self, *args):
        """
        ActsOn(Handle_AIS_AttributeFilter self, TopAbs_ShapeEnum const aStandardMode) -> Standard_Boolean

        Returns true in an AIS local context, if this filter
        operates on a type of subshape defined in a filter
        class inheriting this framework.
        This function completes IsOk in an AIS local context.

        :type aStandardMode: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AttributeFilter_ActsOn(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_AttributeFilter self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_AttributeFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_AttributeFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_AttributeFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AttributeFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_AttributeFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_AttributeFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AttributeFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_AttributeFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_AttributeFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_AttributeFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AttributeFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_AttributeFilter self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_AttributeFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_AttributeFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AttributeFilter_DecrementRefCounter(self, *args)

Handle_AIS_AttributeFilter_swigregister = _AIS.Handle_AIS_AttributeFilter_swigregister
Handle_AIS_AttributeFilter_swigregister(Handle_AIS_AttributeFilter)

def Handle_AIS_AttributeFilter_DownCast(thing):
    return _AIS.Handle_AIS_AttributeFilter_DownCast(thing)
Handle_AIS_AttributeFilter_DownCast = _AIS.Handle_AIS_AttributeFilter_DownCast

class Handle_AIS_AnimationObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_AnimationObject self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_AnimationObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_AnimationObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_AnimationObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_AnimationObject self, AIS_AnimationObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_AnimationObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_AnimationObject self, Handle_AIS_AnimationObject theHandle) -> Handle_AIS_AnimationObject
        assign(Handle_AIS_AnimationObject self, AIS_AnimationObject thePtr) -> Handle_AIS_AnimationObject
        assign(Handle_AIS_AnimationObject self, Handle_AIS_AnimationObject theHandle) -> Handle_AIS_AnimationObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_AnimationObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_AnimationObject self) -> AIS_AnimationObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_AnimationObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_AnimationObject self) -> AIS_AnimationObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_AnimationObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_AnimationObject self) -> AIS_AnimationObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_AnimationObject___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_AnimationObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_AnimationObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_AnimationObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_AnimationObject_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_AnimationObject

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_AnimationObject self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_AnimationObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AnimationObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_AnimationObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Animation name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_AnimationObject_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartPts(self, *args):
        """
        StartPts(Handle_AIS_AnimationObject self) -> Standard_Real

        @return start time of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationObject_StartPts(self, *args)


    def SetStartPts(self, *args):
        """
        SetStartPts(Handle_AIS_AnimationObject self, Standard_Real const thePtsStart)

        Sets time limits for animation in the animation timeline

        :type thePtsStart: float

        """
        return _AIS.Handle_AIS_AnimationObject_SetStartPts(self, *args)


    def Duration(self, *args):
        """
        Duration(Handle_AIS_AnimationObject self) -> Standard_Real

        @return duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationObject_Duration(self, *args)


    def UpdateTotalDuration(self, *args):
        """
        UpdateTotalDuration(Handle_AIS_AnimationObject self)

        Update total duration considering all animations on timeline.


        """
        return _AIS.Handle_AIS_AnimationObject_UpdateTotalDuration(self, *args)


    def HasOwnDuration(self, *args):
        """
        HasOwnDuration(Handle_AIS_AnimationObject self) -> Standard_Boolean

        Return true if duration is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationObject_HasOwnDuration(self, *args)


    def OwnDuration(self, *args):
        """
        OwnDuration(Handle_AIS_AnimationObject self) -> Standard_Real

        @return own duration of the animation in the timeline

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationObject_OwnDuration(self, *args)


    def SetOwnDuration(self, *args):
        """
        SetOwnDuration(Handle_AIS_AnimationObject self, Standard_Real const theDuration)

        Defines duration of the animation.

        :type theDuration: float

        """
        return _AIS.Handle_AIS_AnimationObject_SetOwnDuration(self, *args)


    def Add(self, *args):
        """
        Add(Handle_AIS_AnimationObject self, Handle_AIS_Animation theAnimation)

        Add single animation to the timeline.
        @param theAnimation input animation

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_AnimationObject_Add(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_AIS_AnimationObject self)

        Clear animation timeline - remove all animations from it.


        """
        return _AIS.Handle_AIS_AnimationObject_Clear(self, *args)


    def Find(self, *args):
        """
        Find(Handle_AIS_AnimationObject self, TCollection_AsciiString theAnimationName) -> Handle_AIS_Animation

        Return the child animation with the given name.

        :type theAnimationName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_AnimationObject_Find(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_AIS_AnimationObject self, Handle_AIS_Animation theAnimation) -> Standard_Boolean

        Remove the child animation.

        :type theAnimation: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationObject_Remove(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_AIS_AnimationObject self, Handle_AIS_Animation theAnimationOld, Handle_AIS_Animation theAnimationNew) -> Standard_Boolean

        Replace the child animation.

        :type theAnimationOld: OCC.wrapper.AIS.Handle_AIS_Animation
        :type theAnimationNew: OCC.wrapper.AIS.Handle_AIS_Animation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationObject_Replace(self, *args)


    def CopyFrom(self, *args):
        """
        CopyFrom(Handle_AIS_AnimationObject self, Handle_AIS_Animation theOther)

        Clears own children and then copy child animations from another object.
        Copy also Start Time and Duration values.

        :type theOther: OCC.wrapper.AIS.Handle_AIS_Animation

        """
        return _AIS.Handle_AIS_AnimationObject_CopyFrom(self, *args)


    def Children(self, *args):
        """
        Return sequence of child animations.

        :rtype: OCC.wrapper.AIS.NCollection_Sequence_Handle_AIS_Animation

        """
        res = _AIS.Handle_AIS_AnimationObject_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StartTimer(self, *args):
        """
        StartTimer(Handle_AIS_AnimationObject self, Standard_Real const theStartPts, Standard_Real const thePlaySpeed, Standard_Boolean const theToUpdate, Standard_Boolean const theToStopTimer)

        Start animation with internally defined timer instance.
        Calls ::Start() internally.
        @param theStartPts    starting timer position (presentation timestamp)
        @param thePlaySpeed   playback speed (1.0 means normal speed)
        @param theToUpdate    flag to update defined animations to specified start position
        @param theToStopTimer flag to pause timer at the starting position

        :type theStartPts: float
        :type thePlaySpeed: float
        :type theToUpdate: bool
        :type theToStopTimer: bool

        """
        return _AIS.Handle_AIS_AnimationObject_StartTimer(self, *args)


    def UpdateTimer(self, *args):
        """
        UpdateTimer(Handle_AIS_AnimationObject self) -> Standard_Real

        Update single frame of animation, update timer state
        @return current time of timeline progress.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationObject_UpdateTimer(self, *args)


    def ElapsedTime(self, *args):
        """
        ElapsedTime(Handle_AIS_AnimationObject self) -> Standard_Real

        Return elapsed time.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_AnimationObject_ElapsedTime(self, *args)


    def Start(self, *args):
        """
        Start(Handle_AIS_AnimationObject self, Standard_Boolean const theToUpdate)

        Start animation. This method changes status of the animation to Started.
        This status defines whether animation is to be performed in the timeline or not.
        @param theToUpdate call Update() method

        :type theToUpdate: bool

        """
        return _AIS.Handle_AIS_AnimationObject_Start(self, *args)


    def Pause(self, *args):
        """
        Pause(Handle_AIS_AnimationObject self)

        Pause the process timeline.


        """
        return _AIS.Handle_AIS_AnimationObject_Pause(self, *args)


    def Stop(self, *args):
        """
        Stop(Handle_AIS_AnimationObject self)

        Stop animation. This method changed status of the animation to Stopped.
        This status shows that animation will not be performed in the timeline or it is finished.


        """
        return _AIS.Handle_AIS_AnimationObject_Stop(self, *args)


    def IsStopped(self, *args):
        """
        IsStopped(Handle_AIS_AnimationObject self) -> bool

        Check if animation is to be performed in the animation timeline.
        @return True if it is stopped of finished.

        :rtype: bool

        """
        return _AIS.Handle_AIS_AnimationObject_IsStopped(self, *args)


    def Update(self, *args):
        """
        Update(Handle_AIS_AnimationObject self, Standard_Real const thePts) -> Standard_Boolean

        Update single frame of animation, update timer state
        @param thePts [in] the time moment within [0; Duration()]
        @return True if timeline is in progress

        :type thePts: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationObject_Update(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_AnimationObject self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_AnimationObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_AnimationObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_AnimationObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_AnimationObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_AnimationObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_AnimationObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_AnimationObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_AnimationObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_AnimationObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AnimationObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_AnimationObject self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_AnimationObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_AnimationObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_AnimationObject_DecrementRefCounter(self, *args)

Handle_AIS_AnimationObject_swigregister = _AIS.Handle_AIS_AnimationObject_swigregister
Handle_AIS_AnimationObject_swigregister(Handle_AIS_AnimationObject)

def Handle_AIS_AnimationObject_DownCast(thing):
    return _AIS.Handle_AIS_AnimationObject_DownCast(thing)
Handle_AIS_AnimationObject_DownCast = _AIS.Handle_AIS_AnimationObject_DownCast

class Handle_AIS_Manipulator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Manipulator self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Manipulator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Manipulator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Manipulator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Manipulator self, AIS_Manipulator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Manipulator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Manipulator self, Handle_AIS_Manipulator theHandle) -> Handle_AIS_Manipulator
        assign(Handle_AIS_Manipulator self, AIS_Manipulator thePtr) -> Handle_AIS_Manipulator
        assign(Handle_AIS_Manipulator self, Handle_AIS_Manipulator theHandle) -> Handle_AIS_Manipulator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Manipulator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Manipulator self) -> AIS_Manipulator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Manipulator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Manipulator self) -> AIS_Manipulator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Manipulator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Manipulator self) -> AIS_Manipulator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Manipulator___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Manipulator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Manipulator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Manipulator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Manipulator_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Manipulator

    def SetPart(self, *args):
        """
        SetPart(Handle_AIS_Manipulator self, Standard_Integer const theAxisIndex, AIS_ManipulatorMode const theMode, Standard_Boolean const theIsEnabled)

        Disable or enable visual parts for translation, rotation or scaling for some axis.
        By default all parts are enabled (will be displayed).
        @warning Enabling or disabling of visual parts of manipulator does not manage the manipulation (selection) mode.
        @warning Raises program error if axis index is < 0 or > 2.

        :type theAxisIndex: int
        :type theMode: OCC.wrapper.AIS.AIS_ManipulatorMode
        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Manipulator_SetPart(self, *args)


    def EnableMode(self, *args):
        """
        EnableMode(Handle_AIS_Manipulator self, AIS_ManipulatorMode const theMode)

        Enable manipualtion mode.
        @warning It activates selection mode in the current context.
        If manipulator is not displayed, no mode will be activated.

        :type theMode: OCC.wrapper.AIS.AIS_ManipulatorMode

        """
        return _AIS.Handle_AIS_Manipulator_EnableMode(self, *args)


    def SetModeActivationOnDetection(self, *args):
        """
        SetModeActivationOnDetection(Handle_AIS_Manipulator self, Standard_Boolean const theToEnable)

        Enables mode activation on detection (highlighting).
        By default, mode is activated on selection of manipulator part.
        @warning If this mode is enabled, selection of parts does nothing.

        :type theToEnable: bool

        """
        return _AIS.Handle_AIS_Manipulator_SetModeActivationOnDetection(self, *args)


    def IsModeActivationOnDetection(self, *args):
        """
        IsModeActivationOnDetection(Handle_AIS_Manipulator self) -> Standard_Boolean

        @return true if manual mode activation is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsModeActivationOnDetection(self, *args)


    def StartTransform(self, *args):
        """
        StartTransform(Handle_AIS_Manipulator self, Standard_Integer const theX, Standard_Integer const theY, Handle_V3d_View theView)

        Init start (reference) transformation.
        @warning It is used in chain with StartTransform-Transform(gp_Trsf)-StopTransform
        and is used only for custom transform set. If Transform(const Standard_Integer, const Standard_Integer) is used,
        initial data is set automatically, and it is reset on DeactivateCurrentMode call if it is not reset yet.

        :type theX: int
        :type theY: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View

        """
        return _AIS.Handle_AIS_Manipulator_StartTransform(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_AIS_Manipulator self, gp_Trsf aTrsf)
        Transform(Handle_AIS_Manipulator self, Standard_Integer const theX, Standard_Integer const theY, Handle_V3d_View theView) -> gp_Trsf

        Apply transformation made from mouse moving from start position
        (save on the first Tranform() call and reset on DeactivateCurrentMode() call.)
        to the in/out mouse position (theX, theY)

        :type theX: int
        :type theY: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _AIS.Handle_AIS_Manipulator_Transform(self, *args)


    def StopTransform(self, *args):
        """
        StopTransform(Handle_AIS_Manipulator self, Standard_Boolean const theToApply)

        Reset start (reference) transformation.
        @param theToApply [in] option to apply or to cancel the started transformation.
        @warning It is used in chain with StartTransform-Transform(gp_Trsf)-StopTransform
        and is used only for custom transform set.

        :type theToApply: bool

        """
        return _AIS.Handle_AIS_Manipulator_StopTransform(self, *args)


    def ObjectTransformation(self, *args):
        """
        ObjectTransformation(Handle_AIS_Manipulator self, Standard_Integer const theX, Standard_Integer const theY, Handle_V3d_View theView, gp_Trsf theTrsf) -> Standard_Boolean

        Computes transformation of parent object according to the active mode and input motion vector.
        You can use this method to get object transformation according to current mode or use own algorithm
        to implement any other tranformation for modes.
        @return transformation of parent object.

        :type theX: int
        :type theY: int
        :type theView: OCC.wrapper.V3d.Handle_V3d_View
        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_ObjectTransformation(self, *args)


    def DeactivateCurrentMode(self, *args):
        """
        DeactivateCurrentMode(Handle_AIS_Manipulator self)

        Make inactive the current selected manipulator part and reset current axis index and current mode.
        After its call HasActiveMode() returns false.
        @sa HasActiveMode()


        """
        return _AIS.Handle_AIS_Manipulator_DeactivateCurrentMode(self, *args)


    def Detach(self, *args):
        """
        Detach(Handle_AIS_Manipulator self)

        Detaches himself from the owner object, and removes itself from context.


        """
        return _AIS.Handle_AIS_Manipulator_Detach(self, *args)


    def Objects(self, *args):
        """
        Objects(Handle_AIS_Manipulator self) -> Handle_AIS_ManipulatorObjectSequence

        @return all owning objects.

        :rtype: OCC.wrapper.AIS.Handle_AIS_ManipulatorObjectSequence

        """
        return _AIS.Handle_AIS_Manipulator_Objects(self, *args)


    def Object(self, *args):
        """
        Object(Handle_AIS_Manipulator self) -> Handle_AIS_InteractiveObject
        Object(Handle_AIS_Manipulator self, Standard_Integer const theIndex) -> Handle_AIS_InteractiveObject

        @return one of the owning objects.
        @warning raises program error if theIndex is more than owning objects count or less than 1.

        :type theIndex: int
        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        return _AIS.Handle_AIS_Manipulator_Object(self, *args)


    def IsAttached(self, *args):
        """
        IsAttached(Handle_AIS_Manipulator self) -> Standard_Boolean

        @return true if manipulator is attached to some interactive object (has owning object).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsAttached(self, *args)


    def HasActiveMode(self, *args):
        """
        HasActiveMode(Handle_AIS_Manipulator self) -> Standard_Boolean

        @return true if some part of manipulator is selected (transformation mode is active, and owning object can be transformed).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasActiveMode(self, *args)


    def HasActiveTransformation(self, *args):
        """
        HasActiveTransformation(Handle_AIS_Manipulator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasActiveTransformation(self, *args)


    def StartTransformation(self, *args):
        """
        StartTransformation(Handle_AIS_Manipulator self) -> gp_Trsf
        StartTransformation(Handle_AIS_Manipulator self, Standard_Integer theIndex) -> gp_Trsf

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _AIS.Handle_AIS_Manipulator_StartTransformation(self, *args)


    def SetZoomPersistence(self, *args):
        """
        SetZoomPersistence(Handle_AIS_Manipulator self, Standard_Boolean const theToEnable)

        Enable or disable zoom persistence mode for the manipulator. With
        this mode turned on the presentation will keep fixed screen size.
        @warning when turned on this option overrides transform persistence
        properties and local transformation to achieve necessary visual effect.
        @warning revise use of AdjustSize argument of of \sa AttachToObjects method
        when enabling zoom persistence.

        :type theToEnable: bool

        """
        return _AIS.Handle_AIS_Manipulator_SetZoomPersistence(self, *args)


    def ZoomPersistence(self, *args):
        """
        ZoomPersistence(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns state of zoom persistence mode, whether it turned on or off.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_ZoomPersistence(self, *args)


    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Manipulator self, Handle_Graphic3d_TransformPers theTrsfPers)

        Redefines transform persistence management to setup transformation for sub-presentation of axes.
        @warning this interactive object does not support custom transformation persistence when
        using \sa ZoomPersistence mode. In this mode the transformation persistence flags for
        presentations are overridden by this class.
        @warning Invokes debug assertion to catch incompatible usage of the method with \sa ZoomPersistence mode,
        silently does nothing in release mode.
        @warning revise use of AdjustSize argument of of \sa AttachToObjects method
        when enabling zoom persistence.

        :type theTrsfPers: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        return _AIS.Handle_AIS_Manipulator_SetTransformPersistence(self, *args)


    def ActiveMode(self, *args):
        """
        ActiveMode(Handle_AIS_Manipulator self) -> AIS_ManipulatorMode

        @name Setters for parameters

        :rtype: OCC.wrapper.AIS.AIS_ManipulatorMode

        """
        return _AIS.Handle_AIS_Manipulator_ActiveMode(self, *args)


    def Position(self, *args):
        """
        @return poition of manipulator interactive object.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _AIS.Handle_AIS_Manipulator_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_Manipulator self, gp_Ax2 thePosition)

        Sets position of the manipulator object.

        :type thePosition: OCC.wrapper.gp.gp_Ax2

        """
        return _AIS.Handle_AIS_Manipulator_SetPosition(self, *args)


    def Size(self, *args):
        """
        Size(Handle_AIS_Manipulator self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _AIS.Handle_AIS_Manipulator_Size(self, *args)


    def SetSize(self, *args):
        """
        SetSize(Handle_AIS_Manipulator self, Standard_ShortReal const theSideLength)

        Sets size (length of side of the manipulator cubic bounding box.

        :type theSideLength: float

        """
        return _AIS.Handle_AIS_Manipulator_SetSize(self, *args)


    def SetGap(self, *args):
        """
        SetGap(Handle_AIS_Manipulator self, Standard_ShortReal const theValue)

        Sets gaps between translator, scaler and rotator sub-presentations.

        :type theValue: float

        """
        return _AIS.Handle_AIS_Manipulator_SetGap(self, *args)


    def SetTransformBehavior(self, *args):
        """
        SetTransformBehavior(Handle_AIS_Manipulator self, AIS_Manipulator::BehaviorOnTransform const & theSettings)

        Sets behavior settings for transformation action carried on the manipulator,
        whether it translates, rotates together with the transformed object or not.

        :type theSettings: BehaviorOnTransform

        """
        return _AIS.Handle_AIS_Manipulator_SetTransformBehavior(self, *args)


    def ChangeTransformBehavior(self, *args):
        """
        ChangeTransformBehavior(Handle_AIS_Manipulator self) -> AIS_Manipulator::BehaviorOnTransform &

        @return behavior settings for transformation action of the manipulator.

        :rtype: BehaviorOnTransform

        """
        return _AIS.Handle_AIS_Manipulator_ChangeTransformBehavior(self, *args)


    def TransformBehavior(self, *args):
        """
        @return behavior settings for transformation action of the manipulator.

        :rtype: BehaviorOnTransform

        """
        res = _AIS.Handle_AIS_Manipulator_TransformBehavior(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentationManager thePrsMgr, Handle_Prs3d_Presentation thePrs, Standard_Integer const theMode=0)

        Fills presentation.
        @note Manipulator presentation does not use display mode and for all modes has the same presentation.

        :type thePrsMgr: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theMode: int

        """
        return _AIS.Handle_AIS_Manipulator_Compute(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Manipulator self) -> Standard_Boolean

        Disables auto highlighting to use HilightSelected() and HilightOwnerWithColor() overridden methods.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsAutoHilight(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Manipulator self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw ).


        """
        return _AIS.Handle_AIS_Manipulator_ClearSelected(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentationManager thePM, NCollection_Sequence_Handle_SelectMgr_EntityOwner theSeq)

        Method which draws selected owners ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theSeq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Manipulator_HilightSelected(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw ).

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Manipulator_HilightOwnerWithColor(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Manipulator self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Manipulator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Manipulator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Manipulator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def attach(self, *args):
        """
        attach(Handle_AIS_Manipulator self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False, Standard_Boolean const enableAllModes=True)
        attach(Handle_AIS_Manipulator self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False)
        attach(Handle_AIS_Manipulator self, Handle_AIS_InteractiveObject theObject, Standard_Boolean const adjustPosition=True)
        attach(Handle_AIS_Manipulator self, Handle_AIS_InteractiveObject theObject)
        attach(Handle_AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False, Standard_Boolean const enableAllModes=True)
        attach(Handle_AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject, Standard_Boolean const adjustPosition=True, Standard_Boolean const adjustSize=False)
        attach(Handle_AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject, Standard_Boolean const adjustPosition=True)
        attach(Handle_AIS_Manipulator self, Handle_AIS_ManipulatorObjectSequence theObject)
        """
        return _AIS.Handle_AIS_Manipulator_attach(self, *args)


    def SetLocalTransformation(self, *args):
        return _AIS.Handle_AIS_Manipulator_SetLocalTransformation(self, *args)

    def Type(self, *args):
        """
        Type(Handle_AIS_Manipulator self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Manipulator_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Manipulator self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Manipulator_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Manipulator self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Manipulator self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Manipulator_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Manipulator self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Manipulator_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Manipulator self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Manipulator_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Manipulator self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_Manipulator_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Manipulator self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Manipulator_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Manipulator self)"""
        return _AIS.Handle_AIS_Manipulator_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Manipulator self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Manipulator self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Manipulator_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Manipulator self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Manipulator_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Manipulator self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Manipulator_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Manipulator self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Manipulator self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Manipulator_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Manipulator self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Manipulator_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Manipulator_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Manipulator self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Manipulator_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Manipulator self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Manipulator_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Manipulator self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Manipulator_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Manipulator self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Manipulator_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Manipulator self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Manipulator_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Manipulator self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Manipulator_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Manipulator self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Manipulator_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Manipulator self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Manipulator_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Manipulator self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Manipulator_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Manipulator self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Manipulator_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Manipulator self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Manipulator_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Manipulator self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Manipulator_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Manipulator self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Manipulator_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Manipulator self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Manipulator_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Manipulator self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Manipulator_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Manipulator self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_Manipulator_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Manipulator self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Manipulator_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Manipulator self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Manipulator_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Manipulator self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Manipulator_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Manipulator self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Manipulator_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Manipulator self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Manipulator_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Manipulator self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Manipulator_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Manipulator self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Manipulator_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Manipulator self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Manipulator_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Manipulator self)
        RecomputePrimitives(Handle_AIS_Manipulator self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Manipulator_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Manipulator self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Manipulator_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Manipulator self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Manipulator_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Manipulator_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Manipulator self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Manipulator_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Manipulator self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Manipulator_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Manipulator self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Manipulator self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Manipulator_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Manipulator_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Manipulator self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Manipulator_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Manipulator self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Manipulator_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Manipulator self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Manipulator_UpdateTransformations(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Manipulator_ClearDynamicHighlight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Manipulator self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Manipulator_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Manipulator_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Manipulator_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Manipulator self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Manipulator_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Manipulator self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Manipulator_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Manipulator self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Manipulator_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Manipulator self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Manipulator_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Manipulator self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Manipulator_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Manipulator self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Manipulator_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Manipulator self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Manipulator_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Manipulator_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Manipulator self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Manipulator_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Manipulator self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Manipulator_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Manipulator_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Manipulator self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Manipulator_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Manipulator self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Manipulator_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Manipulator self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Manipulator_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Manipulator self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Manipulator self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Manipulator_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Manipulator self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Manipulator_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Manipulator_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Manipulator_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Manipulator_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Manipulator_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Manipulator_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Manipulator self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Manipulator_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Manipulator self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Manipulator_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Manipulator self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Manipulator_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Manipulator self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Manipulator self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Manipulator_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Manipulator_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Manipulator self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Manipulator_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Manipulator_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Manipulator self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Manipulator_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Manipulator_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Manipulator self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Manipulator self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Manipulator_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Manipulator self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Manipulator_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Manipulator_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Manipulator_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Manipulator self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Manipulator_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Manipulator_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Manipulator self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Manipulator_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Manipulator self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Manipulator_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Manipulator self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Manipulator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Manipulator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Manipulator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Manipulator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Manipulator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Manipulator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Manipulator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Manipulator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Manipulator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Manipulator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Manipulator self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Manipulator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Manipulator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Manipulator_DecrementRefCounter(self, *args)

Handle_AIS_Manipulator_swigregister = _AIS.Handle_AIS_Manipulator_swigregister
Handle_AIS_Manipulator_swigregister(Handle_AIS_Manipulator)

def Handle_AIS_Manipulator_DownCast(thing):
    return _AIS.Handle_AIS_Manipulator_DownCast(thing)
Handle_AIS_Manipulator_DownCast = _AIS.Handle_AIS_Manipulator_DownCast

class AIS_Triangulation(AIS_InteractiveObject):
    """
    Interactive object that draws data from  Poly_Triangulation, optionally with colors associated
    with each triangulation vertex. For maximum efficiency colors are represented as 32-bit integers
    instead of classic Quantity_Color values.
    Interactive selection of triangles and vertices is not yet implemented.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_Triangulation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_Triangulation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AIS_Triangulation self, Handle_Poly_Triangulation aTriangulation) -> AIS_Triangulation

        Constructs the Triangulation display object

        :type aTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        this = _AIS.new_AIS_Triangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetColors(self, *args):
        """
        SetColors(AIS_Triangulation self, Handle_TColStd_HArray1OfInteger aColor)

        Set the color for each node.
        Each 32-bit color is Alpha << 24 + Blue << 16 + Green << 8 + Red
        Order of color components is essential for further usage by OpenGL

        :type aColor: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _AIS.AIS_Triangulation_SetColors(self, *args)


    def GetColors(self, *args):
        """
        GetColors(AIS_Triangulation self) -> Handle_TColStd_HArray1OfInteger

        Get the color for each node.
        Each 32-bit color is Alpha << 24 + Blue << 16 + Green << 8 + Red

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _AIS.AIS_Triangulation_GetColors(self, *args)


    def HasVertexColors(self, *args):
        """
        HasVertexColors(AIS_Triangulation self) -> Standard_Boolean

        Returns true if triangulation has vertex colors.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_Triangulation_HasVertexColors(self, *args)


    def SetTriangulation(self, *args):
        """
        SetTriangulation(AIS_Triangulation self, Handle_Poly_Triangulation aTriangulation)

        :type aTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _AIS.AIS_Triangulation_SetTriangulation(self, *args)


    def GetTriangulation(self, *args):
        """
        GetTriangulation(AIS_Triangulation self) -> Handle_Poly_Triangulation

        Returns Poly_Triangulation .

        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _AIS.AIS_Triangulation_GetTriangulation(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(AIS_Triangulation self, Standard_Real const aValue=0.6)

        Sets the value aValue for transparency in the reconstructed compound shape.

        :type aValue: float

        """
        return _AIS.AIS_Triangulation_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(AIS_Triangulation self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _AIS.AIS_Triangulation_UnsetTransparency(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_Triangulation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_Triangulation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_Triangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_Triangulation
AIS_Triangulation_swigregister = _AIS.AIS_Triangulation_swigregister
AIS_Triangulation_swigregister(AIS_Triangulation)

def AIS_Triangulation_get_type_name(*args):
    """
    AIS_Triangulation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_Triangulation_get_type_name(*args)

def AIS_Triangulation_get_type_descriptor(*args):
    """
    AIS_Triangulation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_Triangulation_get_type_descriptor(*args)

class Handle_AIS_C0RegularityFilter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_C0RegularityFilter self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_C0RegularityFilter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_C0RegularityFilter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_C0RegularityFilter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_C0RegularityFilter self, AIS_C0RegularityFilter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_C0RegularityFilter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_C0RegularityFilter self, Handle_AIS_C0RegularityFilter theHandle) -> Handle_AIS_C0RegularityFilter
        assign(Handle_AIS_C0RegularityFilter self, AIS_C0RegularityFilter thePtr) -> Handle_AIS_C0RegularityFilter
        assign(Handle_AIS_C0RegularityFilter self, Handle_AIS_C0RegularityFilter theHandle) -> Handle_AIS_C0RegularityFilter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_C0RegularityFilter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_C0RegularityFilter self) -> AIS_C0RegularityFilter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_C0RegularityFilter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_C0RegularityFilter self) -> AIS_C0RegularityFilter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_C0RegularityFilter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_C0RegularityFilter self) -> AIS_C0RegularityFilter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_C0RegularityFilter___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_C0RegularityFilter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_C0RegularityFilter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_C0RegularityFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_C0RegularityFilter_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_C0RegularityFilter

    def ActsOn(self, *args):
        """
        ActsOn(Handle_AIS_C0RegularityFilter self, TopAbs_ShapeEnum const aType) -> Standard_Boolean

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_C0RegularityFilter_ActsOn(self, *args)


    def IsOk(self, *args):
        """
        IsOk(Handle_AIS_C0RegularityFilter self, Handle_SelectMgr_EntityOwner EO) -> Standard_Boolean

        :type EO: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_C0RegularityFilter_IsOk(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_C0RegularityFilter self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_C0RegularityFilter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_C0RegularityFilter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_C0RegularityFilter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AIS_C0RegularityFilter self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_C0RegularityFilter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_C0RegularityFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_C0RegularityFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_C0RegularityFilter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_C0RegularityFilter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_C0RegularityFilter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_C0RegularityFilter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_C0RegularityFilter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_C0RegularityFilter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_C0RegularityFilter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_C0RegularityFilter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_C0RegularityFilter self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_C0RegularityFilter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_C0RegularityFilter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_C0RegularityFilter_DecrementRefCounter(self, *args)

Handle_AIS_C0RegularityFilter_swigregister = _AIS.Handle_AIS_C0RegularityFilter_swigregister
Handle_AIS_C0RegularityFilter_swigregister(Handle_AIS_C0RegularityFilter)

def Handle_AIS_C0RegularityFilter_DownCast(thing):
    return _AIS.Handle_AIS_C0RegularityFilter_DownCast(thing)
Handle_AIS_C0RegularityFilter_DownCast = _AIS.Handle_AIS_C0RegularityFilter_DownCast

class AIS_LocalStatus(Standard.Standard_Transient):
    """Stored Info about temporary objects."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AIS_LocalStatus
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AIS_LocalStatus(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AIS.AIS_LocalStatus_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AIS.AIS_LocalStatus_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.AIS_LocalStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(AIS_LocalStatus self, Standard_Boolean const theIsTemporary, Standard_Boolean const theIsToDecompose, Standard_Integer const theDisplayMode=-1, Standard_Integer const theSelectionMode=-1, Standard_Integer const theHilightMode=0, Standard_Boolean const theIsSubIntensity=0, Handle_Prs3d_Drawer theStyle) -> AIS_LocalStatus

        :type theIsTemporary: bool
        :type theIsToDecompose: bool
        :type theDisplayMode: int
        :type theSelectionMode: int
        :type theHilightMode: int
        :type theIsSubIntensity: bool
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        this = _AIS.new_AIS_LocalStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Decomposed(self, *args):
        """
        Decomposed(AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalStatus_Decomposed(self, *args)


    def IsTemporary(self, *args):
        """
        IsTemporary(AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalStatus_IsTemporary(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(AIS_LocalStatus self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_LocalStatus_DisplayMode(self, *args)


    def SelectionModes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.AIS_LocalStatus_SelectionModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsActivated(self, *args):
        """
        IsActivated(AIS_LocalStatus self, Standard_Integer const aSelMode) -> Standard_Boolean

        :type aSelMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalStatus_IsActivated(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(AIS_LocalStatus self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.AIS_LocalStatus_HilightMode(self, *args)


    def IsSubIntensityOn(self, *args):
        """
        IsSubIntensityOn(AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalStatus_IsSubIntensityOn(self, *args)


    def HilightStyle(self, *args):
        """
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.AIS_LocalStatus_HilightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDecomposition(self, *args):
        """
        SetDecomposition(AIS_LocalStatus self, Standard_Boolean const astatus)

        :type astatus: bool

        """
        return _AIS.AIS_LocalStatus_SetDecomposition(self, *args)


    def SetTemporary(self, *args):
        """
        SetTemporary(AIS_LocalStatus self, Standard_Boolean const astatus)

        :type astatus: bool

        """
        return _AIS.AIS_LocalStatus_SetTemporary(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.AIS_LocalStatus_SetDisplayMode(self, *args)


    def SetFirstDisplay(self, *args):
        """
        SetFirstDisplay(AIS_LocalStatus self, Standard_Boolean const aStatus)

        :type aStatus: bool

        """
        return _AIS.AIS_LocalStatus_SetFirstDisplay(self, *args)


    def IsFirstDisplay(self, *args):
        """
        IsFirstDisplay(AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalStatus_IsFirstDisplay(self, *args)


    def AddSelectionMode(self, *args):
        """
        AddSelectionMode(AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.AIS_LocalStatus_AddSelectionMode(self, *args)


    def RemoveSelectionMode(self, *args):
        """
        RemoveSelectionMode(AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.AIS_LocalStatus_RemoveSelectionMode(self, *args)


    def ClearSelectionModes(self, *args):
        """ClearSelectionModes(AIS_LocalStatus self)"""
        return _AIS.AIS_LocalStatus_ClearSelectionModes(self, *args)


    def IsSelModeIn(self, *args):
        """
        IsSelModeIn(AIS_LocalStatus self, Standard_Integer const aMode) -> Standard_Boolean

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.AIS_LocalStatus_IsSelModeIn(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.AIS_LocalStatus_SetHilightMode(self, *args)


    def SetHilightStyle(self, *args):
        """
        SetHilightStyle(AIS_LocalStatus self, Handle_Prs3d_Drawer theStyle)

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.AIS_LocalStatus_SetHilightStyle(self, *args)


    def SubIntensityOn(self, *args):
        """SubIntensityOn(AIS_LocalStatus self)"""
        return _AIS.AIS_LocalStatus_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """SubIntensityOff(AIS_LocalStatus self)"""
        return _AIS.AIS_LocalStatus_SubIntensityOff(self, *args)


    def SetPreviousState(self, *args):
        """
        SetPreviousState(AIS_LocalStatus self, Handle_Standard_Transient aStatus)

        :type aStatus: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.AIS_LocalStatus_SetPreviousState(self, *args)


    def PreviousState(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.AIS_LocalStatus_PreviousState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AIS.delete_AIS_LocalStatus
AIS_LocalStatus_swigregister = _AIS.AIS_LocalStatus_swigregister
AIS_LocalStatus_swigregister(AIS_LocalStatus)

def AIS_LocalStatus_get_type_name(*args):
    """
    AIS_LocalStatus_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AIS.AIS_LocalStatus_get_type_name(*args)

def AIS_LocalStatus_get_type_descriptor(*args):
    """
    AIS_LocalStatus_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AIS.AIS_LocalStatus_get_type_descriptor(*args)

class AIS_GraphicTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetLineColor(*args):
        """
        GetLineColor(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes) -> Quantity_NameOfColor
        GetLineColor(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes, Quantity_Color TheLineColor)

        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
        :type TheLineColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_GraphicTool_GetLineColor(*args)

    GetLineColor = staticmethod(GetLineColor)

    def GetLineWidth(*args):
        """
        GetLineWidth(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes) -> Standard_Real

        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.AIS_GraphicTool_GetLineWidth(*args)

    GetLineWidth = staticmethod(GetLineWidth)

    def GetLineType(*args):
        """
        GetLineType(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes) -> Aspect_TypeOfLine

        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.AIS_GraphicTool_GetLineType(*args)

    GetLineType = staticmethod(GetLineType)

    def GetLineAtt(*args):
        """
        GetLineAtt(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes)

        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
        :type aCol: OCC.wrapper.Quantity.Quantity_NameOfColor
        :type aWidth: float
        :type aTyp: OCC.wrapper.Aspect.Aspect_TypeOfLine

        """
        return _AIS.AIS_GraphicTool_GetLineAtt(*args)

    GetLineAtt = staticmethod(GetLineAtt)

    def GetInteriorColor(*args):
        """
        GetInteriorColor(Handle_Prs3d_Drawer aDrawer) -> Quantity_NameOfColor
        GetInteriorColor(Handle_Prs3d_Drawer aDrawer, Quantity_Color aColor)

        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.AIS_GraphicTool_GetInteriorColor(*args)

    GetInteriorColor = staticmethod(GetInteriorColor)

    def GetMaterial(*args):
        """
        GetMaterial(Handle_Prs3d_Drawer aDrawer) -> Graphic3d_MaterialAspect

        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.AIS_GraphicTool_GetMaterial(*args)

    GetMaterial = staticmethod(GetMaterial)

    def __init__(self):
        this = _AIS.new_AIS_GraphicTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_AIS_GraphicTool
AIS_GraphicTool_swigregister = _AIS.AIS_GraphicTool_swigregister
AIS_GraphicTool_swigregister(AIS_GraphicTool)

def AIS_GraphicTool_GetLineColor(*args):
    """
    GetLineColor(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes) -> Quantity_NameOfColor
    AIS_GraphicTool_GetLineColor(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes, Quantity_Color TheLineColor)

    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
    :type TheLineColor: OCC.wrapper.Quantity.Quantity_Color

    """
    return _AIS.AIS_GraphicTool_GetLineColor(*args)

def AIS_GraphicTool_GetLineWidth(*args):
    """
    AIS_GraphicTool_GetLineWidth(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes) -> Standard_Real

    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _AIS.AIS_GraphicTool_GetLineWidth(*args)

def AIS_GraphicTool_GetLineType(*args):
    """
    AIS_GraphicTool_GetLineType(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes) -> Aspect_TypeOfLine

    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
    :rtype: OCC.wrapper.Aspect.Aspect_TypeOfLine

    """
    return _AIS.AIS_GraphicTool_GetLineType(*args)

def AIS_GraphicTool_GetLineAtt(*args):
    """
    AIS_GraphicTool_GetLineAtt(Handle_Prs3d_Drawer aDrawer, AIS_TypeOfAttribute const TheTypeOfAttributes)

    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type TheTypeOfAttributes: OCC.wrapper.AIS.AIS_TypeOfAttribute
    :type aCol: OCC.wrapper.Quantity.Quantity_NameOfColor
    :type aWidth: float
    :type aTyp: OCC.wrapper.Aspect.Aspect_TypeOfLine

    """
    return _AIS.AIS_GraphicTool_GetLineAtt(*args)

def AIS_GraphicTool_GetInteriorColor(*args):
    """
    GetInteriorColor(Handle_Prs3d_Drawer aDrawer) -> Quantity_NameOfColor
    AIS_GraphicTool_GetInteriorColor(Handle_Prs3d_Drawer aDrawer, Quantity_Color aColor)

    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type aColor: OCC.wrapper.Quantity.Quantity_Color

    """
    return _AIS.AIS_GraphicTool_GetInteriorColor(*args)

def AIS_GraphicTool_GetMaterial(*args):
    """
    AIS_GraphicTool_GetMaterial(Handle_Prs3d_Drawer aDrawer) -> Graphic3d_MaterialAspect

    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

    """
    return _AIS.AIS_GraphicTool_GetMaterial(*args)

class Handle_AIS_OffsetDimension(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_OffsetDimension self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_OffsetDimension_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_OffsetDimension self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_OffsetDimension self, AIS_OffsetDimension thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_OffsetDimension_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_OffsetDimension self, Handle_AIS_OffsetDimension theHandle) -> Handle_AIS_OffsetDimension
        assign(Handle_AIS_OffsetDimension self, AIS_OffsetDimension thePtr) -> Handle_AIS_OffsetDimension
        assign(Handle_AIS_OffsetDimension self, Handle_AIS_OffsetDimension theHandle) -> Handle_AIS_OffsetDimension

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_OffsetDimension_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_OffsetDimension self) -> AIS_OffsetDimension

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_OffsetDimension_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_OffsetDimension self) -> AIS_OffsetDimension

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_OffsetDimension___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_OffsetDimension self) -> AIS_OffsetDimension

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_OffsetDimension___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_OffsetDimension___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_OffsetDimension___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_OffsetDimension(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_OffsetDimension_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_OffsetDimension

    def Compute(self, *args):
        """
        Compute(Handle_AIS_OffsetDimension self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_OffsetDimension_Compute(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_OffsetDimension self) -> AIS_KindOfDimension

        Indicates that the dimension we are concerned with is an offset.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_OffsetDimension_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the offset datum is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_IsMovable(self, *args)


    def SetRelativePos(self, *args):
        """
        SetRelativePos(Handle_AIS_OffsetDimension self, gp_Trsf aTrsf)

        Sets a transformation aTrsf for presentation and
        selection to a relative position.

        :type aTrsf: OCC.wrapper.gp.gp_Trsf

        """
        return _AIS.Handle_AIS_OffsetDimension_SetRelativePos(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_OffsetDimension self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_OffsetDimension_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_OffsetDimension_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_OffsetDimension_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_OffsetDimension self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_OffsetDimension_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_OffsetDimension self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_OffsetDimension_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_OffsetDimension self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_OffsetDimension_Type(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_OffsetDimension_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_OffsetDimension self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_OffsetDimension_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_OffsetDimension_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_OffsetDimension self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_OffsetDimension_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_OffsetDimension self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_OffsetDimension_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_OffsetDimension self)"""
        return _AIS.Handle_AIS_OffsetDimension_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_OffsetDimension_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_OffsetDimension self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_OffsetDimension_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_OffsetDimension self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_OffsetDimension_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_OffsetDimension self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_OffsetDimension_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_OffsetDimension_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_OffsetDimension self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_OffsetDimension_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_OffsetDimension_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_OffsetDimension self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_OffsetDimension_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_OffsetDimension self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_OffsetDimension_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_OffsetDimension self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_OffsetDimension_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_OffsetDimension self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_OffsetDimension_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_OffsetDimension self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_OffsetDimension_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_OffsetDimension self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_OffsetDimension_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_OffsetDimension self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_OffsetDimension self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_OffsetDimension self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_OffsetDimension_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_OffsetDimension self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_OffsetDimension_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_OffsetDimension self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_OffsetDimension_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_OffsetDimension self)"""
        return _AIS.Handle_AIS_OffsetDimension_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_OffsetDimension self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_OffsetDimension self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_OffsetDimension self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_OffsetDimension_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_OffsetDimension self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_OffsetDimension_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_OffsetDimension_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_OffsetDimension self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_OffsetDimension_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_OffsetDimension self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_OffsetDimension_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_OffsetDimension self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_OffsetDimension_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_OffsetDimension self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_OffsetDimension_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_OffsetDimension self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_OffsetDimension_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_OffsetDimension self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_OffsetDimension_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_OffsetDimension self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_OffsetDimension_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_OffsetDimension self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_OffsetDimension_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_OffsetDimension self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_OffsetDimension_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_OffsetDimension self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_OffsetDimension_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_OffsetDimension self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_OffsetDimension_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_OffsetDimension self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_OffsetDimension_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_OffsetDimension self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_OffsetDimension_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_OffsetDimension self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_OffsetDimension_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_OffsetDimension self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_OffsetDimension_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_OffsetDimension self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_OffsetDimension_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_OffsetDimension self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_OffsetDimension_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_OffsetDimension self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_OffsetDimension_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_OffsetDimension self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_OffsetDimension_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_OffsetDimension self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_OffsetDimension_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_OffsetDimension self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_OffsetDimension self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_OffsetDimension_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_OffsetDimension self)
        RecomputePrimitives(Handle_AIS_OffsetDimension self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_OffsetDimension_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_OffsetDimension self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_OffsetDimension_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_OffsetDimension self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_OffsetDimension_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_OffsetDimension self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_OffsetDimension_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_OffsetDimension self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_OffsetDimension_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_OffsetDimension self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_OffsetDimension_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_OffsetDimension_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_OffsetDimension self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_OffsetDimension_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_OffsetDimension self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_OffsetDimension_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_OffsetDimension self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_OffsetDimension_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_OffsetDimension self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_OffsetDimension_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_OffsetDimension self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_OffsetDimension_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_OffsetDimension self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_OffsetDimension_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_OffsetDimension self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_OffsetDimension_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_OffsetDimension self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_OffsetDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_OffsetDimension_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_OffsetDimension self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_OffsetDimension_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_OffsetDimension self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_OffsetDimension self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_OffsetDimension_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_OffsetDimension self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_OffsetDimension_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_OffsetDimension self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_OffsetDimension_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_OffsetDimension self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_OffsetDimension_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_OffsetDimension self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_OffsetDimension_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_OffsetDimension_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_OffsetDimension self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_OffsetDimension_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_OffsetDimension self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_OffsetDimension_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_OffsetDimension_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_OffsetDimension self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_OffsetDimension self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_OffsetDimension_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_OffsetDimension self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_OffsetDimension_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_OffsetDimension self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_OffsetDimension_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_OffsetDimension self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_OffsetDimension_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_OffsetDimension self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_OffsetDimension self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_OffsetDimension_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_OffsetDimension self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_OffsetDimension_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_OffsetDimension_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_OffsetDimension self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_OffsetDimension self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_OffsetDimension_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_OffsetDimension_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_OffsetDimension_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_OffsetDimension_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_OffsetDimension_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_OffsetDimension self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_OffsetDimension_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_OffsetDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_OffsetDimension_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_OffsetDimension self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_OffsetDimension_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_OffsetDimension self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_OffsetDimension self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_OffsetDimension_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_OffsetDimension_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_OffsetDimension self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_OffsetDimension_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_OffsetDimension self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_OffsetDimension_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_OffsetDimension self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_OffsetDimension_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_OffsetDimension_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_OffsetDimension self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_OffsetDimension self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_OffsetDimension_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_OffsetDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_OffsetDimension_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_OffsetDimension_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_OffsetDimension_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_OffsetDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_OffsetDimension_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_OffsetDimension_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_OffsetDimension self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_OffsetDimension_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_OffsetDimension self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_OffsetDimension_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_OffsetDimension self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_OffsetDimension_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_OffsetDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_OffsetDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_OffsetDimension self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_OffsetDimension self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_OffsetDimension_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_OffsetDimension self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_OffsetDimension_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_OffsetDimension self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_OffsetDimension_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_OffsetDimension self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_OffsetDimension_DecrementRefCounter(self, *args)

Handle_AIS_OffsetDimension_swigregister = _AIS.Handle_AIS_OffsetDimension_swigregister
Handle_AIS_OffsetDimension_swigregister(Handle_AIS_OffsetDimension)

def Handle_AIS_OffsetDimension_DownCast(thing):
    return _AIS.Handle_AIS_OffsetDimension_DownCast(thing)
Handle_AIS_OffsetDimension_DownCast = _AIS.Handle_AIS_OffsetDimension_DownCast

class NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectMgr_EntityOwner >,opencascade::handle< Prs3d_Presentation >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectMgr_EntityOwner >,opencascade::handle< Prs3d_Presentation >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectMgr_EntityOwner >,opencascade::handle< Prs3d_Presentation >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< SelectMgr_EntityOwner >,opencascade::handle< Prs3d_Presentation >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _AIS.new_NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_SelectMgr_EntityOwner theKey1, Handle_Prs3d_Presentation theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_SelectMgr_EntityOwner theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_SelectMgr_EntityOwner theKey1, Handle_Prs3d_Presentation theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_SelectMgr_EntityOwner theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Standard_Integer const theIndex) -> Handle_Prs3d_Presentation

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_SelectMgr_EntityOwner theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_SelectMgr_EntityOwner theKey1) -> Handle_Prs3d_Presentation

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_SelectMgr_EntityOwner theKey1) -> Handle_Prs3d_Presentation

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_SelectMgr_EntityOwner theKey1) -> Handle_Prs3d_Presentation

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher
NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_swigregister = _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_swigregister
NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_swigregister(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher)

class NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper_swigregister = _AIS.NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher_IteratorHelper)


try:
	AIS_IndexedDataMapOfOwnerPrs = NCollection_IndexedDataMap_Handle_SelectMgr_EntityOwner_Handle_Prs3d_Presentation_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_EqualDistanceRelation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_EqualDistanceRelation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_EqualDistanceRelation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_EqualDistanceRelation self, AIS_EqualDistanceRelation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_EqualDistanceRelation self, Handle_AIS_EqualDistanceRelation theHandle) -> Handle_AIS_EqualDistanceRelation
        assign(Handle_AIS_EqualDistanceRelation self, AIS_EqualDistanceRelation thePtr) -> Handle_AIS_EqualDistanceRelation
        assign(Handle_AIS_EqualDistanceRelation self, Handle_AIS_EqualDistanceRelation theHandle) -> Handle_AIS_EqualDistanceRelation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_EqualDistanceRelation self) -> AIS_EqualDistanceRelation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_EqualDistanceRelation self) -> AIS_EqualDistanceRelation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_EqualDistanceRelation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_EqualDistanceRelation self) -> AIS_EqualDistanceRelation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_EqualDistanceRelation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_EqualDistanceRelation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_EqualDistanceRelation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_EqualDistanceRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_EqualDistanceRelation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_EqualDistanceRelation

    def SetShape3(self, *args):
        """
        SetShape3(Handle_AIS_EqualDistanceRelation self, TopoDS_Shape aShape)

        Sets the shape aShape to be used as the shape
        aShape3 in the framework created at construction time.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetShape3(self, *args)


    def Shape3(self, *args):
        """
        Returns the shape aShape3 from the framework
        created at construction time.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Shape3(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape4(self, *args):
        """
        SetShape4(Handle_AIS_EqualDistanceRelation self, TopoDS_Shape aShape)

        Sets the shape aShape to be used as the shape
        aShape4 in the framework created at construction time.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetShape4(self, *args)


    def Shape4(self, *args):
        """
        Returns the shape aShape4 from the framework
        created at construction time.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Shape4(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_Projector aProjector, Handle_Geom_Transformation aTrsf, Handle_Prs3d_Presentation aPresentation)

        Computes the presentation according to a point of view
        given by <aProjector>.
        To be Used when the associated degenerated Presentations
        have been transformed by <aTrsf> which is not a Pure
        Translation. The HLR Prs can't be deducted automatically
        WARNING :<aTrsf> must be applied
        to the object to display before computation  !!!

        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type aTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Compute(self, *args)


    def ComputeTwoEdgesLength(self, *args):
        """
        ComputeTwoEdgesLength(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Edge FirstEdge, TopoDS_Edge SecondEdge, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

        Computes the location of an intreval between
        between two edges. FirstAttach , SecondAttach
        are the returned extreme points of the interval.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type ArrowSize: float
        :type FirstEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type SecondEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type AutomaticPos: bool
        :type IsSetBndBox: bool
        :type BndBox: OCC.wrapper.Bnd.Bnd_Box
        :type Position: OCC.wrapper.gp.gp_Pnt
        :type FirstAttach: OCC.wrapper.gp.gp_Pnt
        :type SecondAttach: OCC.wrapper.gp.gp_Pnt
        :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
        :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
        :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ComputeTwoEdgesLength(self, *args)


    def ComputeTwoVerticesLength(self, *args):
        """
        ComputeTwoVerticesLength(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Vertex FirstVertex, TopoDS_Vertex SecondVertex, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, AIS_TypeOfDist const TypeDist, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

        Computes the interval position between two vertexs. FirstAttach,
        SecondAttach are the returned extreme points of the interval.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type ArrowSize: float
        :type FirstVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type SecondVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type AutomaticPos: bool
        :type IsSetBndBox: bool
        :type BndBox: OCC.wrapper.Bnd.Bnd_Box
        :type TypeDist: OCC.wrapper.AIS.AIS_TypeOfDist
        :type Position: OCC.wrapper.gp.gp_Pnt
        :type FirstAttach: OCC.wrapper.gp.gp_Pnt
        :type SecondAttach: OCC.wrapper.gp.gp_Pnt
        :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
        :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
        :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ComputeTwoVerticesLength(self, *args)


    def ComputeOneEdgeOneVertexLength(self, *args):
        """
        ComputeOneEdgeOneVertexLength(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_Presentation aPresentation, Handle_Prs3d_Drawer aDrawer, Standard_Real const ArrowSize, TopoDS_Shape FirstShape, TopoDS_Shape SecondShape, Handle_Geom_Plane Plane, Standard_Boolean const AutomaticPos, Standard_Boolean const IsSetBndBox, Bnd_Box BndBox, gp_Pnt Position, gp_Pnt FirstAttach, gp_Pnt SecondAttach, gp_Pnt FirstExtreme, gp_Pnt SecondExtreme)

        Compute the interval location between a vertex and an edge. Edge may be
        a line or a circle.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type ArrowSize: float
        :type FirstShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SecondShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type AutomaticPos: bool
        :type IsSetBndBox: bool
        :type BndBox: OCC.wrapper.Bnd.Bnd_Box
        :type Position: OCC.wrapper.gp.gp_Pnt
        :type FirstAttach: OCC.wrapper.gp.gp_Pnt
        :type SecondAttach: OCC.wrapper.gp.gp_Pnt
        :type FirstExtreme: OCC.wrapper.gp.gp_Pnt
        :type SecondExtreme: OCC.wrapper.gp.gp_Pnt
        :type SymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ComputeOneEdgeOneVertexLength(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_EqualDistanceRelation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_EqualDistanceRelation self, Quantity_Color theColor)

        Allows you to provide settings for the color theColor
        of the lines representing the relation between the two shapes.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_EqualDistanceRelation self)

        Allows you to remove settings for the color of the
        lines representing the relation between the two shapes.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetColor(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_EqualDistanceRelation self) -> AIS_KindOfInteractive

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Type(self, *args)


    def KindOfDimension(self, *args):
        """
        KindOfDimension(Handle_AIS_EqualDistanceRelation self) -> AIS_KindOfDimension

        Indicates that the type of dimension is unknown.

        :rtype: OCC.wrapper.AIS.AIS_KindOfDimension

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_KindOfDimension(self, *args)


    def IsMovable(self, *args):
        """
        IsMovable(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the interactive object is movable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsMovable(self, *args)


    def FirstShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstShape(self, *args):
        """
        SetFirstShape(Handle_AIS_EqualDistanceRelation self, TopoDS_Shape aFShape)

        :type aFShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetFirstShape(self, *args)


    def SecondShape(self, *args):
        """
        Returns the second shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_SecondShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSecondShape(self, *args):
        """
        SetSecondShape(Handle_AIS_EqualDistanceRelation self, TopoDS_Shape aSShape)

        Allows you to identify the second shape aSShape
        relative to the first.

        :type aSShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetSecondShape(self, *args)


    def SetBndBox(self, *args):
        """
        SetBndBox(Handle_AIS_EqualDistanceRelation self, Standard_Real const theXmin, Standard_Real const theYmin, Standard_Real const theZmin, Standard_Real const theXmax, Standard_Real const theYmax, Standard_Real const theZmax)

        :type theXmin: float
        :type theYmin: float
        :type theZmin: float
        :type theXmax: float
        :type theYmax: float
        :type theZmax: float

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetBndBox(self, *args)


    def UnsetBndBox(self, *args):
        """UnsetBndBox(Handle_AIS_EqualDistanceRelation self)"""
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetBndBox(self, *args)


    def Plane(self, *args):
        """
        Returns the plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Plane(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlane(self, *args):
        """
        SetPlane(Handle_AIS_EqualDistanceRelation self, Handle_Geom_Plane thePlane)

        Allows you to set the plane thePlane. This is used to
        define relations and dimensions in several daughter classes.

        :type thePlane: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetPlane(self, *args)


    def Value(self, *args):
        """
        Value(Handle_AIS_EqualDistanceRelation self) -> Standard_Real

        Returns the value of each object in the relation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_AIS_EqualDistanceRelation self, Standard_Real const theVal)

        Allows you to provide settings for the value theVal for each object in the relation.

        :type theVal: float

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetValue(self, *args)


    def Position(self, *args):
        """
        Returns the position set using SetPosition.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(Handle_AIS_EqualDistanceRelation self, gp_Pnt thePosition)

        Allows you to provide the objects in the relation with
        settings for a non-default position.

        :type thePosition: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetPosition(self, *args)


    def Text(self, *args):
        """
        Returns settings for text aspect.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetText(self, *args):
        """
        SetText(Handle_AIS_EqualDistanceRelation self, TCollection_ExtendedString theText)

        Allows you to provide the settings theText for text aspect.

        :type theText: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetText(self, *args)


    def ArrowSize(self, *args):
        """
        ArrowSize(Handle_AIS_EqualDistanceRelation self) -> Standard_Real

        Returns the value for the size of the arrow identifying
        the relation between the two shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ArrowSize(self, *args)


    def SetArrowSize(self, *args):
        """
        SetArrowSize(Handle_AIS_EqualDistanceRelation self, Standard_Real const theArrowSize)

        Allows you to provide settings for the size of the
        arrow theArrowSize identifying the relation between the two shapes.

        :type theArrowSize: float

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetArrowSize(self, *args)


    def SymbolPrs(self, *args):
        """
        SymbolPrs(Handle_AIS_EqualDistanceRelation self) -> DsgPrs_ArrowSide

        Returns the value of the symbol presentation. This will be one of:
        -   AS_NONE - none
        -   AS_FIRSTAR - first arrow
        -   AS_LASTAR - last arrow
        -   AS_BOTHAR - both arrows
        -   AS_FIRSTPT - first point
        -   AS_LASTPT - last point
        -   AS_BOTHPT - both points
        -   AS_FIRSTAR_LASTPT - first arrow, last point
        -   AS_FIRSTPT_LASTAR - first point, last arrow

        :rtype: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SymbolPrs(self, *args)


    def SetSymbolPrs(self, *args):
        """
        SetSymbolPrs(Handle_AIS_EqualDistanceRelation self, DsgPrs_ArrowSide const theSymbolPrs)

        Allows you to provide settings for the symbol presentation.

        :type theSymbolPrs: OCC.wrapper.DsgPrs.DsgPrs_ArrowSide

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetSymbolPrs(self, *args)


    def SetExtShape(self, *args):
        """
        SetExtShape(Handle_AIS_EqualDistanceRelation self, Standard_Integer const theIndex)

        Allows you to set the status of the extension shape by
        the index aIndex.
        The status will be one of the following:
        -   0 - there is no connection to a shape;
        -   1 - there is a connection to the first shape;
        -   2 - there is a connection to the second shape.

        :type theIndex: int

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetExtShape(self, *args)


    def ExtShape(self, *args):
        """
        ExtShape(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Returns the status index of the extension shape.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ExtShape(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_EqualDistanceRelation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the display mode aMode is accepted
        for the Interactive Objects in the relation.
        ComputeProjPresentation(me;
        aPres    : Presentation from Prs3d;
        Curve1   : Curve                from Geom;
        Curve2   : Curve                from Geom;
        FirstP1  : Pnt                  from gp;
        LastP1   : Pnt                  from gp;
        FirstP2  : Pnt                  from gp;
        LastP2   : Pnt                  from gp;
        aColor   : NameOfColor          from Quantity = Quantity_NOC_PURPLE;
        aWidth   : Real                 from Standard = 2;
        aProjTOL : TypeOfLine           from Aspect   = Aspect_TOL_DASH;
        aCallTOL : TypeOfLine           from Aspect   = Aspect_TOL_DOT)

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_AcceptDisplayMode(self, *args)


    def SetAutomaticPosition(self, *args):
        """
        SetAutomaticPosition(Handle_AIS_EqualDistanceRelation self, Standard_Boolean const theStatus)

        :type theStatus: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetAutomaticPosition(self, *args)


    def AutomaticPosition(self, *args):
        """
        AutomaticPosition(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_AutomaticPosition(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_EqualDistanceRelation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_EqualDistanceRelation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_EqualDistanceRelation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_EqualDistanceRelation self)"""
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_EqualDistanceRelation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_EqualDistanceRelation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_EqualDistanceRelation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_EqualDistanceRelation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_EqualDistanceRelation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_EqualDistanceRelation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_EqualDistanceRelation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_EqualDistanceRelation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_EqualDistanceRelation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_EqualDistanceRelation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_EqualDistanceRelation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_EqualDistanceRelation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_EqualDistanceRelation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_EqualDistanceRelation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_EqualDistanceRelation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_EqualDistanceRelation self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_EqualDistanceRelation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_EqualDistanceRelation self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_EqualDistanceRelation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_EqualDistanceRelation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_EqualDistanceRelation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_EqualDistanceRelation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_EqualDistanceRelation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_EqualDistanceRelation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_EqualDistanceRelation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_EqualDistanceRelation self)
        RecomputePrimitives(Handle_AIS_EqualDistanceRelation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_EqualDistanceRelation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_EqualDistanceRelation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_EqualDistanceRelation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_EqualDistanceRelation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_EqualDistanceRelation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_EqualDistanceRelation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_EqualDistanceRelation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_EqualDistanceRelation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_EqualDistanceRelation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_EqualDistanceRelation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_EqualDistanceRelation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_EqualDistanceRelation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_EqualDistanceRelation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_EqualDistanceRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_EqualDistanceRelation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_EqualDistanceRelation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_EqualDistanceRelation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_EqualDistanceRelation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_EqualDistanceRelation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_EqualDistanceRelation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_EqualDistanceRelation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_EqualDistanceRelation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_EqualDistanceRelation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_EqualDistanceRelation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_EqualDistanceRelation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_EqualDistanceRelation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_EqualDistanceRelation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_EqualDistanceRelation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_EqualDistanceRelation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_EqualDistanceRelation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_EqualDistanceRelation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_EqualDistanceRelation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_EqualDistanceRelation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_EqualDistanceRelation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_EqualDistanceRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_EqualDistanceRelation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_EqualDistanceRelation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_EqualDistanceRelation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_EqualDistanceRelation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_EqualDistanceRelation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_EqualDistanceRelation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_EqualDistanceRelation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_EqualDistanceRelation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_EqualDistanceRelation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_EqualDistanceRelation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_EqualDistanceRelation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_EqualDistanceRelation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_EqualDistanceRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_EqualDistanceRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_EqualDistanceRelation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_EqualDistanceRelation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_EqualDistanceRelation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_EqualDistanceRelation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_EqualDistanceRelation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_EqualDistanceRelation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_EqualDistanceRelation_DecrementRefCounter(self, *args)

Handle_AIS_EqualDistanceRelation_swigregister = _AIS.Handle_AIS_EqualDistanceRelation_swigregister
Handle_AIS_EqualDistanceRelation_swigregister(Handle_AIS_EqualDistanceRelation)

def Handle_AIS_EqualDistanceRelation_DownCast(thing):
    return _AIS.Handle_AIS_EqualDistanceRelation_DownCast(thing)
Handle_AIS_EqualDistanceRelation_DownCast = _AIS.Handle_AIS_EqualDistanceRelation_DownCast

class Handle_AIS_Triangulation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Triangulation self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Triangulation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Triangulation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Triangulation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Triangulation self, AIS_Triangulation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Triangulation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Triangulation self, Handle_AIS_Triangulation theHandle) -> Handle_AIS_Triangulation
        assign(Handle_AIS_Triangulation self, AIS_Triangulation thePtr) -> Handle_AIS_Triangulation
        assign(Handle_AIS_Triangulation self, Handle_AIS_Triangulation theHandle) -> Handle_AIS_Triangulation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Triangulation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Triangulation self) -> AIS_Triangulation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Triangulation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Triangulation self) -> AIS_Triangulation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Triangulation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Triangulation self) -> AIS_Triangulation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Triangulation___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Triangulation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Triangulation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Triangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Triangulation_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Triangulation

    def SetColors(self, *args):
        """
        SetColors(Handle_AIS_Triangulation self, Handle_TColStd_HArray1OfInteger aColor)

        Set the color for each node.
        Each 32-bit color is Alpha << 24 + Blue << 16 + Green << 8 + Red
        Order of color components is essential for further usage by OpenGL

        :type aColor: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _AIS.Handle_AIS_Triangulation_SetColors(self, *args)


    def GetColors(self, *args):
        """
        GetColors(Handle_AIS_Triangulation self) -> Handle_TColStd_HArray1OfInteger

        Get the color for each node.
        Each 32-bit color is Alpha << 24 + Blue << 16 + Green << 8 + Red

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _AIS.Handle_AIS_Triangulation_GetColors(self, *args)


    def HasVertexColors(self, *args):
        """
        HasVertexColors(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if triangulation has vertex colors.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasVertexColors(self, *args)


    def SetTriangulation(self, *args):
        """
        SetTriangulation(Handle_AIS_Triangulation self, Handle_Poly_Triangulation aTriangulation)

        :type aTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _AIS.Handle_AIS_Triangulation_SetTriangulation(self, *args)


    def GetTriangulation(self, *args):
        """
        GetTriangulation(Handle_AIS_Triangulation self) -> Handle_Poly_Triangulation

        Returns Poly_Triangulation .

        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _AIS.Handle_AIS_Triangulation_GetTriangulation(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Triangulation self, Standard_Real const aValue=0.6)

        Sets the value aValue for transparency in the reconstructed compound shape.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Triangulation_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Triangulation self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_Triangulation_UnsetTransparency(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Triangulation self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Triangulation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Triangulation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Triangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_AIS_Triangulation self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Triangulation_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_Triangulation self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Triangulation_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Triangulation self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Triangulation self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Triangulation_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Triangulation self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Triangulation_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Triangulation self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Triangulation_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Triangulation self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_Triangulation_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Triangulation self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Triangulation_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_Triangulation self)"""
        return _AIS.Handle_AIS_Triangulation_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Triangulation self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Triangulation self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Triangulation_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Triangulation self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Triangulation_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Triangulation self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Triangulation_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Triangulation self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Triangulation self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Triangulation_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Triangulation self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Triangulation_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Triangulation_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Triangulation self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Triangulation_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Triangulation self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Triangulation_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Triangulation self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Triangulation_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Triangulation self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Triangulation_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Triangulation self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Triangulation_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Triangulation self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Triangulation_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Triangulation self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Triangulation_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Triangulation self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Triangulation_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_Triangulation self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Triangulation_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Triangulation self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Triangulation_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Triangulation self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Triangulation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Triangulation self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Triangulation_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Triangulation self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_Triangulation_UnsetMaterial(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Triangulation self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Triangulation_Transparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Triangulation self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Triangulation_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Triangulation self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Triangulation_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Triangulation self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Triangulation_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Triangulation self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Triangulation_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Triangulation self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Triangulation_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_Triangulation self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Triangulation_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Triangulation self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Triangulation_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Triangulation self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Triangulation_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Triangulation self)
        RecomputePrimitives(Handle_AIS_Triangulation self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Triangulation_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Triangulation self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Triangulation_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Triangulation self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Triangulation_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Triangulation_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Triangulation self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Triangulation_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Triangulation self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Triangulation_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Triangulation self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Triangulation self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Triangulation_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Triangulation_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Triangulation self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Triangulation_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Triangulation self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Triangulation_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Triangulation self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Triangulation_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Triangulation self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Triangulation_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Triangulation self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Triangulation_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Triangulation self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Triangulation_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Triangulation self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Triangulation_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Triangulation self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Triangulation self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Triangulation_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Triangulation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Triangulation_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Triangulation self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Triangulation_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Triangulation self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Triangulation_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Triangulation self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Triangulation_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Triangulation self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Triangulation_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Triangulation self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Triangulation_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Triangulation self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Triangulation_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Triangulation self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Triangulation_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Triangulation self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Triangulation_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Triangulation_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Triangulation self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Triangulation_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Triangulation self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Triangulation_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Triangulation_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Triangulation self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Triangulation self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Triangulation_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Triangulation self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Triangulation_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Triangulation self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Triangulation_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Triangulation self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Triangulation_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Triangulation self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Triangulation self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Triangulation_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Triangulation self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Triangulation_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Triangulation_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Triangulation self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Triangulation self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Triangulation_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Triangulation_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Triangulation_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Triangulation_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Triangulation_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Triangulation self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Triangulation_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Triangulation self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Triangulation_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Triangulation self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Triangulation_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Triangulation self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Triangulation self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Triangulation_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Triangulation_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Triangulation self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Triangulation_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Triangulation self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Triangulation_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Triangulation self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Triangulation_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Triangulation_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Triangulation self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Triangulation self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Triangulation_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Triangulation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Triangulation_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Triangulation_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Triangulation_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Triangulation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Triangulation_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Triangulation_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Triangulation self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Triangulation_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Triangulation self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Triangulation_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Triangulation self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Triangulation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Triangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Triangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Triangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Triangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Triangulation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Triangulation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Triangulation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Triangulation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Triangulation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Triangulation self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Triangulation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Triangulation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Triangulation_DecrementRefCounter(self, *args)

Handle_AIS_Triangulation_swigregister = _AIS.Handle_AIS_Triangulation_swigregister
Handle_AIS_Triangulation_swigregister(Handle_AIS_Triangulation)

def Handle_AIS_Triangulation_DownCast(thing):
    return _AIS.Handle_AIS_Triangulation_DownCast(thing)
Handle_AIS_Triangulation_DownCast = _AIS.Handle_AIS_Triangulation_DownCast

class Handle_AIS_TrihedronOwner(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_TrihedronOwner self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_TrihedronOwner_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_TrihedronOwner self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_TrihedronOwner self, AIS_TrihedronOwner thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_TrihedronOwner_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_TrihedronOwner self, Handle_AIS_TrihedronOwner theHandle) -> Handle_AIS_TrihedronOwner
        assign(Handle_AIS_TrihedronOwner self, AIS_TrihedronOwner thePtr) -> Handle_AIS_TrihedronOwner
        assign(Handle_AIS_TrihedronOwner self, Handle_AIS_TrihedronOwner theHandle) -> Handle_AIS_TrihedronOwner

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_TrihedronOwner_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_TrihedronOwner self) -> AIS_TrihedronOwner

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_TrihedronOwner_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_TrihedronOwner self) -> AIS_TrihedronOwner

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_TrihedronOwner___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_TrihedronOwner self) -> AIS_TrihedronOwner

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_TrihedronOwner___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_TrihedronOwner___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_TrihedronOwner___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_TrihedronOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_TrihedronOwner_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_TrihedronOwner

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_TrihedronOwner self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_TrihedronOwner_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TrihedronOwner_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_TrihedronOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DatumPart(self, *args):
        """
        DatumPart(Handle_AIS_TrihedronOwner self) -> Prs3d_DatumParts

        Returns the datum part identifier.

        :rtype: OCC.wrapper.Prs3d.Prs3d_DatumParts

        """
        return _AIS.Handle_AIS_TrihedronOwner_DatumPart(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(Handle_AIS_TrihedronOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode)

        Highlights selectable object's presentation.

        :type thePM: OCC.wrapper.AIS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _AIS.Handle_AIS_TrihedronOwner_HilightWithColor(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_AIS_TrihedronOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if the presentation manager thePM
        highlights selections corresponding to the selection mode aMode.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsHilighted(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_AIS_TrihedronOwner self, Handle_PrsMgr_PresentationManager thePM, Standard_Integer const theMode)

        Removes highlighting from the owner of a detected
        selectable object in the presentation manager thePM.

        :type thePM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type theMode: int

        """
        return _AIS.Handle_AIS_TrihedronOwner_Unhilight(self, *args)


    def HasSelectable(self, *args):
        """
        HasSelectable(Handle_AIS_TrihedronOwner self) -> Standard_Boolean

        Returns true if there is a selectable object to serve as an owner.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_HasSelectable(self, *args)


    def Selectable(self, *args):
        """
        Selectable(Handle_AIS_TrihedronOwner self) -> Handle_SelectMgr_SelectableObject

        Returns a selectable object detected in the working context.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_TrihedronOwner_Selectable(self, *args)


    def SetSelectable(self, *args):
        """
        SetSelectable(Handle_AIS_TrihedronOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_TrihedronOwner_SetSelectable(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_AIS_TrihedronOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0)

        Clears the owners matching the value of the selection
        mode aMode from the presentation manager object aPM.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int

        """
        return _AIS.Handle_AIS_TrihedronOwner_Clear(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(Handle_AIS_TrihedronOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_HasLocation(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_AIS_TrihedronOwner self, TopLoc_Location aLoc)

        :type aLoc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_TrihedronOwner_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """ResetLocation(Handle_AIS_TrihedronOwner self)"""
        return _AIS.Handle_AIS_TrihedronOwner_ResetLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_AIS_TrihedronOwner self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _AIS.Handle_AIS_TrihedronOwner_Location(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_AIS_TrihedronOwner self, Standard_Boolean const theIsSelected)

        Set the state of the owner.
        @param theIsSelected [in] shows if owner is selected.

        :type theIsSelected: bool

        """
        return _AIS.Handle_AIS_TrihedronOwner_SetSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_AIS_TrihedronOwner self) -> Standard_Boolean

        @return Standard_True if the owner is selected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsSelected(self, *args)


    def State(self, *args):
        """
        State(Handle_AIS_TrihedronOwner self, Standard_Integer const theStatus)
        State(Handle_AIS_TrihedronOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TrihedronOwner_State(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_TrihedronOwner self) -> Standard_Boolean

        if owner is not auto hilighted, for group contains many such owners
        will be called one method HilightSelected of SelectableObject

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsAutoHilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(Handle_AIS_TrihedronOwner self) -> Standard_Boolean

        if this method returns TRUE the owner will allways call method
        Hilight for SelectableObject when the owner is detected. By default
        it always return FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsForcedHilight(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_TrihedronOwner self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_TrihedronOwner_SetZLayer(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(Handle_AIS_TrihedronOwner self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentationManager theManager, Standard_Integer const theDispMode)

        Implements immediate application of location transformation of parent object to dynamic highlight structure

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theManager: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theDispMode: int

        """
        return _AIS.Handle_AIS_TrihedronOwner_UpdateHighlightTrsf(self, *args)


    def IsSameSelectable(self, *args):
        """
        IsSameSelectable(Handle_AIS_TrihedronOwner self, Handle_SelectMgr_SelectableObject theOther) -> Standard_Boolean

        Returns true if pointer to selectable object of this owner is equal to the given one

        :type theOther: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsSameSelectable(self, *args)


    def ComesFromDecomposition(self, *args):
        """
        ComesFromDecomposition(Handle_AIS_TrihedronOwner self) -> Standard_Boolean

        Returns TRUE if this owner points to a part of object and FALSE for entire object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_ComesFromDecomposition(self, *args)


    def SetComesFromDecomposition(self, *args):
        """
        SetComesFromDecomposition(Handle_AIS_TrihedronOwner self, Standard_Boolean const theIsFromDecomposition)

        Sets flag indicating this owner points to a part of object (TRUE) or to entire object (FALSE).

        :type theIsFromDecomposition: bool

        """
        return _AIS.Handle_AIS_TrihedronOwner_SetComesFromDecomposition(self, *args)


    def Set(self, *args):
        """
        Set(Handle_AIS_TrihedronOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _AIS.Handle_AIS_TrihedronOwner_Set(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(Handle_AIS_TrihedronOwner self, Standard_Integer const thePriority)

        sets the selectable priority of the owner

        :type thePriority: int

        """
        return _AIS.Handle_AIS_TrihedronOwner_SetPriority(self, *args)


    def Priority(self, *args):
        """
        Priority(Handle_AIS_TrihedronOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TrihedronOwner_Priority(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_TrihedronOwner self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_TrihedronOwner_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_TrihedronOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_TrihedronOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_TrihedronOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_TrihedronOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_TrihedronOwner_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_TrihedronOwner self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_TrihedronOwner_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_TrihedronOwner self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TrihedronOwner_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_TrihedronOwner self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_TrihedronOwner_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_TrihedronOwner self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_TrihedronOwner_DecrementRefCounter(self, *args)

Handle_AIS_TrihedronOwner_swigregister = _AIS.Handle_AIS_TrihedronOwner_swigregister
Handle_AIS_TrihedronOwner_swigregister(Handle_AIS_TrihedronOwner)

def Handle_AIS_TrihedronOwner_DownCast(thing):
    return _AIS.Handle_AIS_TrihedronOwner_DownCast(thing)
Handle_AIS_TrihedronOwner_DownCast = _AIS.Handle_AIS_TrihedronOwner_DownCast

class NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,opencascade::handle< AIS_LocalStatus >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,opencascade::handle< AIS_LocalStatus >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,opencascade::handle< AIS_LocalStatus >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< SelectMgr_SelectableObject >,opencascade::handle< AIS_LocalStatus >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _AIS.new_NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey, Handle_AIS_LocalStatus theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey, Handle_AIS_LocalStatus theItem) -> Handle_AIS_LocalStatus

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> Handle_AIS_LocalStatus

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> Handle_AIS_LocalStatus

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_SelectMgr_SelectableObject theKey) -> Handle_AIS_LocalStatus

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher
NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_swigregister = _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper_swigregister = _AIS.NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher_IteratorHelper)


try:
	AIS_DataMapOfSelStat = NCollection_DataMap_Handle_SelectMgr_SelectableObject_Handle_AIS_LocalStatus_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_PointCloud(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_PointCloud self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_PointCloud_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_PointCloud self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_PointCloud_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_PointCloud self, AIS_PointCloud thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_PointCloud_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_PointCloud self, Handle_AIS_PointCloud theHandle) -> Handle_AIS_PointCloud
        assign(Handle_AIS_PointCloud self, AIS_PointCloud thePtr) -> Handle_AIS_PointCloud
        assign(Handle_AIS_PointCloud self, Handle_AIS_PointCloud theHandle) -> Handle_AIS_PointCloud

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_PointCloud_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_PointCloud self) -> AIS_PointCloud

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_PointCloud_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_PointCloud self) -> AIS_PointCloud

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_PointCloud___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_PointCloud self) -> AIS_PointCloud

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_PointCloud___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_PointCloud___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_PointCloud___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_PointCloud(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_PointCloud_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_PointCloud

    def SetPoints(self, *args):
        """
        SetPoints(Handle_AIS_PointCloud self, Handle_Graphic3d_ArrayOfPoints thePoints)
        SetPoints(Handle_AIS_PointCloud self, Handle_TColgp_HArray1OfPnt theCoords, Handle_Quantity_HArray1OfColor theColors=0, Handle_TColgp_HArray1OfDir theNormals=0)

        Sets the points with optional colors.
        The input data will be copied into internal buffer.
        The input arrays should have equal length, otherwise
        the presentation will not be computed and displayed.
        @param theCoords  [in] the array of coordinates
        @param theColors  [in] optional array of colors
        @param theNormals [in] optional array of normals

        :type theCoords: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt
        :type theColors: OCC.wrapper.Quantity.Handle_Quantity_HArray1OfColor
        :type theNormals: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfDir

        """
        return _AIS.Handle_AIS_PointCloud_SetPoints(self, *args)


    def GetPoints(self, *args):
        """
        GetPoints(Handle_AIS_PointCloud self) -> Handle_Graphic3d_ArrayOfPoints

        Get the points array.
        Method might be overridden to fill in points array dynamically from application data structures.
        @return the array of points

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPoints

        """
        return _AIS.Handle_AIS_PointCloud_GetPoints(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(Handle_AIS_PointCloud self) -> Bnd_Box

        Get bounding box for presentation.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_PointCloud_GetBoundingBox(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_PointCloud self, Quantity_Color theColor)

        Setup custom color. Affects presentation only when no per-point color attribute has been assigned.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_PointCloud_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_PointCloud self)

        Restore default color.


        """
        return _AIS.Handle_AIS_PointCloud_UnsetColor(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_PointCloud self, Graphic3d_MaterialAspect theMat)

        Setup custom material. Affects presentation only when normals are defined.

        :type theMat: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_PointCloud_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_PointCloud self)

        Restore default material.


        """
        return _AIS.Handle_AIS_PointCloud_UnsetMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_PointCloud self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_PointCloud_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_PointCloud_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_PointCloud_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DisplayMode(self):
        return _AIS.Handle_AIS_PointCloud_DisplayMode(self)

    def Type(self, *args):
        """
        Type(Handle_AIS_PointCloud self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_PointCloud_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_PointCloud self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PointCloud_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_PointCloud self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_PointCloud self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_PointCloud_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_PointCloud self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_PointCloud_CurrentFacingModel(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_PointCloud self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_PointCloud_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_PointCloud self)"""
        return _AIS.Handle_AIS_PointCloud_UnsetWidth(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_PointCloud self, Standard_Integer const aMode) -> Standard_Boolean

        Returns true if the class of objects accepts the display mode aMode.
        The interactive context can have a default mode of
        representation for the set of Interactive Objects. This
        mode may not be accepted by a given class of
        objects. Consequently, this virtual method allowing us
        to get information about the class in question must be implemented.

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_AcceptDisplayMode(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_PointCloud self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PointCloud_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_PointCloud self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_PointCloud_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_PointCloud self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_PointCloud_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_PointCloud self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_PointCloud self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_PointCloud_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_PointCloud self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_PointCloud_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_PointCloud_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_PointCloud self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_PointCloud_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_PointCloud self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_PointCloud_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_PointCloud self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_PointCloud_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_PointCloud self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_PointCloud_UnsetDisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_PointCloud self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PointCloud_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_PointCloud self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PointCloud_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_PointCloud self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_PointCloud_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_PointCloud self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_PointCloud_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_PointCloud self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PointCloud_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_PointCloud self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_PointCloud_Material(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_PointCloud self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_PointCloud_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_PointCloud self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_PointCloud_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_PointCloud self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_PointCloud_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_PointCloud self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_PointCloud_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_PointCloud self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PointCloud_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_PointCloud self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_PointCloud_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_PointCloud self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_PointCloud_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_PointCloud self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_PointCloud_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_PointCloud self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_PointCloud_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_PointCloud self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_PointCloud_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_PointCloud self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_PointCloud_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_PointCloud self)
        RecomputePrimitives(Handle_AIS_PointCloud self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PointCloud_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_PointCloud self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_PointCloud_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_PointCloud self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_PointCloud_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_PointCloud_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_PointCloud self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_PointCloud_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_PointCloud self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_PointCloud_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_PointCloud self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_PointCloud self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_PointCloud_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_PointCloud_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_PointCloud self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_PointCloud_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_PointCloud self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_PointCloud_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_PointCloud self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_PointCloud_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_PointCloud self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_PointCloud_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_PointCloud self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_PointCloud_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_PointCloud self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_PointCloud_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_PointCloud self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_PointCloud_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_PointCloud self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_PointCloud self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_PointCloud_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_PointCloud self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PointCloud_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_PointCloud self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_PointCloud_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_PointCloud self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_PointCloud_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_PointCloud self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_PointCloud_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_PointCloud self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_PointCloud_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_PointCloud self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_PointCloud_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_PointCloud self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_PointCloud_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_PointCloud self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PointCloud_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_PointCloud self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_PointCloud_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_PointCloud_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_PointCloud self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_PointCloud_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_PointCloud self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_PointCloud_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_PointCloud_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_PointCloud self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_PointCloud self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_PointCloud_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_PointCloud self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_PointCloud_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_PointCloud self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_PointCloud_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_PointCloud self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_PointCloud_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_PointCloud self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_PointCloud self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_PointCloud_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_PointCloud self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_PointCloud_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_PointCloud_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_PointCloud self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_PointCloud self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_PointCloud_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_PointCloud_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_PointCloud_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_PointCloud_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_PointCloud_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_PointCloud self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_PointCloud_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_PointCloud self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_PointCloud_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_PointCloud self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_PointCloud_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_PointCloud self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_PointCloud self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_PointCloud_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_PointCloud_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_PointCloud self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_PointCloud_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_PointCloud self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_PointCloud_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_PointCloud self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_PointCloud_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_PointCloud_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_PointCloud self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_PointCloud self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_PointCloud_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_PointCloud self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PointCloud_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PointCloud_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PointCloud_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_PointCloud self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PointCloud_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_PointCloud_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_PointCloud self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_PointCloud_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_PointCloud self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_PointCloud_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_PointCloud self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_PointCloud_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_PointCloud self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_PointCloud self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_PointCloud self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_PointCloud self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_PointCloud_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_PointCloud self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_PointCloud_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_PointCloud self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PointCloud_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_PointCloud self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_PointCloud_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_PointCloud self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_PointCloud_DecrementRefCounter(self, *args)

Handle_AIS_PointCloud_swigregister = _AIS.Handle_AIS_PointCloud_swigregister
Handle_AIS_PointCloud_swigregister(Handle_AIS_PointCloud)

def Handle_AIS_PointCloud_DownCast(thing):
    return _AIS.Handle_AIS_PointCloud_DownCast(thing)
Handle_AIS_PointCloud_DownCast = _AIS.Handle_AIS_PointCloud_DownCast

class NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< AIS_InteractiveObject >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< AIS_InteractiveObject >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _AIS.new_NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject K) -> Standard_Boolean
        Contains(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher self, NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_Differ(self, *args)


    def __iter__(self):
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher
NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_swigregister = _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_swigregister
NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_swigregister(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher)

class NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper_swigregister = _AIS.NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher_IteratorHelper)


try:
	AIS_MapOfInteractive = NCollection_Map_Handle_AIS_InteractiveObject_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_Shape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_Shape self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_Shape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_Shape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_Shape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_Shape self, AIS_Shape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_Shape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_Shape self, Handle_AIS_Shape theHandle) -> Handle_AIS_Shape
        assign(Handle_AIS_Shape self, AIS_Shape thePtr) -> Handle_AIS_Shape
        assign(Handle_AIS_Shape self, Handle_AIS_Shape theHandle) -> Handle_AIS_Shape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_Shape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_Shape self) -> AIS_Shape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_Shape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_Shape self) -> AIS_Shape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_Shape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_Shape self) -> AIS_Shape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_Shape___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_Shape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_Shape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_Shape_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_Shape

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_Shape self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_Shape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Shape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_Shape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Signature(self, *args):
        """
        Signature(Handle_AIS_Shape self) -> Standard_Integer

        Returns index 0. This value refers to SHAPE from TopAbs_ShapeEnum

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_AIS_Shape self) -> AIS_KindOfInteractive

        Returns Object as the type of Interactive Object.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_Shape_Type(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the Interactive Object accepts shape decomposition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_AcceptShapeDecomposition(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_Shape self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if specified display mode is supported.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_AcceptDisplayMode(self, *args)


    def Shape(self, *args):
        """
        Returns this shape object.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _AIS.Handle_AIS_Shape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape(self, *args):
        """
        SetShape(Handle_AIS_Shape self, TopoDS_Shape theShape)

        Constructs an instance of the shape object theShape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Shape_SetShape(self, *args)


    def Set(self, *args):
        """
        Set(Handle_AIS_Shape self, TopoDS_Shape theShape)

        Alias for ::SetShape().

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _AIS.Handle_AIS_Shape_Set(self, *args)


    def SetOwnDeviationCoefficient(self, *args):
        """
        SetOwnDeviationCoefficient(Handle_AIS_Shape self) -> Standard_Boolean
        SetOwnDeviationCoefficient(Handle_AIS_Shape self, Standard_Real const aCoefficient)

        Sets a local value for deviation coefficient for this specific shape.

        :type aCoefficient: float

        """
        return _AIS.Handle_AIS_Shape_SetOwnDeviationCoefficient(self, *args)


    def SetOwnHLRDeviationCoefficient(self, *args):
        """
        SetOwnHLRDeviationCoefficient(Handle_AIS_Shape self) -> Standard_Boolean
        SetOwnHLRDeviationCoefficient(Handle_AIS_Shape self, Standard_Real const aCoefficient)

        sets myOwnHLRDeviationCoefficient field in Prs3d_Drawer &
        recomputes presentation

        :type aCoefficient: float

        """
        return _AIS.Handle_AIS_Shape_SetOwnHLRDeviationCoefficient(self, *args)


    def SetOwnDeviationAngle(self, *args):
        """
        SetOwnDeviationAngle(Handle_AIS_Shape self) -> Standard_Boolean
        SetOwnDeviationAngle(Handle_AIS_Shape self, Standard_Real const anAngle)

        sets myOwnDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.Handle_AIS_Shape_SetOwnDeviationAngle(self, *args)


    def SetOwnHLRDeviationAngle(self, *args):
        """
        SetOwnHLRDeviationAngle(Handle_AIS_Shape self) -> Standard_Boolean
        SetOwnHLRDeviationAngle(Handle_AIS_Shape self, Standard_Real const anAngle)

        sets myOwnHLRDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _AIS.Handle_AIS_Shape_SetOwnHLRDeviationAngle(self, *args)


    def SetAngleAndDeviation(self, *args):
        """
        SetAngleAndDeviation(Handle_AIS_Shape self, Standard_Real const anAngle)

        this compute a new angle and Deviation from the value anAngle
        and set the values stored in myDrawer with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.Handle_AIS_Shape_SetAngleAndDeviation(self, *args)


    def UserAngle(self, *args):
        """
        UserAngle(Handle_AIS_Shape self) -> Standard_Real

        gives back the angle initial value put by the User.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Shape_UserAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args):
        """
        SetHLRAngleAndDeviation(Handle_AIS_Shape self, Standard_Real const anAngle)

        this compute a new Angle and Deviation from the value anAngle for HLR
        and set the values stored in myDrawer for with these that become local to the shape

        :type anAngle: float

        """
        return _AIS.Handle_AIS_Shape_SetHLRAngleAndDeviation(self, *args)


    def OwnDeviationCoefficient(self, *args):
        """
        OwnDeviationCoefficient(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true and the values of the deviation
        coefficient aCoefficient and the previous deviation
        coefficient aPreviousCoefficient. If these values are
        not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_OwnDeviationCoefficient(self, *args)


    def OwnHLRDeviationCoefficient(self, *args):
        """
        OwnHLRDeviationCoefficient(Handle_AIS_Shape self) -> Standard_Boolean

        Returns   true and the values of the HLR deviation
        coefficient aCoefficient and the previous HLR
        deviation coefficient aPreviousCoefficient. If these
        values are not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_OwnHLRDeviationCoefficient(self, *args)


    def OwnDeviationAngle(self, *args):
        """
        OwnDeviationAngle(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true and the values of the deviation angle
        anAngle and the previous deviation angle aPreviousAngle.
        If these values are not already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_OwnDeviationAngle(self, *args)


    def OwnHLRDeviationAngle(self, *args):
        """
        OwnHLRDeviationAngle(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true and the values   of the HLR deviation
        angle anAngle and of the previous HLR deviation
        angle aPreviousAngle. If these values are not
        already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_OwnHLRDeviationAngle(self, *args)


    def SetTypeOfHLR(self, *args):
        """
        SetTypeOfHLR(Handle_AIS_Shape self, Prs3d_TypeOfHLR const theTypeOfHLR)

        Sets the type of HLR algorithm used by the shape

        :type theTypeOfHLR: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_Shape_SetTypeOfHLR(self, *args)


    def TypeOfHLR(self, *args):
        """
        TypeOfHLR(Handle_AIS_Shape self) -> Prs3d_TypeOfHLR

        Gets the type of HLR algorithm

        :rtype: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_Shape_TypeOfHLR(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_Shape self, Quantity_Color theColor)

        Sets the color aColor in the reconstructed
        compound shape. Acts via the Drawer methods below on the appearance of:
        -   free boundaries:
        Prs3d_Drawer_FreeBoundaryAspect,
        -   isos: Prs3d_Drawer_UIsoAspect,
        Prs3dDrawer_VIsoAspect,
        -   shared boundaries:
        Prs3d_Drawer_UnFreeBoundaryAspect,
        -   shading: Prs3d_Drawer_ShadingAspect,
        -   visible line color in hidden line mode:
        Prs3d_Drawer_SeenLineAspect
        -   hidden line color in hidden line mode:
        Prs3d_Drawer_HiddenLineAspect.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Shape_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_Shape self)

        Removes settings for color in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_Shape_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_Shape self, Standard_Real const aValue)

        Sets the value aValue for line width in the reconstructed compound shape.
        Changes line aspects for lines-only presentation modes like Wireframe and Bounding Box.
        Doesn't change face boundary line aspect.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Shape_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_AIS_Shape self)

        Removes the setting for line width in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_Shape_UnsetWidth(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_Shape self, Graphic3d_MaterialAspect aName)

        Allows you to provide settings for the material aName
        in the reconstructed compound shape.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_Shape_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_Shape self)

        Removes settings for material in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_Shape_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_Shape self, Standard_Real const aValue=0.6)

        Sets the value aValue for transparency in the reconstructed compound shape.

        :type aValue: float

        """
        return _AIS.Handle_AIS_Shape_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_Shape self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _AIS.Handle_AIS_Shape_UnsetTransparency(self, *args)


    def BoundingBox(self, *args):
        """
        Constructs a bounding box with which to reconstruct
        compound topological shapes for presentation.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _AIS.Handle_AIS_Shape_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Color(self, *args):
        """
        Color(Handle_AIS_Shape self, Quantity_Color aColor)

        Returns the Color attributes of the shape accordingly to
        the current facing model;

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_Shape_Color(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_Shape self) -> Graphic3d_NameOfMaterial

        Returns the NameOfMaterial attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_Shape_Material(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_Shape self) -> Standard_Real

        Returns the transparency attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Shape_Transparency(self, *args)


    def SelectionType(self, *args):
        """
        SelectionType(Handle_AIS_Shape self, Standard_Integer const theSelMode) -> TopAbs_ShapeEnum

        Return shape type for specified selection mode.

        :type theSelMode: int
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _AIS.Handle_AIS_Shape_SelectionType(self, *args)


    def SelectionMode(self, *args):
        """
        SelectionMode(Handle_AIS_Shape self, TopAbs_ShapeEnum const theShapeType) -> Standard_Integer

        Return selection mode for specified shape type.

        :type theShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_SelectionMode(self, *args)


    def TextureRepeatUV(self, *args):
        """
        Return texture repeat UV values; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_Shape_TextureRepeatUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureRepeatUV(self, *args):
        """
        SetTextureRepeatUV(Handle_AIS_Shape self, gp_Pnt2d theRepeatUV)

        Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1).
        Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax).

        :type theRepeatUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_Shape_SetTextureRepeatUV(self, *args)


    def TextureOriginUV(self, *args):
        """
        Return texture origin UV position; (0, 0) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_Shape_TextureOriginUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureOriginUV(self, *args):
        """
        SetTextureOriginUV(Handle_AIS_Shape self, gp_Pnt2d theOriginUV)

        Use this method to change the origin of the texture.
        The texel (0,0) will be mapped to the surface (myUVOrigin.X(), myUVOrigin.Y()).

        :type theOriginUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_Shape_SetTextureOriginUV(self, *args)


    def TextureScaleUV(self, *args):
        """
        Return scale factor for UV coordinates; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _AIS.Handle_AIS_Shape_TextureScaleUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureScaleUV(self, *args):
        """
        SetTextureScaleUV(Handle_AIS_Shape self, gp_Pnt2d theScaleUV)

        Use this method to scale the texture (percent of the face).
        You can specify a scale factor for both U and V.
        Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat,
        the texture will appear twice on the face in each direction.

        :type theScaleUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _AIS.Handle_AIS_Shape_SetTextureScaleUV(self, *args)


    def computeHlrPresentation(self, *args):
        """
        computeHlrPresentation(Handle_AIS_Shape self, Handle_Prs3d_Projector theProjector, Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

        Compute HLR presentation for specified shape.

        :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Shape_computeHlrPresentation(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_Shape self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Shape_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_Shape self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_Shape_CurrentFacingModel(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_Shape self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_Shape self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_Shape_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_Shape self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_Shape_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_Shape self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_Shape self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Shape_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_Shape self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_Shape_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_Shape_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_Shape self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_Shape_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_Shape self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_Shape_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_Shape self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_Shape_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_Shape self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_Shape_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_Shape self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_Shape self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_Shape self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Shape_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_Shape self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_Shape_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasColor(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_Shape self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_Shape_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasMaterial(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_IsTransparent(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_Shape self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_Shape_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_Shape self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_Shape self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Shape_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_Shape self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_Shape_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_Shape self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Shape_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_Shape self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_Shape self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_Shape_PolygonOffsets(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_Shape self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_Shape_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_Shape self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_Shape_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_Shape self)
        RecomputePrimitives(Handle_AIS_Shape self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Shape_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_Shape self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_Shape_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_Shape self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_Shape_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Shape_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_Shape self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_Shape_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_Shape self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Shape_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_Shape self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_Shape self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_Shape_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_Shape_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_Shape self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_Shape_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_Shape self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_Shape_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_Shape self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_Shape_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_Shape self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_Shape_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_Shape self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_Shape_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_Shape self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_Shape_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_Shape self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Shape_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_Shape self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_Shape self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_Shape_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_Shape self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Shape_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_Shape self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_Shape_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_Shape self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_Shape_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_Shape self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Shape_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_Shape self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_Shape_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_Shape self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_Shape_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_Shape self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_Shape_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_Shape self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_Shape self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_Shape_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_Shape_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_Shape self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_Shape_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_Shape self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Shape_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_Shape_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_Shape self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_Shape self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Shape_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_Shape self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_Shape_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_Shape self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_Shape_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_Shape self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_Shape_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_Shape self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_Shape self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_Shape_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_Shape self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_Shape_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Shape_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_Shape self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_Shape self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_Shape_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_Shape_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Shape_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_Shape_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_Shape_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_Shape self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_Shape_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_Shape self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Shape_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_Shape self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_Shape_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_Shape self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_Shape self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_Shape_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_Shape_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_Shape self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_Shape_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_Shape self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Shape_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_Shape self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_Shape_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_Shape_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_Shape self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_Shape self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_Shape_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_Shape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Shape_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Shape_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Shape_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_Shape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Shape_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_Shape_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_Shape self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_Shape_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_Shape self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_Shape_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_Shape self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_Shape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_Shape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_Shape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_Shape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_Shape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_Shape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_Shape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_Shape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_Shape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_Shape self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_Shape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_Shape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_Shape_DecrementRefCounter(self, *args)

Handle_AIS_Shape_swigregister = _AIS.Handle_AIS_Shape_swigregister
Handle_AIS_Shape_swigregister(Handle_AIS_Shape)

def Handle_AIS_Shape_DownCast(thing):
    return _AIS.Handle_AIS_Shape_DownCast(thing)
Handle_AIS_Shape_DownCast = _AIS.Handle_AIS_Shape_DownCast

class Handle_PrsMgr_PresentationManager3d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_PrsMgr_PresentationManager3d self)

        Nullify the handle


        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_PrsMgr_PresentationManager3d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_PrsMgr_PresentationManager3d self, PrsMgr_PresentationManager thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentationManager theHandle) -> Handle_PrsMgr_PresentationManager
        assign(Handle_PrsMgr_PresentationManager3d self, PrsMgr_PresentationManager thePtr) -> Handle_PrsMgr_PresentationManager
        assign(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentationManager theHandle) -> Handle_PrsMgr_PresentationManager

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_PrsMgr_PresentationManager3d self) -> PrsMgr_PresentationManager

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_PrsMgr_PresentationManager3d self) -> PrsMgr_PresentationManager

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_PrsMgr_PresentationManager3d self) -> PrsMgr_PresentationManager

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_PrsMgr_PresentationManager3d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_PrsMgr_PresentationManager3d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_PrsMgr_PresentationManager3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_PrsMgr_PresentationManager3d_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_PrsMgr_PresentationManager3d

    def get_type_name(self, *args):
        """
        get_type_name(Handle_PrsMgr_PresentationManager3d self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_PrsMgr_PresentationManager3d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_PrsMgr_PresentationManager3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Display(self, *args):
        """
        Display(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0)

        Displays the presentation of the object in the given Presentation manager with the given mode.
        The mode should be enumerated by the object which inherits PresentableObject.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Display(self, *args)


    def Erase(self, *args):
        """
        Erase(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0)

        erases the presentation of the object in the given
        Presentation manager with the given mode.
        If @theMode is -1, then erases all presentations of the object.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Erase(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0)

        Clears the presentation of the presentable object thePrsObject in this framework with the display mode theMode.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Clear(self, *args)


    def SetVisibility(self, *args):
        """
        SetVisibility(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode, Standard_Boolean const theValue)

        Sets the visibility of presentable object.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :type theValue: bool

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_SetVisibility(self, *args)


    def Unhighlight(self, *args):
        """
        Unhighlight(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject)
        Unhighlight(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode)

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Unhighlight(self, *args)


    def SetDisplayPriority(self, *args):
        """
        SetDisplayPriority(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode, Standard_Integer const theNewPrior)

        Sets the display priority theNewPrior of the
        presentable object thePrsObject in this framework with the display mode theMode.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :type theNewPrior: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_SetDisplayPriority(self, *args)


    def DisplayPriority(self, *args):
        """
        DisplayPriority(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode) -> Standard_Integer

        Returns the display priority of the presentable object
        thePrsObject in this framework with the display mode theMode.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_DisplayPriority(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID for all presentations of the object.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_SetZLayer(self, *args)


    def GetZLayer(self, *args):
        """
        GetZLayer(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject) -> Graphic3d_ZLayerId

        Get Z layer ID assigned to all presentations of the object.
        Method returns -1 value if object has no presentations and is
        impossible to get layer index.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_GetZLayer(self, *args)


    def IsDisplayed(self, *args):
        """
        IsDisplayed(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0) -> Standard_Boolean

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_IsDisplayed(self, *args)


    def IsHighlighted(self, *args):
        """
        IsHighlighted(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0) -> Standard_Boolean

        Returns true if the presentation of the presentable
        object thePrsObject in this framework with the display mode theMode is highlighted.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_IsHighlighted(self, *args)


    def Update(self, *args):
        """
        Update(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0)

        Updates the presentation of the presentable object
        thePrsObject in this framework with the display mode theMode.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Update(self, *args)


    def BeginImmediateDraw(self, *args):
        """
        BeginImmediateDraw(Handle_PrsMgr_PresentationManager3d self)

        Resets the transient list of presentations previously displayed in immediate mode
        and begins accumulation of new list by following AddToImmediateList()/Color()/Highlight() calls.


        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_BeginImmediateDraw(self, *args)


    def ClearImmediateDraw(self, *args):
        """
        ClearImmediateDraw(Handle_PrsMgr_PresentationManager3d self)

        Resets the transient list of presentations previously displayed in immediate mode.


        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_ClearImmediateDraw(self, *args)


    def AddToImmediateList(self, *args):
        """
        AddToImmediateList(Handle_PrsMgr_PresentationManager3d self, Handle_Prs3d_Presentation thePrs)

        Stores thePrs in the transient list of presentations to be displayed in immediate mode.
        Will be taken in account in EndImmediateDraw method.

        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_AddToImmediateList(self, *args)


    def EndImmediateDraw(self, *args):
        """
        EndImmediateDraw(Handle_PrsMgr_PresentationManager3d self, Handle_V3d_Viewer theViewer)

        Allows rapid drawing of the each view in theViewer by avoiding an update of the whole background.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_EndImmediateDraw(self, *args)


    def RedrawImmediate(self, *args):
        """
        RedrawImmediate(Handle_PrsMgr_PresentationManager3d self, Handle_V3d_Viewer theViewer)

        Clears and redisplays immediate structures of the viewer taking into account its affinity.

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_RedrawImmediate(self, *args)


    def IsImmediateModeOn(self, *args):
        """
        IsImmediateModeOn(Handle_PrsMgr_PresentationManager3d self) -> Standard_Boolean

        Returns true if Presentation Manager is accumulating transient list of presentations to be displayed in immediate mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_IsImmediateModeOn(self, *args)


    def Color(self, *args):
        """
        Color(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode=0, Handle_PrsMgr_PresentableObject theSelObj=0, Graphic3d_ZLayerId const theImmediateStructLayerId=Graphic3d_ZLayerId_Topmost)

        Highlights the graphic object thePrsObject in the color theColor.
        thePrsObject has the display mode theMode;
        this has the default value of 0, that is, the wireframe display mode.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int
        :type theSelObj: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theImmediateStructLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Color(self, *args)


    def Connect(self, *args):
        """
        Connect(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Handle_PrsMgr_PresentableObject theOtherObject, Standard_Integer const theMode=0, Standard_Integer const theOtherMode=0)

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theOtherObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :type theOtherMode: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Connect(self, *args)


    def Transform(self, *args):
        """
        Transform(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Handle_Geom_Transformation theTransformation, Standard_Integer const theMode=0)

        Sets the transformation theTransformation for the presentable object thePrsObject.
        thePrsObject has the display mode theMode; this has the default value of 0, that is, the wireframe display mode.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theTransformation: OCC.wrapper.Geom.Handle_Geom_Transformation
        :type theMode: int

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Transform(self, *args)


    def StructureManager(self, *args):
        """
        Returns the structure manager.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_StructureManager

        """
        res = _AIS.Handle_PrsMgr_PresentationManager3d_StructureManager(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0) -> Standard_Boolean

        Returns true if there is a presentation of the
        presentable object thePrsObject in this framework, thePrsObject having the display mode theMode.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_PrsMgr_PresentationManager3d self, Handle_PrsMgr_PresentableObject thePrsObject, Standard_Integer const theMode=0, Standard_Boolean const theToCreate, Handle_PrsMgr_PresentableObject theSelObj=0) -> Handle_PrsMgr_Presentation

        Returns the presentation Presentation of the presentable object thePrsObject in this framework.
        When theToCreate is true - automatically creates presentation for specified mode when not exist.
        Optional argument theSelObj specifies parent decomposed object to inherit its view affinity.

        :type thePrsObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :type theToCreate: bool
        :type theSelObj: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :rtype: OCC.wrapper.PrsMgr.Handle_PrsMgr_Presentation

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Presentation(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(Handle_PrsMgr_PresentationManager3d self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentableObject theObj, Standard_Integer const theMode=0, Handle_PrsMgr_PresentableObject theSelObj=0)

        Allows to apply location transformation to shadow highlight presentation immediately.
        @param theObj defines the base object, it local transformation will be applied to corresponding highlight structure
        @param theMode defines display mode of the base object
        @param theSelObj defines the object produced after decomposition of the base object for local selection

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theObj: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject
        :type theMode: int
        :type theSelObj: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_UpdateHighlightTrsf(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_PrsMgr_PresentationManager3d self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_PrsMgr_PresentationManager3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_PrsMgr_PresentationManager3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_PrsMgr_PresentationManager3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_PrsMgr_PresentationManager3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_PrsMgr_PresentationManager3d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_PrsMgr_PresentationManager3d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_PrsMgr_PresentationManager3d self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_PrsMgr_PresentationManager3d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_PrsMgr_PresentationManager3d_DecrementRefCounter(self, *args)

Handle_PrsMgr_PresentationManager3d_swigregister = _AIS.Handle_PrsMgr_PresentationManager3d_swigregister
Handle_PrsMgr_PresentationManager3d_swigregister(Handle_PrsMgr_PresentationManager3d)

def Handle_PrsMgr_PresentationManager3d_DownCast(thing):
    return _AIS.Handle_PrsMgr_PresentationManager3d_DownCast(thing)
Handle_PrsMgr_PresentationManager3d_DownCast = _AIS.Handle_PrsMgr_PresentationManager3d_DownCast

class NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< AIS_InteractiveObject >,opencascade::handle< AIS_GlobalStatus >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< AIS_InteractiveObject >,opencascade::handle< AIS_GlobalStatus >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< AIS_InteractiveObject >,opencascade::handle< AIS_GlobalStatus >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< AIS_InteractiveObject >,opencascade::handle< AIS_GlobalStatus >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _AIS.new_NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject theKey, Handle_AIS_GlobalStatus theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject theKey, Handle_AIS_GlobalStatus theItem) -> Handle_AIS_GlobalStatus

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject theKey) -> Handle_AIS_GlobalStatus

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject theKey) -> Handle_AIS_GlobalStatus

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_AIS_InteractiveObject theKey) -> Handle_AIS_GlobalStatus

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher
NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_swigregister = _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _AIS.new_NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AIS.delete_NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper_swigregister = _AIS.NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher_IteratorHelper)


try:
	AIS_DataMapOfIOStatus = NCollection_DataMap_Handle_AIS_InteractiveObject_Handle_AIS_GlobalStatus_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_AIS_ConnectedInteractive(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ConnectedInteractive self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ConnectedInteractive_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ConnectedInteractive self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ConnectedInteractive self, AIS_ConnectedInteractive thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ConnectedInteractive_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ConnectedInteractive self, Handle_AIS_ConnectedInteractive theHandle) -> Handle_AIS_ConnectedInteractive
        assign(Handle_AIS_ConnectedInteractive self, AIS_ConnectedInteractive thePtr) -> Handle_AIS_ConnectedInteractive
        assign(Handle_AIS_ConnectedInteractive self, Handle_AIS_ConnectedInteractive theHandle) -> Handle_AIS_ConnectedInteractive

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ConnectedInteractive_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ConnectedInteractive self) -> AIS_ConnectedInteractive

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ConnectedInteractive_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ConnectedInteractive self) -> AIS_ConnectedInteractive

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ConnectedInteractive___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ConnectedInteractive self) -> AIS_ConnectedInteractive

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ConnectedInteractive___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ConnectedInteractive___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ConnectedInteractive___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ConnectedInteractive(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ConnectedInteractive_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ConnectedInteractive

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ConnectedInteractive self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ConnectedInteractive_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_AIS_ConnectedInteractive self) -> AIS_KindOfInteractive

        Returns KOI_Object

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_AIS_ConnectedInteractive self) -> Standard_Integer

        Returns 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Signature(self, *args)


    def Connect(self, *args):
        """
        Connect(Handle_AIS_ConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj)
        Connect(Handle_AIS_ConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, gp_Trsf theLocation)
        Connect(Handle_AIS_ConnectedInteractive self, Handle_AIS_InteractiveObject theAnotherObj, Handle_Geom_Transformation theLocation)

        Establishes the connection between the Connected
        Interactive Object, anotherIobj, and its reference.
        Locates instance in aLocation.

        :type theAnotherObj: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :type theLocation: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Connect(self, *args)


    def HasConnection(self, *args):
        """
        HasConnection(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if there is a connection established
        between the presentation and its source reference.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasConnection(self, *args)


    def ConnectedTo(self, *args):
        """
        Returns the connection with the reference Interactive Object.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveObject

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_ConnectedTo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Disconnect(self, *args):
        """
        Disconnect(Handle_AIS_ConnectedInteractive self)

        Clears the connection with a source reference. The
        presentation will no longer be displayed.
        Warning Must be done before deleting the presentation.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_Disconnect(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_AcceptShapeDecomposition(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_AIS_ConnectedInteractive self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if reference presentation accepts specified display mode.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_AcceptDisplayMode(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_AIS_ConnectedInteractive self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_AIS_ConnectedInteractive self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _AIS.Handle_AIS_ConnectedInteractive_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_ConnectedInteractive self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_AIS_ConnectedInteractive self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_AIS_ConnectedInteractive self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_AIS_ConnectedInteractive self)"""
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_AIS_ConnectedInteractive self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_AIS_ConnectedInteractive self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_AIS_ConnectedInteractive self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_AIS_ConnectedInteractive self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_AIS_ConnectedInteractive self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_AIS_ConnectedInteractive self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_AIS_ConnectedInteractive self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_ConnectedInteractive self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_AIS_ConnectedInteractive self)

        Removes display mode settings from the interactive object.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_ConnectedInteractive self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_ConnectedInteractive self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_ConnectedInteractive self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_AIS_ConnectedInteractive self)

        Unsets highlight display mode.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_AIS_ConnectedInteractive self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_AIS_ConnectedInteractive self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_AIS_ConnectedInteractive self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_AIS_ConnectedInteractive self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_AIS_ConnectedInteractive self)

        Removes the setting for material.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_ConnectedInteractive self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_ConnectedInteractive self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_AIS_ConnectedInteractive self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_AIS_ConnectedInteractive self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_AIS_ConnectedInteractive self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_AIS_ConnectedInteractive self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_AIS_ConnectedInteractive self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_AIS_ConnectedInteractive self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _AIS.Handle_AIS_ConnectedInteractive_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_AIS_ConnectedInteractive self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ConnectedInteractive_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_ConnectedInteractive self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_AIS_ConnectedInteractive self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _AIS.Handle_AIS_ConnectedInteractive_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_AIS_ConnectedInteractive self)
        RecomputePrimitives(Handle_AIS_ConnectedInteractive self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ConnectedInteractive_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_AIS_ConnectedInteractive self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _AIS.Handle_AIS_ConnectedInteractive_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_AIS_ConnectedInteractive self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_AIS_ConnectedInteractive self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_AIS_ConnectedInteractive self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_AIS_ConnectedInteractive self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_AIS_ConnectedInteractive self)

        resets local transformation to identity.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_AIS_ConnectedInteractive self)

        Recomputes the location of the selection aSelection.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_AIS_ConnectedInteractive self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _AIS.Handle_AIS_ConnectedInteractive_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_AIS_ConnectedInteractive self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_AIS_ConnectedInteractive self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _AIS.Handle_AIS_ConnectedInteractive_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_AIS_ConnectedInteractive self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _AIS.Handle_AIS_ConnectedInteractive_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_AIS_ConnectedInteractive self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_AIS_ConnectedInteractive self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_AIS_ConnectedInteractive self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_AIS_ConnectedInteractive self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_AIS_ConnectedInteractive self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_ConnectedInteractive self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_AIS_ConnectedInteractive self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ConnectedInteractive_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_AIS_ConnectedInteractive self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_AIS_ConnectedInteractive self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _AIS.Handle_AIS_ConnectedInteractive_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_AIS_ConnectedInteractive self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_AIS_ConnectedInteractive self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_AIS_ConnectedInteractive self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_AIS_ConnectedInteractive self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ConnectedInteractive_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_AIS_ConnectedInteractive self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_AIS_ConnectedInteractive self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_AIS_ConnectedInteractive self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_AIS_ConnectedInteractive self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_AIS_ConnectedInteractive self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_AIS_ConnectedInteractive self, Standard_Integer const aMode)
        SetToUpdate(Handle_AIS_ConnectedInteractive self)

        flags all the Presentations to be Updated.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_AIS_ConnectedInteractive self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _AIS.Handle_AIS_ConnectedInteractive_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_AIS_ConnectedInteractive self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_AIS_ConnectedInteractive self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_ConnectedInteractive self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ConnectedInteractive_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_AIS_ConnectedInteractive self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ConnectedInteractive_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_AIS_ConnectedInteractive self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _AIS.Handle_AIS_ConnectedInteractive_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_AIS_ConnectedInteractive self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_AIS_ConnectedInteractive self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_AIS_ConnectedInteractive self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_AIS_ConnectedInteractive self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ConnectedInteractive_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_AIS_ConnectedInteractive self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _AIS.Handle_AIS_ConnectedInteractive_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_AIS_ConnectedInteractive self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_AIS_ConnectedInteractive self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_AIS_ConnectedInteractive self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_AIS_ConnectedInteractive self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ConnectedInteractive_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_AIS_ConnectedInteractive self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_AIS_ConnectedInteractive self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _AIS.Handle_AIS_ConnectedInteractive_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ConnectedInteractive self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ConnectedInteractive_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ConnectedInteractive self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ConnectedInteractive self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ConnectedInteractive self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ConnectedInteractive self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ConnectedInteractive_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ConnectedInteractive self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ConnectedInteractive_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ConnectedInteractive self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ConnectedInteractive self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ConnectedInteractive_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ConnectedInteractive self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ConnectedInteractive_DecrementRefCounter(self, *args)

Handle_AIS_ConnectedInteractive_swigregister = _AIS.Handle_AIS_ConnectedInteractive_swigregister
Handle_AIS_ConnectedInteractive_swigregister(Handle_AIS_ConnectedInteractive)

def Handle_AIS_ConnectedInteractive_DownCast(thing):
    return _AIS.Handle_AIS_ConnectedInteractive_DownCast(thing)
Handle_AIS_ConnectedInteractive_DownCast = _AIS.Handle_AIS_ConnectedInteractive_DownCast

class Handle_AIS_LocalStatus(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_LocalStatus self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_LocalStatus_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_LocalStatus self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_LocalStatus_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_LocalStatus self, AIS_LocalStatus thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_LocalStatus_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_LocalStatus self, Handle_AIS_LocalStatus theHandle) -> Handle_AIS_LocalStatus
        assign(Handle_AIS_LocalStatus self, AIS_LocalStatus thePtr) -> Handle_AIS_LocalStatus
        assign(Handle_AIS_LocalStatus self, Handle_AIS_LocalStatus theHandle) -> Handle_AIS_LocalStatus

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_LocalStatus_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_LocalStatus self) -> AIS_LocalStatus

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_LocalStatus_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_LocalStatus self) -> AIS_LocalStatus

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_LocalStatus___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_LocalStatus self) -> AIS_LocalStatus

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_LocalStatus___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_LocalStatus___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_LocalStatus___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_LocalStatus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_LocalStatus_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_LocalStatus

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_LocalStatus self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_LocalStatus_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_LocalStatus_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_LocalStatus_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Decomposed(self, *args):
        """
        Decomposed(Handle_AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_Decomposed(self, *args)


    def IsTemporary(self, *args):
        """
        IsTemporary(Handle_AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_IsTemporary(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_LocalStatus self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalStatus_DisplayMode(self, *args)


    def SelectionModes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _AIS.Handle_AIS_LocalStatus_SelectionModes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsActivated(self, *args):
        """
        IsActivated(Handle_AIS_LocalStatus self, Standard_Integer const aSelMode) -> Standard_Boolean

        :type aSelMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_IsActivated(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_AIS_LocalStatus self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalStatus_HilightMode(self, *args)


    def IsSubIntensityOn(self, *args):
        """
        IsSubIntensityOn(Handle_AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_IsSubIntensityOn(self, *args)


    def HilightStyle(self, *args):
        """
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_LocalStatus_HilightStyle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDecomposition(self, *args):
        """
        SetDecomposition(Handle_AIS_LocalStatus self, Standard_Boolean const astatus)

        :type astatus: bool

        """
        return _AIS.Handle_AIS_LocalStatus_SetDecomposition(self, *args)


    def SetTemporary(self, *args):
        """
        SetTemporary(Handle_AIS_LocalStatus self, Standard_Boolean const astatus)

        :type astatus: bool

        """
        return _AIS.Handle_AIS_LocalStatus_SetTemporary(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.Handle_AIS_LocalStatus_SetDisplayMode(self, *args)


    def SetFirstDisplay(self, *args):
        """
        SetFirstDisplay(Handle_AIS_LocalStatus self, Standard_Boolean const aStatus)

        :type aStatus: bool

        """
        return _AIS.Handle_AIS_LocalStatus_SetFirstDisplay(self, *args)


    def IsFirstDisplay(self, *args):
        """
        IsFirstDisplay(Handle_AIS_LocalStatus self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_IsFirstDisplay(self, *args)


    def AddSelectionMode(self, *args):
        """
        AddSelectionMode(Handle_AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.Handle_AIS_LocalStatus_AddSelectionMode(self, *args)


    def RemoveSelectionMode(self, *args):
        """
        RemoveSelectionMode(Handle_AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.Handle_AIS_LocalStatus_RemoveSelectionMode(self, *args)


    def ClearSelectionModes(self, *args):
        """ClearSelectionModes(Handle_AIS_LocalStatus self)"""
        return _AIS.Handle_AIS_LocalStatus_ClearSelectionModes(self, *args)


    def IsSelModeIn(self, *args):
        """
        IsSelModeIn(Handle_AIS_LocalStatus self, Standard_Integer const aMode) -> Standard_Boolean

        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_IsSelModeIn(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_AIS_LocalStatus self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _AIS.Handle_AIS_LocalStatus_SetHilightMode(self, *args)


    def SetHilightStyle(self, *args):
        """
        SetHilightStyle(Handle_AIS_LocalStatus self, Handle_Prs3d_Drawer theStyle)

        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_LocalStatus_SetHilightStyle(self, *args)


    def SubIntensityOn(self, *args):
        """SubIntensityOn(Handle_AIS_LocalStatus self)"""
        return _AIS.Handle_AIS_LocalStatus_SubIntensityOn(self, *args)


    def SubIntensityOff(self, *args):
        """SubIntensityOff(Handle_AIS_LocalStatus self)"""
        return _AIS.Handle_AIS_LocalStatus_SubIntensityOff(self, *args)


    def SetPreviousState(self, *args):
        """
        SetPreviousState(Handle_AIS_LocalStatus self, Handle_Standard_Transient aStatus)

        :type aStatus: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _AIS.Handle_AIS_LocalStatus_SetPreviousState(self, *args)


    def PreviousState(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _AIS.Handle_AIS_LocalStatus_PreviousState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AIS_LocalStatus self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_LocalStatus_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_LocalStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_LocalStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_LocalStatus self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_LocalStatus self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_LocalStatus_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_LocalStatus self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_LocalStatus_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_LocalStatus self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalStatus_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_LocalStatus self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_LocalStatus_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_LocalStatus self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_LocalStatus_DecrementRefCounter(self, *args)

Handle_AIS_LocalStatus_swigregister = _AIS.Handle_AIS_LocalStatus_swigregister
Handle_AIS_LocalStatus_swigregister(Handle_AIS_LocalStatus)

def Handle_AIS_LocalStatus_DownCast(thing):
    return _AIS.Handle_AIS_LocalStatus_DownCast(thing)
Handle_AIS_LocalStatus_DownCast = _AIS.Handle_AIS_LocalStatus_DownCast

class Handle_AIS_ColoredDrawer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AIS_ColoredDrawer self)

        Nullify the handle


        """
        return _AIS.Handle_AIS_ColoredDrawer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AIS_ColoredDrawer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AIS_ColoredDrawer self, AIS_ColoredDrawer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AIS.Handle_AIS_ColoredDrawer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AIS_ColoredDrawer self, Handle_AIS_ColoredDrawer theHandle) -> Handle_AIS_ColoredDrawer
        assign(Handle_AIS_ColoredDrawer self, AIS_ColoredDrawer thePtr) -> Handle_AIS_ColoredDrawer
        assign(Handle_AIS_ColoredDrawer self, Handle_AIS_ColoredDrawer theHandle) -> Handle_AIS_ColoredDrawer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AIS.Handle_AIS_ColoredDrawer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AIS_ColoredDrawer self) -> AIS_ColoredDrawer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AIS.Handle_AIS_ColoredDrawer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AIS_ColoredDrawer self) -> AIS_ColoredDrawer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AIS.Handle_AIS_ColoredDrawer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AIS_ColoredDrawer self) -> AIS_ColoredDrawer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AIS.Handle_AIS_ColoredDrawer___ref__(self, *args)


    def __hash__(self):
        return _AIS.Handle_AIS_ColoredDrawer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AIS.Handle_AIS_ColoredDrawer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AIS.new_Handle_AIS_ColoredDrawer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AIS.Handle_AIS_ColoredDrawer_DownCast)
    __swig_destroy__ = _AIS.delete_Handle_AIS_ColoredDrawer

    def get_type_name(self, *args):
        """
        get_type_name(Handle_AIS_ColoredDrawer self) -> char const *

        :rtype: const char *

        """
        return _AIS.Handle_AIS_ColoredDrawer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ColoredDrawer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AIS.Handle_AIS_ColoredDrawer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsHidden(self, *args):
        """
        IsHidden(Handle_AIS_ColoredDrawer self) -> bool

        :rtype: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_IsHidden(self, *args)


    def SetHidden(self, *args):
        """
        SetHidden(Handle_AIS_ColoredDrawer self, bool const theToHide)

        :type theToHide: const bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetHidden(self, *args)


    def HasOwnColor(self, *args):
        """
        HasOwnColor(Handle_AIS_ColoredDrawer self) -> bool

        :rtype: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnColor(self, *args)


    def UnsetOwnColor(self, *args):
        """UnsetOwnColor(Handle_AIS_ColoredDrawer self)"""
        return _AIS.Handle_AIS_ColoredDrawer_UnsetOwnColor(self, *args)


    def SetOwnColor(self, *args):
        """
        SetOwnColor(Handle_AIS_ColoredDrawer self, Quantity_Color arg2)

        :type : OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetOwnColor(self, *args)


    def HasOwnWidth(self, *args):
        """
        HasOwnWidth(Handle_AIS_ColoredDrawer self) -> bool

        :rtype: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnWidth(self, *args)


    def UnsetOwnWidth(self, *args):
        """UnsetOwnWidth(Handle_AIS_ColoredDrawer self)"""
        return _AIS.Handle_AIS_ColoredDrawer_UnsetOwnWidth(self, *args)


    def SetOwnWidth(self, *args):
        """
        SetOwnWidth(Handle_AIS_ColoredDrawer self, Standard_Real const arg2)

        :type : float

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetOwnWidth(self, *args)


    def SetTypeOfDeflection(self, *args):
        """
        SetTypeOfDeflection(Handle_AIS_ColoredDrawer self, Aspect_TypeOfDeflection const theTypeOfDeflection)

        Sets the type of chordal deflection.
        This indicates whether the deflection value is absolute or relative to the size of the object.

        :type theTypeOfDeflection: OCC.wrapper.Aspect.Aspect_TypeOfDeflection

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetTypeOfDeflection(self, *args)


    def TypeOfDeflection(self, *args):
        """
        TypeOfDeflection(Handle_AIS_ColoredDrawer self) -> Aspect_TypeOfDeflection

        Returns the type of chordal deflection.
        This indicates whether the deflection value is absolute or relative to the size of the object.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfDeflection

        """
        return _AIS.Handle_AIS_ColoredDrawer_TypeOfDeflection(self, *args)


    def HasOwnTypeOfDeflection(self, *args):
        """
        HasOwnTypeOfDeflection(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has a type of deflection setting active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnTypeOfDeflection(self, *args)


    def SetMaximalChordialDeviation(self, *args):
        """
        SetMaximalChordialDeviation(Handle_AIS_ColoredDrawer self, Standard_Real const theChordialDeviation)

        Defines the maximal chordial deviation when drawing any curve.
        Even if the type of deviation is set to TOD_Relative, this value is used by: 
        Prs3d_DeflectionCurve
        Prs3d_WFDeflectionSurface
        Prs3d_WFDeflectionRestrictedFace

        :type theChordialDeviation: float

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetMaximalChordialDeviation(self, *args)


    def MaximalChordialDeviation(self, *args):
        """
        MaximalChordialDeviation(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the maximal chordal deviation. The default value is 0.1.
        Drawings of curves or patches are made with respect to an absolute maximal chordal deviation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_MaximalChordialDeviation(self, *args)


    def HasOwnMaximalChordialDeviation(self, *args):
        """
        HasOwnMaximalChordialDeviation(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has a maximal chordial deviation setting active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnMaximalChordialDeviation(self, *args)


    def SetTypeOfHLR(self, *args):
        """
        SetTypeOfHLR(Handle_AIS_ColoredDrawer self, Prs3d_TypeOfHLR const theTypeOfHLR)

        Sets the type of HLR algorithm used by drawer's interactive objects

        :type theTypeOfHLR: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetTypeOfHLR(self, *args)


    def TypeOfHLR(self, *args):
        """
        TypeOfHLR(Handle_AIS_ColoredDrawer self) -> Prs3d_TypeOfHLR

        Returns the type of HLR algorithm currently in use.

        :rtype: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _AIS.Handle_AIS_ColoredDrawer_TypeOfHLR(self, *args)


    def HasOwnTypeOfHLR(self, *args):
        """
        HasOwnTypeOfHLR(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the type of HLR is not equal to Prs3d_TOH_NotSet.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnTypeOfHLR(self, *args)


    def SetMaximalParameterValue(self, *args):
        """
        SetMaximalParameterValue(Handle_AIS_ColoredDrawer self, Standard_Real const theValue)

        Defines the maximum value allowed for the first and last
        parameters of an infinite curve.

        :type theValue: float

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetMaximalParameterValue(self, *args)


    def MaximalParameterValue(self, *args):
        """
        MaximalParameterValue(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Sets the maximum value allowed for the first and last
        parameters of an infinite curve. By default, this value is 500000.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_MaximalParameterValue(self, *args)


    def HasOwnMaximalParameterValue(self, *args):
        """
        HasOwnMaximalParameterValue(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has a maximum value allowed for the first and last
        parameters of an infinite curve setting active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnMaximalParameterValue(self, *args)


    def SetIsoOnPlane(self, *args):
        """
        SetIsoOnPlane(Handle_AIS_ColoredDrawer self, Standard_Boolean const theIsEnabled)

        Sets IsoOnPlane on or off by setting the parameter theIsEnabled to true or false.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetIsoOnPlane(self, *args)


    def IsoOnPlane(self, *args):
        """
        IsoOnPlane(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns True if the drawing of isos on planes is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_IsoOnPlane(self, *args)


    def HasOwnIsoOnPlane(self, *args):
        """
        HasOwnIsoOnPlane(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has IsoOnPlane setting active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnIsoOnPlane(self, *args)


    def IsoOnTriangulation(self, *args):
        """
        IsoOnTriangulation(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns True if the drawing of isos on triangulation is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_IsoOnTriangulation(self, *args)


    def HasOwnIsoOnTriangulation(self, *args):
        """
        HasOwnIsoOnTriangulation(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has IsoOnTriangulation setting active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnIsoOnTriangulation(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_AIS_ColoredDrawer self, Standard_Boolean const theToEnable)

        Enables or disables isolines on triangulation by setting the parameter theIsEnabled to true or false.

        :type theToEnable: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetIsoOnTriangulation(self, *args)


    def SetDiscretisation(self, *args):
        """
        SetDiscretisation(Handle_AIS_ColoredDrawer self, Standard_Integer const theValue)

        Sets the discretisation parameter theValue.

        :type theValue: int

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDiscretisation(self, *args)


    def Discretisation(self, *args):
        """
        Discretisation(Handle_AIS_ColoredDrawer self) -> Standard_Integer

        Returns the discretisation setting. 

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredDrawer_Discretisation(self, *args)


    def HasOwnDiscretisation(self, *args):
        """
        HasOwnDiscretisation(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has discretisation setting active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDiscretisation(self, *args)


    def SetDeviationCoefficient(self, *args):
        """
        SetDeviationCoefficient(Handle_AIS_ColoredDrawer self, Standard_Real const theCoefficient)
        SetDeviationCoefficient(Handle_AIS_ColoredDrawer self)

        Sets the hasOwnDeviationCoefficient flag to Standard_False


        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDeviationCoefficient(self, *args)


    def DeviationCoefficient(self, *args):
        """
        DeviationCoefficient(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the deviation coefficient.
        Drawings of curves or patches are made with respect
        to a maximal chordal deviation. A Deviation coefficient
        is used in the shading display mode. The shape is
        seen decomposed into triangles. These are used to
        calculate reflection of light from the surface of the
        object. The triangles are formed from chords of the
        curves in the shape. The deviation coefficient gives
        the highest value of the angle with which a chord can
        deviate from a tangent to a   curve. If this limit is
        reached, a new triangle is begun.
        This deviation is absolute and is set through the
        method: SetMaximalChordialDeviation. The default value is 0.001.
        In drawing shapes, however, you are allowed to ask
        for a relative deviation. This deviation will be:
        SizeOfObject * DeviationCoefficient.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_DeviationCoefficient(self, *args)


    def HasOwnDeviationCoefficient(self, *args):
        """
        HasOwnDeviationCoefficient(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if there is a local setting for deviation
        coefficient in this framework for a specific interactive object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDeviationCoefficient(self, *args)


    def PreviousDeviationCoefficient(self, *args):
        """
        PreviousDeviationCoefficient(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Saves the previous value used for the chordal
        deviation coefficient. 

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_PreviousDeviationCoefficient(self, *args)


    def UpdatePreviousDeviationCoefficient(self, *args):
        """
        UpdatePreviousDeviationCoefficient(Handle_AIS_ColoredDrawer self)

        Updates the previous value used for the chordal deviation coefficient to the current state.


        """
        return _AIS.Handle_AIS_ColoredDrawer_UpdatePreviousDeviationCoefficient(self, *args)


    def SetHLRDeviationCoefficient(self, *args):
        """
        SetHLRDeviationCoefficient(Handle_AIS_ColoredDrawer self, Standard_Real const theCoefficient)
        SetHLRDeviationCoefficient(Handle_AIS_ColoredDrawer self)

        Sets the hasOwnHLRDeviationCoefficient flag to Standard_False 


        """
        return _AIS.Handle_AIS_ColoredDrawer_SetHLRDeviationCoefficient(self, *args)


    def HLRDeviationCoefficient(self, *args):
        """
        HLRDeviationCoefficient(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the real number value of the hidden line
        removal deviation coefficient in this framework, if the flag
        hasOwnHLRDeviationCoefficient is true or there is no Link.
        Else the shape's HLR deviation coefficient is used.
        A Deviation coefficient is used in the shading display
        mode. The shape is seen decomposed into triangles.
        These are used to calculate reflection of light from the
        surface of the object.
        The triangles are formed from chords of the curves in
        the shape. The deviation coefficient give the highest
        value of the angle with which a chord can deviate
        from a tangent to a curve. If this limit is reached, a new triangle is begun.
        To find the hidden lines, hidden line display mode
        entails recalculation of the view at each different projector perspective.
        Since hidden lines entail calculations of more than
        usual complexity to decompose them into these
        triangles, a deviation coefficient allowing greater
        tolerance is used. This increases efficiency in calculation.
        The Default value is 0.02.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_HLRDeviationCoefficient(self, *args)


    def HasOwnHLRDeviationCoefficient(self, *args):
        """
        HasOwnHLRDeviationCoefficient(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the there is a setting for HLR deviation
        coefficient in this framework for a specific interactive object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnHLRDeviationCoefficient(self, *args)


    def PreviousHLRDeviationCoefficient(self, *args):
        """
        PreviousHLRDeviationCoefficient(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the previous value of the hidden line removal deviation coefficient.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_PreviousHLRDeviationCoefficient(self, *args)


    def SetDeviationAngle(self, *args):
        """
        SetDeviationAngle(Handle_AIS_ColoredDrawer self, Standard_Real const theAngle)
        SetDeviationAngle(Handle_AIS_ColoredDrawer self)

        Sets the hasOwnDeviationAngle flag to Standard_False


        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDeviationAngle(self, *args)


    def DeviationAngle(self, *args):
        """
        DeviationAngle(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the value for deviation angle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_DeviationAngle(self, *args)


    def HasOwnDeviationAngle(self, *args):
        """
        HasOwnDeviationAngle(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the there is a local setting for deviation
        angle in this framework for a specific interactive object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDeviationAngle(self, *args)


    def PreviousDeviationAngle(self, *args):
        """
        PreviousDeviationAngle(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the previous deviation angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_PreviousDeviationAngle(self, *args)


    def UpdatePreviousDeviationAngle(self, *args):
        """
        UpdatePreviousDeviationAngle(Handle_AIS_ColoredDrawer self)

        Updates the previous deviation angle to the current value


        """
        return _AIS.Handle_AIS_ColoredDrawer_UpdatePreviousDeviationAngle(self, *args)


    def SetHLRAngle(self, *args):
        """
        SetHLRAngle(Handle_AIS_ColoredDrawer self, Standard_Real const theAngle)
        SetHLRAngle(Handle_AIS_ColoredDrawer self)

        Sets the hasOwnHLRDeviationAngle flag to Standard_False


        """
        return _AIS.Handle_AIS_ColoredDrawer_SetHLRAngle(self, *args)


    def HLRAngle(self, *args):
        """
        HLRAngle(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the real number value of the deviation angle
        in hidden line removal views. The default value is 20 * M_PI / 180.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_HLRAngle(self, *args)


    def HasOwnHLRDeviationAngle(self, *args):
        """
        HasOwnHLRDeviationAngle(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the there is a setting for HLR deviation
        angle in this framework for a specific interactive object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnHLRDeviationAngle(self, *args)


    def PreviousHLRDeviationAngle(self, *args):
        """
        PreviousHLRDeviationAngle(Handle_AIS_ColoredDrawer self) -> Standard_Real

        Returns the previous value of the HLR deviation angle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AIS.Handle_AIS_ColoredDrawer_PreviousHLRDeviationAngle(self, *args)


    def SetAutoTriangulation(self, *args):
        """
        SetAutoTriangulation(Handle_AIS_ColoredDrawer self, Standard_Boolean const theIsEnabled)

        Sets IsAutoTriangulated on or off by setting the parameter theIsEnabled to true or false.
        If this flag is True automatic re-triangulation with deflection-check logic will be applied.
        Else this feature will be disable and triangulation is expected to be computed by application itself
        and no shading presentation at all if unavailable.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetAutoTriangulation(self, *args)


    def IsAutoTriangulation(self, *args):
        """
        IsAutoTriangulation(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns True if automatic triangulation is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_IsAutoTriangulation(self, *args)


    def HasOwnIsAutoTriangulation(self, *args):
        """
        HasOwnIsAutoTriangulation(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has IsoOnPlane setting active.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnIsAutoTriangulation(self, *args)


    def UIsoAspect(self, *args):
        """
        Defines the attributes which are used when drawing an
        U isoparametric curve of a face. Defines the number
        of U isoparametric curves to be drawn for a single face.
        The LineAspect for U isoparametric lines can be edited
        (methods SetColor, SetTypeOfLine, SetWidth, SetNumber)
        The default values are:
        COLOR       : Quantity_NOC_GRAY75
        TYPE OF LINE: Aspect_TOL_SOLID
        WIDTH       : 0.5

        These attributes are used by the following algorithms:
        Prs3d_WFDeflectionSurface
        Prs3d_WFDeflectionRestrictedFace

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_IsoAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_UIsoAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetUIsoAspect(self, *args):
        """
        SetUIsoAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_IsoAspect theAspect)

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_IsoAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetUIsoAspect(self, *args)


    def HasOwnUIsoAspect(self, *args):
        """
        HasOwnUIsoAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        UIso aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnUIsoAspect(self, *args)


    def VIsoAspect(self, *args):
        """
        Defines the attributes which are used when drawing an
        V isoparametric curve of a face. Defines the number
        of V isoparametric curves to be drawn for a single face.
        The LineAspect for V isoparametric lines can be edited
        (methods SetColor, SetTypeOfLine, SetWidth, SetNumber)
        The default values are:
        COLOR       : Quantity_NOC_GRAY82
        TYPE OF LINE: Aspect_TOL_SOLID
        WIDTH       : 0.5

        These attributes are used by the following algorithms:
        Prs3d_WFDeflectionSurface
        Prs3d_WFDeflectionRestrictedFace

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_IsoAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_VIsoAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVIsoAspect(self, *args):
        """
        SetVIsoAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_IsoAspect theAspect)

        Sets the appearance of V isoparameters - theAspect.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_IsoAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetVIsoAspect(self, *args)


    def HasOwnVIsoAspect(self, *args):
        """
        HasOwnVIsoAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        VIso aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnVIsoAspect(self, *args)


    def WireAspect(self, *args):
        """
        Returns wire aspect settings.
        The LineAspect for the free boundaries can be edited.
        The default values are:
        Color: Quantity_NOC_GREEN
        Type of line: Aspect_TOL_SOLID
        Width: 1.0
        These attributes are used by the algorithm Prs3d_WFShape.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_WireAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetWireAspect(self, *args):
        """
        SetWireAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the parameter theAspect for display of wires.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetWireAspect(self, *args)


    def HasOwnWireAspect(self, *args):
        """
        HasOwnWireAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        wire aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnWireAspect(self, *args)


    def SetWireDraw(self, *args):
        """
        SetWireDraw(Handle_AIS_ColoredDrawer self, Standard_Boolean const theIsEnabled)

        Sets WireDraw on or off by setting the parameter theIsEnabled to true or false.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetWireDraw(self, *args)


    def WireDraw(self, *args):
        """
        WireDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns True if the drawing of the wire is enabled.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_WireDraw(self, *args)


    def HasOwnWireDraw(self, *args):
        """
        HasOwnWireDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        "draw wires" flag that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnWireDraw(self, *args)


    def PointAspect(self, *args):
        """
        Returns the point aspect setting. The default values are
        Color: Quantity_NOC_YELLOW
        Type of marker: Aspect_TOM_PLUS
        Scale: 1.0
        These attributes are used by the algorithms Prs3d_Point.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_PointAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_PointAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPointAspect(self, *args):
        """
        SetPointAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_PointAspect theAspect)

        Sets the parameter theAspect for display attributes of points

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_PointAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetPointAspect(self, *args)


    def HasOwnPointAspect(self, *args):
        """
        HasOwnPointAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        point aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnPointAspect(self, *args)


    def LineAspect(self, *args):
        """
        Returns settings for line aspects.
        These settings can be edited. The default values are:
        Color: Quantity_NOC_YELLOW
        Type of line: Aspect_TOL_SOLID
        Width: 1.0
        These attributes are used by the following algorithms:
        Prs3d_Curve
        Prs3d_Line
        Prs3d_HLRShape

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_LineAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLineAspect(self, *args):
        """
        SetLineAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the parameter theAspect for display attributes of lines.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetLineAspect(self, *args)


    def HasOwnLineAspect(self, *args):
        """
        HasOwnLineAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        line aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnLineAspect(self, *args)


    def TextAspect(self, *args):
        """
        Returns settings for text aspect.
        These settings can be edited. The default value is:
        - Color: Quantity_NOC_YELLOW

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_TextAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_TextAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextAspect(self, *args):
        """
        SetTextAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_TextAspect theAspect)

        Sets the parameter theAspect for display attributes of text.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_TextAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetTextAspect(self, *args)


    def HasOwnTextAspect(self, *args):
        """
        HasOwnTextAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        text aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnTextAspect(self, *args)


    def ShadingAspect(self, *args):
        """
        Returns settings for shading aspects.
        These settings can be edited. The default values are:
        -   Color: Quantity_NOC_YELLOW
        -   Material: Graphic3d_NOM_BRASS
        Shading aspect is obtained through decomposition of
        3d faces into triangles, each side of each triangle
        being a chord of the corresponding curved edge in the face.
        Reflection of light in each projector perspective is then calculated for each of the
        resultant triangular planes.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_ShadingAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_ShadingAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShadingAspect(self, *args):
        """
        SetShadingAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_ShadingAspect theAspect)

        Sets the parameter theAspect for display attributes of shading.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_ShadingAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetShadingAspect(self, *args)


    def HasOwnShadingAspect(self, *args):
        """
        HasOwnShadingAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        shading aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnShadingAspect(self, *args)


    def SeenLineAspect(self, *args):
        """
        Returns settings for seen line aspects.
        These settings can be edited. The default values are:
        Color: Quantity_NOC_YELLOW
        Type of line: Aspect_TOL_SOLID
        Width: 1.0

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_SeenLineAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSeenLineAspect(self, *args):
        """
        SetSeenLineAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the parameter theAspect for the display of seen lines in hidden line removal mode.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetSeenLineAspect(self, *args)


    def HasOwnSeenLineAspect(self, *args):
        """
        HasOwnSeenLineAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        seen line aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnSeenLineAspect(self, *args)


    def PlaneAspect(self, *args):
        """
        Returns settings for the appearance of planes.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_PlaneAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_PlaneAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPlaneAspect(self, *args):
        """
        SetPlaneAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_PlaneAspect theAspect)

        Sets the parameter theAspect for the display of planes. 

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_PlaneAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetPlaneAspect(self, *args)


    def HasOwnPlaneAspect(self, *args):
        """
        HasOwnPlaneAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        plane aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnPlaneAspect(self, *args)


    def ArrowAspect(self, *args):
        """
        Returns the attributes for display of arrows.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_ArrowAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_ArrowAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArrowAspect(self, *args):
        """
        SetArrowAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_ArrowAspect theAspect)

        Sets the parameter theAspect for display attributes of arrows.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_ArrowAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetArrowAspect(self, *args)


    def HasOwnArrowAspect(self, *args):
        """
        HasOwnArrowAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        arrow aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnArrowAspect(self, *args)


    def SetLineArrowDraw(self, *args):
        """
        SetLineArrowDraw(Handle_AIS_ColoredDrawer self, Standard_Boolean const theIsEnabled)

        Enables the drawing of an arrow at the end of each line.
        By default the arrows are not drawn.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetLineArrowDraw(self, *args)


    def LineArrowDraw(self, *args):
        """
        LineArrowDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns True if drawing an arrow at the end of each edge is enabled
        and False otherwise (the default).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_LineArrowDraw(self, *args)


    def HasOwnLineArrowDraw(self, *args):
        """
        HasOwnLineArrowDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        "draw arrow" flag that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnLineArrowDraw(self, *args)


    def HiddenLineAspect(self, *args):
        """
        Returns settings for hidden line aspects.
        These settings can be edited. The default values are:
        Color: Quantity_NOC_YELLOW
        Type of line: Aspect_TOL_DASH
        Width: 1.0

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_HiddenLineAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHiddenLineAspect(self, *args):
        """
        SetHiddenLineAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the parameter theAspect for the display of hidden lines in hidden line removal mode.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetHiddenLineAspect(self, *args)


    def HasOwnHiddenLineAspect(self, *args):
        """
        HasOwnHiddenLineAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        hidden lines aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnHiddenLineAspect(self, *args)


    def DrawHiddenLine(self, *args):
        """
        DrawHiddenLine(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns Standard_True if the hidden lines are to be drawn.
        By default the hidden lines are not drawn.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_DrawHiddenLine(self, *args)


    def EnableDrawHiddenLine(self, *args):
        """
        EnableDrawHiddenLine(Handle_AIS_ColoredDrawer self)

        Enables the DrawHiddenLine function.


        """
        return _AIS.Handle_AIS_ColoredDrawer_EnableDrawHiddenLine(self, *args)


    def DisableDrawHiddenLine(self, *args):
        """
        DisableDrawHiddenLine(Handle_AIS_ColoredDrawer self)

        Disables the DrawHiddenLine function.


        """
        return _AIS.Handle_AIS_ColoredDrawer_DisableDrawHiddenLine(self, *args)


    def HasOwnDrawHiddenLine(self, *args):
        """
        HasOwnDrawHiddenLine(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        "draw hidden lines" flag that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDrawHiddenLine(self, *args)


    def VectorAspect(self, *args):
        """
        Returns settings for the appearance of vectors.
        These settings can be edited. The default values are:
        Color: Quantity_NOC_SKYBLUE
        Type of line: Aspect_TOL_SOLID
        Width: 1.0

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_VectorAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVectorAspect(self, *args):
        """
        SetVectorAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the modality theAspect for the display of vectors.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetVectorAspect(self, *args)


    def HasOwnVectorAspect(self, *args):
        """
        HasOwnVectorAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        vector aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnVectorAspect(self, *args)


    def SetVertexDrawMode(self, *args):
        """
        SetVertexDrawMode(Handle_AIS_ColoredDrawer self, Prs3d_VertexDrawMode const theMode)

        Sets the mode of visualization of vertices of a TopoDS_Shape instance.
        By default, only stand-alone vertices (not belonging topologically to an edge) are drawn,
        that corresponds to Prs3d_VDM_Standalone mode. 
        Switching to Prs3d_VDM_Standalone mode makes all shape's vertices visible.
        To inherit this parameter from the global drawer instance ("the link") when it is present,
        Prs3d_VDM_Inherited value should be used.

        :type theMode: OCC.wrapper.Prs3d.Prs3d_VertexDrawMode

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetVertexDrawMode(self, *args)


    def VertexDrawMode(self, *args):
        """
        VertexDrawMode(Handle_AIS_ColoredDrawer self) -> Prs3d_VertexDrawMode

        Returns the current mode of visualization of vertices of a TopoDS_Shape instance.

        :rtype: OCC.wrapper.Prs3d.Prs3d_VertexDrawMode

        """
        return _AIS.Handle_AIS_ColoredDrawer_VertexDrawMode(self, *args)


    def HasOwnVertexDrawMode(self, *args):
        """
        HasOwnVertexDrawMode(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the vertex draw mode is not equal to <b>Prs3d_VDM_Inherited</b>. 
        This means that individual vertex draw mode value (i.e. not inherited from the global 
        drawer) is used for a specific interactive object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnVertexDrawMode(self, *args)


    def DatumAspect(self, *args):
        """
        Returns settings for the appearance of datums.
        These settings can be edited. The default values for the three axes are:
        Color: Quantity_NOC_PEACHPUFF
        Type of line: Aspect_TOL_SOLID
        Width: 1.0

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DatumAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_DatumAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDatumAspect(self, *args):
        """
        SetDatumAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_DatumAspect theAspect)

        Sets the modality theAspect for the display of datums.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DatumAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDatumAspect(self, *args)


    def HasOwnDatumAspect(self, *args):
        """
        HasOwnDatumAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        datum aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDatumAspect(self, *args)


    def SectionAspect(self, *args):
        """
        The LineAspect for the wire can be edited.
        The default values are:
        Color: Quantity_NOC_ORANGE
        Type of line: Aspect_TOL_SOLID
        Width: 1.0
        These attributes are used by the algorithm Prs3d_WFShape.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_SectionAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSectionAspect(self, *args):
        """
        SetSectionAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the parameter theAspect for display attributes of sections. 

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetSectionAspect(self, *args)


    def HasOwnSectionAspect(self, *args):
        """
        HasOwnSectionAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        section aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnSectionAspect(self, *args)


    def SetFreeBoundaryAspect(self, *args):
        """
        SetFreeBoundaryAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the parameter theAspect for the display of free boundaries.
        The method sets aspect owned by the drawer that will be used during
        visualization instead of the one set in link.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetFreeBoundaryAspect(self, *args)


    def FreeBoundaryAspect(self, *args):
        """
        Returns the values for presentation of free boundaries,
        in other words, boundaries which are not shared.
        The LineAspect for the  free boundaries can be edited.
        The default values are:
        Color: Quantity_NOC_GREEN
        Type of line: Aspect_TOL_SOLID
        Width: 1.0
        These attributes are used by the algorithm Prs3d_WFShape

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_FreeBoundaryAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnFreeBoundaryAspect(self, *args):
        """
        HasOwnFreeBoundaryAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        free boundaries aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnFreeBoundaryAspect(self, *args)


    def SetFreeBoundaryDraw(self, *args):
        """
        SetFreeBoundaryDraw(Handle_AIS_ColoredDrawer self, Standard_Boolean const theIsEnabled)

        Enables or disables drawing of free boundaries for shading presentations.
        The method sets drawing flag owned by the drawer that will be used during
        visualization instead of the one set in link.
        theIsEnabled is a boolean flag indicating whether the free boundaries should be
        drawn or not.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetFreeBoundaryDraw(self, *args)


    def FreeBoundaryDraw(self, *args):
        """
        FreeBoundaryDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns True if the drawing of the free boundaries is enabled
        True is the default setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_FreeBoundaryDraw(self, *args)


    def HasOwnFreeBoundaryDraw(self, *args):
        """
        HasOwnFreeBoundaryDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        "draw free boundaries" flag that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnFreeBoundaryDraw(self, *args)


    def SetUnFreeBoundaryAspect(self, *args):
        """
        SetUnFreeBoundaryAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets the parameter theAspect for the display of shared boundaries.
        The method sets aspect owned by the drawer that will be used during
        visualization instead of the one set in link.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetUnFreeBoundaryAspect(self, *args)


    def UnFreeBoundaryAspect(self, *args):
        """
        Returns settings for shared boundary line aspects.
        The LineAspect for the unfree boundaries can be edited.
        The default values are:
        Color: Quantity_NOC_YELLOW
        Type of line: Aspect_TOL_SOLID
        Width: 1.
        These attributes are used by the algorithm Prs3d_WFShape

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_UnFreeBoundaryAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnUnFreeBoundaryAspect(self, *args):
        """
        HasOwnUnFreeBoundaryAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        unfree boundaries aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnUnFreeBoundaryAspect(self, *args)


    def SetUnFreeBoundaryDraw(self, *args):
        """
        SetUnFreeBoundaryDraw(Handle_AIS_ColoredDrawer self, Standard_Boolean const theIsEnabled)

        Enables or disables drawing of shared boundaries for shading presentations.
        The method sets drawing flag owned by the drawer that will be used during
        visualization instead of the one set in link.
        theIsEnabled is a boolean flag indicating whether the shared boundaries should be drawn or not.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetUnFreeBoundaryDraw(self, *args)


    def UnFreeBoundaryDraw(self, *args):
        """
        UnFreeBoundaryDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns True if the drawing of the shared boundaries is enabled.
        True is the default setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_UnFreeBoundaryDraw(self, *args)


    def HasOwnUnFreeBoundaryDraw(self, *args):
        """
        HasOwnUnFreeBoundaryDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        "draw shared boundaries" flag that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnUnFreeBoundaryDraw(self, *args)


    def SetFaceBoundaryAspect(self, *args):
        """
        SetFaceBoundaryAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_LineAspect theAspect)

        Sets line aspect for face boundaries.
        The method sets line aspect owned by the drawer that will be used during
        visualization instead of the one set in link.
        theAspect is the line aspect that determines the look of the face boundaries.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetFaceBoundaryAspect(self, *args)


    def FaceBoundaryAspect(self, *args):
        """
        Returns line aspect of face boundaries.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_LineAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_FaceBoundaryAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnFaceBoundaryAspect(self, *args):
        """
        HasOwnFaceBoundaryAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        face boundaries aspect that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnFaceBoundaryAspect(self, *args)


    def SetFaceBoundaryDraw(self, *args):
        """
        SetFaceBoundaryDraw(Handle_AIS_ColoredDrawer self, Standard_Boolean const theIsEnabled)

        Enables or disables face boundary drawing for shading presentations. 
        The method sets drawing flag owned by the drawer that will be used during
        visualization instead of the one set in link.
        theIsEnabled is a boolean flag indicating whether the face boundaries should be drawn or not.

        :type theIsEnabled: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetFaceBoundaryDraw(self, *args)


    def FaceBoundaryDraw(self, *args):
        """
        FaceBoundaryDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Checks whether the face boundary drawing is enabled or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_FaceBoundaryDraw(self, *args)


    def HasOwnFaceBoundaryDraw(self, *args):
        """
        HasOwnFaceBoundaryDraw(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        "draw face boundaries" flag that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnFaceBoundaryDraw(self, *args)


    def DimensionAspect(self, *args):
        """
        Returns settings for the appearance of dimensions. 

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        res = _AIS.Handle_AIS_ColoredDrawer_DimensionAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDimensionAspect(self, *args):
        """
        SetDimensionAspect(Handle_AIS_ColoredDrawer self, Handle_Prs3d_DimensionAspect theAspect)

        Sets the settings for the appearance of dimensions.
        The method sets aspect owned by the drawer that will be used during
        visualization instead of the one set in link.

        :type theAspect: OCC.wrapper.Prs3d.Handle_Prs3d_DimensionAspect

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDimensionAspect(self, *args)


    def HasOwnDimensionAspect(self, *args):
        """
        HasOwnDimensionAspect(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        the appearance of dimensions that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDimensionAspect(self, *args)


    def SetDimLengthModelUnits(self, *args):
        """
        SetDimLengthModelUnits(Handle_AIS_ColoredDrawer self, TCollection_AsciiString theUnits)

        Sets dimension length model units for computing of dimension presentation.
        The method sets value owned by the drawer that will be used during
        visualization instead of the one set in link.

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDimLengthModelUnits(self, *args)


    def SetDimAngleModelUnits(self, *args):
        """
        SetDimAngleModelUnits(Handle_AIS_ColoredDrawer self, TCollection_AsciiString theUnits)

        Sets dimension angle model units for computing of dimension presentation.
        The method sets value owned by the drawer that will be used during
        visualization instead of the one set in link.

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDimAngleModelUnits(self, *args)


    def DimLengthModelUnits(self, *args):
        """
        Returns length model units for the dimension presentation. 

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_ColoredDrawer_DimLengthModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DimAngleModelUnits(self, *args):
        """
        Returns angle model units for the dimension presentation. 

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_ColoredDrawer_DimAngleModelUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnDimLengthModelUnits(self, *args):
        """
        HasOwnDimLengthModelUnits(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        dimension length model units that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDimLengthModelUnits(self, *args)


    def HasOwnDimAngleModelUnits(self, *args):
        """
        HasOwnDimAngleModelUnits(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        dimension angle model units that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDimAngleModelUnits(self, *args)


    def SetDimLengthDisplayUnits(self, *args):
        """
        SetDimLengthDisplayUnits(Handle_AIS_ColoredDrawer self, TCollection_AsciiString theUnits)

        Sets length units in which value for dimension presentation is displayed.
        The method sets value owned by the drawer that will be used during
        visualization instead of the one set in link.

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDimLengthDisplayUnits(self, *args)


    def SetDimAngleDisplayUnits(self, *args):
        """
        SetDimAngleDisplayUnits(Handle_AIS_ColoredDrawer self, TCollection_AsciiString theUnits)

        Sets angle units in which value for dimension presentation is displayed.
        The method sets value owned by the drawer that will be used during
        visualization instead of the one set in link.

        :type theUnits: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDimAngleDisplayUnits(self, *args)


    def DimLengthDisplayUnits(self, *args):
        """
        Returns length units in which dimension presentation is displayed.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_ColoredDrawer_DimLengthDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DimAngleDisplayUnits(self, *args):
        """
        Returns angle units in which dimension presentation is displayed.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _AIS.Handle_AIS_ColoredDrawer_DimAngleDisplayUnits(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnDimLengthDisplayUnits(self, *args):
        """
        HasOwnDimLengthDisplayUnits(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        length units in which dimension presentation is displayed
        that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDimLengthDisplayUnits(self, *args)


    def HasOwnDimAngleDisplayUnits(self, *args):
        """
        HasOwnDimAngleDisplayUnits(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the drawer has its own attribute for
        angle units in which dimension presentation is displayed
        that overrides the one in the link.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasOwnDimAngleDisplayUnits(self, *args)


    def Link(self, *args):
        """
        Returns the drawer to which the current object references.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _AIS.Handle_AIS_ColoredDrawer_Link(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasLink(self, *args):
        """
        HasLink(Handle_AIS_ColoredDrawer self) -> Standard_Boolean

        Returns true if the current object has a link on the other drawer.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_HasLink(self, *args)


    def SetLink(self, *args):
        """
        SetLink(Handle_AIS_ColoredDrawer self, Handle_Prs3d_Drawer theDrawer)

        Sets theDrawer as a link to which the current object references.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetLink(self, *args)


    def ClearLocalAttributes(self, *args):
        """
        ClearLocalAttributes(Handle_AIS_ColoredDrawer self)

        Removes local attributes. 


        """
        return _AIS.Handle_AIS_ColoredDrawer_ClearLocalAttributes(self, *args)


    def SetShaderProgram(self, *args):
        """
        SetShaderProgram(Handle_AIS_ColoredDrawer self, Handle_Graphic3d_ShaderProgram theProgram, Graphic3d_GroupAspect const theAspect, bool const theToOverrideDefaults=False) -> bool

        Assign shader program for specified type of primitives.
        @param theProgram new program to set (might be NULL)
        @param theAspect  the type of primitives
        @param theToOverrideDefaults if true then non-overridden attributes using defaults will be allocated and copied from the Link;
        otherwise, only already customized attributes will be changed
        @return TRUE if presentation should be recomputed after creating aspects not previously customized (if theToOverrideDefaults is also TRUE)

        :type theProgram: OCC.wrapper.Graphic3d.Handle_Graphic3d_ShaderProgram
        :type theAspect: OCC.wrapper.Graphic3d.Graphic3d_GroupAspect
        :type theToOverrideDefaults: const bool
        :rtype: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetShaderProgram(self, *args)


    def SetShadingModel(self, *args):
        """
        SetShadingModel(Handle_AIS_ColoredDrawer self, Graphic3d_TypeOfShadingModel theModel, bool theToOverrideDefaults=False) -> bool

        Sets Shading Model type for the shading aspect.

        :type theModel: OCC.wrapper.Graphic3d.Graphic3d_TypeOfShadingModel
        :type theToOverrideDefaults: bool
        :rtype: bool

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetShadingModel(self, *args)


    def Method(self, *args):
        """
        Method(Handle_AIS_ColoredDrawer self) -> Aspect_TypeOfHighlightMethod

        Returns highlight method, Aspect_TOHM_COLOR by default.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfHighlightMethod

        """
        return _AIS.Handle_AIS_ColoredDrawer_Method(self, *args)


    def SetMethod(self, *args):
        """
        SetMethod(Handle_AIS_ColoredDrawer self, Aspect_TypeOfHighlightMethod const theMethod)

        Changes highlight method to the given one.

        :type theMethod: OCC.wrapper.Aspect.Aspect_TypeOfHighlightMethod

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetMethod(self, *args)


    def ColorRGBA(self, *args):
        """
        Returns basic presentation color (including alpha channel).

        :rtype: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        res = _AIS.Handle_AIS_ColoredDrawer_ColorRGBA(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Color(self, *args):
        """
        Returns basic presentation color, Quantity_NOC_WHITE by default.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _AIS.Handle_AIS_ColoredDrawer_Color(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColor(self, *args):
        """
        SetColor(Handle_AIS_ColoredDrawer self, Quantity_Color theColor)

        Sets basic presentation color (RGB components, does not modifies transparency).

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetColor(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_AIS_ColoredDrawer self) -> Standard_ShortReal

        Returns basic presentation transparency (0 - opaque, 1 - fully transparent), 0 by default (opaque).

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _AIS.Handle_AIS_ColoredDrawer_Transparency(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_AIS_ColoredDrawer self, Standard_ShortReal const theTranspCoef)

        Sets basic presentation transparency (0 - opaque, 1 - fully transparent).

        :type theTranspCoef: float

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetTransparency(self, *args)


    def ZLayer(self, *args):
        """
        ZLayer(Handle_AIS_ColoredDrawer self) -> Graphic3d_ZLayerId

        Returns presentation Zlayer, Graphic3d_ZLayerId_Default by default.
        Graphic3d_ZLayerId_UNKNOWN means undefined (a layer of main presentation to be used).

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ColoredDrawer_ZLayer(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_AIS_ColoredDrawer self, Graphic3d_ZLayerId const theLayer)

        Sets presentation Zlayer.

        :type theLayer: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetZLayer(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_AIS_ColoredDrawer self) -> Standard_Integer

        Returns display mode, 0 by default.
        -1 means undefined (main display mode of presentation to be used).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredDrawer_DisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_AIS_ColoredDrawer self, Standard_Integer const theMode)

        Sets display mode.

        :type theMode: int

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetDisplayMode(self, *args)


    def BasicFillAreaAspect(self, *args):
        """
        Return basic presentation fill area aspect, NULL by default.
        When set, might be used instead of Color() property.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        res = _AIS.Handle_AIS_ColoredDrawer_BasicFillAreaAspect(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBasicFillAreaAspect(self, *args):
        """
        SetBasicFillAreaAspect(Handle_AIS_ColoredDrawer self, Handle_Graphic3d_AspectFillArea3d theAspect)

        Sets basic presentation fill area aspect.

        :type theAspect: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _AIS.Handle_AIS_ColoredDrawer_SetBasicFillAreaAspect(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_AIS_ColoredDrawer self)

        Memory deallocator for transient classes


        """
        return _AIS.Handle_AIS_ColoredDrawer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AIS_ColoredDrawer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AIS_ColoredDrawer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AIS_ColoredDrawer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AIS_ColoredDrawer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AIS.Handle_AIS_ColoredDrawer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AIS_ColoredDrawer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AIS.Handle_AIS_ColoredDrawer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AIS_ColoredDrawer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredDrawer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AIS_ColoredDrawer self)

        Increments the reference counter of this object


        """
        return _AIS.Handle_AIS_ColoredDrawer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AIS_ColoredDrawer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AIS.Handle_AIS_ColoredDrawer_DecrementRefCounter(self, *args)

Handle_AIS_ColoredDrawer_swigregister = _AIS.Handle_AIS_ColoredDrawer_swigregister
Handle_AIS_ColoredDrawer_swigregister(Handle_AIS_ColoredDrawer)

def Handle_AIS_ColoredDrawer_DownCast(thing):
    return _AIS.Handle_AIS_ColoredDrawer_DownCast(thing)
Handle_AIS_ColoredDrawer_DownCast = _AIS.Handle_AIS_ColoredDrawer_DownCast




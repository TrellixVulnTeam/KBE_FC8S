# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopOpeBRepTool')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopOpeBRepTool')
    _TopOpeBRepTool = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopOpeBRepTool', [dirname(__file__)])
        except ImportError:
            import _TopOpeBRepTool
            return _TopOpeBRepTool
        try:
            _mod = imp.load_module('_TopOpeBRepTool', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopOpeBRepTool = swig_import_helper()
    del swig_import_helper
else:
    import _TopOpeBRepTool
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopOpeBRepTool.delete_SwigPyIterator

    def value(self):
        return _TopOpeBRepTool.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopOpeBRepTool.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopOpeBRepTool.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopOpeBRepTool.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopOpeBRepTool.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopOpeBRepTool.SwigPyIterator_copy(self)

    def next(self):
        return _TopOpeBRepTool.SwigPyIterator_next(self)

    def __next__(self):
        return _TopOpeBRepTool.SwigPyIterator___next__(self)

    def previous(self):
        return _TopOpeBRepTool.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopOpeBRepTool.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopOpeBRepTool.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopOpeBRepTool.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopOpeBRepTool.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopOpeBRepTool.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopOpeBRepTool.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopOpeBRepTool.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopOpeBRepTool.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopOpeBRepTool.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopOpeBRepTool.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopOpeBRepTool.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopOpeBRepTool.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopOpeBRepTool.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopOpeBRepTool.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopOpeBRepTool.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopOpeBRepTool.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopOpeBRepTool.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopOpeBRepTool.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopOpeBRepTool.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopOpeBRepTool.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopOpeBRepTool.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopOpeBRepTool.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopOpeBRepTool.ptr_to_number(item)
ptr_to_number = _TopOpeBRepTool.ptr_to_number

def HashCode(*args):
    return _TopOpeBRepTool.HashCode(*args)
HashCode = _TopOpeBRepTool.HashCode

def ptr_equal(a, b):
    return _TopOpeBRepTool.ptr_equal(a, b)
ptr_equal = _TopOpeBRepTool.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
TopOpeBRepTool_BSPLINE1 = _TopOpeBRepTool.TopOpeBRepTool_BSPLINE1
TopOpeBRepTool_APPROX = _TopOpeBRepTool.TopOpeBRepTool_APPROX
TopOpeBRepTool_INTERPOL = _TopOpeBRepTool.TopOpeBRepTool_INTERPOL
class TopOpeBRepTool_C2DF(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_C2DF self) -> TopOpeBRepTool_C2DF
        __init__(TopOpeBRepTool_C2DF self, Handle_Geom2d_Curve PC, Standard_Real const f2d, Standard_Real const l2d, Standard_Real const tol, TopoDS_Face F) -> TopOpeBRepTool_C2DF

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type f2d: float
        :type l2d: float
        :type tol: float
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_C2DF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetPC(self, *args):
        """
        SetPC(TopOpeBRepTool_C2DF self, Handle_Geom2d_Curve PC, Standard_Real const f2d, Standard_Real const l2d, Standard_Real const tol)

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type f2d: float
        :type l2d: float
        :type tol: float

        """
        return _TopOpeBRepTool.TopOpeBRepTool_C2DF_SetPC(self, *args)


    def SetFace(self, *args):
        """
        SetFace(TopOpeBRepTool_C2DF self, TopoDS_Face F)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRepTool.TopOpeBRepTool_C2DF_SetFace(self, *args)


    def PC(self, *args):
        """
        :type f2d: float
        :type l2d: float
        :type tol: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_C2DF_PC(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_C2DF_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsPC(self, *args):
        """
        IsPC(TopOpeBRepTool_C2DF self, Handle_Geom2d_Curve PC) -> Standard_Boolean

        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_C2DF_IsPC(self, *args)


    def IsFace(self, *args):
        """
        IsFace(TopOpeBRepTool_C2DF self, TopoDS_Face F) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_C2DF_IsFace(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_C2DF
TopOpeBRepTool_C2DF_swigregister = _TopOpeBRepTool.TopOpeBRepTool_C2DF_swigregister
TopOpeBRepTool_C2DF_swigregister(TopOpeBRepTool_C2DF)

class TopOpeBRepTool_ShapeExplorer(TopExp.TopExp_Explorer):
    """
    Extends TopExp_Explorer by counting index of current item
    (for tracing and debug)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_ShapeExplorer self) -> TopOpeBRepTool_ShapeExplorer
        __init__(TopOpeBRepTool_ShapeExplorer self, TopoDS_Shape S, TopAbs_ShapeEnum const ToFind, TopAbs_ShapeEnum const ToAvoid=TopAbs_SHAPE) -> TopOpeBRepTool_ShapeExplorer

        Creates an Explorer on the Shape <S>.

        <ToFind> is the type of shapes to search.
        TopAbs_VERTEX, TopAbs_EDGE, ...

        <ToAvoid>   is the type   of shape to  skip in the
        exploration.   If   <ToAvoid>  is  equal  or  less
        complex than <ToFind> or if  <ToAVoid> is SHAPE it
        has no effect on the exploration.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ToFind: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type ToAvoid: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_ShapeExplorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepTool_ShapeExplorer self, TopoDS_Shape S, TopAbs_ShapeEnum const ToFind, TopAbs_ShapeEnum const ToAvoid=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ToFind: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type ToAvoid: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeExplorer_Init(self, *args)


    def Next(self, *args):
        """
        Next(TopOpeBRepTool_ShapeExplorer self)

        Moves to the next Shape in the exploration.


        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeExplorer_Next(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRepTool_ShapeExplorer self) -> Standard_Integer

        Index of current sub-shape

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeExplorer_Index(self, *args)


    def DumpCurrent(self, *args):
        """
        DumpCurrent(TopOpeBRepTool_ShapeExplorer self, Standard_OStream & OS) -> Standard_OStream &

        Dump info on current shape to stream

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeExplorer_DumpCurrent(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_ShapeExplorer
TopOpeBRepTool_ShapeExplorer_swigregister = _TopOpeBRepTool.TopOpeBRepTool_ShapeExplorer_swigregister
TopOpeBRepTool_ShapeExplorer_swigregister(TopOpeBRepTool_ShapeExplorer)

class TopOpeBRepTool_REGUS(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepTool_REGUS self) -> TopOpeBRepTool_REGUS"""
        this = _TopOpeBRepTool.new_TopOpeBRepTool_REGUS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepTool_REGUS self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_Init(self, *args)


    def S(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_REGUS_S(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MapS(self, *args):
        """
        MapS(TopOpeBRepTool_REGUS self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_MapS(self, *args)


    def WireToFace(*args):
        """
        WireToFace(TopoDS_Face Fanc, NCollection_List_TopoDS_Shape nWs, NCollection_List_TopoDS_Shape nFs) -> Standard_Boolean

        :type Fanc: OCC.wrapper.TopoDS.TopoDS_Face
        :type nWs: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type nFs: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_WireToFace(*args)

    WireToFace = staticmethod(WireToFace)

    def SplitF(*args):
        """
        SplitF(TopoDS_Face Fanc, NCollection_List_TopoDS_Shape FSplits) -> Standard_Boolean

        :type Fanc: OCC.wrapper.TopoDS.TopoDS_Face
        :type FSplits: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_SplitF(*args)

    SplitF = staticmethod(SplitF)

    def SplitFaces(self, *args):
        """
        SplitFaces(TopOpeBRepTool_REGUS self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_SplitFaces(self, *args)


    def REGU(self, *args):
        """
        REGU(TopOpeBRepTool_REGUS self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_REGU(self, *args)


    def SetFsplits(self, *args):
        """
        SetFsplits(TopOpeBRepTool_REGUS self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher Fsplits)

        :type Fsplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_SetFsplits(self, *args)


    def GetFsplits(self, *args):
        """
        GetFsplits(TopOpeBRepTool_REGUS self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher Fsplits)

        :type Fsplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_GetFsplits(self, *args)


    def SetOshNsh(self, *args):
        """
        SetOshNsh(TopOpeBRepTool_REGUS self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OshNsh)

        :type OshNsh: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_SetOshNsh(self, *args)


    def GetOshNsh(self, *args):
        """
        GetOshNsh(TopOpeBRepTool_REGUS self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OshNsh)

        :type OshNsh: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_GetOshNsh(self, *args)


    def InitBlock(self, *args):
        """
        InitBlock(TopOpeBRepTool_REGUS self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_InitBlock(self, *args)


    def NextinBlock(self, *args):
        """
        NextinBlock(TopOpeBRepTool_REGUS self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_NextinBlock(self, *args)


    def NearestF(self, *args):
        """
        NearestF(TopOpeBRepTool_REGUS self, TopoDS_Edge e, NCollection_List_TopoDS_Shape lof, TopoDS_Face ffound) -> Standard_Boolean

        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :type lof: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type ffound: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUS_NearestF(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_REGUS
TopOpeBRepTool_REGUS_swigregister = _TopOpeBRepTool.TopOpeBRepTool_REGUS_swigregister
TopOpeBRepTool_REGUS_swigregister(TopOpeBRepTool_REGUS)

def TopOpeBRepTool_REGUS_WireToFace(*args):
    """
    TopOpeBRepTool_REGUS_WireToFace(TopoDS_Face Fanc, NCollection_List_TopoDS_Shape nWs, NCollection_List_TopoDS_Shape nFs) -> Standard_Boolean

    :type Fanc: OCC.wrapper.TopoDS.TopoDS_Face
    :type nWs: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type nFs: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_REGUS_WireToFace(*args)

def TopOpeBRepTool_REGUS_SplitF(*args):
    """
    TopOpeBRepTool_REGUS_SplitF(TopoDS_Face Fanc, NCollection_List_TopoDS_Shape FSplits) -> Standard_Boolean

    :type Fanc: OCC.wrapper.TopoDS.TopoDS_Face
    :type FSplits: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_REGUS_SplitF(*args)

class TopOpeBRepTool_connexity(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_connexity self) -> TopOpeBRepTool_connexity
        __init__(TopOpeBRepTool_connexity self, TopoDS_Shape Key) -> TopOpeBRepTool_connexity

        :type Key: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_connexity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetKey(self, *args):
        """
        SetKey(TopOpeBRepTool_connexity self, TopoDS_Shape Key)

        :type Key: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_SetKey(self, *args)


    def Key(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_connexity_Key(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Item(self, *args):
        """
        Item(TopOpeBRepTool_connexity self, Standard_Integer const OriKey, NCollection_List_TopoDS_Shape Item) -> Standard_Integer

        :type OriKey: int
        :type Item: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_Item(self, *args)


    def AllItems(self, *args):
        """
        AllItems(TopOpeBRepTool_connexity self, NCollection_List_TopoDS_Shape Item) -> Standard_Integer

        :type Item: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_AllItems(self, *args)


    def AddItem(self, *args):
        """
        AddItem(TopOpeBRepTool_connexity self, Standard_Integer const OriKey, NCollection_List_TopoDS_Shape Item)
        AddItem(TopOpeBRepTool_connexity self, Standard_Integer const OriKey, TopoDS_Shape Item)

        :type OriKey: int
        :type Item: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_AddItem(self, *args)


    def RemoveItem(self, *args):
        """
        RemoveItem(TopOpeBRepTool_connexity self, Standard_Integer const OriKey, TopoDS_Shape Item) -> Standard_Boolean
        RemoveItem(TopOpeBRepTool_connexity self, TopoDS_Shape Item) -> Standard_Boolean

        :type Item: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_RemoveItem(self, *args)


    def ChangeItem(self, *args):
        """
        ChangeItem(TopOpeBRepTool_connexity self, Standard_Integer const OriKey) -> NCollection_List_TopoDS_Shape

        :type OriKey: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_ChangeItem(self, *args)


    def IsMultiple(self, *args):
        """
        IsMultiple(TopOpeBRepTool_connexity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_IsMultiple(self, *args)


    def IsFaulty(self, *args):
        """
        IsFaulty(TopOpeBRepTool_connexity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_IsFaulty(self, *args)


    def IsInternal(self, *args):
        """
        IsInternal(TopOpeBRepTool_connexity self, NCollection_List_TopoDS_Shape Item) -> Standard_Integer

        :type Item: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_connexity_IsInternal(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_connexity
TopOpeBRepTool_connexity_swigregister = _TopOpeBRepTool.TopOpeBRepTool_connexity_swigregister
TopOpeBRepTool_connexity_swigregister(TopOpeBRepTool_connexity)

class TopOpeBRepTool_mkTondgE(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepTool_mkTondgE self) -> TopOpeBRepTool_mkTondgE"""
        this = _TopOpeBRepTool.new_TopOpeBRepTool_mkTondgE(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TopOpeBRepTool_mkTondgE self, TopoDS_Edge dgE, TopoDS_Face F, gp_Pnt2d uvi, TopoDS_Face Fi) -> Standard_Boolean

        :type dgE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type uvi: OCC.wrapper.gp.gp_Pnt2d
        :type Fi: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_mkTondgE_Initialize(self, *args)


    def SetclE(self, *args):
        """
        SetclE(TopOpeBRepTool_mkTondgE self, TopoDS_Edge clE) -> Standard_Boolean

        :type clE: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_mkTondgE_SetclE(self, *args)


    def IsT2d(self, *args):
        """
        IsT2d(TopOpeBRepTool_mkTondgE self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_mkTondgE_IsT2d(self, *args)


    def SetRest(self, *args):
        """
        SetRest(TopOpeBRepTool_mkTondgE self, Standard_Real const pari, TopoDS_Edge Ei) -> Standard_Boolean

        :type pari: float
        :type Ei: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_mkTondgE_SetRest(self, *args)


    def GetAllRest(self, *args):
        """
        GetAllRest(TopOpeBRepTool_mkTondgE self, NCollection_List_TopoDS_Shape lEi) -> Standard_Integer

        :type lEi: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_mkTondgE_GetAllRest(self, *args)


    def MkTonE(self, *args):
        """
        MkTonE(TopOpeBRepTool_mkTondgE self) -> Standard_Boolean
        MkTonE(TopOpeBRepTool_mkTondgE self, TopoDS_Edge Ei) -> Standard_Boolean

        :type Ei: OCC.wrapper.TopoDS.TopoDS_Edge
        :type mkT: int
        :type par1: float
        :type par2: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_mkTondgE_MkTonE(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_mkTondgE
TopOpeBRepTool_mkTondgE_swigregister = _TopOpeBRepTool.TopOpeBRepTool_mkTondgE_swigregister
TopOpeBRepTool_mkTondgE_swigregister(TopOpeBRepTool_mkTondgE)

class NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper___next__(self)
NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper_swigregister
NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper_swigregister(NCollection_List_TopOpeBRepTool_C2DF_IteratorHelper)


try:
	TopOpeBRepTool_ListOfC2DF = NCollection_List_TopOpeBRepTool_C2DF
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepTool_CLASSI(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepTool_CLASSI self) -> TopOpeBRepTool_CLASSI"""
        this = _TopOpeBRepTool.new_TopOpeBRepTool_CLASSI(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init2d(self, *args):
        """
        Init2d(TopOpeBRepTool_CLASSI self, TopoDS_Face Fref)

        :type Fref: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_Init2d(self, *args)


    def HasInit2d(self, *args):
        """
        HasInit2d(TopOpeBRepTool_CLASSI self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_HasInit2d(self, *args)


    def Add2d(self, *args):
        """
        Add2d(TopOpeBRepTool_CLASSI self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_Add2d(self, *args)


    def GetBox2d(self, *args):
        """
        GetBox2d(TopOpeBRepTool_CLASSI self, TopoDS_Shape S, Bnd_Box2d Box2d) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Box2d: OCC.wrapper.Bnd.Bnd_Box2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_GetBox2d(self, *args)


    def ClassiBnd2d(self, *args):
        """
        ClassiBnd2d(TopOpeBRepTool_CLASSI self, TopoDS_Shape S1, TopoDS_Shape S2, Standard_Real const tol, Standard_Boolean const checklarge) -> Standard_Integer

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type tol: float
        :type checklarge: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_ClassiBnd2d(self, *args)


    def Classip2d(self, *args):
        """
        Classip2d(TopOpeBRepTool_CLASSI self, TopoDS_Shape S1, TopoDS_Shape S2, Standard_Integer const stabnd2d12) -> Standard_Integer

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type stabnd2d12: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_Classip2d(self, *args)


    def Getface(self, *args):
        """
        Getface(TopOpeBRepTool_CLASSI self, TopoDS_Shape S, TopOpeBRepTool_face fa) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type fa: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_Getface(self, *args)


    def Classilist(self, *args):
        """
        Classilist(TopOpeBRepTool_CLASSI self, NCollection_List_TopoDS_Shape lS, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher mapgreasma) -> Standard_Boolean

        :type lS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type mapgreasma: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CLASSI_Classilist(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_CLASSI
TopOpeBRepTool_CLASSI_swigregister = _TopOpeBRepTool.TopOpeBRepTool_CLASSI_swigregister
TopOpeBRepTool_CLASSI_swigregister(TopOpeBRepTool_CLASSI)

class TopOpeBRepTool_face(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepTool_face self) -> TopOpeBRepTool_face"""
        this = _TopOpeBRepTool.new_TopOpeBRepTool_face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepTool_face self, TopoDS_Wire W, TopoDS_Face Fref) -> Standard_Boolean

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Fref: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_face_Init(self, *args)


    def W(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_face_W(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(TopOpeBRepTool_face self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_face_IsDone(self, *args)


    def Finite(self, *args):
        """
        Finite(TopOpeBRepTool_face self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_face_Finite(self, *args)


    def Ffinite(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_face_Ffinite(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RealF(self, *args):
        """
        RealF(TopOpeBRepTool_face self) -> TopoDS_Face

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRepTool.TopOpeBRepTool_face_RealF(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_face
TopOpeBRepTool_face_swigregister = _TopOpeBRepTool.TopOpeBRepTool_face_swigregister
TopOpeBRepTool_face_swigregister(TopOpeBRepTool_face)

class TopOpeBRepTool_CORRISO(object):
    """
    Fref is built on x-periodic surface (x=u,v).
    S built on Fref's geometry, should be UVClosed.

    Give us E, an edge of S. 2drep(E) is not UV connexed.
    We translate 2drep(E) in xdir*xperiod if necessary.

    call : TopOpeBRepTool_CORRISO Tool(Fref);
    Tool.Init(S);
    if (!Tool.UVClosed()) {
    // initialize EdsToCheck,nfybounds,stopatfirst

    Tool.EdgeWithFaultyUV(EdsToCheck,nfybounds,FyEds,stopatfirst);
    if (Tool.SetUVClosed()) S = Tool.GetnewS();
    }
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_CORRISO self) -> TopOpeBRepTool_CORRISO
        __init__(TopOpeBRepTool_CORRISO self, TopoDS_Face FRef) -> TopOpeBRepTool_CORRISO

        :type FRef: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_CORRISO(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Fref(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_CORRISO_Fref(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GASref(self, *args):
        """
        :rtype: OCC.wrapper.GeomAdaptor.GeomAdaptor_Surface

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_CORRISO_GASref(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Refclosed(self, *args):
        """
        Refclosed(TopOpeBRepTool_CORRISO self, Standard_Integer const x) -> Standard_Boolean

        :type x: int
        :type xperiod: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_Refclosed(self, *args)


    def Init(self, *args):
        """
        Init(TopOpeBRepTool_CORRISO self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_Init(self, *args)


    def S(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_CORRISO_S(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Eds(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_CORRISO_Eds(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UVClosed(self, *args):
        """
        UVClosed(TopOpeBRepTool_CORRISO self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_UVClosed(self, *args)


    def Tol(self, *args):
        """
        Tol(TopOpeBRepTool_CORRISO self, Standard_Integer const I, Standard_Real const tol3d) -> Standard_Real

        :type I: int
        :type tol3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_Tol(self, *args)


    def PurgeFyClosingE(self, *args):
        """
        PurgeFyClosingE(TopOpeBRepTool_CORRISO self, NCollection_List_TopoDS_Shape ClEds, NCollection_List_TopoDS_Shape fyClEds) -> Standard_Boolean

        :type ClEds: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type fyClEds: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_PurgeFyClosingE(self, *args)


    def EdgeOUTofBoundsUV(self, *args):
        """
        EdgeOUTofBoundsUV(TopOpeBRepTool_CORRISO self, TopoDS_Edge E, Standard_Boolean const onU, Standard_Real const tolx) -> Standard_Integer

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type onU: bool
        :type tolx: float
        :type parspE: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_EdgeOUTofBoundsUV(self, *args)


    def EdgesOUTofBoundsUV(self, *args):
        """
        EdgesOUTofBoundsUV(TopOpeBRepTool_CORRISO self, NCollection_List_TopoDS_Shape EdsToCheck, Standard_Boolean const onU, Standard_Real const tolx, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher FyEds) -> Standard_Boolean

        :type EdsToCheck: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type onU: bool
        :type tolx: float
        :type FyEds: OCC.wrapper.TopTools.TopTools_DataMapOfOrientedShapeInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_EdgesOUTofBoundsUV(self, *args)


    def EdgesWithFaultyUV(self, *args):
        """
        EdgesWithFaultyUV(TopOpeBRepTool_CORRISO self, NCollection_List_TopoDS_Shape EdsToCheck, Standard_Integer const nfybounds, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher FyEds, Standard_Boolean const stopatfirst) -> Standard_Boolean

        :type EdsToCheck: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type nfybounds: int
        :type FyEds: OCC.wrapper.TopTools.TopTools_DataMapOfOrientedShapeInteger
        :type stopatfirst: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_EdgesWithFaultyUV(self, *args)


    def EdgeWithFaultyUV(self, *args):
        """
        EdgeWithFaultyUV(TopOpeBRepTool_CORRISO self, TopoDS_Edge E) -> Standard_Boolean
        EdgeWithFaultyUV(TopOpeBRepTool_CORRISO self, NCollection_List_TopoDS_Shape EdsToCheck, Standard_Integer const nfybounds, TopoDS_Shape fyE) -> Standard_Boolean

        :type EdsToCheck: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type nfybounds: int
        :type fyE: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Ifaulty: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_EdgeWithFaultyUV(self, *args)


    def TrslUV(self, *args):
        """
        TrslUV(TopOpeBRepTool_CORRISO self, Standard_Boolean const onU, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_OrientedShapeMapHasher FyEds) -> Standard_Boolean

        :type onU: bool
        :type FyEds: OCC.wrapper.TopTools.TopTools_DataMapOfOrientedShapeInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_TrslUV(self, *args)


    def GetnewS(self, *args):
        """
        GetnewS(TopOpeBRepTool_CORRISO self, TopoDS_Face newS) -> Standard_Boolean

        :type newS: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_GetnewS(self, *args)


    def UVRep(self, *args):
        """
        UVRep(TopOpeBRepTool_CORRISO self, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_UVRep(self, *args)


    def SetUVRep(self, *args):
        """
        SetUVRep(TopOpeBRepTool_CORRISO self, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_SetUVRep(self, *args)


    def Connexity(self, *args):
        """
        Connexity(TopOpeBRepTool_CORRISO self, TopoDS_Vertex V, NCollection_List_TopoDS_Shape Eds) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Eds: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_Connexity(self, *args)


    def SetConnexity(self, *args):
        """
        SetConnexity(TopOpeBRepTool_CORRISO self, TopoDS_Vertex V, NCollection_List_TopoDS_Shape Eds) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Eds: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_SetConnexity(self, *args)


    def AddNewConnexity(self, *args):
        """
        AddNewConnexity(TopOpeBRepTool_CORRISO self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_AddNewConnexity(self, *args)


    def RemoveOldConnexity(self, *args):
        """
        RemoveOldConnexity(TopOpeBRepTool_CORRISO self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CORRISO_RemoveOldConnexity(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_CORRISO
TopOpeBRepTool_CORRISO_swigregister = _TopOpeBRepTool.TopOpeBRepTool_CORRISO_swigregister
TopOpeBRepTool_CORRISO_swigregister(TopOpeBRepTool_CORRISO)

class TopOpeBRepTool_TOOL(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def OriinSor(*args):
        """
        OriinSor(TopoDS_Shape sub, TopoDS_Shape S, Standard_Boolean const checkclo) -> Standard_Integer

        :type sub: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type checkclo: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_OriinSor(*args)

    OriinSor = staticmethod(OriinSor)

    def OriinSorclosed(*args):
        """
        OriinSorclosed(TopoDS_Shape sub, TopoDS_Shape S) -> Standard_Integer

        :type sub: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_OriinSorclosed(*args)

    OriinSorclosed = staticmethod(OriinSorclosed)

    def ClosedE(*args):
        """
        ClosedE(TopoDS_Edge E, TopoDS_Vertex vclo) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type vclo: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ClosedE(*args)

    ClosedE = staticmethod(ClosedE)

    def ClosedS(*args):
        """
        ClosedS(TopoDS_Face F) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ClosedS(*args)

    ClosedS = staticmethod(ClosedS)

    def IsClosingE(*args):
        """
        IsClosingE(TopoDS_Edge E, TopoDS_Face F) -> Standard_Boolean
        IsClosingE(TopoDS_Edge E, TopoDS_Shape W, TopoDS_Face F) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type W: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_IsClosingE(*args)

    IsClosingE = staticmethod(IsClosingE)

    def Vertices(*args):
        """
        Vertices(TopoDS_Edge E, NCollection_Array1_TopoDS_Shape Vces)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Vces: OCC.wrapper.TopTools.TopTools_Array1OfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Vertices(*args)

    Vertices = staticmethod(Vertices)

    def Vertex(*args):
        """
        Vertex(Standard_Integer const Iv, TopoDS_Edge E) -> TopoDS_Vertex

        :type Iv: int
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Vertex(*args)

    Vertex = staticmethod(Vertex)

    def ParE(*args):
        """
        ParE(Standard_Integer const Iv, TopoDS_Edge E) -> Standard_Real

        :type Iv: int
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ParE(*args)

    ParE = staticmethod(ParE)

    def OnBoundary(*args):
        """
        OnBoundary(Standard_Real const par, TopoDS_Edge E) -> Standard_Integer

        :type par: float
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_OnBoundary(*args)

    OnBoundary = staticmethod(OnBoundary)

    def UVF(*args):
        """
        UVF(Standard_Real const par, TopOpeBRepTool_C2DF C2DF) -> gp_Pnt2d

        :type par: float
        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_UVF(*args)

    UVF = staticmethod(UVF)

    def ParISO(*args):
        """
        ParISO(gp_Pnt2d p2d, TopoDS_Edge e, TopoDS_Face f) -> Standard_Boolean

        :type p2d: OCC.wrapper.gp.gp_Pnt2d
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :type f: OCC.wrapper.TopoDS.TopoDS_Face
        :type pare: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ParISO(*args)

    ParISO = staticmethod(ParISO)

    def ParE2d(*args):
        """
        ParE2d(gp_Pnt2d p2d, TopoDS_Edge e, TopoDS_Face f) -> Standard_Boolean

        :type p2d: OCC.wrapper.gp.gp_Pnt2d
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :type f: OCC.wrapper.TopoDS.TopoDS_Face
        :type par: float
        :type dist: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ParE2d(*args)

    ParE2d = staticmethod(ParE2d)

    def Getduv(*args):
        """
        Getduv(TopoDS_Face f, gp_Pnt2d uv, gp_Vec dir, Standard_Real const factor, gp_Dir2d duv) -> Standard_Boolean

        :type f: OCC.wrapper.TopoDS.TopoDS_Face
        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type dir: OCC.wrapper.gp.gp_Vec
        :type factor: float
        :type duv: OCC.wrapper.gp.gp_Dir2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Getduv(*args)

    Getduv = staticmethod(Getduv)

    def uvApp(*args):
        """
        uvApp(TopoDS_Face f, TopoDS_Edge e, Standard_Real const par, Standard_Real const eps, gp_Pnt2d uvapp) -> Standard_Boolean

        :type f: OCC.wrapper.TopoDS.TopoDS_Face
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :type par: float
        :type eps: float
        :type uvapp: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_uvApp(*args)

    uvApp = staticmethod(uvApp)

    def TolUV(*args):
        """
        TolUV(TopoDS_Face F, Standard_Real const tol3d) -> Standard_Real

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type tol3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TolUV(*args)

    TolUV = staticmethod(TolUV)

    def TolP(*args):
        """
        TolP(TopoDS_Edge E, TopoDS_Face F) -> Standard_Real

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TolP(*args)

    TolP = staticmethod(TolP)

    def minDUV(*args):
        """
        minDUV(TopoDS_Face F) -> Standard_Real

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_minDUV(*args)

    minDUV = staticmethod(minDUV)

    def outUVbounds(*args):
        """
        outUVbounds(gp_Pnt2d uv, TopoDS_Face F) -> Standard_Boolean

        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_outUVbounds(*args)

    outUVbounds = staticmethod(outUVbounds)

    def stuvF(*args):
        """
        stuvF(gp_Pnt2d uv, TopoDS_Face F)

        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type onU: int
        :type onV: int

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_stuvF(*args)

    stuvF = staticmethod(stuvF)

    def TggeomE(*args):
        """
        TggeomE(Standard_Real const par, BRepAdaptor_Curve BC, gp_Vec Tg) -> Standard_Boolean
        TggeomE(Standard_Real const par, TopoDS_Edge E, gp_Vec Tg) -> Standard_Boolean

        :type par: float
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Tg: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TggeomE(*args)

    TggeomE = staticmethod(TggeomE)

    def TgINSIDE(*args):
        """
        TgINSIDE(TopoDS_Vertex v, TopoDS_Edge E, gp_Vec Tg) -> Standard_Boolean

        :type v: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Tg: OCC.wrapper.gp.gp_Vec
        :type OvinE: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TgINSIDE(*args)

    TgINSIDE = staticmethod(TgINSIDE)

    def Tg2d(*args):
        """
        Tg2d(Standard_Integer const iv, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF) -> gp_Vec2d

        :type iv: int
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Tg2d(*args)

    Tg2d = staticmethod(Tg2d)

    def Tg2dApp(*args):
        """
        Tg2dApp(Standard_Integer const iv, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF, Standard_Real const factor) -> gp_Vec2d

        :type iv: int
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
        :type factor: float
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Tg2dApp(*args)

    Tg2dApp = staticmethod(Tg2dApp)

    def tryTg2dApp(*args):
        """
        tryTg2dApp(Standard_Integer const iv, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF, Standard_Real const factor) -> gp_Vec2d

        :type iv: int
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
        :type factor: float
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_tryTg2dApp(*args)

    tryTg2dApp = staticmethod(tryTg2dApp)

    def XX(*args):
        """
        XX(gp_Pnt2d uv, TopoDS_Face f, Standard_Real const par, TopoDS_Edge e, gp_Dir xx) -> Standard_Boolean

        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type f: OCC.wrapper.TopoDS.TopoDS_Face
        :type par: float
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :type xx: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_XX(*args)

    XX = staticmethod(XX)

    def Nt(*args):
        """
        Nt(gp_Pnt2d uv, TopoDS_Face f, gp_Dir normt) -> Standard_Boolean

        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type f: OCC.wrapper.TopoDS.TopoDS_Face
        :type normt: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Nt(*args)

    Nt = staticmethod(Nt)

    def NggeomF(*args):
        """
        NggeomF(gp_Pnt2d uv, TopoDS_Face F, gp_Vec ng) -> Standard_Boolean

        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type ng: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_NggeomF(*args)

    NggeomF = staticmethod(NggeomF)

    def NgApp(*args):
        """
        NgApp(Standard_Real const par, TopoDS_Edge E, TopoDS_Face F, Standard_Real const tola, gp_Dir ngApp) -> Standard_Boolean

        :type par: float
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type tola: float
        :type ngApp: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_NgApp(*args)

    NgApp = staticmethod(NgApp)

    def tryNgApp(*args):
        """
        tryNgApp(Standard_Real const par, TopoDS_Edge E, TopoDS_Face F, Standard_Real const tola, gp_Dir ng) -> Standard_Boolean

        :type par: float
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type tola: float
        :type ng: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_tryNgApp(*args)

    tryNgApp = staticmethod(tryNgApp)

    def tryOriEinF(*args):
        """
        tryOriEinF(Standard_Real const par, TopoDS_Edge E, TopoDS_Face F) -> Standard_Integer

        :type par: float
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_tryOriEinF(*args)

    tryOriEinF = staticmethod(tryOriEinF)

    def IsQuad(*args):
        """
        IsQuad(TopoDS_Edge E) -> Standard_Boolean
        IsQuad(TopoDS_Face F) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_IsQuad(*args)

    IsQuad = staticmethod(IsQuad)

    def CurvE(*args):
        """
        CurvE(TopoDS_Edge E, Standard_Real const par, gp_Dir tg0) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type par: float
        :type tg0: OCC.wrapper.gp.gp_Dir
        :type Curv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_CurvE(*args)

    CurvE = staticmethod(CurvE)

    def CurvF(*args):
        """
        CurvF(TopoDS_Face F, gp_Pnt2d uv, gp_Dir tg0) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type tg0: OCC.wrapper.gp.gp_Dir
        :type Curv: float
        :type direct: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_CurvF(*args)

    CurvF = staticmethod(CurvF)

    def UVISO(*args):
        """
        UVISO(Handle_Geom2d_Curve PC, gp_Dir2d d2d, gp_Pnt2d o2d) -> Standard_Boolean
        UVISO(TopOpeBRepTool_C2DF C2DF, gp_Dir2d d2d, gp_Pnt2d o2d) -> Standard_Boolean
        UVISO(TopoDS_Edge E, TopoDS_Face F, gp_Dir2d d2d, gp_Pnt2d o2d) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type isou: bool
        :type isov: bool
        :type d2d: OCC.wrapper.gp.gp_Dir2d
        :type o2d: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_UVISO(*args)

    UVISO = staticmethod(UVISO)

    def IsonCLO(*args):
        """
        IsonCLO(Handle_Geom2d_Curve PC, Standard_Boolean const onU, Standard_Real const xfirst, Standard_Real const xperiod, Standard_Real const xtol) -> Standard_Boolean
        IsonCLO(TopOpeBRepTool_C2DF C2DF, Standard_Boolean const onU, Standard_Real const xfirst, Standard_Real const xperiod, Standard_Real const xtol) -> Standard_Boolean

        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
        :type onU: bool
        :type xfirst: float
        :type xperiod: float
        :type xtol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_IsonCLO(*args)

    IsonCLO = staticmethod(IsonCLO)

    def TrslUV(*args):
        """
        TrslUV(gp_Vec2d t2d, TopOpeBRepTool_C2DF C2DF)

        :type t2d: OCC.wrapper.gp.gp_Vec2d
        :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TrslUV(*args)

    TrslUV = staticmethod(TrslUV)

    def TrslUVModifE(*args):
        """
        TrslUVModifE(gp_Vec2d t2d, TopoDS_Face F, TopoDS_Edge E) -> Standard_Boolean

        :type t2d: OCC.wrapper.gp.gp_Vec2d
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TrslUVModifE(*args)

    TrslUVModifE = staticmethod(TrslUVModifE)

    def Matter(*args):
        """
        Matter(gp_Vec d1, gp_Vec d2, gp_Vec ref) -> Standard_Real
        Matter(gp_Vec2d d1, gp_Vec2d d2) -> Standard_Real
        Matter(gp_Dir xx1, gp_Dir nt1, gp_Dir xx2, gp_Dir nt2, Standard_Real const tola) -> Standard_Boolean
        Matter(TopoDS_Face f1, TopoDS_Face f2, TopoDS_Edge e, Standard_Real const pare, Standard_Real const tola) -> Standard_Boolean

        :type f1: OCC.wrapper.TopoDS.TopoDS_Face
        :type f2: OCC.wrapper.TopoDS.TopoDS_Face
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :type pare: float
        :type tola: float
        :type Ang: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Matter(*args)

    Matter = staticmethod(Matter)

    def MatterKPtg(*args):
        """
        MatterKPtg(TopoDS_Face f1, TopoDS_Face f2, TopoDS_Edge e) -> Standard_Boolean

        :type f1: OCC.wrapper.TopoDS.TopoDS_Face
        :type f2: OCC.wrapper.TopoDS.TopoDS_Face
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Ang: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_MatterKPtg(*args)

    MatterKPtg = staticmethod(MatterKPtg)

    def Getstp3dF(*args):
        """
        Getstp3dF(gp_Pnt p, TopoDS_Face f, gp_Pnt2d uv) -> Standard_Boolean

        :type p: OCC.wrapper.gp.gp_Pnt
        :type f: OCC.wrapper.TopoDS.TopoDS_Face
        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type st: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Getstp3dF(*args)

    Getstp3dF = staticmethod(Getstp3dF)

    def SplitE(*args):
        """
        SplitE(TopoDS_Edge Eanc, NCollection_List_TopoDS_Shape Splits) -> Standard_Boolean

        :type Eanc: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Splits: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_SplitE(*args)

    SplitE = staticmethod(SplitE)

    def MkShell(*args):
        """
        MkShell(NCollection_List_TopoDS_Shape lF, TopoDS_Shape She)

        :type lF: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type She: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_MkShell(*args)

    MkShell = staticmethod(MkShell)

    def Remove(*args):
        """
        Remove(NCollection_List_TopoDS_Shape loS, TopoDS_Shape toremove) -> Standard_Boolean

        :type loS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type toremove: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Remove(*args)

    Remove = staticmethod(Remove)

    def WireToFace(*args):
        """
        WireToFace(TopoDS_Face Fref, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher mapWlow, NCollection_List_TopoDS_Shape lFs) -> Standard_Boolean

        :type Fref: OCC.wrapper.TopoDS.TopoDS_Face
        :type mapWlow: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type lFs: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_WireToFace(*args)

    WireToFace = staticmethod(WireToFace)

    def EdgeONFace(*args):
        """
        EdgeONFace(Standard_Real const par, TopoDS_Edge ed, gp_Pnt2d uv, TopoDS_Face fa) -> Standard_Boolean

        :type par: float
        :type ed: OCC.wrapper.TopoDS.TopoDS_Edge
        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type fa: OCC.wrapper.TopoDS.TopoDS_Face
        :type isonfa: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_TOOL_EdgeONFace(*args)

    EdgeONFace = staticmethod(EdgeONFace)

    def __init__(self):
        this = _TopOpeBRepTool.new_TopOpeBRepTool_TOOL()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_TOOL
TopOpeBRepTool_TOOL_swigregister = _TopOpeBRepTool.TopOpeBRepTool_TOOL_swigregister
TopOpeBRepTool_TOOL_swigregister(TopOpeBRepTool_TOOL)

def TopOpeBRepTool_TOOL_OriinSor(*args):
    """
    TopOpeBRepTool_TOOL_OriinSor(TopoDS_Shape sub, TopoDS_Shape S, Standard_Boolean const checkclo) -> Standard_Integer

    :type sub: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type checkclo: bool
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_OriinSor(*args)

def TopOpeBRepTool_TOOL_OriinSorclosed(*args):
    """
    TopOpeBRepTool_TOOL_OriinSorclosed(TopoDS_Shape sub, TopoDS_Shape S) -> Standard_Integer

    :type sub: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_OriinSorclosed(*args)

def TopOpeBRepTool_TOOL_ClosedE(*args):
    """
    TopOpeBRepTool_TOOL_ClosedE(TopoDS_Edge E, TopoDS_Vertex vclo) -> Standard_Boolean

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type vclo: OCC.wrapper.TopoDS.TopoDS_Vertex
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ClosedE(*args)

def TopOpeBRepTool_TOOL_ClosedS(*args):
    """
    TopOpeBRepTool_TOOL_ClosedS(TopoDS_Face F) -> Standard_Boolean

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ClosedS(*args)

def TopOpeBRepTool_TOOL_IsClosingE(*args):
    """
    IsClosingE(TopoDS_Edge E, TopoDS_Face F) -> Standard_Boolean
    TopOpeBRepTool_TOOL_IsClosingE(TopoDS_Edge E, TopoDS_Shape W, TopoDS_Face F) -> Standard_Boolean

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type W: OCC.wrapper.TopoDS.TopoDS_Shape
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_IsClosingE(*args)

def TopOpeBRepTool_TOOL_Vertices(*args):
    """
    TopOpeBRepTool_TOOL_Vertices(TopoDS_Edge E, NCollection_Array1_TopoDS_Shape Vces)

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Vces: OCC.wrapper.TopTools.TopTools_Array1OfShape

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Vertices(*args)

def TopOpeBRepTool_TOOL_Vertex(*args):
    """
    TopOpeBRepTool_TOOL_Vertex(Standard_Integer const Iv, TopoDS_Edge E) -> TopoDS_Vertex

    :type Iv: int
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Vertex(*args)

def TopOpeBRepTool_TOOL_ParE(*args):
    """
    TopOpeBRepTool_TOOL_ParE(Standard_Integer const Iv, TopoDS_Edge E) -> Standard_Real

    :type Iv: int
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ParE(*args)

def TopOpeBRepTool_TOOL_OnBoundary(*args):
    """
    TopOpeBRepTool_TOOL_OnBoundary(Standard_Real const par, TopoDS_Edge E) -> Standard_Integer

    :type par: float
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_OnBoundary(*args)

def TopOpeBRepTool_TOOL_UVF(*args):
    """
    TopOpeBRepTool_TOOL_UVF(Standard_Real const par, TopOpeBRepTool_C2DF C2DF) -> gp_Pnt2d

    :type par: float
    :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_UVF(*args)

def TopOpeBRepTool_TOOL_ParISO(*args):
    """
    TopOpeBRepTool_TOOL_ParISO(gp_Pnt2d p2d, TopoDS_Edge e, TopoDS_Face f) -> Standard_Boolean

    :type p2d: OCC.wrapper.gp.gp_Pnt2d
    :type e: OCC.wrapper.TopoDS.TopoDS_Edge
    :type f: OCC.wrapper.TopoDS.TopoDS_Face
    :type pare: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ParISO(*args)

def TopOpeBRepTool_TOOL_ParE2d(*args):
    """
    TopOpeBRepTool_TOOL_ParE2d(gp_Pnt2d p2d, TopoDS_Edge e, TopoDS_Face f) -> Standard_Boolean

    :type p2d: OCC.wrapper.gp.gp_Pnt2d
    :type e: OCC.wrapper.TopoDS.TopoDS_Edge
    :type f: OCC.wrapper.TopoDS.TopoDS_Face
    :type par: float
    :type dist: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_ParE2d(*args)

def TopOpeBRepTool_TOOL_Getduv(*args):
    """
    TopOpeBRepTool_TOOL_Getduv(TopoDS_Face f, gp_Pnt2d uv, gp_Vec dir, Standard_Real const factor, gp_Dir2d duv) -> Standard_Boolean

    :type f: OCC.wrapper.TopoDS.TopoDS_Face
    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type dir: OCC.wrapper.gp.gp_Vec
    :type factor: float
    :type duv: OCC.wrapper.gp.gp_Dir2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Getduv(*args)

def TopOpeBRepTool_TOOL_uvApp(*args):
    """
    TopOpeBRepTool_TOOL_uvApp(TopoDS_Face f, TopoDS_Edge e, Standard_Real const par, Standard_Real const eps, gp_Pnt2d uvapp) -> Standard_Boolean

    :type f: OCC.wrapper.TopoDS.TopoDS_Face
    :type e: OCC.wrapper.TopoDS.TopoDS_Edge
    :type par: float
    :type eps: float
    :type uvapp: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_uvApp(*args)

def TopOpeBRepTool_TOOL_TolUV(*args):
    """
    TopOpeBRepTool_TOOL_TolUV(TopoDS_Face F, Standard_Real const tol3d) -> Standard_Real

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type tol3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TolUV(*args)

def TopOpeBRepTool_TOOL_TolP(*args):
    """
    TopOpeBRepTool_TOOL_TolP(TopoDS_Edge E, TopoDS_Face F) -> Standard_Real

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TolP(*args)

def TopOpeBRepTool_TOOL_minDUV(*args):
    """
    TopOpeBRepTool_TOOL_minDUV(TopoDS_Face F) -> Standard_Real

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_minDUV(*args)

def TopOpeBRepTool_TOOL_outUVbounds(*args):
    """
    TopOpeBRepTool_TOOL_outUVbounds(gp_Pnt2d uv, TopoDS_Face F) -> Standard_Boolean

    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_outUVbounds(*args)

def TopOpeBRepTool_TOOL_stuvF(*args):
    """
    TopOpeBRepTool_TOOL_stuvF(gp_Pnt2d uv, TopoDS_Face F)

    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type onU: int
    :type onV: int

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_stuvF(*args)

def TopOpeBRepTool_TOOL_TggeomE(*args):
    """
    TggeomE(Standard_Real const par, BRepAdaptor_Curve BC, gp_Vec Tg) -> Standard_Boolean
    TopOpeBRepTool_TOOL_TggeomE(Standard_Real const par, TopoDS_Edge E, gp_Vec Tg) -> Standard_Boolean

    :type par: float
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Tg: OCC.wrapper.gp.gp_Vec
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TggeomE(*args)

def TopOpeBRepTool_TOOL_TgINSIDE(*args):
    """
    TopOpeBRepTool_TOOL_TgINSIDE(TopoDS_Vertex v, TopoDS_Edge E, gp_Vec Tg) -> Standard_Boolean

    :type v: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Tg: OCC.wrapper.gp.gp_Vec
    :type OvinE: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TgINSIDE(*args)

def TopOpeBRepTool_TOOL_Tg2d(*args):
    """
    TopOpeBRepTool_TOOL_Tg2d(Standard_Integer const iv, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF) -> gp_Vec2d

    :type iv: int
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Tg2d(*args)

def TopOpeBRepTool_TOOL_Tg2dApp(*args):
    """
    TopOpeBRepTool_TOOL_Tg2dApp(Standard_Integer const iv, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF, Standard_Real const factor) -> gp_Vec2d

    :type iv: int
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
    :type factor: float
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Tg2dApp(*args)

def TopOpeBRepTool_TOOL_tryTg2dApp(*args):
    """
    TopOpeBRepTool_TOOL_tryTg2dApp(Standard_Integer const iv, TopoDS_Edge E, TopOpeBRepTool_C2DF C2DF, Standard_Real const factor) -> gp_Vec2d

    :type iv: int
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
    :type factor: float
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_tryTg2dApp(*args)

def TopOpeBRepTool_TOOL_XX(*args):
    """
    TopOpeBRepTool_TOOL_XX(gp_Pnt2d uv, TopoDS_Face f, Standard_Real const par, TopoDS_Edge e, gp_Dir xx) -> Standard_Boolean

    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type f: OCC.wrapper.TopoDS.TopoDS_Face
    :type par: float
    :type e: OCC.wrapper.TopoDS.TopoDS_Edge
    :type xx: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_XX(*args)

def TopOpeBRepTool_TOOL_Nt(*args):
    """
    TopOpeBRepTool_TOOL_Nt(gp_Pnt2d uv, TopoDS_Face f, gp_Dir normt) -> Standard_Boolean

    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type f: OCC.wrapper.TopoDS.TopoDS_Face
    :type normt: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Nt(*args)

def TopOpeBRepTool_TOOL_NggeomF(*args):
    """
    TopOpeBRepTool_TOOL_NggeomF(gp_Pnt2d uv, TopoDS_Face F, gp_Vec ng) -> Standard_Boolean

    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type ng: OCC.wrapper.gp.gp_Vec
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_NggeomF(*args)

def TopOpeBRepTool_TOOL_NgApp(*args):
    """
    TopOpeBRepTool_TOOL_NgApp(Standard_Real const par, TopoDS_Edge E, TopoDS_Face F, Standard_Real const tola, gp_Dir ngApp) -> Standard_Boolean

    :type par: float
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type tola: float
    :type ngApp: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_NgApp(*args)

def TopOpeBRepTool_TOOL_tryNgApp(*args):
    """
    TopOpeBRepTool_TOOL_tryNgApp(Standard_Real const par, TopoDS_Edge E, TopoDS_Face F, Standard_Real const tola, gp_Dir ng) -> Standard_Boolean

    :type par: float
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type tola: float
    :type ng: OCC.wrapper.gp.gp_Dir
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_tryNgApp(*args)

def TopOpeBRepTool_TOOL_tryOriEinF(*args):
    """
    TopOpeBRepTool_TOOL_tryOriEinF(Standard_Real const par, TopoDS_Edge E, TopoDS_Face F) -> Standard_Integer

    :type par: float
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_tryOriEinF(*args)

def TopOpeBRepTool_TOOL_IsQuad(*args):
    """
    IsQuad(TopoDS_Edge E) -> Standard_Boolean
    TopOpeBRepTool_TOOL_IsQuad(TopoDS_Face F) -> Standard_Boolean

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_IsQuad(*args)

def TopOpeBRepTool_TOOL_CurvE(*args):
    """
    TopOpeBRepTool_TOOL_CurvE(TopoDS_Edge E, Standard_Real const par, gp_Dir tg0) -> Standard_Boolean

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type par: float
    :type tg0: OCC.wrapper.gp.gp_Dir
    :type Curv: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_CurvE(*args)

def TopOpeBRepTool_TOOL_CurvF(*args):
    """
    TopOpeBRepTool_TOOL_CurvF(TopoDS_Face F, gp_Pnt2d uv, gp_Dir tg0) -> Standard_Boolean

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type tg0: OCC.wrapper.gp.gp_Dir
    :type Curv: float
    :type direct: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_CurvF(*args)

def TopOpeBRepTool_TOOL_UVISO(*args):
    """
    UVISO(Handle_Geom2d_Curve PC, gp_Dir2d d2d, gp_Pnt2d o2d) -> Standard_Boolean
    UVISO(TopOpeBRepTool_C2DF C2DF, gp_Dir2d d2d, gp_Pnt2d o2d) -> Standard_Boolean
    TopOpeBRepTool_TOOL_UVISO(TopoDS_Edge E, TopoDS_Face F, gp_Dir2d d2d, gp_Pnt2d o2d) -> Standard_Boolean

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type isou: bool
    :type isov: bool
    :type d2d: OCC.wrapper.gp.gp_Dir2d
    :type o2d: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_UVISO(*args)

def TopOpeBRepTool_TOOL_IsonCLO(*args):
    """
    IsonCLO(Handle_Geom2d_Curve PC, Standard_Boolean const onU, Standard_Real const xfirst, Standard_Real const xperiod, Standard_Real const xtol) -> Standard_Boolean
    TopOpeBRepTool_TOOL_IsonCLO(TopOpeBRepTool_C2DF C2DF, Standard_Boolean const onU, Standard_Real const xfirst, Standard_Real const xperiod, Standard_Real const xtol) -> Standard_Boolean

    :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF
    :type onU: bool
    :type xfirst: float
    :type xperiod: float
    :type xtol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_IsonCLO(*args)

def TopOpeBRepTool_TOOL_TrslUV(*args):
    """
    TopOpeBRepTool_TOOL_TrslUV(gp_Vec2d t2d, TopOpeBRepTool_C2DF C2DF)

    :type t2d: OCC.wrapper.gp.gp_Vec2d
    :type C2DF: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_C2DF

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TrslUV(*args)

def TopOpeBRepTool_TOOL_TrslUVModifE(*args):
    """
    TopOpeBRepTool_TOOL_TrslUVModifE(gp_Vec2d t2d, TopoDS_Face F, TopoDS_Edge E) -> Standard_Boolean

    :type t2d: OCC.wrapper.gp.gp_Vec2d
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_TrslUVModifE(*args)

def TopOpeBRepTool_TOOL_Matter(*args):
    """
    Matter(gp_Vec d1, gp_Vec d2, gp_Vec ref) -> Standard_Real
    Matter(gp_Vec2d d1, gp_Vec2d d2) -> Standard_Real
    Matter(gp_Dir xx1, gp_Dir nt1, gp_Dir xx2, gp_Dir nt2, Standard_Real const tola) -> Standard_Boolean
    TopOpeBRepTool_TOOL_Matter(TopoDS_Face f1, TopoDS_Face f2, TopoDS_Edge e, Standard_Real const pare, Standard_Real const tola) -> Standard_Boolean

    :type f1: OCC.wrapper.TopoDS.TopoDS_Face
    :type f2: OCC.wrapper.TopoDS.TopoDS_Face
    :type e: OCC.wrapper.TopoDS.TopoDS_Edge
    :type pare: float
    :type tola: float
    :type Ang: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Matter(*args)

def TopOpeBRepTool_TOOL_MatterKPtg(*args):
    """
    TopOpeBRepTool_TOOL_MatterKPtg(TopoDS_Face f1, TopoDS_Face f2, TopoDS_Edge e) -> Standard_Boolean

    :type f1: OCC.wrapper.TopoDS.TopoDS_Face
    :type f2: OCC.wrapper.TopoDS.TopoDS_Face
    :type e: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Ang: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_MatterKPtg(*args)

def TopOpeBRepTool_TOOL_Getstp3dF(*args):
    """
    TopOpeBRepTool_TOOL_Getstp3dF(gp_Pnt p, TopoDS_Face f, gp_Pnt2d uv) -> Standard_Boolean

    :type p: OCC.wrapper.gp.gp_Pnt
    :type f: OCC.wrapper.TopoDS.TopoDS_Face
    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type st: OCC.wrapper.TopAbs.TopAbs_State
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Getstp3dF(*args)

def TopOpeBRepTool_TOOL_SplitE(*args):
    """
    TopOpeBRepTool_TOOL_SplitE(TopoDS_Edge Eanc, NCollection_List_TopoDS_Shape Splits) -> Standard_Boolean

    :type Eanc: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Splits: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_SplitE(*args)

def TopOpeBRepTool_TOOL_MkShell(*args):
    """
    TopOpeBRepTool_TOOL_MkShell(NCollection_List_TopoDS_Shape lF, TopoDS_Shape She)

    :type lF: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type She: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_MkShell(*args)

def TopOpeBRepTool_TOOL_Remove(*args):
    """
    TopOpeBRepTool_TOOL_Remove(NCollection_List_TopoDS_Shape loS, TopoDS_Shape toremove) -> Standard_Boolean

    :type loS: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type toremove: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_Remove(*args)

def TopOpeBRepTool_TOOL_WireToFace(*args):
    """
    TopOpeBRepTool_TOOL_WireToFace(TopoDS_Face Fref, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher mapWlow, NCollection_List_TopoDS_Shape lFs) -> Standard_Boolean

    :type Fref: OCC.wrapper.TopoDS.TopoDS_Face
    :type mapWlow: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
    :type lFs: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_WireToFace(*args)

def TopOpeBRepTool_TOOL_EdgeONFace(*args):
    """
    TopOpeBRepTool_TOOL_EdgeONFace(Standard_Real const par, TopoDS_Edge ed, gp_Pnt2d uv, TopoDS_Face fa) -> Standard_Boolean

    :type par: float
    :type ed: OCC.wrapper.TopoDS.TopoDS_Edge
    :type uv: OCC.wrapper.gp.gp_Pnt2d
    :type fa: OCC.wrapper.TopoDS.TopoDS_Face
    :type isonfa: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_TOOL_EdgeONFace(*args)

class TopOpeBRepTool_REGUW(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_REGUW self, TopoDS_Face FRef) -> TopOpeBRepTool_REGUW

        :type FRef: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_REGUW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Fref(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_REGUW_Fref(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEsplits(self, *args):
        """
        SetEsplits(TopOpeBRepTool_REGUW self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher Esplits)

        :type Esplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_SetEsplits(self, *args)


    def GetEsplits(self, *args):
        """
        GetEsplits(TopOpeBRepTool_REGUW self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher Esplits)

        :type Esplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_GetEsplits(self, *args)


    def SetOwNw(self, *args):
        """
        SetOwNw(TopOpeBRepTool_REGUW self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OwNw)

        :type OwNw: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_SetOwNw(self, *args)


    def GetOwNw(self, *args):
        """
        GetOwNw(TopOpeBRepTool_REGUW self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OwNw)

        :type OwNw: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_GetOwNw(self, *args)


    def SplitEds(self, *args):
        """
        SplitEds(TopOpeBRepTool_REGUW self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_SplitEds(self, *args)


    def Init(self, *args):
        """
        Init(TopOpeBRepTool_REGUW self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_Init(self, *args)


    def S(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_REGUW_S(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasInit(self, *args):
        """
        HasInit(TopOpeBRepTool_REGUW self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_HasInit(self, *args)


    def MapS(self, *args):
        """
        MapS(TopOpeBRepTool_REGUW self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_MapS(self, *args)


    def REGU(self, *args):
        """
        REGU(TopOpeBRepTool_REGUW self, Standard_Integer const istep, TopoDS_Shape Scur, NCollection_List_TopoDS_Shape Splits) -> Standard_Boolean
        REGU(TopOpeBRepTool_REGUW self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_REGU(self, *args)


    def GetSplits(self, *args):
        """
        GetSplits(TopOpeBRepTool_REGUW self, NCollection_List_TopoDS_Shape Splits) -> Standard_Boolean

        :type Splits: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_GetSplits(self, *args)


    def InitBlock(self, *args):
        """
        InitBlock(TopOpeBRepTool_REGUW self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_InitBlock(self, *args)


    def NextinBlock(self, *args):
        """
        NextinBlock(TopOpeBRepTool_REGUW self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_NextinBlock(self, *args)


    def NearestE(self, *args):
        """
        NearestE(TopOpeBRepTool_REGUW self, NCollection_List_TopoDS_Shape loe, TopoDS_Edge efound) -> Standard_Boolean

        :type loe: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type efound: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_NearestE(self, *args)


    def Connexity(self, *args):
        """
        Connexity(TopOpeBRepTool_REGUW self, TopoDS_Vertex v, TopOpeBRepTool_connexity co) -> Standard_Boolean

        :type v: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type co: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_connexity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_Connexity(self, *args)


    def AddNewConnexity(self, *args):
        """
        AddNewConnexity(TopOpeBRepTool_REGUW self, TopoDS_Vertex v, Standard_Integer const OriKey, TopoDS_Edge e) -> Standard_Boolean

        :type v: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type OriKey: int
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_AddNewConnexity(self, *args)


    def RemoveOldConnexity(self, *args):
        """
        RemoveOldConnexity(TopOpeBRepTool_REGUW self, TopoDS_Vertex v, Standard_Integer const OriKey, TopoDS_Edge e) -> Standard_Boolean

        :type v: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type OriKey: int
        :type e: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_RemoveOldConnexity(self, *args)


    def UpdateMultiple(self, *args):
        """
        UpdateMultiple(TopOpeBRepTool_REGUW self, TopoDS_Vertex v) -> Standard_Boolean

        :type v: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_REGUW_UpdateMultiple(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_REGUW
TopOpeBRepTool_REGUW_swigregister = _TopOpeBRepTool.TopOpeBRepTool_REGUW_swigregister
TopOpeBRepTool_REGUW_swigregister(TopOpeBRepTool_REGUW)

class TopOpeBRepTool_BoxSort(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_BoxSort self) -> TopOpeBRepTool_BoxSort
        __init__(TopOpeBRepTool_BoxSort self, Handle_TopOpeBRepTool_HBoxTool T) -> TopOpeBRepTool_BoxSort

        :type T: OCC.wrapper.TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_BoxSort(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetHBoxTool(self, *args):
        """
        SetHBoxTool(TopOpeBRepTool_BoxSort self, Handle_TopOpeBRepTool_HBoxTool T)

        :type T: OCC.wrapper.TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool

        """
        return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_SetHBoxTool(self, *args)


    def HBoxTool(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_BoxSort_HBoxTool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """Clear(TopOpeBRepTool_BoxSort self)"""
        return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_Clear(self, *args)


    def AddBoxes(self, *args):
        """
        AddBoxes(TopOpeBRepTool_BoxSort self, TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_AddBoxes(self, *args)


    def MakeHAB(self, *args):
        """
        MakeHAB(TopOpeBRepTool_BoxSort self, TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_MakeHAB(self, *args)


    def HAB(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_BoxSort_HAB(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MakeHABCOB(*args):
        """
        MakeHABCOB(Handle_Bnd_HArray1OfBox HAB, Bnd_Box COB)

        :type HAB: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox
        :type COB: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_MakeHABCOB(*args)

    MakeHABCOB = staticmethod(MakeHABCOB)

    def HABShape(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_BoxSort_HABShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MakeCOB(self, *args):
        """
        MakeCOB(TopOpeBRepTool_BoxSort self, TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_MakeCOB(self, *args)


    def AddBoxesMakeCOB(self, *args):
        """
        AddBoxesMakeCOB(TopOpeBRepTool_BoxSort self, TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_AddBoxesMakeCOB(self, *args)


    def Compare(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TColStd.TColStd_ListIteratorOfListOfInteger

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_BoxSort_Compare(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TouchedShape(self, *args):
        """
        :type I: OCC.wrapper.TColStd.TColStd_ListIteratorOfListOfInteger
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_BoxSort_TouchedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Box(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_BoxSort_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_BoxSort
TopOpeBRepTool_BoxSort_swigregister = _TopOpeBRepTool.TopOpeBRepTool_BoxSort_swigregister
TopOpeBRepTool_BoxSort_swigregister(TopOpeBRepTool_BoxSort)

def TopOpeBRepTool_BoxSort_MakeHABCOB(*args):
    """
    TopOpeBRepTool_BoxSort_MakeHABCOB(Handle_Bnd_HArray1OfBox HAB, Bnd_Box COB)

    :type HAB: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox
    :type COB: OCC.wrapper.Bnd.Bnd_Box

    """
    return _TopOpeBRepTool.TopOpeBRepTool_BoxSort_MakeHABCOB(*args)

class TopOpeBRepTool_ShapeClassifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_ShapeClassifier self) -> TopOpeBRepTool_ShapeClassifier
        __init__(TopOpeBRepTool_ShapeClassifier self, TopoDS_Shape SRef) -> TopOpeBRepTool_ShapeClassifier

        SRef is the reference shape.
        StateShapeShape(S) calls will classify S with SRef.

        :type SRef: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_ShapeClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ClearAll(self, *args):
        """
        ClearAll(TopOpeBRepTool_ShapeClassifier self)

        reset all internal data (SolidClassifier included)


        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_ClearAll(self, *args)


    def ClearCurrent(self, *args):
        """
        ClearCurrent(TopOpeBRepTool_ShapeClassifier self)

        reset all internal data (except SolidClassified)


        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_ClearCurrent(self, *args)


    def SetReference(self, *args):
        """
        SetReference(TopOpeBRepTool_ShapeClassifier self, TopoDS_Shape SRef)

        Set SRef as reference shape
        the next StateShapeReference(S,AvoidS) calls will classify S with SRef.

        :type SRef: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_SetReference(self, *args)


    def SameDomain(self, *args):
        """
        SameDomain(TopOpeBRepTool_ShapeClassifier self) -> Standard_Integer
        SameDomain(TopOpeBRepTool_ShapeClassifier self, Standard_Integer const samedomain)

        set mode for next StateShapeShape call
        samedomain = true --> S,Sref are same domain --> point
        on restriction (ON S) is used to classify S.
        samedomain = false --> S,Sref are not domain --> point
        not on restriction of S (IN S) is used to classify S.
        samedomain value is used only in next StateShapeShape call

        :type samedomain: int

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_SameDomain(self, *args)


    def StateShapeShape(self, *args):
        """
        StateShapeShape(TopOpeBRepTool_ShapeClassifier self, TopoDS_Shape S, TopoDS_Shape SRef, Standard_Integer const samedomain=0) -> TopAbs_State
        StateShapeShape(TopOpeBRepTool_ShapeClassifier self, TopoDS_Shape S, TopoDS_Shape AvoidS, TopoDS_Shape SRef) -> TopAbs_State
        StateShapeShape(TopOpeBRepTool_ShapeClassifier self, TopoDS_Shape S, NCollection_List_TopoDS_Shape LAvoidS, TopoDS_Shape SRef) -> TopAbs_State

        classify shape S compared with shape SRef.
        LAvoidS is list of S subshapes to avoid in classification
        AvoidS is not used in classification; AvoidS may be IsNull().
        (usefull to avoid ON or UNKNOWN state in special cases)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LAvoidS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type SRef: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_StateShapeShape(self, *args)


    def StateShapeReference(self, *args):
        """
        StateShapeReference(TopOpeBRepTool_ShapeClassifier self, TopoDS_Shape S, TopoDS_Shape AvoidS) -> TopAbs_State
        StateShapeReference(TopOpeBRepTool_ShapeClassifier self, TopoDS_Shape S, NCollection_List_TopoDS_Shape LAvoidS) -> TopAbs_State

        classify shape S compared with reference shape.
        LAvoidS is list of S subshapes to avoid in classification
        (usefull to avoid ON or UNKNOWN state in special cases)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LAvoidS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_StateShapeReference(self, *args)


    def ChangeSolidClassifier(self, *args):
        """
        ChangeSolidClassifier(TopOpeBRepTool_ShapeClassifier self) -> TopOpeBRepTool_SolidClassifier

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_SolidClassifier

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_ChangeSolidClassifier(self, *args)


    def StateP2DReference(self, *args):
        """
        StateP2DReference(TopOpeBRepTool_ShapeClassifier self, gp_Pnt2d P2D)

        classify point P2D with myRef

        :type P2D: OCC.wrapper.gp.gp_Pnt2d

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_StateP2DReference(self, *args)


    def StateP3DReference(self, *args):
        """
        StateP3DReference(TopOpeBRepTool_ShapeClassifier self, gp_Pnt P3D)

        classify point P3D with myRef

        :type P3D: OCC.wrapper.gp.gp_Pnt

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_StateP3DReference(self, *args)


    def State(self, *args):
        """
        State(TopOpeBRepTool_ShapeClassifier self) -> TopAbs_State

        return field myState

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_State(self, *args)


    def P2D(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_P2D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def P3D(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_P3D(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_ShapeClassifier
TopOpeBRepTool_ShapeClassifier_swigregister = _TopOpeBRepTool.TopOpeBRepTool_ShapeClassifier_swigregister
TopOpeBRepTool_ShapeClassifier_swigregister(TopOpeBRepTool_ShapeClassifier)

class TopOpeBRepTool_AncestorsTool(object):
    """
    Describes the ancestors tool needed by
    the class DSFiller from TopOpeInter.

    This class has been created because it is not possible
    to instantiate the argument TheAncestorsTool (of
    DSFiller from TopOpeInter) with a  package (TopExp)
    giving services as package methods.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeAncestors(*args):
        """
        MakeAncestors(TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher M)

        same as package method TopExp::MapShapeListOfShapes()

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type M: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_AncestorsTool_MakeAncestors(*args)

    MakeAncestors = staticmethod(MakeAncestors)

    def __init__(self):
        """
        Describes the ancestors tool needed by
        the class DSFiller from TopOpeInter.

        This class has been created because it is not possible
        to instantiate the argument TheAncestorsTool (of
        DSFiller from TopOpeInter) with a  package (TopExp)
        giving services as package methods.
        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_AncestorsTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_AncestorsTool
TopOpeBRepTool_AncestorsTool_swigregister = _TopOpeBRepTool.TopOpeBRepTool_AncestorsTool_swigregister
TopOpeBRepTool_AncestorsTool_swigregister(TopOpeBRepTool_AncestorsTool)

def TopOpeBRepTool_AncestorsTool_MakeAncestors(*args):
    """
    TopOpeBRepTool_AncestorsTool_MakeAncestors(TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher M)

    same as package method TopExp::MapShapeListOfShapes()

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type M: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

    """
    return _TopOpeBRepTool.TopOpeBRepTool_AncestorsTool_MakeAncestors(*args)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_ListOfC2DF,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_ListOfC2DF,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_ListOfC2DF,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_ListOfC2DF,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepTool.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List< TopOpeBRepTool_C2DF > const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List< TopOpeBRepTool_C2DF > const & theItem) -> NCollection_List< TopOpeBRepTool_C2DF > *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< TopOpeBRepTool_C2DF > const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< TopOpeBRepTool_C2DF > *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< TopOpeBRepTool_C2DF > &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepTool_DataMapOfShapeListOfC2DF = NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_ListOfC2DF_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepTool_PurgeInternalEdges(object):
    """
    remove from  a shape, the  internal edges that are
    not  connected to any face in  the shape.   We can
    get  the    list   of      the    edges  as   a
    DataMapOfShapeListOfShape with a Face of the Shape
    as  the key and  a  list of internal  edges as the
    value.  The list   of internal edges  means edges
    that are  not connected to any  face in the shape.

    Example of use          :
    TopTools_DataMapOfShapeListOfShape     mymap;
    TopOpeBRepTool_PurgeInternalEdges
    mypurgealgo(mysolid); mypurgealgo.GetFaces(mymap);
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_PurgeInternalEdges self, TopoDS_Shape theShape, Standard_Boolean const PerformNow) -> TopOpeBRepTool_PurgeInternalEdges

        Initialize   members and  begin  exploration   of  shape
        depending of the value of PerformNow

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type PerformNow: bool

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_PurgeInternalEdges(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Faces(self, *args):
        """
        Faces(TopOpeBRepTool_PurgeInternalEdges self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theMapFacLstEdg)

        returns  the list  internal edges associated  with
        the faces of the  myShape. If PerformNow was False
        when created, then call the private Perform method
        that do the main job.

        :type theMapFacLstEdg: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_PurgeInternalEdges_Faces(self, *args)


    def Shape(self, *args):
        """
        Shape(TopOpeBRepTool_PurgeInternalEdges self) -> TopoDS_Shape

        returns myShape modified with the list of internal
        edges removed from it.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_PurgeInternalEdges_Shape(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(TopOpeBRepTool_PurgeInternalEdges self) -> Standard_Integer

        returns the number of edges candidate to be removed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_PurgeInternalEdges_NbEdges(self, *args)


    def IsDone(self, *args):
        """
        IsDone(TopOpeBRepTool_PurgeInternalEdges self) -> Standard_Boolean

        returns False  if the list  of internal  edges has
        not been extracted

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_PurgeInternalEdges_IsDone(self, *args)


    def Perform(self, *args):
        """
        Perform(TopOpeBRepTool_PurgeInternalEdges self)

        Using   the list  of internal edge    from each face,
        rebuild myShape by removing thoses edges.


        """
        return _TopOpeBRepTool.TopOpeBRepTool_PurgeInternalEdges_Perform(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_PurgeInternalEdges
TopOpeBRepTool_PurgeInternalEdges_swigregister = _TopOpeBRepTool.TopOpeBRepTool_PurgeInternalEdges_swigregister
TopOpeBRepTool_PurgeInternalEdges_swigregister(TopOpeBRepTool_PurgeInternalEdges)

class TopOpeBRepTool_SolidClassifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepTool_SolidClassifier self) -> TopOpeBRepTool_SolidClassifier"""
        this = _TopOpeBRepTool.new_TopOpeBRepTool_SolidClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """Clear(TopOpeBRepTool_SolidClassifier self)"""
        return _TopOpeBRepTool.TopOpeBRepTool_SolidClassifier_Clear(self, *args)


    def LoadSolid(self, *args):
        """
        LoadSolid(TopOpeBRepTool_SolidClassifier self, TopoDS_Solid S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _TopOpeBRepTool.TopOpeBRepTool_SolidClassifier_LoadSolid(self, *args)


    def LoadShell(self, *args):
        """
        LoadShell(TopOpeBRepTool_SolidClassifier self, TopoDS_Shell S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _TopOpeBRepTool.TopOpeBRepTool_SolidClassifier_LoadShell(self, *args)


    def Classify(self, *args):
        """
        Classify(TopOpeBRepTool_SolidClassifier self, TopoDS_Solid S, gp_Pnt P, Standard_Real const Tol) -> TopAbs_State
        Classify(TopOpeBRepTool_SolidClassifier self, TopoDS_Shell S, gp_Pnt P, Standard_Real const Tol) -> TopAbs_State

        compute the position of point <P> regarding with the
        geometric domain of the shell <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepTool.TopOpeBRepTool_SolidClassifier_Classify(self, *args)


    def State(self, *args):
        """
        State(TopOpeBRepTool_SolidClassifier self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepTool.TopOpeBRepTool_SolidClassifier_State(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_SolidClassifier
TopOpeBRepTool_SolidClassifier_swigregister = _TopOpeBRepTool.TopOpeBRepTool_SolidClassifier_swigregister
TopOpeBRepTool_SolidClassifier_swigregister(TopOpeBRepTool_SolidClassifier)

class TopOpeBRepTool_GeomTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_GeomTool self, TopOpeBRepTool_OutCurveType const TypeC3D=TopOpeBRepTool_BSPLINE1, Standard_Boolean const CompC3D, Standard_Boolean const CompPC1, Standard_Boolean const CompPC2) -> TopOpeBRepTool_GeomTool

        Boolean flags <CompC3D>, <CompPC1>, <CompPC2>
        indicate whether  the  corresponding result curves
        <C3D>, <PC1>, <PC2> of MakeCurves method  must or not
        be computed from an intersection line <L>.
        When  the line <L> is a walking one, <TypeC3D> is the
        kind  of the 3D curve <C3D>  to  compute  :
        - BSPLINE1 to compute  a BSpline of  degree 1 on the
        walking   points  of  <L>,
        - APPROX  to build  an  approximation curve on the
        walking points of <L>.

        :type TypeC3D: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_OutCurveType
        :type CompC3D: bool
        :type CompPC1: bool
        :type CompPC2: bool

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_GeomTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DefineCurves(self, *args):
        """
        DefineCurves(TopOpeBRepTool_GeomTool self, Standard_Boolean const CompC3D)

        :type CompC3D: bool

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_DefineCurves(self, *args)


    def DefinePCurves1(self, *args):
        """
        DefinePCurves1(TopOpeBRepTool_GeomTool self, Standard_Boolean const CompPC1)

        :type CompPC1: bool

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_DefinePCurves1(self, *args)


    def DefinePCurves2(self, *args):
        """
        DefinePCurves2(TopOpeBRepTool_GeomTool self, Standard_Boolean const CompPC2)

        :type CompPC2: bool

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_DefinePCurves2(self, *args)


    def Define(self, *args):
        """
        Define(TopOpeBRepTool_GeomTool self, TopOpeBRepTool_OutCurveType const TypeC3D, Standard_Boolean const CompC3D, Standard_Boolean const CompPC1, Standard_Boolean const CompPC2)
        Define(TopOpeBRepTool_GeomTool self, TopOpeBRepTool_OutCurveType const TypeC3D)
        Define(TopOpeBRepTool_GeomTool self, TopOpeBRepTool_GeomTool GT)

        :type GT: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_Define(self, *args)


    def GetTolerances(self, *args):
        """
        GetTolerances(TopOpeBRepTool_GeomTool self)

        :type tol3d: float
        :type tol2d: float

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_GetTolerances(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(TopOpeBRepTool_GeomTool self, Standard_Real const tol3d, Standard_Real const tol2d)

        :type tol3d: float
        :type tol2d: float

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_SetTolerances(self, *args)


    def NbPntMax(self, *args):
        """
        NbPntMax(TopOpeBRepTool_GeomTool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_NbPntMax(self, *args)


    def SetNbPntMax(self, *args):
        """
        SetNbPntMax(TopOpeBRepTool_GeomTool self, Standard_Integer const NbPntMax)

        :type NbPntMax: int

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_SetNbPntMax(self, *args)


    def TypeC3D(self, *args):
        """
        TypeC3D(TopOpeBRepTool_GeomTool self) -> TopOpeBRepTool_OutCurveType

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_OutCurveType

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_TypeC3D(self, *args)


    def CompC3D(self, *args):
        """
        CompC3D(TopOpeBRepTool_GeomTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_CompC3D(self, *args)


    def CompPC1(self, *args):
        """
        CompPC1(TopOpeBRepTool_GeomTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_CompPC1(self, *args)


    def CompPC2(self, *args):
        """
        CompPC2(TopOpeBRepTool_GeomTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_GeomTool_CompPC2(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_GeomTool
TopOpeBRepTool_GeomTool_swigregister = _TopOpeBRepTool.TopOpeBRepTool_GeomTool_swigregister
TopOpeBRepTool_GeomTool_swigregister(TopOpeBRepTool_GeomTool)

class NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box2d,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box2d,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box2d,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box2d,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopOpeBRepTool.new_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1, Bnd_Box2d theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, Bnd_Box2d theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self)

        RemoveLast


        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex) -> Bnd_Box2d

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box2d

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box2d

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box2d

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_swigregister = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepTool_IndexedDataMapOfShapeBox2d = NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box2d_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepTool_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_CurveTool self) -> TopOpeBRepTool_CurveTool
        __init__(TopOpeBRepTool_CurveTool self, TopOpeBRepTool_OutCurveType const OCT) -> TopOpeBRepTool_CurveTool
        __init__(TopOpeBRepTool_CurveTool self, TopOpeBRepTool_GeomTool GT) -> TopOpeBRepTool_CurveTool

        :type GT: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_CurveTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ChangeGeomTool(self, *args):
        """
        ChangeGeomTool(TopOpeBRepTool_CurveTool self) -> TopOpeBRepTool_GeomTool

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_ChangeGeomTool(self, *args)


    def GetGeomTool(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_CurveTool_GetGeomTool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetGeomTool(self, *args):
        """
        SetGeomTool(TopOpeBRepTool_CurveTool self, TopOpeBRepTool_GeomTool GT)

        :type GT: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_SetGeomTool(self, *args)


    def MakeCurves(self, *args):
        """
        MakeCurves(TopOpeBRepTool_CurveTool self, Standard_Real const min, Standard_Real const max, Handle_Geom_Curve C3D, Handle_Geom2d_Curve PC1, Handle_Geom2d_Curve PC2, TopoDS_Shape S1, TopoDS_Shape S2, Handle_Geom_Curve C3DN, Handle_Geom2d_Curve PC1N, Handle_Geom2d_Curve PC2N) -> Standard_Boolean

        Approximates curves.
        Returns False in the case of failure

        :type min: float
        :type max: float
        :type C3D: OCC.wrapper.Geom.Handle_Geom_Curve
        :type PC1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type PC2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C3DN: OCC.wrapper.Geom.Handle_Geom_Curve
        :type PC1N: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type PC2N: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol3d: float
        :type Tol2d: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_MakeCurves(self, *args)


    def MakeBSpline1fromPnt(*args):
        """
        MakeBSpline1fromPnt(NCollection_Array1_gp_Pnt P) -> Handle_Geom_Curve

        :type P: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt(*args)

    MakeBSpline1fromPnt = staticmethod(MakeBSpline1fromPnt)

    def MakeBSpline1fromPnt2d(*args):
        """
        MakeBSpline1fromPnt2d(NCollection_Array1_gp_Pnt2d P) -> Handle_Geom2d_Curve

        :type P: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt2d(*args)

    MakeBSpline1fromPnt2d = staticmethod(MakeBSpline1fromPnt2d)

    def IsProjectable(*args):
        """
        IsProjectable(TopoDS_Shape S, Handle_Geom_Curve C) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_IsProjectable(*args)

    IsProjectable = staticmethod(IsProjectable)

    def MakePCurveOnFace(*args):
        """
        MakePCurveOnFace(TopoDS_Shape S, Handle_Geom_Curve C, Standard_Real const first=0.0, Standard_Real const last=0.0) -> Handle_Geom2d_Curve

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type TolReached2d: float
        :type first: float
        :type last: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_MakePCurveOnFace(*args)

    MakePCurveOnFace = staticmethod(MakePCurveOnFace)
    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_CurveTool
TopOpeBRepTool_CurveTool_swigregister = _TopOpeBRepTool.TopOpeBRepTool_CurveTool_swigregister
TopOpeBRepTool_CurveTool_swigregister(TopOpeBRepTool_CurveTool)

def TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt(*args):
    """
    TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt(NCollection_Array1_gp_Pnt P) -> Handle_Geom_Curve

    :type P: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt(*args)

def TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt2d(*args):
    """
    TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt2d(NCollection_Array1_gp_Pnt2d P) -> Handle_Geom2d_Curve

    :type P: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_MakeBSpline1fromPnt2d(*args)

def TopOpeBRepTool_CurveTool_IsProjectable(*args):
    """
    TopOpeBRepTool_CurveTool_IsProjectable(TopoDS_Shape S, Handle_Geom_Curve C) -> Standard_Boolean

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_IsProjectable(*args)

def TopOpeBRepTool_CurveTool_MakePCurveOnFace(*args):
    """
    TopOpeBRepTool_CurveTool_MakePCurveOnFace(TopoDS_Shape S, Handle_Geom_Curve C, Standard_Real const first=0.0, Standard_Real const last=0.0) -> Handle_Geom2d_Curve

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :type TolReached2d: float
    :type first: float
    :type last: float
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _TopOpeBRepTool.TopOpeBRepTool_CurveTool_MakePCurveOnFace(*args)

class NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopOpeBRepTool.new_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1, Bnd_Box theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, Bnd_Box theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self)

        RemoveLast


        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, Standard_Integer const theIndex) -> Bnd_Box

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_swigregister = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepTool_IndexedDataMapOfShapeBox = NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepTool_(object):
    """
    This package provides services used by the TopOpeBRep
    package performing topological operations on the BRep
    data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def PurgeClosingEdges(*args):
        """
        PurgeClosingEdges(TopoDS_Face F, TopoDS_Face FF, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher MWisOld, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher MshNOK) -> Standard_Boolean
        PurgeClosingEdges(TopoDS_Face F, NCollection_List_TopoDS_Shape LOF, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher MWisOld, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher MshNOK) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type LOF: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type MWisOld: OCC.wrapper.TopTools.TopTools_DataMapOfShapeInteger
        :type MshNOK: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool__PurgeClosingEdges(*args)

    PurgeClosingEdges = staticmethod(PurgeClosingEdges)

    def CorrectONUVISO(*args):
        """
        CorrectONUVISO(TopoDS_Face F, TopoDS_Face Fsp) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Fsp: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool__CorrectONUVISO(*args)

    CorrectONUVISO = staticmethod(CorrectONUVISO)

    def MakeFaces(*args):
        """
        MakeFaces(TopoDS_Face F, NCollection_List_TopoDS_Shape LOF, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher MshNOK, NCollection_List_TopoDS_Shape LOFF) -> Standard_Boolean

        Builds up the correct list of faces <LOFF> from <LOF>, using
        faulty shapes from map <MshNOK>.
        <LOF> is the list of <F>'s descendant faces.
        returns false if building fails

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type LOF: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type MshNOK: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
        :type LOFF: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool__MakeFaces(*args)

    MakeFaces = staticmethod(MakeFaces)

    def Regularize(*args):
        """
        Regularize(TopoDS_Face aFace, NCollection_List_TopoDS_Shape aListOfFaces, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher ESplits) -> Standard_Boolean

        Returns <False>  if  the  face is  valid (the UV
        representation  of  the  face is   a set   of  pcurves
        connexed by points with   connexity 2).
        Else,  splits <aFace> in order to return a list of valid
        faces.

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type aListOfFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type ESplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool__Regularize(*args)

    Regularize = staticmethod(Regularize)

    def RegularizeWires(*args):
        """
        RegularizeWires(TopoDS_Face aFace, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OldWiresNewWires, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher ESplits) -> Standard_Boolean

        Returns <False>  if  the  face is  valid (the UV
        representation  of  the  face is   a set   of  pcurves
        connexed by points with   connexity 2).
        Else,  splits wires of the face, these are boundaries of the
        new faces to build up; <OldWiresNewWires> describes (wire,
        splits of wire); <ESplits> describes (edge, edge's splits)

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type OldWiresNewWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type ESplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool__RegularizeWires(*args)

    RegularizeWires = staticmethod(RegularizeWires)

    def RegularizeFace(*args):
        """
        RegularizeFace(TopoDS_Face aFace, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OldWiresnewWires, NCollection_List_TopoDS_Shape aListOfFaces) -> Standard_Boolean

        Classify wire's splits of map <OldWiresnewWires> in order to
        compute <aListOfFaces>, the splits of <aFace>.

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type OldWiresnewWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type aListOfFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool__RegularizeFace(*args)

    RegularizeFace = staticmethod(RegularizeFace)

    def RegularizeShells(*args):
        """
        RegularizeShells(TopoDS_Solid aSolid, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OldSheNewShe, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher FSplits) -> Standard_Boolean

        Returns <False> if the shell is valid (the solid is a set
        of faces connexed by edges with connexity 2).
        Else, splits faces of the shell; <OldFacesnewFaces> describes
        (face, splits of face).

        :type aSolid: OCC.wrapper.TopoDS.TopoDS_Solid
        :type OldSheNewShe: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type FSplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool__RegularizeShells(*args)

    RegularizeShells = staticmethod(RegularizeShells)

    def Print(*args):
        """
        Print(TopOpeBRepTool_OutCurveType const OCT, Standard_OStream & S) -> Standard_OStream &

        Prints <OCT> as string on stream <S>; returns <S>.

        :type OCT: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_OutCurveType
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepTool.TopOpeBRepTool__Print(*args)

    Print = staticmethod(Print)

    def __init__(self):
        """
        This package provides services used by the TopOpeBRep
        package performing topological operations on the BRep
        data structure.
        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_
TopOpeBRepTool__swigregister = _TopOpeBRepTool.TopOpeBRepTool__swigregister
TopOpeBRepTool__swigregister(TopOpeBRepTool_)

def TopOpeBRepTool__PurgeClosingEdges(*args):
    """
    PurgeClosingEdges(TopoDS_Face F, TopoDS_Face FF, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher MWisOld, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher MshNOK) -> Standard_Boolean
    TopOpeBRepTool__PurgeClosingEdges(TopoDS_Face F, NCollection_List_TopoDS_Shape LOF, NCollection_DataMap_TopoDS_Shape_Standard_Integer_TopTools_ShapeMapHasher MWisOld, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher MshNOK) -> Standard_Boolean

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type LOF: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type MWisOld: OCC.wrapper.TopTools.TopTools_DataMapOfShapeInteger
    :type MshNOK: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool__PurgeClosingEdges(*args)

def TopOpeBRepTool__CorrectONUVISO(*args):
    """
    TopOpeBRepTool__CorrectONUVISO(TopoDS_Face F, TopoDS_Face Fsp) -> Standard_Boolean

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type Fsp: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool__CorrectONUVISO(*args)

def TopOpeBRepTool__MakeFaces(*args):
    """
    TopOpeBRepTool__MakeFaces(TopoDS_Face F, NCollection_List_TopoDS_Shape LOF, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher MshNOK, NCollection_List_TopoDS_Shape LOFF) -> Standard_Boolean

    Builds up the correct list of faces <LOFF> from <LOF>, using
    faulty shapes from map <MshNOK>.
    <LOF> is the list of <F>'s descendant faces.
    returns false if building fails

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type LOF: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type MshNOK: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
    :type LOFF: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool__MakeFaces(*args)

def TopOpeBRepTool__Regularize(*args):
    """
    TopOpeBRepTool__Regularize(TopoDS_Face aFace, NCollection_List_TopoDS_Shape aListOfFaces, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher ESplits) -> Standard_Boolean

    Returns <False>  if  the  face is  valid (the UV
    representation  of  the  face is   a set   of  pcurves
    connexed by points with   connexity 2).
    Else,  splits <aFace> in order to return a list of valid
    faces.

    :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type aListOfFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type ESplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool__Regularize(*args)

def TopOpeBRepTool__RegularizeWires(*args):
    """
    TopOpeBRepTool__RegularizeWires(TopoDS_Face aFace, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OldWiresNewWires, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher ESplits) -> Standard_Boolean

    Returns <False>  if  the  face is  valid (the UV
    representation  of  the  face is   a set   of  pcurves
    connexed by points with   connexity 2).
    Else,  splits wires of the face, these are boundaries of the
    new faces to build up; <OldWiresNewWires> describes (wire,
    splits of wire); <ESplits> describes (edge, edge's splits)

    :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type OldWiresNewWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
    :type ESplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool__RegularizeWires(*args)

def TopOpeBRepTool__RegularizeFace(*args):
    """
    TopOpeBRepTool__RegularizeFace(TopoDS_Face aFace, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OldWiresnewWires, NCollection_List_TopoDS_Shape aListOfFaces) -> Standard_Boolean

    Classify wire's splits of map <OldWiresnewWires> in order to
    compute <aListOfFaces>, the splits of <aFace>.

    :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type OldWiresnewWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
    :type aListOfFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool__RegularizeFace(*args)

def TopOpeBRepTool__RegularizeShells(*args):
    """
    TopOpeBRepTool__RegularizeShells(TopoDS_Solid aSolid, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher OldSheNewShe, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher FSplits) -> Standard_Boolean

    Returns <False> if the shell is valid (the solid is a set
    of faces connexed by edges with connexity 2).
    Else, splits faces of the shell; <OldFacesnewFaces> describes
    (face, splits of face).

    :type aSolid: OCC.wrapper.TopoDS.TopoDS_Solid
    :type OldSheNewShe: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
    :type FSplits: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool__RegularizeShells(*args)

def TopOpeBRepTool__Print(*args):
    """
    TopOpeBRepTool__Print(TopOpeBRepTool_OutCurveType const OCT, Standard_OStream & S) -> Standard_OStream &

    Prints <OCT> as string on stream <S>; returns <S>.

    :type OCT: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_OutCurveType
    :type S: OCC.wrapper.Standard.Standard_OStream
    :rtype: OCC.wrapper.Standard.Standard_OStream

    """
    return _TopOpeBRepTool.TopOpeBRepTool__Print(*args)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_C2DF,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_C2DF,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_C2DF,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_C2DF,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepTool.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, TopOpeBRepTool_C2DF theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, TopOpeBRepTool_C2DF theItem) -> TopOpeBRepTool_C2DF

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepTool_C2DF

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepTool_C2DF

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepTool_C2DF

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_swigregister = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepTool_DataMapOfOrientedShapeC2DF = NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_C2DF_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepTool_HBoxTool(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepTool_HBoxTool
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepTool_HBoxTool(self) 
            return h


    def __init__(self, *args):
        """__init__(TopOpeBRepTool_HBoxTool self) -> TopOpeBRepTool_HBoxTool"""
        this = _TopOpeBRepTool.new_TopOpeBRepTool_HBoxTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """Clear(TopOpeBRepTool_HBoxTool self)"""
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_Clear(self, *args)


    def AddBoxes(self, *args):
        """
        AddBoxes(TopOpeBRepTool_HBoxTool self, TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_AddBoxes(self, *args)


    def AddBox(self, *args):
        """
        AddBox(TopOpeBRepTool_HBoxTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_AddBox(self, *args)


    def ComputeBox(*args):
        """
        ComputeBox(TopoDS_Shape S, Bnd_Box B)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_ComputeBox(*args)

    ComputeBox = staticmethod(ComputeBox)

    def ComputeBoxOnVertices(*args):
        """
        ComputeBoxOnVertices(TopoDS_Shape S, Bnd_Box B)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_ComputeBoxOnVertices(*args)

    ComputeBoxOnVertices = staticmethod(ComputeBoxOnVertices)

    def DumpB(*args):
        """
        DumpB(Bnd_Box B)

        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_DumpB(*args)

    DumpB = staticmethod(DumpB)

    def Box(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasBox(self, *args):
        """
        HasBox(TopOpeBRepTool_HBoxTool self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_HasBox(self, *args)


    def Shape(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Index(TopOpeBRepTool_HBoxTool self, TopoDS_Shape S) -> Standard_Integer

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_Index(self, *args)


    def Extent(self, *args):
        """
        Extent(TopOpeBRepTool_HBoxTool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_Extent(self, *args)


    def ChangeIMS(self, *args):
        """
        ChangeIMS(TopOpeBRepTool_HBoxTool self) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_IndexedDataMapOfShapeBox

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_ChangeIMS(self, *args)


    def IMS(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_IndexedDataMapOfShapeBox

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_IMS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_HBoxTool
TopOpeBRepTool_HBoxTool_swigregister = _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_swigregister
TopOpeBRepTool_HBoxTool_swigregister(TopOpeBRepTool_HBoxTool)

def TopOpeBRepTool_HBoxTool_ComputeBox(*args):
    """
    TopOpeBRepTool_HBoxTool_ComputeBox(TopoDS_Shape S, Bnd_Box B)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_ComputeBox(*args)

def TopOpeBRepTool_HBoxTool_ComputeBoxOnVertices(*args):
    """
    TopOpeBRepTool_HBoxTool_ComputeBoxOnVertices(TopoDS_Shape S, Bnd_Box B)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_ComputeBoxOnVertices(*args)

def TopOpeBRepTool_HBoxTool_DumpB(*args):
    """
    TopOpeBRepTool_HBoxTool_DumpB(Bnd_Box B)

    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_DumpB(*args)

def TopOpeBRepTool_HBoxTool_get_type_name(*args):
    """
    TopOpeBRepTool_HBoxTool_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_get_type_name(*args)

def TopOpeBRepTool_HBoxTool_get_type_descriptor(*args):
    """
    TopOpeBRepTool_HBoxTool_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepTool.TopOpeBRepTool_HBoxTool_get_type_descriptor(*args)

class TopOpeBRepTool_FuseEdges(object):
    """
    This class can detect  vertices in a face that can
    be considered useless and then perform the fuse of
    the  edges and remove  the  useless vertices.  By
    useles vertices,  we mean :
    * vertices that  have  exactly two connex edges
    * the edges connex to the vertex must have
    exactly the same 2 connex faces .
    * The edges connex to the vertex must have the
    same geometric support.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepTool_FuseEdges self, TopoDS_Shape theShape, Standard_Boolean const PerformNow) -> TopOpeBRepTool_FuseEdges

        Initialise members  and build  construction of map
        of ancestors.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type PerformNow: bool

        """
        this = _TopOpeBRepTool.new_TopOpeBRepTool_FuseEdges(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AvoidEdges(self, *args):
        """
        AvoidEdges(TopOpeBRepTool_FuseEdges self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapEdg)

        set edges to avoid being fused

        :type theMapEdg: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_AvoidEdges(self, *args)


    def Edges(self, *args):
        """
        Edges(TopOpeBRepTool_FuseEdges self, NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher theMapLstEdg)

        returns  all the list of edges to be fused
        each list of the map represent a set of connex edges
        that can be fused.

        :type theMapLstEdg: OCC.wrapper.TopTools.TopTools_DataMapOfIntegerListOfShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_Edges(self, *args)


    def ResultEdges(self, *args):
        """
        ResultEdges(TopOpeBRepTool_FuseEdges self, NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theMapEdg)

        returns all the fused edges. each integer entry in
        the   map  corresponds  to  the  integer   in the
        DataMapOfIntegerListOfShape  we    get in  method
        Edges.   That is to say, to  the list  of edges in
        theMapLstEdg(i) corresponds the resulting edge theMapEdge(i)

        :type theMapEdg: OCC.wrapper.TopTools.TopTools_DataMapOfIntegerShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_ResultEdges(self, *args)


    def Faces(self, *args):
        """
        Faces(TopOpeBRepTool_FuseEdges self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theMapFac)

        returns the map of modified faces.

        :type theMapFac: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_Faces(self, *args)


    def Shape(self, *args):
        """
        Shape(TopOpeBRepTool_FuseEdges self) -> TopoDS_Shape

        returns myShape modified with the list of internal
        edges removed from it.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_Shape(self, *args)


    def NbVertices(self, *args):
        """
        NbVertices(TopOpeBRepTool_FuseEdges self) -> Standard_Integer

        returns the number of vertices candidate to be removed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_NbVertices(self, *args)


    def Perform(self, *args):
        """
        Perform(TopOpeBRepTool_FuseEdges self)

        Using  map of list of connex  edges, fuse each list to
        one edge and then update myShape


        """
        return _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_Perform(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_FuseEdges
TopOpeBRepTool_FuseEdges_swigregister = _TopOpeBRepTool.TopOpeBRepTool_FuseEdges_swigregister
TopOpeBRepTool_FuseEdges_swigregister(TopOpeBRepTool_FuseEdges)

class TopOpeBRepTool_ShapeTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Tolerance(*args):
        """
        Tolerance(TopoDS_Shape S) -> Standard_Real

        Returns the tolerance of the shape <S>.
        If the shape <S> is Null, returns 0.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def Pnt(*args):
        """
        Pnt(TopoDS_Shape S) -> gp_Pnt

        Returns 3D point of vertex <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Pnt(*args)

    Pnt = staticmethod(Pnt)

    def BASISCURVE(*args):
        """
        BASISCURVE(Handle_Geom_Curve C) -> Handle_Geom_Curve
        BASISCURVE(TopoDS_Edge E) -> Handle_Geom_Curve

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_BASISCURVE(*args)

    BASISCURVE = staticmethod(BASISCURVE)

    def BASISSURFACE(*args):
        """
        BASISSURFACE(Handle_Geom_Surface S) -> Handle_Geom_Surface
        BASISSURFACE(TopoDS_Face F) -> Handle_Geom_Surface

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_BASISSURFACE(*args)

    BASISSURFACE = staticmethod(BASISSURFACE)

    def UVBOUNDS(*args):
        """
        UVBOUNDS(Handle_Geom_Surface S)
        UVBOUNDS(TopoDS_Face F)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type UPeri: bool
        :type VPeri: bool
        :type Umin: float
        :type Umax: float
        :type Vmin: float
        :type Vmax: float

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_UVBOUNDS(*args)

    UVBOUNDS = staticmethod(UVBOUNDS)

    def AdjustOnPeriodic(*args):
        """
        AdjustOnPeriodic(TopoDS_Shape S)

        ajust u,v values in UVBounds of the domain of the
        geometric shape <S>, according to Uperiodicity and
        VPeriodicity of the domain.
        <S> is assumed to be a face.
        u and/or v is/are not modified when the domain is
        not periodic in U and/or V .

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type u: float
        :type v: float

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_AdjustOnPeriodic(*args)

    AdjustOnPeriodic = staticmethod(AdjustOnPeriodic)

    def Closed(*args):
        """
        Closed(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

        indicates wheter shape S1 is a closing shape on S2 or not.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Closed(*args)

    Closed = staticmethod(Closed)

    def PeriodizeParameter(*args):
        """
        PeriodizeParameter(Standard_Real const par, TopoDS_Shape EE, TopoDS_Shape FF) -> Standard_Real

        :type par: float
        :type EE: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FF: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_PeriodizeParameter(*args)

    PeriodizeParameter = staticmethod(PeriodizeParameter)

    def ShapesSameOriented(*args):
        """
        ShapesSameOriented(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_ShapesSameOriented(*args)

    ShapesSameOriented = staticmethod(ShapesSameOriented)

    def SurfacesSameOriented(*args):
        """
        SurfacesSameOriented(BRepAdaptor_Surface S1, BRepAdaptor_Surface S2) -> Standard_Boolean

        :type S1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type S2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_SurfacesSameOriented(*args)

    SurfacesSameOriented = staticmethod(SurfacesSameOriented)

    def FacesSameOriented(*args):
        """
        FacesSameOriented(TopoDS_Shape F1, TopoDS_Shape F2) -> Standard_Boolean

        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_FacesSameOriented(*args)

    FacesSameOriented = staticmethod(FacesSameOriented)

    def CurvesSameOriented(*args):
        """
        CurvesSameOriented(BRepAdaptor_Curve C1, BRepAdaptor_Curve C2) -> Standard_Boolean

        :type C1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type C2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_CurvesSameOriented(*args)

    CurvesSameOriented = staticmethod(CurvesSameOriented)

    def EdgesSameOriented(*args):
        """
        EdgesSameOriented(TopoDS_Shape E1, TopoDS_Shape E2) -> Standard_Boolean

        :type E1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_EdgesSameOriented(*args)

    EdgesSameOriented = staticmethod(EdgesSameOriented)

    def EdgeData(*args):
        """
        EdgeData(BRepAdaptor_Curve BRAC, Standard_Real const P, gp_Dir T, gp_Dir N) -> Standard_Real
        EdgeData(TopoDS_Shape E, Standard_Real const P, gp_Dir T, gp_Dir N) -> Standard_Real

        Same as previous on edge E.

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type P: float
        :type T: OCC.wrapper.gp.gp_Dir
        :type N: OCC.wrapper.gp.gp_Dir
        :type C: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_EdgeData(*args)

    EdgeData = staticmethod(EdgeData)

    def Resolution3dU(*args):
        """
        Resolution3dU(Handle_Geom_Surface SU, Standard_Real const Tol2d) -> Standard_Real

        :type SU: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol2d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Resolution3dU(*args)

    Resolution3dU = staticmethod(Resolution3dU)

    def Resolution3dV(*args):
        """
        Resolution3dV(Handle_Geom_Surface SU, Standard_Real const Tol2d) -> Standard_Real

        :type SU: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol2d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Resolution3dV(*args)

    Resolution3dV = staticmethod(Resolution3dV)

    def Resolution3d(*args):
        """
        Resolution3d(Handle_Geom_Surface SU, Standard_Real const Tol2d) -> Standard_Real
        Resolution3d(TopoDS_Face F, Standard_Real const Tol2d) -> Standard_Real

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Tol2d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Resolution3d(*args)

    Resolution3d = staticmethod(Resolution3d)

    def __init__(self):
        this = _TopOpeBRepTool.new_TopOpeBRepTool_ShapeTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_ShapeTool
TopOpeBRepTool_ShapeTool_swigregister = _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_swigregister
TopOpeBRepTool_ShapeTool_swigregister(TopOpeBRepTool_ShapeTool)

def TopOpeBRepTool_ShapeTool_Tolerance(*args):
    """
    TopOpeBRepTool_ShapeTool_Tolerance(TopoDS_Shape S) -> Standard_Real

    Returns the tolerance of the shape <S>.
    If the shape <S> is Null, returns 0.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Tolerance(*args)

def TopOpeBRepTool_ShapeTool_Pnt(*args):
    """
    TopOpeBRepTool_ShapeTool_Pnt(TopoDS_Shape S) -> gp_Pnt

    Returns 3D point of vertex <S>.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Pnt(*args)

def TopOpeBRepTool_ShapeTool_BASISCURVE(*args):
    """
    BASISCURVE(Handle_Geom_Curve C) -> Handle_Geom_Curve
    TopOpeBRepTool_ShapeTool_BASISCURVE(TopoDS_Edge E) -> Handle_Geom_Curve

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_BASISCURVE(*args)

def TopOpeBRepTool_ShapeTool_BASISSURFACE(*args):
    """
    BASISSURFACE(Handle_Geom_Surface S) -> Handle_Geom_Surface
    TopOpeBRepTool_ShapeTool_BASISSURFACE(TopoDS_Face F) -> Handle_Geom_Surface

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_BASISSURFACE(*args)

def TopOpeBRepTool_ShapeTool_UVBOUNDS(*args):
    """
    UVBOUNDS(Handle_Geom_Surface S)
    TopOpeBRepTool_ShapeTool_UVBOUNDS(TopoDS_Face F)

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type UPeri: bool
    :type VPeri: bool
    :type Umin: float
    :type Umax: float
    :type Vmin: float
    :type Vmax: float

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_UVBOUNDS(*args)

def TopOpeBRepTool_ShapeTool_AdjustOnPeriodic(*args):
    """
    TopOpeBRepTool_ShapeTool_AdjustOnPeriodic(TopoDS_Shape S)

    ajust u,v values in UVBounds of the domain of the
    geometric shape <S>, according to Uperiodicity and
    VPeriodicity of the domain.
    <S> is assumed to be a face.
    u and/or v is/are not modified when the domain is
    not periodic in U and/or V .

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type u: float
    :type v: float

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_AdjustOnPeriodic(*args)

def TopOpeBRepTool_ShapeTool_Closed(*args):
    """
    TopOpeBRepTool_ShapeTool_Closed(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

    indicates wheter shape S1 is a closing shape on S2 or not.

    :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Closed(*args)

def TopOpeBRepTool_ShapeTool_PeriodizeParameter(*args):
    """
    TopOpeBRepTool_ShapeTool_PeriodizeParameter(Standard_Real const par, TopoDS_Shape EE, TopoDS_Shape FF) -> Standard_Real

    :type par: float
    :type EE: OCC.wrapper.TopoDS.TopoDS_Shape
    :type FF: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_PeriodizeParameter(*args)

def TopOpeBRepTool_ShapeTool_ShapesSameOriented(*args):
    """
    TopOpeBRepTool_ShapeTool_ShapesSameOriented(TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Boolean

    :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_ShapesSameOriented(*args)

def TopOpeBRepTool_ShapeTool_SurfacesSameOriented(*args):
    """
    TopOpeBRepTool_ShapeTool_SurfacesSameOriented(BRepAdaptor_Surface S1, BRepAdaptor_Surface S2) -> Standard_Boolean

    :type S1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :type S2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_SurfacesSameOriented(*args)

def TopOpeBRepTool_ShapeTool_FacesSameOriented(*args):
    """
    TopOpeBRepTool_ShapeTool_FacesSameOriented(TopoDS_Shape F1, TopoDS_Shape F2) -> Standard_Boolean

    :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type F2: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_FacesSameOriented(*args)

def TopOpeBRepTool_ShapeTool_CurvesSameOriented(*args):
    """
    TopOpeBRepTool_ShapeTool_CurvesSameOriented(BRepAdaptor_Curve C1, BRepAdaptor_Curve C2) -> Standard_Boolean

    :type C1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type C2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_CurvesSameOriented(*args)

def TopOpeBRepTool_ShapeTool_EdgesSameOriented(*args):
    """
    TopOpeBRepTool_ShapeTool_EdgesSameOriented(TopoDS_Shape E1, TopoDS_Shape E2) -> Standard_Boolean

    :type E1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type E2: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_EdgesSameOriented(*args)

def TopOpeBRepTool_ShapeTool_EdgeData(*args):
    """
    EdgeData(BRepAdaptor_Curve BRAC, Standard_Real const P, gp_Dir T, gp_Dir N) -> Standard_Real
    TopOpeBRepTool_ShapeTool_EdgeData(TopoDS_Shape E, Standard_Real const P, gp_Dir T, gp_Dir N) -> Standard_Real

    Same as previous on edge E.

    :type E: OCC.wrapper.TopoDS.TopoDS_Shape
    :type P: float
    :type T: OCC.wrapper.gp.gp_Dir
    :type N: OCC.wrapper.gp.gp_Dir
    :type C: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_EdgeData(*args)

def TopOpeBRepTool_ShapeTool_Resolution3dU(*args):
    """
    TopOpeBRepTool_ShapeTool_Resolution3dU(Handle_Geom_Surface SU, Standard_Real const Tol2d) -> Standard_Real

    :type SU: OCC.wrapper.Geom.Handle_Geom_Surface
    :type Tol2d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Resolution3dU(*args)

def TopOpeBRepTool_ShapeTool_Resolution3dV(*args):
    """
    TopOpeBRepTool_ShapeTool_Resolution3dV(Handle_Geom_Surface SU, Standard_Real const Tol2d) -> Standard_Real

    :type SU: OCC.wrapper.Geom.Handle_Geom_Surface
    :type Tol2d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Resolution3dV(*args)

def TopOpeBRepTool_ShapeTool_Resolution3d(*args):
    """
    Resolution3d(Handle_Geom_Surface SU, Standard_Real const Tol2d) -> Standard_Real
    TopOpeBRepTool_ShapeTool_Resolution3d(TopoDS_Face F, Standard_Real const Tol2d) -> Standard_Real

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type Tol2d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRepTool.TopOpeBRepTool_ShapeTool_Resolution3d(*args)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_face,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_face,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_face,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepTool_face,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepTool.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopOpeBRepTool_face theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopOpeBRepTool_face theItem) -> TopOpeBRepTool_face

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepTool_face

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepTool_face

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepTool_face

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepTool_DataMapOfShapeface = NCollection_DataMap_TopoDS_Shape_TopOpeBRepTool_face_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopOpeBRepTool_HBoxTool(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepTool_HBoxTool self)

        Nullify the handle


        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepTool_HBoxTool self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepTool_HBoxTool self, TopOpeBRepTool_HBoxTool thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepTool_HBoxTool self, Handle_TopOpeBRepTool_HBoxTool theHandle) -> Handle_TopOpeBRepTool_HBoxTool
        assign(Handle_TopOpeBRepTool_HBoxTool self, TopOpeBRepTool_HBoxTool thePtr) -> Handle_TopOpeBRepTool_HBoxTool
        assign(Handle_TopOpeBRepTool_HBoxTool self, Handle_TopOpeBRepTool_HBoxTool theHandle) -> Handle_TopOpeBRepTool_HBoxTool

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepTool_HBoxTool self) -> TopOpeBRepTool_HBoxTool

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepTool_HBoxTool self) -> TopOpeBRepTool_HBoxTool

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepTool_HBoxTool self) -> TopOpeBRepTool_HBoxTool

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepTool.new_Handle_TopOpeBRepTool_HBoxTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_DownCast)
    __swig_destroy__ = _TopOpeBRepTool.delete_Handle_TopOpeBRepTool_HBoxTool

    def Clear(self, *args):
        """Clear(Handle_TopOpeBRepTool_HBoxTool self)"""
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_Clear(self, *args)


    def AddBoxes(self, *args):
        """
        AddBoxes(Handle_TopOpeBRepTool_HBoxTool self, TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_AddBoxes(self, *args)


    def AddBox(self, *args):
        """
        AddBox(Handle_TopOpeBRepTool_HBoxTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_AddBox(self, *args)


    def ComputeBox(self, *args):
        """
        ComputeBox(Handle_TopOpeBRepTool_HBoxTool self, TopoDS_Shape S, Bnd_Box B)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_ComputeBox(self, *args)


    def ComputeBoxOnVertices(self, *args):
        """
        ComputeBoxOnVertices(Handle_TopOpeBRepTool_HBoxTool self, TopoDS_Shape S, Bnd_Box B)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_ComputeBoxOnVertices(self, *args)


    def DumpB(self, *args):
        """
        DumpB(Handle_TopOpeBRepTool_HBoxTool self, Bnd_Box B)

        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_DumpB(self, *args)


    def Box(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasBox(self, *args):
        """
        HasBox(Handle_TopOpeBRepTool_HBoxTool self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_HasBox(self, *args)


    def Shape(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Index(Handle_TopOpeBRepTool_HBoxTool self, TopoDS_Shape S) -> Standard_Integer

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_Index(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_TopOpeBRepTool_HBoxTool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_Extent(self, *args)


    def ChangeIMS(self, *args):
        """
        ChangeIMS(Handle_TopOpeBRepTool_HBoxTool self) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_OrientedShapeMapHasher

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_IndexedDataMapOfShapeBox

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_ChangeIMS(self, *args)


    def IMS(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_IndexedDataMapOfShapeBox

        """
        res = _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_IMS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepTool_HBoxTool self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepTool_HBoxTool self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepTool_HBoxTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepTool_HBoxTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepTool_HBoxTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepTool_HBoxTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepTool_HBoxTool self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepTool_HBoxTool self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepTool_HBoxTool self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepTool_HBoxTool self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_DecrementRefCounter(self, *args)

Handle_TopOpeBRepTool_HBoxTool_swigregister = _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_swigregister
Handle_TopOpeBRepTool_HBoxTool_swigregister(Handle_TopOpeBRepTool_HBoxTool)

def Handle_TopOpeBRepTool_HBoxTool_DownCast(thing):
    return _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_DownCast(thing)
Handle_TopOpeBRepTool_HBoxTool_DownCast = _TopOpeBRepTool.Handle_TopOpeBRepTool_HBoxTool_DownCast

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepTool_connexity,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepTool_connexity,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepTool_connexity,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepTool_connexity,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopOpeBRepTool.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, TopOpeBRepTool_connexity theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, TopOpeBRepTool_connexity theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> TopOpeBRepTool_connexity

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepTool_connexity

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepTool_connexity

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepTool_connexity

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepTool_IndexedDataMapOfShapeconnexity = NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepTool_connexity_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepTool_makeTransition(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepTool_makeTransition self) -> TopOpeBRepTool_makeTransition"""
        this = _TopOpeBRepTool.new_TopOpeBRepTool_makeTransition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TopOpeBRepTool_makeTransition self, TopoDS_Edge E, Standard_Real const pbef, Standard_Real const paft, Standard_Real const parE, TopoDS_Face FS, gp_Pnt2d uv, Standard_Real const factor) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type pbef: float
        :type paft: float
        :type parE: float
        :type FS: OCC.wrapper.TopoDS.TopoDS_Face
        :type uv: OCC.wrapper.gp.gp_Pnt2d
        :type factor: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_Initialize(self, *args)


    def Setfactor(self, *args):
        """
        Setfactor(TopOpeBRepTool_makeTransition self, Standard_Real const factor)

        :type factor: float

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_Setfactor(self, *args)


    def Getfactor(self, *args):
        """
        Getfactor(TopOpeBRepTool_makeTransition self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_Getfactor(self, *args)


    def IsT2d(self, *args):
        """
        IsT2d(TopOpeBRepTool_makeTransition self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_IsT2d(self, *args)


    def SetRest(self, *args):
        """
        SetRest(TopOpeBRepTool_makeTransition self, TopoDS_Edge ES, Standard_Real const parES) -> Standard_Boolean

        :type ES: OCC.wrapper.TopoDS.TopoDS_Edge
        :type parES: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_SetRest(self, *args)


    def HasRest(self, *args):
        """
        HasRest(TopOpeBRepTool_makeTransition self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_HasRest(self, *args)


    def MkT2donE(self, *args):
        """
        MkT2donE(TopOpeBRepTool_makeTransition self) -> Standard_Boolean

        :type stb: OCC.wrapper.TopAbs.TopAbs_State
        :type sta: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_MkT2donE(self, *args)


    def MkT3onE(self, *args):
        """
        MkT3onE(TopOpeBRepTool_makeTransition self) -> Standard_Boolean

        :type stb: OCC.wrapper.TopAbs.TopAbs_State
        :type sta: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_MkT3onE(self, *args)


    def MkT3dproj(self, *args):
        """
        MkT3dproj(TopOpeBRepTool_makeTransition self) -> Standard_Boolean

        :type stb: OCC.wrapper.TopAbs.TopAbs_State
        :type sta: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_MkT3dproj(self, *args)


    def MkTonE(self, *args):
        """
        MkTonE(TopOpeBRepTool_makeTransition self) -> Standard_Boolean

        :type stb: OCC.wrapper.TopAbs.TopAbs_State
        :type sta: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepTool.TopOpeBRepTool_makeTransition_MkTonE(self, *args)

    __swig_destroy__ = _TopOpeBRepTool.delete_TopOpeBRepTool_makeTransition
TopOpeBRepTool_makeTransition_swigregister = _TopOpeBRepTool.TopOpeBRepTool_makeTransition_swigregister
TopOpeBRepTool_makeTransition_swigregister(TopOpeBRepTool_makeTransition)

class NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepTool.new_NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepTool.NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepTool_IndexedDataMapOfSolidClassifier = NCollection_IndexedDataMap_TopoDS_Shape_BRepClass3d_SolidClassifier_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored




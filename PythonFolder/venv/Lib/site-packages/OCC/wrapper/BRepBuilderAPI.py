# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepBuilderAPI')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepBuilderAPI')
    _BRepBuilderAPI = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepBuilderAPI', [dirname(__file__)])
        except ImportError:
            import _BRepBuilderAPI
            return _BRepBuilderAPI
        try:
            _mod = imp.load_module('_BRepBuilderAPI', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepBuilderAPI = swig_import_helper()
    del swig_import_helper
else:
    import _BRepBuilderAPI
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepBuilderAPI.delete_SwigPyIterator

    def value(self):
        return _BRepBuilderAPI.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepBuilderAPI.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepBuilderAPI.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepBuilderAPI.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepBuilderAPI.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepBuilderAPI.SwigPyIterator_copy(self)

    def next(self):
        return _BRepBuilderAPI.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepBuilderAPI.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepBuilderAPI.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepBuilderAPI.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepBuilderAPI.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepBuilderAPI.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepBuilderAPI.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepBuilderAPI.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepBuilderAPI.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepBuilderAPI.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepBuilderAPI.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepBuilderAPI.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepBuilderAPI.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepBuilderAPI.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepBuilderAPI.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBuilderAPI.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepBuilderAPI.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepBuilderAPI.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepBuilderAPI.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepBuilderAPI.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepBuilderAPI.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepBuilderAPI.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepBuilderAPI.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBuilderAPI.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepBuilderAPI.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepBuilderAPI.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepBuilderAPI.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepBuilderAPI.ptr_to_number(item)
ptr_to_number = _BRepBuilderAPI.ptr_to_number

def HashCode(*args):
    return _BRepBuilderAPI.HashCode(*args)
HashCode = _BRepBuilderAPI.HashCode

def ptr_equal(a, b):
    return _BRepBuilderAPI.ptr_equal(a, b)
ptr_equal = _BRepBuilderAPI.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
BRepBuilderAPI_EdgeDone = _BRepBuilderAPI.BRepBuilderAPI_EdgeDone
BRepBuilderAPI_PointProjectionFailed = _BRepBuilderAPI.BRepBuilderAPI_PointProjectionFailed
BRepBuilderAPI_ParameterOutOfRange = _BRepBuilderAPI.BRepBuilderAPI_ParameterOutOfRange
BRepBuilderAPI_DifferentPointsOnClosedCurve = _BRepBuilderAPI.BRepBuilderAPI_DifferentPointsOnClosedCurve
BRepBuilderAPI_PointWithInfiniteParameter = _BRepBuilderAPI.BRepBuilderAPI_PointWithInfiniteParameter
BRepBuilderAPI_DifferentsPointAndParameter = _BRepBuilderAPI.BRepBuilderAPI_DifferentsPointAndParameter
BRepBuilderAPI_LineThroughIdenticPoints = _BRepBuilderAPI.BRepBuilderAPI_LineThroughIdenticPoints
BRepBuilderAPI_FaceDone = _BRepBuilderAPI.BRepBuilderAPI_FaceDone
BRepBuilderAPI_NoFace = _BRepBuilderAPI.BRepBuilderAPI_NoFace
BRepBuilderAPI_NotPlanar = _BRepBuilderAPI.BRepBuilderAPI_NotPlanar
BRepBuilderAPI_CurveProjectionFailed = _BRepBuilderAPI.BRepBuilderAPI_CurveProjectionFailed
BRepBuilderAPI_ParametersOutOfRange = _BRepBuilderAPI.BRepBuilderAPI_ParametersOutOfRange
BRepBuilderAPI_ShellDone = _BRepBuilderAPI.BRepBuilderAPI_ShellDone
BRepBuilderAPI_EmptyShell = _BRepBuilderAPI.BRepBuilderAPI_EmptyShell
BRepBuilderAPI_DisconnectedShell = _BRepBuilderAPI.BRepBuilderAPI_DisconnectedShell
BRepBuilderAPI_ShellParametersOutOfRange = _BRepBuilderAPI.BRepBuilderAPI_ShellParametersOutOfRange
BRepBuilderAPI_WireDone = _BRepBuilderAPI.BRepBuilderAPI_WireDone
BRepBuilderAPI_EmptyWire = _BRepBuilderAPI.BRepBuilderAPI_EmptyWire
BRepBuilderAPI_DisconnectedWire = _BRepBuilderAPI.BRepBuilderAPI_DisconnectedWire
BRepBuilderAPI_NonManifoldWire = _BRepBuilderAPI.BRepBuilderAPI_NonManifoldWire
BRepBuilderAPI_PipeDone = _BRepBuilderAPI.BRepBuilderAPI_PipeDone
BRepBuilderAPI_PipeNotDone = _BRepBuilderAPI.BRepBuilderAPI_PipeNotDone
BRepBuilderAPI_PlaneNotIntersectGuide = _BRepBuilderAPI.BRepBuilderAPI_PlaneNotIntersectGuide
BRepBuilderAPI_ImpossibleContact = _BRepBuilderAPI.BRepBuilderAPI_ImpossibleContact
BRepBuilderAPI_Preserved = _BRepBuilderAPI.BRepBuilderAPI_Preserved
BRepBuilderAPI_Deleted = _BRepBuilderAPI.BRepBuilderAPI_Deleted
BRepBuilderAPI_Trimmed = _BRepBuilderAPI.BRepBuilderAPI_Trimmed
BRepBuilderAPI_Merged = _BRepBuilderAPI.BRepBuilderAPI_Merged
BRepBuilderAPI_BoundaryModified = _BRepBuilderAPI.BRepBuilderAPI_BoundaryModified
BRepBuilderAPI_Transformed = _BRepBuilderAPI.BRepBuilderAPI_Transformed
BRepBuilderAPI_RightCorner = _BRepBuilderAPI.BRepBuilderAPI_RightCorner
BRepBuilderAPI_RoundCorner = _BRepBuilderAPI.BRepBuilderAPI_RoundCorner
class BRepBuilderAPI_Command(object):
    """
    Root class for all commands in BRepBuilderAPI.

    Provides :

    * Managements of the notDone flag.

    * Catching of exceptions (not implemented).

    * Logging (not implemented).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_Command self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Command_IsDone(self, *args)


    def Check(self, *args):
        """
        Check(BRepBuilderAPI_Command self)

        Raises NotDone if done is false.


        """
        return _BRepBuilderAPI.BRepBuilderAPI_Command_Check(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_Command
BRepBuilderAPI_Command_swigregister = _BRepBuilderAPI.BRepBuilderAPI_Command_swigregister
BRepBuilderAPI_Command_swigregister(BRepBuilderAPI_Command)

class BRepBuilderAPI_MakeShape(BRepBuilderAPI_Command):
    """
    This    is  the  root     class for     all  shape
    constructions.  It stores the result.

    It  provides deferred methods to trace the history
    of sub-shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Build(self, *args):
        """
        Build(BRepBuilderAPI_MakeShape self)

        This is  called by  Shape().  It does  nothing but
        may be redefined.


        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeShape_Build(self, *args)


    def Shape(self, *args):
        """
        Returns a shape built by the shape construction algorithm.
        Raises exception StdFail_NotDone if the shape was not built.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeShape_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeShape_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepBuilderAPI_MakeShape self, TopoDS_Shape S) -> Standard_Boolean

        Returns true if the shape S has been deleted.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeShape_IsDeleted(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeShape
BRepBuilderAPI_MakeShape_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeShape_swigregister
BRepBuilderAPI_MakeShape_swigregister(BRepBuilderAPI_MakeShape)

class BRepBuilderAPI_Sewing(Standard.Standard_Transient):
    """
    Provides methods to

    - identify possible contigous boundaries (for control
    afterwards (of continuity: C0, C1, ...))

    - assemble contigous shapes into one shape.
    Only manifold shapes will be found. Sewing will not
    be done in case of multiple edges.

    For sewing, use this function as following:
    - create an empty object
    - default tolerance 1.E-06
    - with face analysis on
    - with sewing operation on
    - set the cutting option as you need (default True)
    - define a tolerance
    - add shapes to be sewed -> Add
    - compute -> Perfom
    - output the resulted shapes
    - output free edges if necessary
    - output multiple edges if necessary
    - output the problems if any
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepBuilderAPI_Sewing
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepBuilderAPI_Sewing(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_Sewing self, Standard_Real const tolerance=1.0e-06, Standard_Boolean const option1, Standard_Boolean const option2, Standard_Boolean const option3, Standard_Boolean const option4) -> BRepBuilderAPI_Sewing

        Creates an object with
        tolerance of connexity
        option for sewing (if false only control)
        option for analysis of degenerated shapes
        option for cutting of free edges.
        option for non manifold processing

        :type tolerance: float
        :type option1: bool
        :type option2: bool
        :type option3: bool
        :type option4: bool

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_Sewing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(BRepBuilderAPI_Sewing self, Standard_Real const tolerance=1.0e-06, Standard_Boolean const option1, Standard_Boolean const option2, Standard_Boolean const option3, Standard_Boolean const option4)

        initialize the parameters if necessary

        :type tolerance: float
        :type option1: bool
        :type option2: bool
        :type option3: bool
        :type option4: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_Init(self, *args)


    def Load(self, *args):
        """
        Load(BRepBuilderAPI_Sewing self, TopoDS_Shape shape)

        Loades the context shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_Load(self, *args)


    def Add(self, *args):
        """
        Add(BRepBuilderAPI_Sewing self, TopoDS_Shape shape)

        Defines the shapes to be sewed or controlled

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepBuilderAPI_Sewing self, Handle_Message_ProgressIndicator thePI=0)

        Computing
        thePI - progress indicator of algorithm

        :type thePI: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_Perform(self, *args)


    def SewedShape(self, *args):
        """
        Gives the sewed shape
        a null shape if nothing constructed
        may be a face, a shell, a solid or a compound

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_SewedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetContext(self, *args):
        """
        SetContext(BRepBuilderAPI_Sewing self, Handle_BRepTools_ReShape theContext)

        set context

        :type theContext: OCC.wrapper.BRepTools.Handle_BRepTools_ReShape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetContext(self, *args)


    def GetContext(self, *args):
        """
        return context

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_ReShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_GetContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbFreeEdges(self, *args):
        """
        NbFreeEdges(BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of free edges (edge shared by one face)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_NbFreeEdges(self, *args)


    def FreeEdge(self, *args):
        """
        Gives each free edge

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_FreeEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbMultipleEdges(self, *args):
        """
        NbMultipleEdges(BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of multiple edges
        (edge shared by more than two faces)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_NbMultipleEdges(self, *args)


    def MultipleEdge(self, *args):
        """
        Gives each multiple edge

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_MultipleEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbContigousEdges(self, *args):
        """
        NbContigousEdges(BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of contigous edges (edge shared by two faces)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_NbContigousEdges(self, *args)


    def ContigousEdge(self, *args):
        """
        Gives each contigous edge

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_ContigousEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContigousEdgeCouple(self, *args):
        """
        Gives the sections (edge) belonging to a contigous edge

        :type index: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_ContigousEdgeCouple(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsSectionBound(self, *args):
        """
        IsSectionBound(BRepBuilderAPI_Sewing self, TopoDS_Edge section) -> Standard_Boolean

        Indicates if a section is bound (before use SectionToBoundary)

        :type section: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_IsSectionBound(self, *args)


    def SectionToBoundary(self, *args):
        """
        Gives the original edge (free boundary) which becomes the
        the section. Remember that sections constitute  common edges.
        This imformation is important for control because with
        original edge we can find the surface to which the section
        is attached.

        :type section: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_SectionToBoundary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbDegeneratedShapes(self, *args):
        """
        NbDegeneratedShapes(BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of degenerated shapes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_NbDegeneratedShapes(self, *args)


    def DegeneratedShape(self, *args):
        """
        Gives each degenerated shape

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_DegeneratedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDegenerated(self, *args):
        """
        IsDegenerated(BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> Standard_Boolean

        Indicates if a input shape is degenerated

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_IsDegenerated(self, *args)


    def IsModified(self, *args):
        """
        IsModified(BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> Standard_Boolean

        Indicates if a input shape has been modified

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_IsModified(self, *args)


    def Modified(self, *args):
        """
        Gives a modifieded shape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsModifiedSubShape(self, *args):
        """
        IsModifiedSubShape(BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> Standard_Boolean

        Indicates if a input subshape has been modified

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_IsModifiedSubShape(self, *args)


    def ModifiedSubShape(self, *args):
        """
        ModifiedSubShape(BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> TopoDS_Shape

        Gives a modifieded subshape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_ModifiedSubShape(self, *args)


    def Dump(self, *args):
        """
        Dump(BRepBuilderAPI_Sewing self)

        print the informations


        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_Dump(self, *args)


    def NbDeletedFaces(self, *args):
        """
        NbDeletedFaces(BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of deleted faces (faces smallest than tolerance)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_NbDeletedFaces(self, *args)


    def DeletedFace(self, *args):
        """
        Gives each deleted face

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_DeletedFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WhichFace(self, *args):
        """
        WhichFace(BRepBuilderAPI_Sewing self, TopoDS_Edge theEdg, Standard_Integer const index=1) -> TopoDS_Face

        Gives a modified shape

        :type theEdg: OCC.wrapper.TopoDS.TopoDS_Edge
        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_WhichFace(self, *args)


    def SameParameterMode(self, *args):
        """
        SameParameterMode(BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Gets same parameter mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SameParameterMode(self, *args)


    def SetSameParameterMode(self, *args):
        """
        SetSameParameterMode(BRepBuilderAPI_Sewing self, Standard_Boolean const SameParameterMode)

        Sets same parameter mode.

        :type SameParameterMode: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetSameParameterMode(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(BRepBuilderAPI_Sewing self) -> Standard_Real

        Gives set tolerance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_Tolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepBuilderAPI_Sewing self, Standard_Real const theToler)

        Sets tolerance

        :type theToler: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(BRepBuilderAPI_Sewing self) -> Standard_Real

        Gives set min tolerance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_MinTolerance(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(BRepBuilderAPI_Sewing self, Standard_Real const theMinToler)

        Sets min tolerance

        :type theMinToler: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetMinTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(BRepBuilderAPI_Sewing self) -> Standard_Real

        Gives set max tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_MaxTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(BRepBuilderAPI_Sewing self, Standard_Real const theMaxToler)

        Sets max tolerance.

        :type theMaxToler: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetMaxTolerance(self, *args)


    def FaceMode(self, *args):
        """
        FaceMode(BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Returns mode for sewing faces By default - true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_FaceMode(self, *args)


    def SetFaceMode(self, *args):
        """
        SetFaceMode(BRepBuilderAPI_Sewing self, Standard_Boolean const theFaceMode)

        Sets mode for sewing faces By default - true.

        :type theFaceMode: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetFaceMode(self, *args)


    def FloatingEdgesMode(self, *args):
        """
        FloatingEdgesMode(BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Returns mode for sewing floating edges By default - false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_FloatingEdgesMode(self, *args)


    def SetFloatingEdgesMode(self, *args):
        """
        SetFloatingEdgesMode(BRepBuilderAPI_Sewing self, Standard_Boolean const theFloatingEdgesMode)

        Sets mode for sewing floating edges By default - false.
        Returns mode for cutting floating edges By default - false.
        Sets mode for cutting floating edges By default - false.

        :type theFloatingEdgesMode: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetFloatingEdgesMode(self, *args)


    def LocalTolerancesMode(self, *args):
        """
        LocalTolerancesMode(BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Returns mode for accounting of local tolerances
        of edges and vertices during of merging.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_LocalTolerancesMode(self, *args)


    def SetLocalTolerancesMode(self, *args):
        """
        SetLocalTolerancesMode(BRepBuilderAPI_Sewing self, Standard_Boolean const theLocalTolerancesMode)

        Sets mode for accounting of local tolerances
        of edges and vertices during of merging
        in this case WorkTolerance = myTolerance + tolEdge1+ tolEdg2;

        :type theLocalTolerancesMode: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetLocalTolerancesMode(self, *args)


    def SetNonManifoldMode(self, *args):
        """
        SetNonManifoldMode(BRepBuilderAPI_Sewing self, Standard_Boolean const theNonManifoldMode)

        Sets mode for non-manifold sewing.

        :type theNonManifoldMode: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_SetNonManifoldMode(self, *args)


    def NonManifoldMode(self, *args):
        """
        NonManifoldMode(BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Gets mode for non-manifold sewing.

        INTERNAL FUCTIONS ---

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_NonManifoldMode(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Sewing_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Sewing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_Sewing
BRepBuilderAPI_Sewing_swigregister = _BRepBuilderAPI.BRepBuilderAPI_Sewing_swigregister
BRepBuilderAPI_Sewing_swigregister(BRepBuilderAPI_Sewing)

def BRepBuilderAPI_Sewing_get_type_name(*args):
    """
    BRepBuilderAPI_Sewing_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepBuilderAPI.BRepBuilderAPI_Sewing_get_type_name(*args)

def BRepBuilderAPI_Sewing_get_type_descriptor(*args):
    """
    BRepBuilderAPI_Sewing_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepBuilderAPI.BRepBuilderAPI_Sewing_get_type_descriptor(*args)

class BRepBuilderAPI_FastSewing(Standard.Standard_Transient):
    """
    This class performs fast sewing of surfaces (faces). It supposes
    that all surfaces are finite and are naturally restricted by their bounds.
    Moreover, it supposes that stitched together surfaces have the same parameterization
    along common boundaries, therefore it does not perform time-consuming check for
    SameParameter property of edges.

    For sewing, use this function as following:
    - set tolerance value (default tolerance is 1.E-06)
    - add all necessary surfaces (faces)
    - check status if adding is correctly completed.
    - compute -> Perform
    - retrieve the error status if any
    - retrieve the resulted shape
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepBuilderAPI_FastSewing
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepBuilderAPI_FastSewing(self) 
            return h

    FS_OK = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_OK
    FS_Degenerated = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_Degenerated
    FS_FindVertexError = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_FindVertexError
    FS_FindEdgeError = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_FindEdgeError
    FS_FaceWithNullSurface = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_FaceWithNullSurface
    FS_NotNaturalBoundsFace = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_NotNaturalBoundsFace
    FS_InfiniteSurface = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_InfiniteSurface
    FS_EmptyInput = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_EmptyInput
    FS_Exception = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_FS_Exception

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_FastSewing self, Standard_Real const theTolerance=1.0e-06) -> BRepBuilderAPI_FastSewing

        Creates an object with tolerance of connexity

        :type theTolerance: float

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_FastSewing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(BRepBuilderAPI_FastSewing self, TopoDS_Shape theShape) -> Standard_Boolean
        Add(BRepBuilderAPI_FastSewing self, Handle_Geom_Surface theSurface) -> Standard_Boolean

        Adds a surface

        :type theSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepBuilderAPI_FastSewing self)

        Compute resulted shape


        """
        return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_Perform(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepBuilderAPI_FastSewing self, Standard_Real const theToler)

        Sets tolerance

        :type theToler: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_SetTolerance(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepBuilderAPI_FastSewing self) -> Standard_Real

        Returns tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_GetTolerance(self, *args)


    def GetResult(self, *args):
        """
        Returns resulted shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_GetResult(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetStatuses(self, *args):
        """
        GetStatuses(BRepBuilderAPI_FastSewing self, Standard_OStream *const theOS=None) -> BRepBuilderAPI_FastSewing::FS_VARStatuses

        Returns list of statuses. Print message if theOS != 0

        :type theOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: FS_VARStatuses

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_GetStatuses(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_FastSewing
BRepBuilderAPI_FastSewing_swigregister = _BRepBuilderAPI.BRepBuilderAPI_FastSewing_swigregister
BRepBuilderAPI_FastSewing_swigregister(BRepBuilderAPI_FastSewing)

def BRepBuilderAPI_FastSewing_get_type_name(*args):
    """
    BRepBuilderAPI_FastSewing_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_get_type_name(*args)

def BRepBuilderAPI_FastSewing_get_type_descriptor(*args):
    """
    BRepBuilderAPI_FastSewing_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepBuilderAPI.BRepBuilderAPI_FastSewing_get_type_descriptor(*args)

class BRepBuilderAPI_ModifyShape(BRepBuilderAPI_MakeShape):
    """
    Implements   the  methods   of MakeShape for   the
    constant  topology modifications.  The methods are
    implemented  when the modification uses a Modifier
    from BRepTools. Some of  them have to be redefined
    if  the  modification is  implemented with another
    tool (see Transform from BRepBuilderAPI for example).
    The BRepBuilderAPI package provides the following
    frameworks to perform modifications of this sort:
    -   BRepBuilderAPI_Copy to produce the copy of a shape,
    -   BRepBuilderAPI_Transform and
    BRepBuilderAPI_GTransform to apply a geometric
    transformation to a shape,
    -   BRepBuilderAPI_NurbsConvert to convert the
    whole geometry of a shape into NURBS geometry,
    -   BRepOffsetAPI_DraftAngle to build a tapered shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_ModifyShape_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedShape(self, *args):
        """
        ModifiedShape(BRepBuilderAPI_ModifyShape self, TopoDS_Shape S) -> TopoDS_Shape

        Returns the modified shape corresponding to <S>.
        S can correspond to the entire initial shape or to its subshape.
        Exceptions
        Standard_NoSuchObject if S is not the initial shape or
        a subshape of the initial shape to which the
        transformation has been applied. Raises NoSuchObject from Standard
        if S is not the initial shape or a sub-shape
        of the initial shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_ModifyShape_ModifiedShape(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_ModifyShape
BRepBuilderAPI_ModifyShape_swigregister = _BRepBuilderAPI.BRepBuilderAPI_ModifyShape_swigregister
BRepBuilderAPI_ModifyShape_swigregister(BRepBuilderAPI_ModifyShape)

class BRepBuilderAPI_MakeShell(BRepBuilderAPI_MakeShape):
    """
    Describes functions to build a
    shape corresponding to the skin of a surface.
    Note that the term shell in the class name has the same definition
    as that of a shell in STEP, in other words the skin of a shape,
    and not a solid model defined by surface and thickness. If you want
    to build the second sort of shell, you must use
    BRepOffsetAPI_MakeOffsetShape. A shell is made of a series of
    faces connected by their common edges.
    If the underlying surface of a face is not C2 continuous and
    the flag Segment is True, MakeShell breaks the surface down into
    several faces which are all C2 continuous and which are
    connected along the non-regular curves on the surface.
    The resulting shell contains all these faces.
    Construction of a Shell from a non-C2 continuous Surface
    A MakeShell object provides a framework for:
    -      defining the construction of a shell,
    -      implementing the construction algorithm, and
    -      consulting the result.
    Warning
    The connected C2 faces in the shell resulting from a decomposition of
    the surface are not sewn. For a sewn result, you need to use
    BRepOffsetAPI_Sewing. For a shell with thickness, you need to use
    BRepOffsetAPI_MakeOffsetShape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakeShell self) -> BRepBuilderAPI_MakeShell
        __init__(BRepBuilderAPI_MakeShell self, Handle_Geom_Surface S, Standard_Boolean const Segment) -> BRepBuilderAPI_MakeShell
        __init__(BRepBuilderAPI_MakeShell self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Boolean const Segment) -> BRepBuilderAPI_MakeShell

        Constructs a shell from the surface S,
        limited in the u parametric direction by the two
        parameter values UMin and UMax, and limited in the v
        parametric direction by the two parameter values VMin and VMax.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Segment: bool

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakeShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepBuilderAPI_MakeShell self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Boolean const Segment)

        Defines or redefines the arguments
        for the construction of a shell. The construction is initialized
        with the surface S, limited in the u parametric direction by the
        two parameter values UMin and UMax, and in the v parametric
        direction by the two parameter values VMin and VMax.
        Warning
        The function Error returns:
        -      BRepBuilderAPI_ShellParametersOutOfRange
        when the given parameters are outside the bounds of the
        surface or the basis surface if S is trimmed

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Segment: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeShell_Init(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_MakeShell self) -> Standard_Boolean

        Returns true if the shell is built.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeShell_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(BRepBuilderAPI_MakeShell self) -> BRepBuilderAPI_ShellError

        Returns the construction status:
        -   BRepBuilderAPI_ShellDone if the shell is built, or
        -   another value of the BRepBuilderAPI_ShellError
        enumeration indicating why the construction failed.
        This is frequently BRepBuilderAPI_ShellParametersOutOfRange
        indicating that the given parameters are outside the bounds of the surface.

        :rtype: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_ShellError

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeShell_Error(self, *args)


    def Shell(self, *args):
        """
        Returns the new Shell.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeShell_Shell(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeShell
BRepBuilderAPI_MakeShell_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeShell_swigregister
BRepBuilderAPI_MakeShell_swigregister(BRepBuilderAPI_MakeShell)

class BRepBuilderAPI_MakeVertex(BRepBuilderAPI_MakeShape):
    """
    Describes functions to build BRepBuilder vertices directly
    from 3D geometric points. A vertex built using a
    MakeVertex object is only composed of a 3D point and
    a default precision value (Precision::Confusion()).
    Later on, 2D representations can be added, for example,
    when inserting a vertex in an edge.
    A MakeVertex object provides a framework for:
    -   defining and implementing the construction of a vertex, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakeVertex self, gp_Pnt P) -> BRepBuilderAPI_MakeVertex

        Constructs a vertex from point P.
        Example create a vertex from a 3D point.
        gp_Pnt P(0,0,10);
        TopoDS_Vertex V = BRepBuilderAPI_MakeVertex(P);

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakeVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Vertex(self, *args):
        """
        Returns the constructed vertex.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeVertex_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeVertex
BRepBuilderAPI_MakeVertex_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeVertex_swigregister
BRepBuilderAPI_MakeVertex_swigregister(BRepBuilderAPI_MakeVertex)

class Handle_BRepBuilderAPI_Sewing(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepBuilderAPI_Sewing self)

        Nullify the handle


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepBuilderAPI_Sewing self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepBuilderAPI_Sewing self, BRepBuilderAPI_Sewing thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepBuilderAPI_Sewing self, Handle_BRepBuilderAPI_Sewing theHandle) -> Handle_BRepBuilderAPI_Sewing
        assign(Handle_BRepBuilderAPI_Sewing self, BRepBuilderAPI_Sewing thePtr) -> Handle_BRepBuilderAPI_Sewing
        assign(Handle_BRepBuilderAPI_Sewing self, Handle_BRepBuilderAPI_Sewing theHandle) -> Handle_BRepBuilderAPI_Sewing

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepBuilderAPI_Sewing self) -> BRepBuilderAPI_Sewing

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepBuilderAPI_Sewing self) -> BRepBuilderAPI_Sewing

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepBuilderAPI_Sewing self) -> BRepBuilderAPI_Sewing

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing___ref__(self, *args)


    def __hash__(self):
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepBuilderAPI.new_Handle_BRepBuilderAPI_Sewing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_DownCast)
    __swig_destroy__ = _BRepBuilderAPI.delete_Handle_BRepBuilderAPI_Sewing

    def Init(self, *args):
        """
        Init(Handle_BRepBuilderAPI_Sewing self, Standard_Real const tolerance=1.0e-06, Standard_Boolean const option1, Standard_Boolean const option2, Standard_Boolean const option3, Standard_Boolean const option4)

        initialize the parameters if necessary

        :type tolerance: float
        :type option1: bool
        :type option2: bool
        :type option3: bool
        :type option4: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Init(self, *args)


    def Load(self, *args):
        """
        Load(Handle_BRepBuilderAPI_Sewing self, TopoDS_Shape shape)

        Loades the context shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Load(self, *args)


    def Add(self, *args):
        """
        Add(Handle_BRepBuilderAPI_Sewing self, TopoDS_Shape shape)

        Defines the shapes to be sewed or controlled

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_BRepBuilderAPI_Sewing self, Handle_Message_ProgressIndicator thePI=0)

        Computing
        thePI - progress indicator of algorithm

        :type thePI: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Perform(self, *args)


    def SewedShape(self, *args):
        """
        Gives the sewed shape
        a null shape if nothing constructed
        may be a face, a shell, a solid or a compound

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SewedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetContext(self, *args):
        """
        SetContext(Handle_BRepBuilderAPI_Sewing self, Handle_BRepTools_ReShape theContext)

        set context

        :type theContext: OCC.wrapper.BRepTools.Handle_BRepTools_ReShape

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetContext(self, *args)


    def GetContext(self, *args):
        """
        return context

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_ReShape

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_GetContext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbFreeEdges(self, *args):
        """
        NbFreeEdges(Handle_BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of free edges (edge shared by one face)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_NbFreeEdges(self, *args)


    def FreeEdge(self, *args):
        """
        Gives each free edge

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_FreeEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbMultipleEdges(self, *args):
        """
        NbMultipleEdges(Handle_BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of multiple edges
        (edge shared by more than two faces)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_NbMultipleEdges(self, *args)


    def MultipleEdge(self, *args):
        """
        Gives each multiple edge

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_MultipleEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbContigousEdges(self, *args):
        """
        NbContigousEdges(Handle_BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of contigous edges (edge shared by two faces)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_NbContigousEdges(self, *args)


    def ContigousEdge(self, *args):
        """
        Gives each contigous edge

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_ContigousEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ContigousEdgeCouple(self, *args):
        """
        Gives the sections (edge) belonging to a contigous edge

        :type index: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_ContigousEdgeCouple(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsSectionBound(self, *args):
        """
        IsSectionBound(Handle_BRepBuilderAPI_Sewing self, TopoDS_Edge section) -> Standard_Boolean

        Indicates if a section is bound (before use SectionToBoundary)

        :type section: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IsSectionBound(self, *args)


    def SectionToBoundary(self, *args):
        """
        Gives the original edge (free boundary) which becomes the
        the section. Remember that sections constitute  common edges.
        This imformation is important for control because with
        original edge we can find the surface to which the section
        is attached.

        :type section: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SectionToBoundary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbDegeneratedShapes(self, *args):
        """
        NbDegeneratedShapes(Handle_BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of degenerated shapes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_NbDegeneratedShapes(self, *args)


    def DegeneratedShape(self, *args):
        """
        Gives each degenerated shape

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_DegeneratedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDegenerated(self, *args):
        """
        IsDegenerated(Handle_BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> Standard_Boolean

        Indicates if a input shape is degenerated

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IsDegenerated(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> Standard_Boolean

        Indicates if a input shape has been modified

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IsModified(self, *args)


    def Modified(self, *args):
        """
        Gives a modifieded shape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsModifiedSubShape(self, *args):
        """
        IsModifiedSubShape(Handle_BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> Standard_Boolean

        Indicates if a input subshape has been modified

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IsModifiedSubShape(self, *args)


    def ModifiedSubShape(self, *args):
        """
        ModifiedSubShape(Handle_BRepBuilderAPI_Sewing self, TopoDS_Shape shape) -> TopoDS_Shape

        Gives a modifieded subshape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_ModifiedSubShape(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_BRepBuilderAPI_Sewing self)

        print the informations


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Dump(self, *args)


    def NbDeletedFaces(self, *args):
        """
        NbDeletedFaces(Handle_BRepBuilderAPI_Sewing self) -> Standard_Integer

        Gives the number of deleted faces (faces smallest than tolerance)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_NbDeletedFaces(self, *args)


    def DeletedFace(self, *args):
        """
        Gives each deleted face

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_DeletedFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WhichFace(self, *args):
        """
        WhichFace(Handle_BRepBuilderAPI_Sewing self, TopoDS_Edge theEdg, Standard_Integer const index=1) -> TopoDS_Face

        Gives a modified shape

        :type theEdg: OCC.wrapper.TopoDS.TopoDS_Edge
        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_WhichFace(self, *args)


    def SameParameterMode(self, *args):
        """
        SameParameterMode(Handle_BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Gets same parameter mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SameParameterMode(self, *args)


    def SetSameParameterMode(self, *args):
        """
        SetSameParameterMode(Handle_BRepBuilderAPI_Sewing self, Standard_Boolean const SameParameterMode)

        Sets same parameter mode.

        :type SameParameterMode: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetSameParameterMode(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_BRepBuilderAPI_Sewing self) -> Standard_Real

        Gives set tolerance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Tolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_BRepBuilderAPI_Sewing self, Standard_Real const theToler)

        Sets tolerance

        :type theToler: float

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_BRepBuilderAPI_Sewing self) -> Standard_Real

        Gives set min tolerance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_MinTolerance(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_BRepBuilderAPI_Sewing self, Standard_Real const theMinToler)

        Sets min tolerance

        :type theMinToler: float

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetMinTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_BRepBuilderAPI_Sewing self) -> Standard_Real

        Gives set max tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_MaxTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_BRepBuilderAPI_Sewing self, Standard_Real const theMaxToler)

        Sets max tolerance.

        :type theMaxToler: float

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetMaxTolerance(self, *args)


    def FaceMode(self, *args):
        """
        FaceMode(Handle_BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Returns mode for sewing faces By default - true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_FaceMode(self, *args)


    def SetFaceMode(self, *args):
        """
        SetFaceMode(Handle_BRepBuilderAPI_Sewing self, Standard_Boolean const theFaceMode)

        Sets mode for sewing faces By default - true.

        :type theFaceMode: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetFaceMode(self, *args)


    def FloatingEdgesMode(self, *args):
        """
        FloatingEdgesMode(Handle_BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Returns mode for sewing floating edges By default - false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_FloatingEdgesMode(self, *args)


    def SetFloatingEdgesMode(self, *args):
        """
        SetFloatingEdgesMode(Handle_BRepBuilderAPI_Sewing self, Standard_Boolean const theFloatingEdgesMode)

        Sets mode for sewing floating edges By default - false.
        Returns mode for cutting floating edges By default - false.
        Sets mode for cutting floating edges By default - false.

        :type theFloatingEdgesMode: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetFloatingEdgesMode(self, *args)


    def LocalTolerancesMode(self, *args):
        """
        LocalTolerancesMode(Handle_BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Returns mode for accounting of local tolerances
        of edges and vertices during of merging.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_LocalTolerancesMode(self, *args)


    def SetLocalTolerancesMode(self, *args):
        """
        SetLocalTolerancesMode(Handle_BRepBuilderAPI_Sewing self, Standard_Boolean const theLocalTolerancesMode)

        Sets mode for accounting of local tolerances
        of edges and vertices during of merging
        in this case WorkTolerance = myTolerance + tolEdge1+ tolEdg2;

        :type theLocalTolerancesMode: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetLocalTolerancesMode(self, *args)


    def SetNonManifoldMode(self, *args):
        """
        SetNonManifoldMode(Handle_BRepBuilderAPI_Sewing self, Standard_Boolean const theNonManifoldMode)

        Sets mode for non-manifold sewing.

        :type theNonManifoldMode: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_SetNonManifoldMode(self, *args)


    def NonManifoldMode(self, *args):
        """
        NonManifoldMode(Handle_BRepBuilderAPI_Sewing self) -> Standard_Boolean

        Gets mode for non-manifold sewing.

        INTERNAL FUCTIONS ---

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_NonManifoldMode(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepBuilderAPI_Sewing self) -> char const *

        :rtype: const char *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepBuilderAPI_Sewing self)

        Memory deallocator for transient classes


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepBuilderAPI_Sewing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepBuilderAPI_Sewing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepBuilderAPI_Sewing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepBuilderAPI_Sewing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepBuilderAPI_Sewing self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepBuilderAPI_Sewing self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepBuilderAPI_Sewing self)

        Increments the reference counter of this object


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepBuilderAPI_Sewing self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_DecrementRefCounter(self, *args)

Handle_BRepBuilderAPI_Sewing_swigregister = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_swigregister
Handle_BRepBuilderAPI_Sewing_swigregister(Handle_BRepBuilderAPI_Sewing)

def Handle_BRepBuilderAPI_Sewing_DownCast(thing):
    return _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_DownCast(thing)
Handle_BRepBuilderAPI_Sewing_DownCast = _BRepBuilderAPI.Handle_BRepBuilderAPI_Sewing_DownCast

class NCollection_Vector_gp_XYZ(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_gp_XYZ self) -> NCollection_Vector< gp_XYZ >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_gp_XYZ self) -> NCollection_Vector< gp_XYZ >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_gp_XYZ self) -> NCollection_Vector< gp_XYZ >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_gp_XYZ self) -> NCollection_Vector< gp_XYZ >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _BRepBuilderAPI.new_NCollection_Vector_gp_XYZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_gp_XYZ self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_gp_XYZ self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_gp_XYZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_gp_XYZ self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_gp_XYZ self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_gp_XYZ self, NCollection_Vector_gp_XYZ theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_gp_XYZ self, NCollection_Vector_gp_XYZ theOther) -> NCollection_Vector_gp_XYZ

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_gp_XYZ self, gp_XYZ theValue) -> gp_XYZ

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_gp_XYZ self) -> gp_XYZ

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _BRepBuilderAPI.NCollection_Vector_gp_XYZ_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_gp_XYZ self) -> gp_XYZ

        @return first element

        :rtype: TheItemType &

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _BRepBuilderAPI.NCollection_Vector_gp_XYZ_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_gp_XYZ self) -> gp_XYZ

        @return last element

        :rtype: TheItemType &

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepBuilderAPI.NCollection_Vector_gp_XYZ___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepBuilderAPI.NCollection_Vector_gp_XYZ_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_gp_XYZ self, Standard_Integer const theIndex) -> gp_XYZ

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_gp_XYZ self, Standard_Integer const theIndex, gp_XYZ theValue) -> gp_XYZ

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _BRepBuilderAPI.NCollection_Vector_gp_XYZ_SetValue(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_NCollection_Vector_gp_XYZ
NCollection_Vector_gp_XYZ_swigregister = _BRepBuilderAPI.NCollection_Vector_gp_XYZ_swigregister
NCollection_Vector_gp_XYZ_swigregister(NCollection_Vector_gp_XYZ)


try:
	VectorOfPoint = NCollection_Vector_gp_XYZ
except NameError:
	pass # does not exist, probably ignored

class BRepBuilderAPI_MakeSolid(BRepBuilderAPI_MakeShape):
    """
    Describes functions to build a solid from shells.
    A solid is made of one shell, or a series of shells, which
    do not intersect each other. One of these shells
    constitutes the outside skin of the solid. It may be closed
    (a finite solid) or open (an infinite solid). Other shells
    form hollows (cavities) in these previous ones. Each
    must bound a closed volume.
    A MakeSolid object provides a framework for:
    -   defining and implementing the construction of a solid, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakeSolid self) -> BRepBuilderAPI_MakeSolid
        __init__(BRepBuilderAPI_MakeSolid self, TopoDS_CompSolid S) -> BRepBuilderAPI_MakeSolid
        __init__(BRepBuilderAPI_MakeSolid self, TopoDS_Shell S) -> BRepBuilderAPI_MakeSolid
        __init__(BRepBuilderAPI_MakeSolid self, TopoDS_Shell S1, TopoDS_Shell S2) -> BRepBuilderAPI_MakeSolid
        __init__(BRepBuilderAPI_MakeSolid self, TopoDS_Shell S1, TopoDS_Shell S2, TopoDS_Shell S3) -> BRepBuilderAPI_MakeSolid
        __init__(BRepBuilderAPI_MakeSolid self, TopoDS_Solid So) -> BRepBuilderAPI_MakeSolid
        __init__(BRepBuilderAPI_MakeSolid self, TopoDS_Solid So, TopoDS_Shell S) -> BRepBuilderAPI_MakeSolid

        Add a shell to a solid.

        Constructs a solid:
        -   from the solid So, to which shells can be added, or
        -   by adding the shell S to the solid So.
        Warning
        No check is done to verify the conditions of coherence
        of the resulting solid. In particular S must not intersect the solid S0.
        Besides, after all shells have been added using the Add
        function, one of these shells should constitute the outside
        skin of the solid. It may be closed (a finite solid) or open
        (an infinite solid). Other shells form hollows (cavities) in
        the previous ones. Each must bound a closed volume.

        :type So: OCC.wrapper.TopoDS.TopoDS_Solid
        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakeSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepBuilderAPI_MakeSolid self, TopoDS_Shell S)

        Adds the shell to the current solid.
        Warning
        No check is done to verify the conditions of coherence
        of the resulting solid. In particular, S must not intersect
        other shells of the solid under construction.
        Besides, after all shells have been added, one of
        these shells should constitute the outside skin of the
        solid. It may be closed (a finite solid) or open (an
        infinite solid). Other shells form hollows (cavities) in
        these previous ones. Each must bound a closed volume.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeSolid_Add(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_MakeSolid self) -> Standard_Boolean

        Returns true if the solid is built.
        For this class, a solid under construction is always valid.
        If no shell has been added, it could be a whole-space
        solid. However, no check was done to verify the
        conditions of coherence of the resulting solid.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeSolid_IsDone(self, *args)


    def Solid(self, *args):
        """
        Returns the new Solid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeSolid_Solid(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepBuilderAPI_MakeSolid self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeSolid_IsDeleted(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeSolid
BRepBuilderAPI_MakeSolid_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeSolid_swigregister
BRepBuilderAPI_MakeSolid_swigregister(BRepBuilderAPI_MakeSolid)

class BRepBuilderAPI_MakeWire(BRepBuilderAPI_MakeShape):
    """
    Describes functions to build wires from edges. A wire can
    be built from any number of edges.
    To build a wire you first initialize the construction, then
    add edges in sequence. An unlimited number of edges
    can be added. The initialization of construction is done with:
    -   no edge (an empty wire), or
    -   edges of an existing wire, or
    -   up to four connectable edges.
    In order to be added to a wire under construction, an
    edge (unless it is the first one) must satisfy the following
    condition: one of its vertices must be geometrically
    coincident with one of the vertices of the wire (provided
    that the highest tolerance factor is assigned to the two
    vertices). It could also be the same vertex.
    -   The given edge is shared by the wire if it contains:
    -   two vertices, identical to two vertices of the wire
    under construction (a general case of the wire closure), or
    -   one vertex, identical to a vertex of the wire under
    construction; the other vertex not being
    geometrically coincident with another vertex of the wire.
    -   In other cases, when one of the vertices of the edge
    is simply geometrically coincident with a vertex of the
    wire under construction (provided that the highest
    tolerance factor is assigned to the two vertices), the
    given edge is first copied and the coincident vertex is
    replaced in this new edge, by the coincident vertex of the wire.
    Note: it is possible to build non manifold wires using this construction tool.
    A MakeWire object provides a framework for:
    -   initializing the construction of a wire,
    -   adding edges to the wire under construction, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakeWire self) -> BRepBuilderAPI_MakeWire
        __init__(BRepBuilderAPI_MakeWire self, TopoDS_Edge E) -> BRepBuilderAPI_MakeWire
        __init__(BRepBuilderAPI_MakeWire self, TopoDS_Edge E1, TopoDS_Edge E2) -> BRepBuilderAPI_MakeWire
        __init__(BRepBuilderAPI_MakeWire self, TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Edge E3) -> BRepBuilderAPI_MakeWire
        __init__(BRepBuilderAPI_MakeWire self, TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Edge E3, TopoDS_Edge E4) -> BRepBuilderAPI_MakeWire
        __init__(BRepBuilderAPI_MakeWire self, TopoDS_Wire W) -> BRepBuilderAPI_MakeWire
        __init__(BRepBuilderAPI_MakeWire self, TopoDS_Wire W, TopoDS_Edge E) -> BRepBuilderAPI_MakeWire

        Add an edge to a wire.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakeWire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepBuilderAPI_MakeWire self, TopoDS_Edge E)
        Add(BRepBuilderAPI_MakeWire self, TopoDS_Wire W)
        Add(BRepBuilderAPI_MakeWire self, NCollection_List_TopoDS_Shape L)

        Adds  the edges of <L>   to the current  wire.  The
        edges are not to be consecutive.   But they are to
        be  all  connected geometrically or topologically.
        If some of them are  not connected the Status give
        DisconnectedWire but the "Maker" is Done() and you
        can get the  partial result. (ie connected to  the
        first edgeof the list <L>)

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeWire_Add(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_MakeWire self) -> Standard_Boolean

        Returns true if this algorithm contains a valid wire.
        IsDone returns false if:
        -   there are no edges in the wire, or
        -   the last edge which you tried to add was not connectable.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeWire_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(BRepBuilderAPI_MakeWire self) -> BRepBuilderAPI_WireError

        Returns the construction status
        -   BRepBuilderAPI_WireDone if the wire is built, or
        -   another value of the BRepBuilderAPI_WireError
        enumeration indicating why the construction failed.

        :rtype: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_WireError

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeWire_Error(self, *args)


    def Wire(self, *args):
        """
        Returns the constructed wire; or the part of the wire
        under construction already built.
        Exceptions StdFail_NotDone if a wire is not built.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeWire_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Returns the last edge added to the wire under construction.
        Warning
        -   This edge can be different from the original one (the
        argument of the function Add, for instance,)
        -   A null edge is returned if there are no edges in the
        wire under construction, or if the last edge which you
        tried to add was not connectable..

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeWire_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Returns the last vertex of the last edge added to the
        wire under construction.
        Warning
        A null vertex is returned if there are no edges in the wire
        under construction, or if the last edge which you tried to
        add was not connectableR

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeWire_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeWire
BRepBuilderAPI_MakeWire_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeWire_swigregister
BRepBuilderAPI_MakeWire_swigregister(BRepBuilderAPI_MakeWire)

class BRepBuilderAPI_VertexInspector(NCollection_CellFilter_InspectorXYZ):
    """
    Class BRepBuilderAPI_VertexInspector 
    derived from NCollection_CellFilter_InspectorXYZ
    This class define the Inspector interface for CellFilter algorithm, 
    working with gp_XYZ points in 3d space.
    Used in search of coincidence points with a certain tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_VertexInspector self, Standard_Real const theTol) -> BRepBuilderAPI_VertexInspector

        Constructor; remembers the tolerance

        :type theTol: float

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_VertexInspector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepBuilderAPI_VertexInspector self, gp_XYZ thePnt)

        Keep the points used for comparison

        :type thePnt: OCC.wrapper.gp.gp_XYZ

        """
        return _BRepBuilderAPI.BRepBuilderAPI_VertexInspector_Add(self, *args)


    def ClearResList(self, *args):
        """
        ClearResList(BRepBuilderAPI_VertexInspector self)

        Clear the list of adjacent points


        """
        return _BRepBuilderAPI.BRepBuilderAPI_VertexInspector_ClearResList(self, *args)


    def SetCurrent(self, *args):
        """
        SetCurrent(BRepBuilderAPI_VertexInspector self, gp_XYZ theCurPnt)

        Set current point to search for coincidence

        :type theCurPnt: OCC.wrapper.gp.gp_XYZ

        """
        return _BRepBuilderAPI.BRepBuilderAPI_VertexInspector_SetCurrent(self, *args)


    def ResInd(self, *args):
        """
        Get list of indexes of points adjacent with the current

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_VertexInspector_ResInd(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Inspect(self, *args):
        """
        Inspect(BRepBuilderAPI_VertexInspector self, Standard_Integer const theTarget) -> NCollection_CellFilter_Action

        Implementation of inspection method

        :type theTarget: int
        :rtype: OCC.wrapper.NCollection.NCollection_CellFilter_Action

        """
        return _BRepBuilderAPI.BRepBuilderAPI_VertexInspector_Inspect(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_VertexInspector
BRepBuilderAPI_VertexInspector_swigregister = _BRepBuilderAPI.BRepBuilderAPI_VertexInspector_swigregister
BRepBuilderAPI_VertexInspector_swigregister(BRepBuilderAPI_VertexInspector)

class Handle_BRepBuilderAPI_FastSewing(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepBuilderAPI_FastSewing self)

        Nullify the handle


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepBuilderAPI_FastSewing self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepBuilderAPI_FastSewing self, BRepBuilderAPI_FastSewing thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepBuilderAPI_FastSewing self, Handle_BRepBuilderAPI_FastSewing theHandle) -> Handle_BRepBuilderAPI_FastSewing
        assign(Handle_BRepBuilderAPI_FastSewing self, BRepBuilderAPI_FastSewing thePtr) -> Handle_BRepBuilderAPI_FastSewing
        assign(Handle_BRepBuilderAPI_FastSewing self, Handle_BRepBuilderAPI_FastSewing theHandle) -> Handle_BRepBuilderAPI_FastSewing

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepBuilderAPI_FastSewing self) -> BRepBuilderAPI_FastSewing

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepBuilderAPI_FastSewing self) -> BRepBuilderAPI_FastSewing

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepBuilderAPI_FastSewing self) -> BRepBuilderAPI_FastSewing

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing___ref__(self, *args)


    def __hash__(self):
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepBuilderAPI.new_Handle_BRepBuilderAPI_FastSewing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_DownCast)
    __swig_destroy__ = _BRepBuilderAPI.delete_Handle_BRepBuilderAPI_FastSewing

    def Add(self, *args):
        """
        Add(Handle_BRepBuilderAPI_FastSewing self, TopoDS_Shape theShape) -> Standard_Boolean
        Add(Handle_BRepBuilderAPI_FastSewing self, Handle_Geom_Surface theSurface) -> Standard_Boolean

        Adds a surface

        :type theSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_BRepBuilderAPI_FastSewing self)

        Compute resulted shape


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_Perform(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_BRepBuilderAPI_FastSewing self, Standard_Real const theToler)

        Sets tolerance

        :type theToler: float

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_SetTolerance(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_BRepBuilderAPI_FastSewing self) -> Standard_Real

        Returns tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_GetTolerance(self, *args)


    def GetResult(self, *args):
        """
        Returns resulted shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_GetResult(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetStatuses(self, *args):
        """
        GetStatuses(Handle_BRepBuilderAPI_FastSewing self, Standard_OStream *const theOS=None) -> BRepBuilderAPI_FastSewing::FS_VARStatuses

        Returns list of statuses. Print message if theOS != 0

        :type theOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: FS_VARStatuses

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_GetStatuses(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepBuilderAPI_FastSewing self) -> char const *

        :rtype: const char *

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepBuilderAPI_FastSewing self)

        Memory deallocator for transient classes


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepBuilderAPI_FastSewing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepBuilderAPI_FastSewing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepBuilderAPI_FastSewing self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepBuilderAPI_FastSewing self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepBuilderAPI_FastSewing self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepBuilderAPI_FastSewing self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepBuilderAPI_FastSewing self)

        Increments the reference counter of this object


        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepBuilderAPI_FastSewing self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_DecrementRefCounter(self, *args)

Handle_BRepBuilderAPI_FastSewing_swigregister = _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_swigregister
Handle_BRepBuilderAPI_FastSewing_swigregister(Handle_BRepBuilderAPI_FastSewing)

def Handle_BRepBuilderAPI_FastSewing_DownCast(thing):
    return _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_DownCast(thing)
Handle_BRepBuilderAPI_FastSewing_DownCast = _BRepBuilderAPI.Handle_BRepBuilderAPI_FastSewing_DownCast

class BRepBuilderAPI_Copy(BRepBuilderAPI_ModifyShape):
    """
    Duplication of a shape.
    A Copy object provides a framework for:
    -   defining the construction of a duplicate shape,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_Copy self) -> BRepBuilderAPI_Copy
        __init__(BRepBuilderAPI_Copy self, TopoDS_Shape S, Standard_Boolean const copyGeom, Standard_Boolean const copyMesh) -> BRepBuilderAPI_Copy

        Constructs a copy framework and copies the shape S.
        Use the function Shape to access the result.
        If copyMesh is True, triangulation contained in original shape will be 
        copied along with geometry (by default, triangulation gets lost).
        If copyGeom is False, only topological objects will be copied, while 
        geometry and triangulation will be shared with original shape.
        Note: the constructed framework can be reused to copy
        other shapes: just specify them with the function Perform.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type copyGeom: bool
        :type copyMesh: bool

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_Copy(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepBuilderAPI_Copy self, TopoDS_Shape S, Standard_Boolean const copyGeom, Standard_Boolean const copyMesh)

        Copies the shape S.
        Use the function Shape to access the result.
        If copyMesh is True, triangulation contained in original shape will be 
        copied along with geometry (by default, triangulation gets lost).
        If copyGeom is False, only topological objects will be copied, while 
        geometry and triangulation will be shared with original shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type copyGeom: bool
        :type copyMesh: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Copy_Perform(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_Copy
BRepBuilderAPI_Copy_swigregister = _BRepBuilderAPI.BRepBuilderAPI_Copy_swigregister
BRepBuilderAPI_Copy_swigregister(BRepBuilderAPI_Copy)

class BRepBuilderAPI_Collect(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(BRepBuilderAPI_Collect self) -> BRepBuilderAPI_Collect"""
        this = _BRepBuilderAPI.new_BRepBuilderAPI_Collect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepBuilderAPI_Collect self, TopoDS_Shape SI, BRepBuilderAPI_MakeShape MKS)

        :type SI: OCC.wrapper.TopoDS.TopoDS_Shape
        :type MKS: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_MakeShape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Collect_Add(self, *args)


    def AddGenerated(self, *args):
        """
        AddGenerated(BRepBuilderAPI_Collect self, TopoDS_Shape S, TopoDS_Shape Gen)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Gen: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Collect_AddGenerated(self, *args)


    def AddModif(self, *args):
        """
        AddModif(BRepBuilderAPI_Collect self, TopoDS_Shape S, TopoDS_Shape Mod)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Mod: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Collect_AddModif(self, *args)


    def Filter(self, *args):
        """
        Filter(BRepBuilderAPI_Collect self, TopoDS_Shape SF)

        :type SF: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Collect_Filter(self, *args)


    def Modification(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Collect_Modification(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Collect_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_Collect
BRepBuilderAPI_Collect_swigregister = _BRepBuilderAPI.BRepBuilderAPI_Collect_swigregister
BRepBuilderAPI_Collect_swigregister(BRepBuilderAPI_Collect)

class BRepBuilderAPI_(object):
    """
    The  BRepBuilderAPI  package   provides  an   Application
    Programming Interface  for the BRep  topology data
    structure.

    The API is a set of classes aiming to provide :

    * High level and simple calls  for the most common
    operations.

    *    Keeping   an   access  on    the    low-level
    implementation of high-level calls.

    * Examples  of programming of high-level operations
    from low-level operations.

    * A complete coverage of modelling :

    - Creating vertices ,edges, faces, solids.

    - Sweeping operations.

    - Boolean operations.

    - Global properties computation.

    The API provides  classes to  build  objects:

    * The  constructors  of the classes  provides  the
    different constructions methods.

    * The  class keeps as fields the   different tools
    used to build the object.

    *   The class  provides  a  casting  method to get
    automatically the  result  with  a   function-like
    call.

    For example to make a  vertex <V> from a point <P>
    one can writes :

    V = BRepBuilderAPI_MakeVertex(P);

    or

    BRepBuilderAPI_MakeVertex MV(P);
    V = MV.Vertex();

    For tolerances  a default precision is  used which
    can    be   changed    by    the   packahe  method
    BRepBuilderAPI::Precision.

    For error handling the BRepBuilderAPI commands raise only
    the NotDone error. When Done is false on a command
    the error description can be asked to the command.

    In  theory  the  comands can be    called with any
    arguments, argument  checking  is performed by the
    command.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Plane(*args):
        """
        Plane(Handle_Geom_Plane P)
        Plane() -> Handle_Geom_Plane

        Returns the current plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _BRepBuilderAPI.BRepBuilderAPI__Plane(*args)

    Plane = staticmethod(Plane)

    def Precision(*args):
        """
        Precision(Standard_Real const P)
        Precision() -> Standard_Real

        Returns the default precision.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepBuilderAPI.BRepBuilderAPI__Precision(*args)

    Precision = staticmethod(Precision)

    def __init__(self):
        """
        The  BRepBuilderAPI  package   provides  an   Application
        Programming Interface  for the BRep  topology data
        structure.

        The API is a set of classes aiming to provide :

        * High level and simple calls  for the most common
        operations.

        *    Keeping   an   access  on    the    low-level
        implementation of high-level calls.

        * Examples  of programming of high-level operations
        from low-level operations.

        * A complete coverage of modelling :

        - Creating vertices ,edges, faces, solids.

        - Sweeping operations.

        - Boolean operations.

        - Global properties computation.

        The API provides  classes to  build  objects:

        * The  constructors  of the classes  provides  the
        different constructions methods.

        * The  class keeps as fields the   different tools
        used to build the object.

        *   The class  provides  a  casting  method to get
        automatically the  result  with  a   function-like
        call.

        For example to make a  vertex <V> from a point <P>
        one can writes :

        V = BRepBuilderAPI_MakeVertex(P);

        or

        BRepBuilderAPI_MakeVertex MV(P);
        V = MV.Vertex();

        For tolerances  a default precision is  used which
        can    be   changed    by    the   packahe  method
        BRepBuilderAPI::Precision.

        For error handling the BRepBuilderAPI commands raise only
        the NotDone error. When Done is false on a command
        the error description can be asked to the command.

        In  theory  the  comands can be    called with any
        arguments, argument  checking  is performed by the
        command.
        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_
BRepBuilderAPI__swigregister = _BRepBuilderAPI.BRepBuilderAPI__swigregister
BRepBuilderAPI__swigregister(BRepBuilderAPI_)

def BRepBuilderAPI__Plane(*args):
    """
    Plane(Handle_Geom_Plane P)
    BRepBuilderAPI__Plane() -> Handle_Geom_Plane

    Returns the current plane.

    :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

    """
    return _BRepBuilderAPI.BRepBuilderAPI__Plane(*args)

def BRepBuilderAPI__Precision(*args):
    """
    Precision(Standard_Real const P)
    BRepBuilderAPI__Precision() -> Standard_Real

    Returns the default precision.

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepBuilderAPI.BRepBuilderAPI__Precision(*args)

class BRepBuilderAPI_GTransform(BRepBuilderAPI_ModifyShape):
    """
    Geometric transformation on a shape.
    The transformation to be applied is defined as a gp_GTrsf
    transformation. It may be:
    -      a transformation equivalent to a gp_Trsf transformation, the
    most common case: you should , however, use a BRepAPI_Transform
    object to perform this kind of transformation; or
    -      an affinity, or
    -      more generally, any type of point transformation which may
    be defined by a three row, four column matrix of transformation.
    In the last two cases, the underlying geometry of the
    following shapes may change:
    -      a curve which supports an edge of the shape, or
    -      a surface which supports a face of the shape;
    For example, a circle may be transformed into an ellipse when
    applying an affinity transformation.
    The transformation is applied to:
    -      all the curves which support edges of the shape, and
    -      all the surfaces which support faces of the shape.
    A GTransform object provides a framework for:
    -      defining the geometric transformation to be applied,
    -      implementing the transformation algorithm, and
    -      consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_GTransform self, gp_GTrsf T) -> BRepBuilderAPI_GTransform
        __init__(BRepBuilderAPI_GTransform self, TopoDS_Shape S, gp_GTrsf T, Standard_Boolean const Copy) -> BRepBuilderAPI_GTransform

        Constructs a framework for applying the geometric
        transformation T to a shape, and applies it to the shape S.
        -   If the transformation T is direct and isometric (i.e. if
        the determinant of the vectorial part of T is equal to
        1.), and if Copy equals false (default value), the
        resulting shape is the same as the original but with
        a new location assigned to it.
        -   In all other cases, the transformation is applied to
        a duplicate of S.
        Use the function Shape to access the result.
        Note: the constructed framework can be reused to
        apply the same geometric transformation to other
        shapes: just specify them with the function Perform.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type T: OCC.wrapper.gp.gp_GTrsf
        :type Copy: bool

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_GTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepBuilderAPI_GTransform self, TopoDS_Shape S, Standard_Boolean const Copy)

        Applies the geometric transformation defined at the
        time of construction of this framework to the shape S.
        -   If the transformation T is direct and isometric (i.e. if
        the determinant of the vectorial part of T is equal to
        1.), and if Copy equals false (default value), the
        resulting shape is the same as the original but with
        a new location assigned to it.
        -   In all other cases, the transformation is applied to a duplicate of S.
        Use the function Shape to access the result.
        Note: this framework can be reused to apply the same
        geometric transformation to other shapes: just specify
        them by calling the function Perform again.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Copy: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_GTransform_Perform(self, *args)


    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_GTransform_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedShape(self, *args):
        """
        ModifiedShape(BRepBuilderAPI_GTransform self, TopoDS_Shape S) -> TopoDS_Shape

        Returns the modified shape corresponding to <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_GTransform_ModifiedShape(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_GTransform
BRepBuilderAPI_GTransform_swigregister = _BRepBuilderAPI.BRepBuilderAPI_GTransform_swigregister
BRepBuilderAPI_GTransform_swigregister(BRepBuilderAPI_GTransform)

class BRepBuilderAPI_MakeEdge(BRepBuilderAPI_MakeShape):
    """
    Provides methods to build edges.

    The   methods have  the  following   syntax, where
    TheCurve is one of Lin, Circ, ...

    Create(C : TheCurve)

    Makes an edge on  the whole curve.  Add vertices
    on finite curves.

    Create(C : TheCurve; p1,p2 : Real)

    Make an edge  on the curve between parameters p1
    and p2. if p2 < p1 the edge will be REVERSED. If
    p1  or p2 is infinite the  curve will be open in
    that  direction. Vertices are created for finite
    values of p1 and p2.

    Create(C : TheCurve; P1, P2 : Pnt from gp)

    Make an edge on the curve  between the points P1
    and P2. The  points are projected on   the curve
    and the   previous method is  used. An  error is
    raised if the points are not on the curve.

    Create(C : TheCurve; V1, V2 : Vertex from TopoDS)

    Make an edge  on the curve  between the vertices
    V1 and V2. Same as the  previous but no vertices
    are created. If a vertex is  Null the curve will
    be open in this direction.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakeEdge self) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Lin L) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Lin L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Lin L, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Lin L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Circ L) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Circ L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Circ L, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Circ L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Elips L) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Elips L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Elips L, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Elips L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Hypr L) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Hypr L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Hypr L, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Hypr L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Parab L) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Parab L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Parab L, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, gp_Parab L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve L) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve L, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve L, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge
        __init__(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge

        The general method to directly create an edge is to give
        -      a 3D curve C as the support (geometric domain) of the edge,
        -      two vertices V1 and V2 to limit the curve (definition of the restriction of
        the edge), and
        -      two real values p1 and p2 which are the parameters for the vertices V1 and V2
        on the curve.
        The curve may be defined as a 2d curve in the parametric space of a surface: a
        pcurve. The surface on which the edge is built is then kept at the level of the edge.
        The default tolerance will be associated with this edge.
        Rules applied to the arguments:
        For the curve:
        -      The curve must not be a 'null handle'.
        -      If the curve is a trimmed curve the basis curve is used.
        For the vertices:
        -      Vertices may be null shapes. When V1 or V2 is null the edge is open in the
        corresponding direction and the parameter value p1 or p2 must be infinite
        (remember that Precision::Infinite() defines an infinite value).
        -      The two vertices must be identical if they have the same 3D location.
        Identical vertices are used in particular when the curve is closed.
        For the parameters:
        -      The parameters must be in the parametric range of the curve (or the basis
        curve if the curve is trimmed). If this condition is not satisfied the edge is not
        built, and the Error function will return BRepAPI_ParameterOutOfRange.
        -      Parameter values must not be equal. If this condition is not satisfied (i.e.
        if | p1 - p2 | ) the edge is not built, and the Error function will return
        BRepAPI_LineThroughIdenticPoints.
        Parameter values are expected to be given in increasing order:
        C->FirstParameter()
        - If the parameter values are given in decreasing order the vertices are switched,
        i.e. the "first vertex" is on the point of parameter p2 and the "second vertex" is
        on the point of parameter p1. In such a case, to keep the original intent of the
        construction, the edge will be oriented "reversed".
        - On a periodic curve the parameter values p1 and p2 are adjusted by adding or
        subtracting the period to obtain p1 in the parametric range of the curve, and p2]
        such that [ p1 , where Period is the period of the curve.
        - A parameter value may be infinite. The edge is open in the corresponding
        direction. However the corresponding vertex must be a null shape. If this condition
        is not satisfied the edge is not built, and the Error function will return
        BRepAPI_PointWithInfiniteParameter.
        - The distance between the vertex and the point evaluated on the curve with the
        parameter, must be lower than the precision of the vertex. If this condition is not
        satisfied the edge is not built, and the Error function will return
        BRepAPI_DifferentsPointAndParameter.
        Other edge constructions
        - The parameter values can be omitted, they will be computed by projecting the
        vertices on the curve. Note that projection is the only way to evaluate the
        parameter values of the vertices on the curve: vertices must be given on the curve,
        i.e. the distance from a vertex to the curve must be less than or equal to the
        precision of the vertex. If this condition is not satisfied the edge is not built,
        and the Error function will return BRepAPI_PointProjectionFailed.
        -      3D points can be given in place of vertices. Vertices will be created from the
        points (with the default topological precision Precision::Confusion()).
        Note:
        -      Giving vertices is useful when creating a connected edge.
        -      If the parameter values correspond to the extremities of a closed curve,
        points must be identical, or at least coincident. If this condition is not
        satisfied the edge is not built, and the Error function will return
        BRepAPI_DifferentPointsOnClosedCurve.
        -      The vertices or points can be omitted if the parameter values are given. The
        points will be computed from the parameters on the curve.
        The vertices or points and the parameter values can be omitted. The first and last
        parameters of the curve will then be used.

        Auxiliary methods

        :type L: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakeEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve C)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve C, Standard_Real const p1, Standard_Real const p2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve C, gp_Pnt P1, gp_Pnt P2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve C, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, Standard_Real const p1, Standard_Real const p2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepBuilderAPI_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2)

        Defines or redefines the arguments for the construction of an edge.
        This function is currently used after the empty constructor BRepAPI_MakeEdge().

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeEdge_Init(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_MakeEdge self) -> Standard_Boolean

        Returns true if the edge is built.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeEdge_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(BRepBuilderAPI_MakeEdge self) -> BRepBuilderAPI_EdgeError

        Returns the construction status
        -   BRepBuilderAPI_EdgeDone if the edge is built, or
        -   another value of the BRepBuilderAPI_EdgeError
        enumeration indicating the reason of construction failure.

        :rtype: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_EdgeError

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeEdge_Error(self, *args)


    def Edge(self, *args):
        """
        Returns the constructed edge.
        Exceptions StdFail_NotDone if the edge is not built.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex1(self, *args):
        """
        Returns the first vertex of the edge. May be Null.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge_Vertex1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex2(self, *args):
        """
        Returns the second vertex of the edge. May be Null.

        Warning
        The returned vertex in each function corresponds respectively to
        -   the lowest, or
        -   the highest parameter on the curve along which the edge is built.
        It does not correspond to the first or second vertex
        given at the time of the construction, if the edge is oriented reversed.
        Exceptions
        StdFail_NotDone if the edge is not built.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge_Vertex2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeEdge
BRepBuilderAPI_MakeEdge_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge_swigregister
BRepBuilderAPI_MakeEdge_swigregister(BRepBuilderAPI_MakeEdge)

class BRepBuilderAPI_MakeEdge2d(BRepBuilderAPI_MakeShape):
    """
    Provides methods to build edges.

    The   methods have  the  following   syntax, where
    TheCurve is one of Lin2d, Circ2d, ...

    Create(C : TheCurve)

    Makes an edge on  the whole curve.  Add vertices
    on finite curves.

    Create(C : TheCurve; p1,p2 : Real)

    Make an edge  on the curve between parameters p1
    and p2. if p2 < p1 the edge will be REVERSED. If
    p1  or p2 is infinite the  curve will be open in
    that  direction. Vertices are created for finite
    values of p1 and p2.

    Create(C : TheCurve; P1, P2 : Pnt2d from gp)

    Make an edge on the curve  between the points P1
    and P2. The  points are projected on   the curve
    and the   previous method is  used. An  error is
    raised if the points are not on the curve.

    Create(C : TheCurve; V1, V2 : Vertex from TopoDS)

    Make an edge  on the curve  between the vertices
    V1 and V2. Same as the  previous but no vertices
    are created. If a vertex is  Null the curve will
    be open in this direction.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakeEdge2d self, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Lin2d L) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Lin2d L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Lin2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Lin2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Circ2d L) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Circ2d L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Circ2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Circ2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Elips2d L) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Elips2d L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Elips2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Elips2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Hypr2d L) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Hypr2d L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Hypr2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Hypr2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Parab2d L) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Parab2d L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Parab2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, gp_Parab2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve L) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve L, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve L, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d
        __init__(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2) -> BRepBuilderAPI_MakeEdge2d

        :type L: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakeEdge2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve C)
        Init(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve C, Standard_Real const p1, Standard_Real const p2)
        Init(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve C, gp_Pnt2d P1, gp_Pnt2d P2)
        Init(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2)
        Init(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve C, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepBuilderAPI_MakeEdge2d self, Handle_Geom2d_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2)

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeEdge2d_Init(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_MakeEdge2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeEdge2d_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(BRepBuilderAPI_MakeEdge2d self) -> BRepBuilderAPI_EdgeError

        Returns the error description when NotDone.

        :rtype: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_EdgeError

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeEdge2d_Error(self, *args)


    def Edge(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge2d_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex1(self, *args):
        """
        Returns the first vertex of the edge. May be Null.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge2d_Vertex1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex2(self, *args):
        """
        Returns the second vertex of the edge. May be Null.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge2d_Vertex2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeEdge2d
BRepBuilderAPI_MakeEdge2d_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeEdge2d_swigregister
BRepBuilderAPI_MakeEdge2d_swigregister(BRepBuilderAPI_MakeEdge2d)

class BRepBuilderAPI_MakeFace(BRepBuilderAPI_MakeShape):
    """
    Provides methods to build faces.

    A face may be built :

    * From a surface.

    - Elementary surface from gp.

    - Surface from Geom.

    * From a surface and U,V values.

    * From a wire.

    - Find the surface automatically if possible.

    * From a surface and a wire.

    - A flag Inside is given, when this flag is True
    the  wire is  oriented to bound a finite area on
    the surface.

    * From a face and a wire.

    - The new wire is a perforation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakeFace self) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, TopoDS_Face F) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Pln P) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Cylinder C) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Cone C) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Sphere S) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Torus C) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, Handle_Geom_Surface S, Standard_Real const TolDegen) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Pln P, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Cylinder C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Cone C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Sphere S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Torus C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const TolDegen) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, TopoDS_Wire W, Standard_Boolean const OnlyPlane) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Pln P, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Cylinder C, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Cone C, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Sphere S, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, gp_Torus C, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, Handle_Geom_Surface S, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepBuilderAPI_MakeFace
        __init__(BRepBuilderAPI_MakeFace self, TopoDS_Face F, TopoDS_Wire W) -> BRepBuilderAPI_MakeFace

        Adds the wire <W> in the face <F>
        A general method to create a face is to give
        -      a surface S as the support (the geometric domain) of the face,
        -      and a wire W to bound it.
        The bounds of the face can also be defined by four parameter values
        umin, umax, vmin, vmax which determine isoparametric limitations on
        the parametric space of the surface. In this way, a patch is
        defined. The parameter values are optional. If they are omitted, the
        natural bounds of the surface are used. A wire is automatically
        built using the defined bounds. Up to four edges and four vertices
        are created with this wire (no edge is created when the
        corresponding parameter value is infinite).
        Wires can then be added using the function Add to define other
        restrictions on the face. These restrictions represent holes. More
        than one wire may be added by this way, provided that the wires do
        not cross each other and that they define only one area on the
        surface. (Be careful, however, as this is not checked).
        Forbidden addition of wires
        Note that in this schema, the third case is valid if edges of the
        wire W are declared internal to the face. As a result, these edges
        are no longer bounds of the face.
        A default tolerance (Precision::Confusion()) is given to the face,
        this tolerance may be increased during construction of the face
        using various algorithms.
        Rules applied to the arguments
        For the surface:
        -      The surface must not be a 'null handle'.
        -      If the surface is a trimmed surface, the basis surface is used.
        -      For the wire: the wire is composed of connected edges, each
        edge having a parametric curve description in the parametric
        domain of the surface; in other words, as a pcurve.
        For the parameters:
        -      The parameter values must be in the parametric range of the
        surface (or the basis surface, if the surface is trimmed). If this
        condition is not satisfied, the face is not built, and the Error
        function will return BRepBuilderAPI_ParametersOutOfRange.
        -      The bounding parameters p1 and p2 are adjusted on a periodic
        surface in a given parametric direction by adding or subtracting
        the period to obtain p1 in the parametric range of the surface and
        such p2, that p2 - p1 <= Period, where Period is the period of the
        surface in this parametric direction.
        -      A parameter value may be infinite. There will be no edge and
        no vertex in the corresponding direction.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakeFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepBuilderAPI_MakeFace self, TopoDS_Face F)
        Init(BRepBuilderAPI_MakeFace self, Handle_Geom_Surface S, Standard_Boolean const Bound, Standard_Real const TolDegen)
        Init(BRepBuilderAPI_MakeFace self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const TolDegen)

        Initializes (or reinitializes) the construction of a face on
        the surface S, limited in the u parametric direction by
        the two parameter values UMin and UMax and in the
        v parametric direction by the two parameter values VMin and VMax.
        Warning
        Error returns:
        -      BRepBuilderAPI_ParametersOutOfRange
        when the parameters given are outside the bounds of the
        surface or the basis surface of a trimmed surface.
        TolDegen parameter is used for resolution of degenerated edges.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type TolDegen: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeFace_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepBuilderAPI_MakeFace self, TopoDS_Wire W)

        Adds the wire W to the constructed face as a hole.
        Warning
        W must not cross the other bounds of the face, and all
        the bounds must define only one area on the surface.
        (Be careful, however, as this is not checked.)
        Example
        // a cylinder
        gp_Cylinder C = ..;
        // a wire
        TopoDS_Wire W = ...;
        BRepBuilderAPI_MakeFace MF(C);
        MF.Add(W);
        TopoDS_Face F = MF;

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeFace_Add(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_MakeFace self) -> Standard_Boolean

        Returns true if this algorithm has a valid face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeFace_IsDone(self, *args)


    def Error(self, *args):
        """
        Error(BRepBuilderAPI_MakeFace self) -> BRepBuilderAPI_FaceError

        Returns the construction status
        BRepBuilderAPI_FaceDone if the face is built, or
        -   another value of the BRepBuilderAPI_FaceError
        enumeration indicating why the construction failed, in
        particular when the given parameters are outside the
        bounds of the surface.

        :rtype: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_FaceError

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakeFace_Error(self, *args)


    def Face(self, *args):
        """
        Returns the constructed face.
        Exceptions
        StdFail_NotDone if no face is built.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakeFace_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakeFace
BRepBuilderAPI_MakeFace_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakeFace_swigregister
BRepBuilderAPI_MakeFace_swigregister(BRepBuilderAPI_MakeFace)

class BRepBuilderAPI_NurbsConvert(BRepBuilderAPI_ModifyShape):
    """
    Conversion of the complete geometry of a shape
    (all 3D analytical representation of surfaces and curves)
    into NURBS geometry (execpt for Planes). For example,
    all curves supporting edges of the basis shape are converted
    into BSpline curves, and all surfaces supporting its faces are
    converted into BSpline surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_NurbsConvert self) -> BRepBuilderAPI_NurbsConvert
        __init__(BRepBuilderAPI_NurbsConvert self, TopoDS_Shape S, Standard_Boolean const Copy) -> BRepBuilderAPI_NurbsConvert

        Builds a new shape by converting the geometry of the
        shape S into NURBS geometry. Specifically, all curves
        supporting edges of S are converted into BSpline
        curves, and all surfaces supporting its faces are
        converted into BSpline surfaces.
        Use the function Shape to access the new shape.
        Note: the constructed framework can be reused to
        convert other shapes. You specify these with the
        function Perform.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Copy: bool

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_NurbsConvert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepBuilderAPI_NurbsConvert self, TopoDS_Shape S, Standard_Boolean const Copy)

        Builds a new shape by converting the geometry of the
        shape S into NURBS geometry.
        Specifically, all curves supporting edges of S are
        converted into BSpline curves, and all surfaces
        supporting its faces are converted into BSpline surfaces.
        Use the function Shape to access the new shape.
        Note: this framework can be reused to convert other
        shapes: you specify them by calling the function Perform again.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Copy: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_NurbsConvert_Perform(self, *args)


    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_NurbsConvert_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifiedShape(self, *args):
        """
        ModifiedShape(BRepBuilderAPI_NurbsConvert self, TopoDS_Shape S) -> TopoDS_Shape

        Returns the modified shape corresponding to <S>.
        S can correspond to the entire initial shape or to its subshape.
        Exceptions
        Standard_NoSuchObject if S is not the initial shape or
        a subshape of the initial shape to which the
        transformation has been applied. 

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_NurbsConvert_ModifiedShape(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_NurbsConvert
BRepBuilderAPI_NurbsConvert_swigregister = _BRepBuilderAPI.BRepBuilderAPI_NurbsConvert_swigregister
BRepBuilderAPI_NurbsConvert_swigregister(BRepBuilderAPI_NurbsConvert)

class BRepBuilderAPI_Transform(BRepBuilderAPI_ModifyShape):
    """
    Geometric transformation on a shape.
    The transformation to be applied is defined as a
    gp_Trsf transformation, i.e. a transformation which does
    not modify the underlying geometry of shapes.
    The transformation is applied to:
    -   all curves which support edges of a shape, and
    -   all surfaces which support its faces.
    A Transform object provides a framework for:
    -   defining the geometric transformation to be applied,
    -   implementing the transformation algorithm, and
    -   consulting the results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_Transform self, gp_Trsf T) -> BRepBuilderAPI_Transform
        __init__(BRepBuilderAPI_Transform self, TopoDS_Shape S, gp_Trsf T, Standard_Boolean const Copy) -> BRepBuilderAPI_Transform

        Creates a transformation from the gp_Trsf <T>, and
        applies it to the shape <S>. If the transformation
        is  direct   and isometric (determinant  =  1) and
        <Copy> =  Standard_False,  the resulting shape  is
        <S> on   which  a  new  location has    been  set.
        Otherwise,  the   transformation is applied   on a
        duplication of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type T: OCC.wrapper.gp.gp_Trsf
        :type Copy: bool

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_Transform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepBuilderAPI_Transform self, TopoDS_Shape S, Standard_Boolean const Copy)

        pplies the geometric transformation defined at the
        time of construction of this framework to the shape S.
        - If the transformation T is direct and isometric, in
        other words, if the determinant of the vectorial part
        of T is equal to 1., and if Copy equals false (the
        default value), the resulting shape is the same as
        the original but with a new location assigned to it.
        -   In all other cases, the transformation is applied to a duplicate of S.
        Use the function Shape to access the result.
        Note: this framework can be reused to apply the same
        geometric transformation to other shapes. You only
        need to specify them by calling the function Perform again.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Copy: bool

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Transform_Perform(self, *args)


    def ModifiedShape(self, *args):
        """
        ModifiedShape(BRepBuilderAPI_Transform self, TopoDS_Shape S) -> TopoDS_Shape

        Returns the modified shape corresponding to <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepBuilderAPI.BRepBuilderAPI_Transform_ModifiedShape(self, *args)


    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_Transform_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_Transform
BRepBuilderAPI_Transform_swigregister = _BRepBuilderAPI.BRepBuilderAPI_Transform_swigregister
BRepBuilderAPI_Transform_swigregister(BRepBuilderAPI_Transform)

class BRepBuilderAPI_BndBoxTreeSelector(object):
    """
    Class BRepBuilderAPI_BndBoxTreeSelector 
    derived from UBTree::Selector
    This class is used to select overlapping boxes, stored in 
    NCollection::UBTree; contains methods to maintain the selection
    condition and to retrieve selected objects after search.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_BndBoxTreeSelector self) -> BRepBuilderAPI_BndBoxTreeSelector

        Constructor; calls the base class constructor


        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_BndBoxTreeSelector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reject(self, *args):
        """
        Reject(BRepBuilderAPI_BndBoxTreeSelector self, Bnd_Box theBox) -> Standard_Boolean

        Implementation of rejection method
        @return
        True if the bounding box does not intersect with the current 

        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_BndBoxTreeSelector_Reject(self, *args)


    def Accept(self, *args):
        """
        Accept(BRepBuilderAPI_BndBoxTreeSelector self, Standard_Integer const & theObj) -> Standard_Boolean

        Implementation of acceptance method
        This method is called when the bounding box intersect with the current.
        It stores the object - the index of box in the list of accepted objects.
        @return
        True, because the object is accepted

        :type theObj: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_BndBoxTreeSelector_Accept(self, *args)


    def ClearResList(self, *args):
        """
        ClearResList(BRepBuilderAPI_BndBoxTreeSelector self)

        Clear the list of intersecting boxes


        """
        return _BRepBuilderAPI.BRepBuilderAPI_BndBoxTreeSelector_ClearResList(self, *args)


    def SetCurrent(self, *args):
        """
        SetCurrent(BRepBuilderAPI_BndBoxTreeSelector self, Bnd_Box theBox)

        Set current box to search for overlapping with him

        :type theBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BRepBuilderAPI.BRepBuilderAPI_BndBoxTreeSelector_SetCurrent(self, *args)


    def ResInd(self, *args):
        """
        Get list of indexes of boxes intersecting with the current box

        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_BndBoxTreeSelector_ResInd(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_BndBoxTreeSelector
BRepBuilderAPI_BndBoxTreeSelector_swigregister = _BRepBuilderAPI.BRepBuilderAPI_BndBoxTreeSelector_swigregister
BRepBuilderAPI_BndBoxTreeSelector_swigregister(BRepBuilderAPI_BndBoxTreeSelector)

class BRepBuilderAPI_FindPlane(object):
    """
    Describes functions to find the plane in which the edges
    of a given shape are located.
    A FindPlane object provides a framework for:
    -   extracting the edges of a given shape,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_FindPlane self) -> BRepBuilderAPI_FindPlane
        __init__(BRepBuilderAPI_FindPlane self, TopoDS_Shape S, Standard_Real const Tol=-1) -> BRepBuilderAPI_FindPlane

        Constructs the plane containing the edges of the shape S.
        A plane is built only if all the edges are within a distance
        of less than or equal to tolerance from a planar surface.
        This tolerance value is equal to the larger of the following two values:
        -   Tol, where the default value is negative, or
        -   the largest of the tolerance values assigned to the individual edges of S.
        Use the function Found to verify that a plane is built.
        The resulting plane is then retrieved using the function Plane.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Tol: float

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_FindPlane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepBuilderAPI_FindPlane self, TopoDS_Shape S, Standard_Real const Tol=-1)

        Constructs the plane containing the edges of the shape S.
        A plane is built only if all the edges are within a distance
        of less than or equal to tolerance from a planar surface.
        This tolerance value is equal to the larger of the following two values:
        -   Tol, where the default value is negative, or
        -   the largest of the tolerance values assigned to the individual edges of S.
        Use the function Found to verify that a plane is built.
        The resulting plane is then retrieved using the function Plane.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Tol: float

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FindPlane_Init(self, *args)


    def Found(self, *args):
        """
        Found(BRepBuilderAPI_FindPlane self) -> Standard_Boolean

        Returns true if a plane containing the edges of the
        shape is found and built. Use the function Plane to consult the result.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FindPlane_Found(self, *args)


    def Plane(self, *args):
        """
        Plane(BRepBuilderAPI_FindPlane self) -> Handle_Geom_Plane

        Returns the plane containing the edges of the shape.
        Warning
        Use the function Found to verify that the plane is built. If
        a plane is not found, Plane returns a null handle.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _BRepBuilderAPI.BRepBuilderAPI_FindPlane_Plane(self, *args)

    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_FindPlane
BRepBuilderAPI_FindPlane_swigregister = _BRepBuilderAPI.BRepBuilderAPI_FindPlane_swigregister
BRepBuilderAPI_FindPlane_swigregister(BRepBuilderAPI_FindPlane)


try:
	BRepBuilderAPI_CellFilter = NCollection_CellFilter_BRepBuilderAPI_VertexInspector
except NameError:
	pass # does not exist, probably ignored

class NCollection_UBTree_Standard_Integer_Bnd_Box(object):
    """
    The algorithm of unbalanced binary tree of overlapped bounding boxes.

    Once the tree of boxes  of geometric objects is constructed, the algorithm
    is capable of fast geometric selection of objects.  The tree can be easily
    updated by adding to it a new object with bounding box.

    The time of adding to the tree  of one object is O(log(N)), where N is the
    total number of  objects, so the time  of building a tree of  N objects is
    O(N(log(N)). The search time of one object is O(log(N)).

    Defining  various classes  inheriting NCollection_UBTree::Selector  we can
    perform various kinds of selection over the same b-tree object

    The object  may be of any  type allowing copying. Among  the best suitable
    solutions there can  be a pointer to an object,  handled object or integer
    index of object inside some  collection.  The bounding object may have any
    dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
    public empty and copy constructor and operator =) used in UBTree algorithm
    is as the following:
    @code
    class MyBndType
    {
    public:
    inline void                   Add (const MyBndType& other);
    // Updates me with other bounding

    inline Standard_Boolean       IsOut (const MyBndType& other) const;
    // Classifies other bounding relatively me

    inline Standard_Real          SquareExtent() const;
    // Computes the squared maximal linear extent of me.
    // (For box it is the squared diagonal of box)
    };
    @endcode
    To select objects you need to define a class derived from UBTree::Selector
    that  should  redefine  the  necessary  virtual methods  to  maintain  the
    selection condition.  The object  of this class  is also used  to retrieve
    selected objects after search.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The algorithm of unbalanced binary tree of overlapped bounding boxes.

        Once the tree of boxes  of geometric objects is constructed, the algorithm
        is capable of fast geometric selection of objects.  The tree can be easily
        updated by adding to it a new object with bounding box.

        The time of adding to the tree  of one object is O(log(N)), where N is the
        total number of  objects, so the time  of building a tree of  N objects is
        O(N(log(N)). The search time of one object is O(log(N)).

        Defining  various classes  inheriting NCollection_UBTree::Selector  we can
        perform various kinds of selection over the same b-tree object

        The object  may be of any  type allowing copying. Among  the best suitable
        solutions there can  be a pointer to an object,  handled object or integer
        index of object inside some  collection.  The bounding object may have any
        dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
        public empty and copy constructor and operator =) used in UBTree algorithm
        is as the following:
        @code
        class MyBndType
        {
        public:
        inline void                   Add (const MyBndType& other);
        // Updates me with other bounding

        inline Standard_Boolean       IsOut (const MyBndType& other) const;
        // Classifies other bounding relatively me

        inline Standard_Real          SquareExtent() const;
        // Computes the squared maximal linear extent of me.
        // (For box it is the squared diagonal of box)
        };
        @endcode
        To select objects you need to define a class derived from UBTree::Selector
        that  should  redefine  the  necessary  virtual methods  to  maintain  the
        selection condition.  The object  of this class  is also used  to retrieve
        selected objects after search.
        """
        this = _BRepBuilderAPI.new_NCollection_UBTree_Standard_Integer_Bnd_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(NCollection_UBTree_Standard_Integer_Bnd_Box self, int const & theObj, Bnd_Box theBnd) -> Standard_Boolean

        Update the tree with a new object and its bounding box.
        @param theObj
        added object
        @param theBnd
        bounding box of the object.
        @return
        always True

        :type theObj: const TheObjType &
        :type theBnd: const TheBndType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.NCollection_UBTree_Standard_Integer_Bnd_Box_Add(self, *args)


    def Select(self, *args):
        """
        Select(NCollection_UBTree_Standard_Integer_Bnd_Box self, NCollection_UBTree< Standard_Integer,Bnd_Box >::Selector & theSelector) -> Standard_Integer

        Searches in the branch all objects conforming to the given selector.
        @return
        the number of objects accepted

        :type theBranch: OCC.wrapper.NCollection.TreeNode
        :type theSelector: OCC.wrapper.NCollection.Selector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepBuilderAPI.NCollection_UBTree_Standard_Integer_Bnd_Box_Select(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UBTree_Standard_Integer_Bnd_Box self, Handle_NCollection_BaseAllocator aNewAlloc=0)

        Clears the contents of the tree.
        @param aNewAlloc
        Optional:   a new allocator that will be used when the tree is rebuilt
        anew. This makes sense if the memory allocator needs re-initialisation
        (like NCollection_IncAllocator).  By default the previous allocator is
        kept.

        :type aNewAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepBuilderAPI.NCollection_UBTree_Standard_Integer_Bnd_Box_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UBTree_Standard_Integer_Bnd_Box self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.NCollection_UBTree_Standard_Integer_Bnd_Box_IsEmpty(self, *args)


    def Root(self, *args):
        """
        @return
        the root node of the tree

        :rtype: OCC.wrapper.NCollection.TreeNode

        """
        res = _BRepBuilderAPI.NCollection_UBTree_Standard_Integer_Bnd_Box_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Allocator(self, *args):
        """
        Recommended to be used only in sub-classes.
        @return
        Allocator object used in this instance of UBTree.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _BRepBuilderAPI.NCollection_UBTree_Standard_Integer_Bnd_Box_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_NCollection_UBTree_Standard_Integer_Bnd_Box
NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister = _BRepBuilderAPI.NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister
NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister(NCollection_UBTree_Standard_Integer_Bnd_Box)


try:
	BRepBuilderAPI_BndBoxTree = NCollection_UBTree_Standard_Integer_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class BRepBuilderAPI_MakePolygon(BRepBuilderAPI_MakeShape):
    """
    Describes functions to build polygonal wires. A
    polygonal wire can be built from any number of points
    or vertices, and consists of a sequence of connected
    rectilinear edges.
    When a point or vertex is added to the  polygon if
    it is identic  to the previous  point no  edge  is
    built. The method added can be used to test it.
    Construction of a Polygonal Wire
    You can construct:
    -   a complete polygonal wire by defining all its points
    or vertices (limited to four), or
    -   an empty polygonal wire and add its points or
    vertices in sequence (unlimited number).
    A MakePolygon object provides a framework for:
    -   initializing the construction of a polygonal wire,
    -   adding points or vertices to the polygonal wire under construction, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepBuilderAPI_MakePolygon self) -> BRepBuilderAPI_MakePolygon
        __init__(BRepBuilderAPI_MakePolygon self, gp_Pnt P1, gp_Pnt P2) -> BRepBuilderAPI_MakePolygon
        __init__(BRepBuilderAPI_MakePolygon self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, Standard_Boolean const Close) -> BRepBuilderAPI_MakePolygon
        __init__(BRepBuilderAPI_MakePolygon self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_Pnt P4, Standard_Boolean const Close) -> BRepBuilderAPI_MakePolygon
        __init__(BRepBuilderAPI_MakePolygon self, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepBuilderAPI_MakePolygon
        __init__(BRepBuilderAPI_MakePolygon self, TopoDS_Vertex V1, TopoDS_Vertex V2, TopoDS_Vertex V3, Standard_Boolean const Close) -> BRepBuilderAPI_MakePolygon
        __init__(BRepBuilderAPI_MakePolygon self, TopoDS_Vertex V1, TopoDS_Vertex V2, TopoDS_Vertex V3, TopoDS_Vertex V4, Standard_Boolean const Close) -> BRepBuilderAPI_MakePolygon

        Constructs a polygonal wire from
        2, 3 or 4 vertices. The polygonal wire is closed if Close is true;
        otherwise it is open (default value). Further vertices can be
        added using the Add function. The polygonal wire under
        construction can be consulted at any time by using the Wire function.
        Example
        //a closed triangle from three vertices
        TopoDS_Wire W = BRepBuilderAPI_MakePolygon(V1,V2,V3,Standard_True);
        Warning
        The process is equivalent to:
        -      initializing an empty polygonal wire,
        -      then adding the given points in sequence.
        So be careful, as when using this function, you could create a
        polygonal wire with two consecutive coincident edges if
        the sequence of vertices v1 - v2 - v1 is found among the
        constructor's arguments.

        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V3: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V4: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Close: bool

        """
        this = _BRepBuilderAPI.new_BRepBuilderAPI_MakePolygon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepBuilderAPI_MakePolygon self, gp_Pnt P)
        Add(BRepBuilderAPI_MakePolygon self, TopoDS_Vertex V)

        Adds the point P or the vertex V at the end of the
        polygonal wire under construction. A vertex is
        automatically created on the point P.
        Warning
        -   When P or V is coincident to the previous vertex,
        no edge is built. The method Added can be used to
        test for this. Neither P nor V is checked to verify
        that it is coincident with another vertex than the last
        one, of the polygonal wire under construction. It is
        also possible to add vertices on a closed polygon
        (built for example by using a constructor which
        declares the polygon closed, or after the use of the Close function).
        Consequently, be careful using this function: you might create:
        -      a polygonal wire with two consecutive coincident edges, or
        -      a non manifold polygonal wire.
        -      P or V is not checked to verify if it is
        coincident with another vertex but the last one, of
        the polygonal wire under construction. It is also
        possible to add vertices on a closed polygon (built
        for example by using a constructor which declares
        the polygon closed, or after the use of the Close function).
        Consequently, be careful when using this function: you might create:
        -   a polygonal wire with two consecutive coincident edges, or
        -   a non-manifold polygonal wire.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_Add(self, *args)


    def Added(self, *args):
        """
        Added(BRepBuilderAPI_MakePolygon self) -> Standard_Boolean

        Returns true if the last vertex added to the constructed
        polygonal wire is not coincident with the previous one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_Added(self, *args)


    def Close(self, *args):
        """
        Close(BRepBuilderAPI_MakePolygon self)

        Closes the polygonal wire under construction. Note - this
        is equivalent to adding the first vertex to the polygonal
        wire under construction.


        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_Close(self, *args)


    def FirstVertex(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_FirstVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastVertex(self, *args):
        """
        Returns the first or the last vertex of the polygonal wire under construction.
        If the constructed polygonal wire is closed, the first and the last vertices are identical.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_LastVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(BRepBuilderAPI_MakePolygon self) -> Standard_Boolean

        Returns true if this algorithm contains a valid polygonal
        wire (i.e. if there is at least one edge).
        IsDone returns false if fewer than two vertices have
        been chained together by this construction algorithm.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_IsDone(self, *args)


    def Edge(self, *args):
        """
        Returns the edge built between the last two points or
        vertices added to the constructed polygonal wire under construction.
        Warning
        If there is only one vertex in the polygonal wire, the result is a null edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        Returns the constructed polygonal wire, or the already
        built part of the polygonal wire under construction.
        Exceptions
        StdFail_NotDone if the wire is not built, i.e. if fewer than
        two vertices have been chained together by this construction algorithm.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepBuilderAPI.delete_BRepBuilderAPI_MakePolygon
BRepBuilderAPI_MakePolygon_swigregister = _BRepBuilderAPI.BRepBuilderAPI_MakePolygon_swigregister
BRepBuilderAPI_MakePolygon_swigregister(BRepBuilderAPI_MakePolygon)




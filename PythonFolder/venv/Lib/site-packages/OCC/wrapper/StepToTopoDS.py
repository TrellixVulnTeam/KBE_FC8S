# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepToTopoDS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepToTopoDS')
    _StepToTopoDS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepToTopoDS', [dirname(__file__)])
        except ImportError:
            import _StepToTopoDS
            return _StepToTopoDS
        try:
            _mod = imp.load_module('_StepToTopoDS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepToTopoDS = swig_import_helper()
    del swig_import_helper
else:
    import _StepToTopoDS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepToTopoDS.delete_SwigPyIterator

    def value(self):
        return _StepToTopoDS.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StepToTopoDS.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StepToTopoDS.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StepToTopoDS.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StepToTopoDS.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StepToTopoDS.SwigPyIterator_copy(self)

    def next(self):
        return _StepToTopoDS.SwigPyIterator_next(self)

    def __next__(self):
        return _StepToTopoDS.SwigPyIterator___next__(self)

    def previous(self):
        return _StepToTopoDS.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StepToTopoDS.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StepToTopoDS.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StepToTopoDS.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StepToTopoDS.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StepToTopoDS.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StepToTopoDS.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StepToTopoDS.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StepToTopoDS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepToTopoDS.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StepToTopoDS.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StepToTopoDS.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepToTopoDS.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StepToTopoDS.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StepToTopoDS.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StepToTopoDS.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepToTopoDS.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StepToTopoDS.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StepToTopoDS.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepToTopoDS.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StepToTopoDS.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StepToTopoDS.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StepToTopoDS.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StepToTopoDS.ptr_to_number(item)
ptr_to_number = _StepToTopoDS.ptr_to_number

def HashCode(*args):
    return _StepToTopoDS.HashCode(*args)
HashCode = _StepToTopoDS.HashCode

def ptr_equal(a, b):
    return _StepToTopoDS.ptr_equal(a, b)
ptr_equal = _StepToTopoDS.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Transfer
else:
    import Transfer
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepShape
else:
    import StepShape
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
StepToTopoDS_BuilderDone = _StepToTopoDS.StepToTopoDS_BuilderDone
StepToTopoDS_BuilderOther = _StepToTopoDS.StepToTopoDS_BuilderOther
StepToTopoDS_TranslateShellDone = _StepToTopoDS.StepToTopoDS_TranslateShellDone
StepToTopoDS_TranslateShellOther = _StepToTopoDS.StepToTopoDS_TranslateShellOther
StepToTopoDS_TranslateFaceDone = _StepToTopoDS.StepToTopoDS_TranslateFaceDone
StepToTopoDS_TranslateFaceOther = _StepToTopoDS.StepToTopoDS_TranslateFaceOther
StepToTopoDS_TranslateEdgeDone = _StepToTopoDS.StepToTopoDS_TranslateEdgeDone
StepToTopoDS_TranslateEdgeOther = _StepToTopoDS.StepToTopoDS_TranslateEdgeOther
StepToTopoDS_TranslateVertexDone = _StepToTopoDS.StepToTopoDS_TranslateVertexDone
StepToTopoDS_TranslateVertexOther = _StepToTopoDS.StepToTopoDS_TranslateVertexOther
StepToTopoDS_TranslateVertexLoopDone = _StepToTopoDS.StepToTopoDS_TranslateVertexLoopDone
StepToTopoDS_TranslateVertexLoopOther = _StepToTopoDS.StepToTopoDS_TranslateVertexLoopOther
StepToTopoDS_TranslatePolyLoopDone = _StepToTopoDS.StepToTopoDS_TranslatePolyLoopDone
StepToTopoDS_TranslatePolyLoopOther = _StepToTopoDS.StepToTopoDS_TranslatePolyLoopOther
StepToTopoDS_GeometricToolDone = _StepToTopoDS.StepToTopoDS_GeometricToolDone
StepToTopoDS_GeometricToolIsDegenerated = _StepToTopoDS.StepToTopoDS_GeometricToolIsDegenerated
StepToTopoDS_GeometricToolHasNoPCurve = _StepToTopoDS.StepToTopoDS_GeometricToolHasNoPCurve
StepToTopoDS_GeometricToolWrong3dParameters = _StepToTopoDS.StepToTopoDS_GeometricToolWrong3dParameters
StepToTopoDS_GeometricToolNoProjectiOnCurve = _StepToTopoDS.StepToTopoDS_GeometricToolNoProjectiOnCurve
StepToTopoDS_GeometricToolOther = _StepToTopoDS.StepToTopoDS_GeometricToolOther
StepToTopoDS_TranslateEdgeLoopDone = _StepToTopoDS.StepToTopoDS_TranslateEdgeLoopDone
StepToTopoDS_TranslateEdgeLoopOther = _StepToTopoDS.StepToTopoDS_TranslateEdgeLoopOther
class StepToTopoDS_Root(object):
    """
    This class implements the common services for
    all classes of StepToTopoDS which report error
    and sets and returns precision.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(StepToTopoDS_Root self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_Root_IsDone(self, *args)


    def Precision(self, *args):
        """
        Precision(StepToTopoDS_Root self) -> Standard_Real

        Returns the value of "MyPrecision"

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepToTopoDS.StepToTopoDS_Root_Precision(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(StepToTopoDS_Root self, Standard_Real const preci)

        Sets the value of "MyPrecision"

        :type preci: float

        """
        return _StepToTopoDS.StepToTopoDS_Root_SetPrecision(self, *args)


    def MaxTol(self, *args):
        """
        MaxTol(StepToTopoDS_Root self) -> Standard_Real

        Returns the value of "MaxTol"

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepToTopoDS.StepToTopoDS_Root_MaxTol(self, *args)


    def SetMaxTol(self, *args):
        """
        SetMaxTol(StepToTopoDS_Root self, Standard_Real const maxpreci)

        Sets the value of MaxTol

        :type maxpreci: float

        """
        return _StepToTopoDS.StepToTopoDS_Root_SetMaxTol(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_Root
StepToTopoDS_Root_swigregister = _StepToTopoDS.StepToTopoDS_Root_swigregister
StepToTopoDS_Root_swigregister(StepToTopoDS_Root)

class StepToTopoDS_PointPair(object):
    """Stores a pair of Points from step"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_PointPair self, Handle_StepGeom_CartesianPoint P1, Handle_StepGeom_CartesianPoint P2) -> StepToTopoDS_PointPair

        :type P1: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
        :type P2: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint

        """
        this = _StepToTopoDS.new_StepToTopoDS_PointPair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_PointPair
StepToTopoDS_PointPair_swigregister = _StepToTopoDS.StepToTopoDS_PointPair_swigregister
StepToTopoDS_PointPair_swigregister(StepToTopoDS_PointPair)

class StepToTopoDS_PointPairHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(StepToTopoDS_PointPair K, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  PointPair

        :type K: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_PointPairHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(StepToTopoDS_PointPair K1, StepToTopoDS_PointPair K2) -> Standard_Boolean

        Returns True  when the two  PointPair are the same

        :type K1: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
        :type K2: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_PointPairHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _StepToTopoDS.new_StepToTopoDS_PointPairHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_PointPairHasher
StepToTopoDS_PointPairHasher_swigregister = _StepToTopoDS.StepToTopoDS_PointPairHasher_swigregister
StepToTopoDS_PointPairHasher_swigregister(StepToTopoDS_PointPairHasher)

def StepToTopoDS_PointPairHasher_HashCode(*args):
    """
    StepToTopoDS_PointPairHasher_HashCode(StepToTopoDS_PointPair K, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  PointPair

    :type K: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _StepToTopoDS.StepToTopoDS_PointPairHasher_HashCode(*args)

def StepToTopoDS_PointPairHasher_IsEqual(*args):
    """
    StepToTopoDS_PointPairHasher_IsEqual(StepToTopoDS_PointPair K1, StepToTopoDS_PointPair K2) -> Standard_Boolean

    Returns True  when the two  PointPair are the same

    :type K1: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
    :type K2: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StepToTopoDS.StepToTopoDS_PointPairHasher_IsEqual(*args)

class StepToTopoDS_GeometricTool(object):
    """
    This class contains some algorithmic services
    specific to the mapping STEP to CAS.CADE
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def PCurve(*args):
        """
        PCurve(Handle_StepGeom_SurfaceCurve SC, Handle_StepGeom_Surface S, Handle_StepGeom_Pcurve PC, Standard_Integer const last=0) -> Standard_Integer

        :type SC: OCC.wrapper.StepGeom.Handle_StepGeom_SurfaceCurve
        :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
        :type PC: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Pcurve
        :type last: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_GeometricTool_PCurve(*args)

    PCurve = staticmethod(PCurve)

    def IsSeamCurve(*args):
        """
        IsSeamCurve(Handle_StepGeom_SurfaceCurve SC, Handle_StepGeom_Surface S, Handle_StepShape_Edge E, Handle_StepShape_EdgeLoop EL) -> Standard_Boolean

        :type SC: OCC.wrapper.StepGeom.Handle_StepGeom_SurfaceCurve
        :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
        :type E: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type EL: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_GeometricTool_IsSeamCurve(*args)

    IsSeamCurve = staticmethod(IsSeamCurve)

    def IsLikeSeam(*args):
        """
        IsLikeSeam(Handle_StepGeom_SurfaceCurve SC, Handle_StepGeom_Surface S, Handle_StepShape_Edge E, Handle_StepShape_EdgeLoop EL) -> Standard_Boolean

        :type SC: OCC.wrapper.StepGeom.Handle_StepGeom_SurfaceCurve
        :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
        :type E: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type EL: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_GeometricTool_IsLikeSeam(*args)

    IsLikeSeam = staticmethod(IsLikeSeam)

    def UpdateParam3d(*args):
        """
        UpdateParam3d(Handle_Geom_Curve C, Standard_Real const preci) -> Standard_Boolean

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type w1: float
        :type w2: float
        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_GeometricTool_UpdateParam3d(*args)

    UpdateParam3d = staticmethod(UpdateParam3d)

    def __init__(self):
        """
        This class contains some algorithmic services
        specific to the mapping STEP to CAS.CADE
        """
        this = _StepToTopoDS.new_StepToTopoDS_GeometricTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_GeometricTool
StepToTopoDS_GeometricTool_swigregister = _StepToTopoDS.StepToTopoDS_GeometricTool_swigregister
StepToTopoDS_GeometricTool_swigregister(StepToTopoDS_GeometricTool)

def StepToTopoDS_GeometricTool_PCurve(*args):
    """
    StepToTopoDS_GeometricTool_PCurve(Handle_StepGeom_SurfaceCurve SC, Handle_StepGeom_Surface S, Handle_StepGeom_Pcurve PC, Standard_Integer const last=0) -> Standard_Integer

    :type SC: OCC.wrapper.StepGeom.Handle_StepGeom_SurfaceCurve
    :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
    :type PC: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Pcurve
    :type last: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _StepToTopoDS.StepToTopoDS_GeometricTool_PCurve(*args)

def StepToTopoDS_GeometricTool_IsSeamCurve(*args):
    """
    StepToTopoDS_GeometricTool_IsSeamCurve(Handle_StepGeom_SurfaceCurve SC, Handle_StepGeom_Surface S, Handle_StepShape_Edge E, Handle_StepShape_EdgeLoop EL) -> Standard_Boolean

    :type SC: OCC.wrapper.StepGeom.Handle_StepGeom_SurfaceCurve
    :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
    :type E: OCC.wrapper.StepShape.Handle_StepShape_Edge
    :type EL: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StepToTopoDS.StepToTopoDS_GeometricTool_IsSeamCurve(*args)

def StepToTopoDS_GeometricTool_IsLikeSeam(*args):
    """
    StepToTopoDS_GeometricTool_IsLikeSeam(Handle_StepGeom_SurfaceCurve SC, Handle_StepGeom_Surface S, Handle_StepShape_Edge E, Handle_StepShape_EdgeLoop EL) -> Standard_Boolean

    :type SC: OCC.wrapper.StepGeom.Handle_StepGeom_SurfaceCurve
    :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
    :type E: OCC.wrapper.StepShape.Handle_StepShape_Edge
    :type EL: OCC.wrapper.StepShape.Handle_StepShape_EdgeLoop
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StepToTopoDS.StepToTopoDS_GeometricTool_IsLikeSeam(*args)

def StepToTopoDS_GeometricTool_UpdateParam3d(*args):
    """
    StepToTopoDS_GeometricTool_UpdateParam3d(Handle_Geom_Curve C, Standard_Real const preci) -> Standard_Boolean

    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :type w1: float
    :type w2: float
    :type preci: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StepToTopoDS.StepToTopoDS_GeometricTool_UpdateParam3d(*args)


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class StepToTopoDS_TranslateEdge(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateEdge self) -> StepToTopoDS_TranslateEdge
        __init__(StepToTopoDS_TranslateEdge self, Handle_StepShape_Edge E, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool) -> StepToTopoDS_TranslateEdge

        :type E: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateEdge self, Handle_StepShape_Edge E, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool)

        :type E: OCC.wrapper.StepShape.Handle_StepShape_Edge
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        return _StepToTopoDS.StepToTopoDS_TranslateEdge_Init(self, *args)


    def MakeFromCurve3D(self, *args):
        """
        MakeFromCurve3D(StepToTopoDS_TranslateEdge self, Handle_StepGeom_Curve C3D, Handle_StepShape_EdgeCurve EC, Handle_StepShape_Vertex Vend, Standard_Real const preci, TopoDS_Edge E, TopoDS_Vertex V1, TopoDS_Vertex V2, StepToTopoDS_Tool T)

        Warning! C3D is assumed to be a Curve 3D ...
        other cases to checked before calling this

        :type C3D: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Curve
        :type EC: OCC.wrapper.StepShape.Handle_StepShape_EdgeCurve
        :type Vend: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type preci: float
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool

        """
        return _StepToTopoDS.StepToTopoDS_TranslateEdge_MakeFromCurve3D(self, *args)


    def MakePCurve(self, *args):
        """
        MakePCurve(StepToTopoDS_TranslateEdge self, Handle_StepGeom_Pcurve PCU, Handle_Geom_Surface ConvSurf) -> Handle_Geom2d_Curve

        :type PCU: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Pcurve
        :type ConvSurf: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _StepToTopoDS.StepToTopoDS_TranslateEdge_MakePCurve(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateEdge_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_TranslateEdge self) -> StepToTopoDS_TranslateEdgeError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateEdgeError

        """
        return _StepToTopoDS.StepToTopoDS_TranslateEdge_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateEdge
StepToTopoDS_TranslateEdge_swigregister = _StepToTopoDS.StepToTopoDS_TranslateEdge_swigregister
StepToTopoDS_TranslateEdge_swigregister(StepToTopoDS_TranslateEdge)

class StepToTopoDS_TranslateCompositeCurve(StepToTopoDS_Root):
    """
    Translate STEP entity composite_curve to TopoDS_Wire
    If surface is given, the curve is assumed to lie on that
    surface and in case if any segment of it is a
    curve_on_surface, the pcurve for that segment will be taken.
    Note: a segment of composite_curve may be itself
    composite_curve. Only one-level protection against
    cyclic references is implemented.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateCompositeCurve self) -> StepToTopoDS_TranslateCompositeCurve
        __init__(StepToTopoDS_TranslateCompositeCurve self, Handle_StepGeom_CompositeCurve CC, Handle_Transfer_TransientProcess TP) -> StepToTopoDS_TranslateCompositeCurve
        __init__(StepToTopoDS_TranslateCompositeCurve self, Handle_StepGeom_CompositeCurve CC, Handle_Transfer_TransientProcess TP, Handle_StepGeom_Surface S, Handle_Geom_Surface Surf) -> StepToTopoDS_TranslateCompositeCurve

        Translates composite_curve lying on surface

        :type CC: OCC.wrapper.StepGeom.Handle_StepGeom_CompositeCurve
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
        :type Surf: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateCompositeCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateCompositeCurve self, Handle_StepGeom_CompositeCurve CC, Handle_Transfer_TransientProcess TP) -> Standard_Boolean
        Init(StepToTopoDS_TranslateCompositeCurve self, Handle_StepGeom_CompositeCurve CC, Handle_Transfer_TransientProcess TP, Handle_StepGeom_Surface S, Handle_Geom_Surface Surf) -> Standard_Boolean

        Translates composite_curve lying on surface

        :type CC: OCC.wrapper.StepGeom.Handle_StepGeom_CompositeCurve
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type S: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
        :type Surf: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_TranslateCompositeCurve_Init(self, *args)


    def Value(self, *args):
        """
        Returns result of last translation or null wire if failed.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateCompositeCurve_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInfiniteSegment(self, *args):
        """
        IsInfiniteSegment(StepToTopoDS_TranslateCompositeCurve self) -> Standard_Boolean

        Returns True if composite_curve contains a segment with infinite parameters.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_TranslateCompositeCurve_IsInfiniteSegment(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateCompositeCurve
StepToTopoDS_TranslateCompositeCurve_swigregister = _StepToTopoDS.StepToTopoDS_TranslateCompositeCurve_swigregister
StepToTopoDS_TranslateCompositeCurve_swigregister(StepToTopoDS_TranslateCompositeCurve)

class NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepRepr_RepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepRepr_RepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepRepr_RepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepRepr_RepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _StepToTopoDS.new_NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepRepr_RepresentationItem theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepRepr_RepresentationItem theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepRepr_RepresentationItem theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepRepr_RepresentationItem theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepRepr_RepresentationItem theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepRepr_RepresentationItem theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepRepr_RepresentationItem theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher
NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_swigregister = _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepToTopoDS.new_NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister = _StepToTopoDS.NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper)


try:
	StepToTopoDS_DataMapOfRI = NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class StepToTopoDS_TranslatePolyLoop(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslatePolyLoop self) -> StepToTopoDS_TranslatePolyLoop
        __init__(StepToTopoDS_TranslatePolyLoop self, Handle_StepShape_PolyLoop PL, StepToTopoDS_Tool T, Handle_Geom_Surface S, TopoDS_Face F) -> StepToTopoDS_TranslatePolyLoop

        :type PL: OCC.wrapper.StepShape.Handle_StepShape_PolyLoop
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslatePolyLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslatePolyLoop self, Handle_StepShape_PolyLoop PL, StepToTopoDS_Tool T, Handle_Geom_Surface S, TopoDS_Face F)

        :type PL: OCC.wrapper.StepShape.Handle_StepShape_PolyLoop
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _StepToTopoDS.StepToTopoDS_TranslatePolyLoop_Init(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_TranslatePolyLoop_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_TranslatePolyLoop self) -> StepToTopoDS_TranslatePolyLoopError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslatePolyLoopError

        """
        return _StepToTopoDS.StepToTopoDS_TranslatePolyLoop_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslatePolyLoop
StepToTopoDS_TranslatePolyLoop_swigregister = _StepToTopoDS.StepToTopoDS_TranslatePolyLoop_swigregister
StepToTopoDS_TranslatePolyLoop_swigregister(StepToTopoDS_TranslatePolyLoop)

class NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,TopoDS_Shape,TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,TopoDS_Shape,TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,TopoDS_Shape,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,TopoDS_Shape,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _StepToTopoDS.new_NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, TCollection_AsciiString theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, TCollection_AsciiString theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, TCollection_AsciiString theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, TCollection_AsciiString theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, TCollection_AsciiString theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_Size(self, *args)


    def __iter__(self):
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString
NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_swigregister = _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_swigregister
NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_swigregister(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString)

class NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepToTopoDS.new_NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper_swigregister = _StepToTopoDS.NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString_IteratorHelper)


try:
	StepToTopoDS_DataMapOfRINames = NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class StepToTopoDS_Tool(object):
    """
    This Tool Class provides Information to build
    a Cas.Cad BRep from a ProSTEP Shape model.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_Tool self) -> StepToTopoDS_Tool
        __init__(StepToTopoDS_Tool self, NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher Map, Handle_Transfer_TransientProcess TP) -> StepToTopoDS_Tool

        :type Map: OCC.wrapper.StepToTopoDS.StepToTopoDS_DataMapOfTRI
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        this = _StepToTopoDS.new_StepToTopoDS_Tool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_Tool self, NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher Map, Handle_Transfer_TransientProcess TP)

        :type Map: OCC.wrapper.StepToTopoDS.StepToTopoDS_DataMapOfTRI
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _StepToTopoDS.StepToTopoDS_Tool_Init(self, *args)


    def IsBound(self, *args):
        """
        IsBound(StepToTopoDS_Tool self, Handle_StepShape_TopologicalRepresentationItem TRI) -> Standard_Boolean

        :type TRI: OCC.wrapper.StepShape.Handle_StepShape_TopologicalRepresentationItem
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_Tool_IsBound(self, *args)


    def Bind(self, *args):
        """
        Bind(StepToTopoDS_Tool self, Handle_StepShape_TopologicalRepresentationItem TRI, TopoDS_Shape S)

        :type TRI: OCC.wrapper.StepShape.Handle_StepShape_TopologicalRepresentationItem
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _StepToTopoDS.StepToTopoDS_Tool_Bind(self, *args)


    def Find(self, *args):
        """
        :type TRI: OCC.wrapper.StepShape.Handle_StepShape_TopologicalRepresentationItem
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_Tool_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClearEdgeMap(self, *args):
        """ClearEdgeMap(StepToTopoDS_Tool self)"""
        return _StepToTopoDS.StepToTopoDS_Tool_ClearEdgeMap(self, *args)


    def IsEdgeBound(self, *args):
        """
        IsEdgeBound(StepToTopoDS_Tool self, StepToTopoDS_PointPair PP) -> Standard_Boolean

        :type PP: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_Tool_IsEdgeBound(self, *args)


    def BindEdge(self, *args):
        """
        BindEdge(StepToTopoDS_Tool self, StepToTopoDS_PointPair PP, TopoDS_Edge E)

        :type PP: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _StepToTopoDS.StepToTopoDS_Tool_BindEdge(self, *args)


    def FindEdge(self, *args):
        """
        :type PP: OCC.wrapper.StepToTopoDS.StepToTopoDS_PointPair
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _StepToTopoDS.StepToTopoDS_Tool_FindEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClearVertexMap(self, *args):
        """ClearVertexMap(StepToTopoDS_Tool self)"""
        return _StepToTopoDS.StepToTopoDS_Tool_ClearVertexMap(self, *args)


    def IsVertexBound(self, *args):
        """
        IsVertexBound(StepToTopoDS_Tool self, Handle_StepGeom_CartesianPoint PG) -> Standard_Boolean

        :type PG: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_Tool_IsVertexBound(self, *args)


    def BindVertex(self, *args):
        """
        BindVertex(StepToTopoDS_Tool self, Handle_StepGeom_CartesianPoint P, TopoDS_Vertex V)

        :type P: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _StepToTopoDS.StepToTopoDS_Tool_BindVertex(self, *args)


    def FindVertex(self, *args):
        """
        :type P: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _StepToTopoDS.StepToTopoDS_Tool_FindVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ComputePCurve(self, *args):
        """
        ComputePCurve(StepToTopoDS_Tool self, Standard_Boolean const B)
        ComputePCurve(StepToTopoDS_Tool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_Tool_ComputePCurve(self, *args)


    def TransientProcess(self, *args):
        """
        TransientProcess(StepToTopoDS_Tool self) -> Handle_Transfer_TransientProcess

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _StepToTopoDS.StepToTopoDS_Tool_TransientProcess(self, *args)


    def AddContinuity(self, *args):
        """
        AddContinuity(StepToTopoDS_Tool self, Handle_Geom_Surface GeomSurf)
        AddContinuity(StepToTopoDS_Tool self, Handle_Geom_Curve GeomCurve)
        AddContinuity(StepToTopoDS_Tool self, Handle_Geom2d_Curve GeomCur2d)

        :type GeomCur2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _StepToTopoDS.StepToTopoDS_Tool_AddContinuity(self, *args)


    def C0Surf(self, *args):
        """
        C0Surf(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C0Surf(self, *args)


    def C1Surf(self, *args):
        """
        C1Surf(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C1Surf(self, *args)


    def C2Surf(self, *args):
        """
        C2Surf(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C2Surf(self, *args)


    def C0Cur2(self, *args):
        """
        C0Cur2(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C0Cur2(self, *args)


    def C1Cur2(self, *args):
        """
        C1Cur2(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C1Cur2(self, *args)


    def C2Cur2(self, *args):
        """
        C2Cur2(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C2Cur2(self, *args)


    def C0Cur3(self, *args):
        """
        C0Cur3(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C0Cur3(self, *args)


    def C1Cur3(self, *args):
        """
        C1Cur3(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C1Cur3(self, *args)


    def C2Cur3(self, *args):
        """
        C2Cur3(StepToTopoDS_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_Tool_C2Cur3(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_Tool
StepToTopoDS_Tool_swigregister = _StepToTopoDS.StepToTopoDS_Tool_swigregister
StepToTopoDS_Tool_swigregister(StepToTopoDS_Tool)

class StepToTopoDS_TranslateShell(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateShell self) -> StepToTopoDS_TranslateShell
        __init__(StepToTopoDS_TranslateShell self, Handle_StepShape_ConnectedFaceSet CFS, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool) -> StepToTopoDS_TranslateShell

        :type CFS: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateShell self, Handle_StepShape_ConnectedFaceSet CFS, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool)

        :type CFS: OCC.wrapper.StepShape.Handle_StepShape_ConnectedFaceSet
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        return _StepToTopoDS.StepToTopoDS_TranslateShell_Init(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateShell_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_TranslateShell self) -> StepToTopoDS_TranslateShellError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateShellError

        """
        return _StepToTopoDS.StepToTopoDS_TranslateShell_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateShell
StepToTopoDS_TranslateShell_swigregister = _StepToTopoDS.StepToTopoDS_TranslateShell_swigregister
StepToTopoDS_TranslateShell_swigregister(StepToTopoDS_TranslateShell)

class StepToTopoDS_TranslateCurveBoundedSurface(StepToTopoDS_Root):
    """Translate curve_bounded_surface into TopoDS_Face"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateCurveBoundedSurface self) -> StepToTopoDS_TranslateCurveBoundedSurface
        __init__(StepToTopoDS_TranslateCurveBoundedSurface self, Handle_StepGeom_CurveBoundedSurface CBS, Handle_Transfer_TransientProcess TP) -> StepToTopoDS_TranslateCurveBoundedSurface

        Translate surface

        :type CBS: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CurveBoundedSurface
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateCurveBoundedSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateCurveBoundedSurface self, Handle_StepGeom_CurveBoundedSurface CBS, Handle_Transfer_TransientProcess TP) -> Standard_Boolean

        Translate surface

        :type CBS: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CurveBoundedSurface
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_TranslateCurveBoundedSurface_Init(self, *args)


    def Value(self, *args):
        """
        Returns result of last translation or null wire if failed.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateCurveBoundedSurface_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateCurveBoundedSurface
StepToTopoDS_TranslateCurveBoundedSurface_swigregister = _StepToTopoDS.StepToTopoDS_TranslateCurveBoundedSurface_swigregister
StepToTopoDS_TranslateCurveBoundedSurface_swigregister(StepToTopoDS_TranslateCurveBoundedSurface)

class StepToTopoDS_TranslateEdgeLoop(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateEdgeLoop self) -> StepToTopoDS_TranslateEdgeLoop
        __init__(StepToTopoDS_TranslateEdgeLoop self, Handle_StepShape_FaceBound FB, TopoDS_Face F, Handle_Geom_Surface S, Handle_StepGeom_Surface SS, Standard_Boolean const ss, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool) -> StepToTopoDS_TranslateEdgeLoop

        :type FB: OCC.wrapper.StepShape.Handle_StepShape_FaceBound
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type SS: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
        :type ss: bool
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateEdgeLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateEdgeLoop self, Handle_StepShape_FaceBound FB, TopoDS_Face F, Handle_Geom_Surface S, Handle_StepGeom_Surface SS, Standard_Boolean const ss, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool)

        :type FB: OCC.wrapper.StepShape.Handle_StepShape_FaceBound
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type SS: OCC.wrapper.StepToTopoDS.Handle_StepGeom_Surface
        :type ss: bool
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        return _StepToTopoDS.StepToTopoDS_TranslateEdgeLoop_Init(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateEdgeLoop_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_TranslateEdgeLoop self) -> StepToTopoDS_TranslateEdgeLoopError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateEdgeLoopError

        """
        return _StepToTopoDS.StepToTopoDS_TranslateEdgeLoop_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateEdgeLoop
StepToTopoDS_TranslateEdgeLoop_swigregister = _StepToTopoDS.StepToTopoDS_TranslateEdgeLoop_swigregister
StepToTopoDS_TranslateEdgeLoop_swigregister(StepToTopoDS_TranslateEdgeLoop)

class StepToTopoDS_(object):
    """
    This package implements the mapping between AP214
    Shape representation and  CAS.CAD Shape Representation.
    The source schema is Part42 (which is included in AP214)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def DecodeBuilderError(*args):
        """
        DecodeBuilderError(StepToTopoDS_BuilderError const Error) -> Handle_TCollection_HAsciiString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_BuilderError
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepToTopoDS.StepToTopoDS__DecodeBuilderError(*args)

    DecodeBuilderError = staticmethod(DecodeBuilderError)

    def DecodeShellError(*args):
        """
        DecodeShellError(StepToTopoDS_TranslateShellError const Error) -> Handle_TCollection_HAsciiString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateShellError
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepToTopoDS.StepToTopoDS__DecodeShellError(*args)

    DecodeShellError = staticmethod(DecodeShellError)

    def DecodeFaceError(*args):
        """
        DecodeFaceError(StepToTopoDS_TranslateFaceError const Error) -> Handle_TCollection_HAsciiString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateFaceError
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepToTopoDS.StepToTopoDS__DecodeFaceError(*args)

    DecodeFaceError = staticmethod(DecodeFaceError)

    def DecodeEdgeError(*args):
        """
        DecodeEdgeError(StepToTopoDS_TranslateEdgeError const Error) -> Handle_TCollection_HAsciiString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateEdgeError
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepToTopoDS.StepToTopoDS__DecodeEdgeError(*args)

    DecodeEdgeError = staticmethod(DecodeEdgeError)

    def DecodeVertexError(*args):
        """
        DecodeVertexError(StepToTopoDS_TranslateVertexError const Error) -> Handle_TCollection_HAsciiString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateVertexError
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepToTopoDS.StepToTopoDS__DecodeVertexError(*args)

    DecodeVertexError = staticmethod(DecodeVertexError)

    def DecodeVertexLoopError(*args):
        """
        DecodeVertexLoopError(StepToTopoDS_TranslateVertexLoopError const Error) -> Handle_TCollection_HAsciiString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateVertexLoopError
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepToTopoDS.StepToTopoDS__DecodeVertexLoopError(*args)

    DecodeVertexLoopError = staticmethod(DecodeVertexLoopError)

    def DecodePolyLoopError(*args):
        """
        DecodePolyLoopError(StepToTopoDS_TranslatePolyLoopError const Error) -> Handle_TCollection_HAsciiString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslatePolyLoopError
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepToTopoDS.StepToTopoDS__DecodePolyLoopError(*args)

    DecodePolyLoopError = staticmethod(DecodePolyLoopError)

    def DecodeGeometricToolError(*args):
        """
        DecodeGeometricToolError(StepToTopoDS_GeometricToolError const Error) -> Standard_CString

        :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_GeometricToolError
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepToTopoDS.StepToTopoDS__DecodeGeometricToolError(*args)

    DecodeGeometricToolError = staticmethod(DecodeGeometricToolError)

    def __init__(self):
        """
        This package implements the mapping between AP214
        Shape representation and  CAS.CAD Shape Representation.
        The source schema is Part42 (which is included in AP214)
        """
        this = _StepToTopoDS.new_StepToTopoDS_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_
StepToTopoDS__swigregister = _StepToTopoDS.StepToTopoDS__swigregister
StepToTopoDS__swigregister(StepToTopoDS_)

def StepToTopoDS__DecodeBuilderError(*args):
    """
    StepToTopoDS__DecodeBuilderError(StepToTopoDS_BuilderError const Error) -> Handle_TCollection_HAsciiString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_BuilderError
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _StepToTopoDS.StepToTopoDS__DecodeBuilderError(*args)

def StepToTopoDS__DecodeShellError(*args):
    """
    StepToTopoDS__DecodeShellError(StepToTopoDS_TranslateShellError const Error) -> Handle_TCollection_HAsciiString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateShellError
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _StepToTopoDS.StepToTopoDS__DecodeShellError(*args)

def StepToTopoDS__DecodeFaceError(*args):
    """
    StepToTopoDS__DecodeFaceError(StepToTopoDS_TranslateFaceError const Error) -> Handle_TCollection_HAsciiString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateFaceError
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _StepToTopoDS.StepToTopoDS__DecodeFaceError(*args)

def StepToTopoDS__DecodeEdgeError(*args):
    """
    StepToTopoDS__DecodeEdgeError(StepToTopoDS_TranslateEdgeError const Error) -> Handle_TCollection_HAsciiString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateEdgeError
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _StepToTopoDS.StepToTopoDS__DecodeEdgeError(*args)

def StepToTopoDS__DecodeVertexError(*args):
    """
    StepToTopoDS__DecodeVertexError(StepToTopoDS_TranslateVertexError const Error) -> Handle_TCollection_HAsciiString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateVertexError
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _StepToTopoDS.StepToTopoDS__DecodeVertexError(*args)

def StepToTopoDS__DecodeVertexLoopError(*args):
    """
    StepToTopoDS__DecodeVertexLoopError(StepToTopoDS_TranslateVertexLoopError const Error) -> Handle_TCollection_HAsciiString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateVertexLoopError
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _StepToTopoDS.StepToTopoDS__DecodeVertexLoopError(*args)

def StepToTopoDS__DecodePolyLoopError(*args):
    """
    StepToTopoDS__DecodePolyLoopError(StepToTopoDS_TranslatePolyLoopError const Error) -> Handle_TCollection_HAsciiString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslatePolyLoopError
    :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

    """
    return _StepToTopoDS.StepToTopoDS__DecodePolyLoopError(*args)

def StepToTopoDS__DecodeGeometricToolError(*args):
    """
    StepToTopoDS__DecodeGeometricToolError(StepToTopoDS_GeometricToolError const Error) -> Standard_CString

    :type Error: OCC.wrapper.StepToTopoDS.StepToTopoDS_GeometricToolError
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _StepToTopoDS.StepToTopoDS__DecodeGeometricToolError(*args)

class NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self) -> NCollection_DataMap< StepToTopoDS_PointPair,TopoDS_Edge,StepToTopoDS_PointPairHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self) -> NCollection_DataMap< StepToTopoDS_PointPair,TopoDS_Edge,StepToTopoDS_PointPairHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self) -> NCollection_DataMap< StepToTopoDS_PointPair,TopoDS_Edge,StepToTopoDS_PointPairHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self) -> NCollection_DataMap< StepToTopoDS_PointPair,TopoDS_Edge,StepToTopoDS_PointPairHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _StepToTopoDS.new_NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher theOther) -> NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher theOther) -> NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, StepToTopoDS_PointPair theKey, TopoDS_Edge theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, StepToTopoDS_PointPair theKey, TopoDS_Edge theItem) -> TopoDS_Edge

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, StepToTopoDS_PointPair theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, StepToTopoDS_PointPair theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, StepToTopoDS_PointPair theKey) -> TopoDS_Edge

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, StepToTopoDS_PointPair theKey) -> TopoDS_Edge

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, StepToTopoDS_PointPair theKey) -> TopoDS_Edge

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_Size(self, *args)


    def __iter__(self):
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher___iter__(self)
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher
NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_swigregister = _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_swigregister
NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_swigregister(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher)

class NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepToTopoDS.new_NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper

    def __next__(self):
        return _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper___next__(self)
NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper_swigregister = _StepToTopoDS.NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper_swigregister
NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper_swigregister(NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher_IteratorHelper)


try:
	StepToTopoDS_PointEdgeMap = NCollection_DataMap_StepToTopoDS_PointPair_TopoDS_Edge_StepToTopoDS_PointPairHasher
except NameError:
	pass # does not exist, probably ignored

class StepToTopoDS_TranslateVertexLoop(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateVertexLoop self) -> StepToTopoDS_TranslateVertexLoop
        __init__(StepToTopoDS_TranslateVertexLoop self, Handle_StepShape_VertexLoop VL, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool) -> StepToTopoDS_TranslateVertexLoop

        :type VL: OCC.wrapper.StepShape.Handle_StepShape_VertexLoop
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateVertexLoop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateVertexLoop self, Handle_StepShape_VertexLoop VL, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool)

        :type VL: OCC.wrapper.StepShape.Handle_StepShape_VertexLoop
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        return _StepToTopoDS.StepToTopoDS_TranslateVertexLoop_Init(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateVertexLoop_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_TranslateVertexLoop self) -> StepToTopoDS_TranslateVertexLoopError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateVertexLoopError

        """
        return _StepToTopoDS.StepToTopoDS_TranslateVertexLoop_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateVertexLoop
StepToTopoDS_TranslateVertexLoop_swigregister = _StepToTopoDS.StepToTopoDS_TranslateVertexLoop_swigregister
StepToTopoDS_TranslateVertexLoop_swigregister(StepToTopoDS_TranslateVertexLoop)

class StepToTopoDS_TranslateFace(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateFace self) -> StepToTopoDS_TranslateFace
        __init__(StepToTopoDS_TranslateFace self, Handle_StepShape_FaceSurface FS, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool) -> StepToTopoDS_TranslateFace

        :type FS: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateFace self, Handle_StepShape_FaceSurface FS, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool)

        :type FS: OCC.wrapper.StepShape.Handle_StepShape_FaceSurface
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        return _StepToTopoDS.StepToTopoDS_TranslateFace_Init(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateFace_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_TranslateFace self) -> StepToTopoDS_TranslateFaceError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateFaceError

        """
        return _StepToTopoDS.StepToTopoDS_TranslateFace_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateFace
StepToTopoDS_TranslateFace_swigregister = _StepToTopoDS.StepToTopoDS_TranslateFace_swigregister
StepToTopoDS_TranslateFace_swigregister(StepToTopoDS_TranslateFace)

class StepToTopoDS_MakeTransformed(StepToTopoDS_Root):
    """Produces instances by Transformation of a basic item"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_MakeTransformed self) -> StepToTopoDS_MakeTransformed

        Produces instances by Transformation of a basic item
        """
        this = _StepToTopoDS.new_StepToTopoDS_MakeTransformed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Compute(self, *args):
        """
        Compute(StepToTopoDS_MakeTransformed self, Handle_StepGeom_Axis2Placement3d Origin, Handle_StepGeom_Axis2Placement3d Target) -> Standard_Boolean
        Compute(StepToTopoDS_MakeTransformed self, Handle_StepGeom_CartesianTransformationOperator3d Operator) -> Standard_Boolean

        Computes a transformation defined by an operator 3D

        :type Operator: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianTransformationOperator3d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_MakeTransformed_Compute(self, *args)


    def Transformation(self, *args):
        """
        Returns the computed transformation (Identity if not yet or
        if failed)

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _StepToTopoDS.StepToTopoDS_MakeTransformed_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transform(self, *args):
        """
        Transform(StepToTopoDS_MakeTransformed self, TopoDS_Shape shape) -> Standard_Boolean

        Applies the computed transformation to a shape
        Returns False if the transformation is Identity

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_MakeTransformed_Transform(self, *args)


    def TranslateMappedItem(self, *args):
        """
        TranslateMappedItem(StepToTopoDS_MakeTransformed self, Handle_StepRepr_MappedItem mapit, Handle_Transfer_TransientProcess TP) -> TopoDS_Shape

        Translates a MappedItem. More precisely
        A MappedItem has a MappingSource and a MappingTarget
        MappingSource has a MappedRepresentation and a MappingOrigin
        MappedRepresentation is the basic item to be instanced
        MappingOrigin is the starting placement
        MappingTarget is the final placement

        Hence, the transformation from MappingOrigin and MappingTarget
        is computed, the MappedRepr. is converted to a Shape, then
        transformed as an instance of this Shape

        :type mapit: OCC.wrapper.StepRepr.Handle_StepRepr_MappedItem
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _StepToTopoDS.StepToTopoDS_MakeTransformed_TranslateMappedItem(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_MakeTransformed
StepToTopoDS_MakeTransformed_swigregister = _StepToTopoDS.StepToTopoDS_MakeTransformed_swigregister
StepToTopoDS_MakeTransformed_swigregister(StepToTopoDS_MakeTransformed)

class StepToTopoDS_CartesianPointHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(Handle_StepGeom_CartesianPoint K, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  CartesianPoint

        :type K: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.StepToTopoDS_CartesianPointHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Handle_StepGeom_CartesianPoint K1, Handle_StepGeom_CartesianPoint K2) -> Standard_Boolean

        Returns True  when the two  CartesianPoint are the same

        :type K1: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
        :type K2: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_CartesianPointHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _StepToTopoDS.new_StepToTopoDS_CartesianPointHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_CartesianPointHasher
StepToTopoDS_CartesianPointHasher_swigregister = _StepToTopoDS.StepToTopoDS_CartesianPointHasher_swigregister
StepToTopoDS_CartesianPointHasher_swigregister(StepToTopoDS_CartesianPointHasher)

def StepToTopoDS_CartesianPointHasher_HashCode(*args):
    """
    StepToTopoDS_CartesianPointHasher_HashCode(Handle_StepGeom_CartesianPoint K, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  CartesianPoint

    :type K: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _StepToTopoDS.StepToTopoDS_CartesianPointHasher_HashCode(*args)

def StepToTopoDS_CartesianPointHasher_IsEqual(*args):
    """
    StepToTopoDS_CartesianPointHasher_IsEqual(Handle_StepGeom_CartesianPoint K1, Handle_StepGeom_CartesianPoint K2) -> Standard_Boolean

    Returns True  when the two  CartesianPoint are the same

    :type K1: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
    :type K2: OCC.wrapper.StepToTopoDS.Handle_StepGeom_CartesianPoint
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StepToTopoDS.StepToTopoDS_CartesianPointHasher_IsEqual(*args)

class StepToTopoDS_Builder(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_Builder self) -> StepToTopoDS_Builder
        __init__(StepToTopoDS_Builder self, Handle_StepShape_ManifoldSolidBrep S, Handle_Transfer_TransientProcess TP) -> StepToTopoDS_Builder
        __init__(StepToTopoDS_Builder self, Handle_StepShape_BrepWithVoids S, Handle_Transfer_TransientProcess TP) -> StepToTopoDS_Builder
        __init__(StepToTopoDS_Builder self, Handle_StepShape_FacetedBrep S, Handle_Transfer_TransientProcess TP) -> StepToTopoDS_Builder
        __init__(StepToTopoDS_Builder self, Handle_StepShape_FacetedBrepAndBrepWithVoids S, Handle_Transfer_TransientProcess TP) -> StepToTopoDS_Builder
        __init__(StepToTopoDS_Builder self, Handle_StepShape_ShellBasedSurfaceModel S, Handle_Transfer_TransientProcess TP, StepToTopoDS_NMTool NMTool) -> StepToTopoDS_Builder

        :type S: OCC.wrapper.StepShape.Handle_StepShape_ShellBasedSurfaceModel
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        this = _StepToTopoDS.new_StepToTopoDS_Builder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_Builder self, Handle_StepShape_ManifoldSolidBrep S, Handle_Transfer_TransientProcess TP)
        Init(StepToTopoDS_Builder self, Handle_StepShape_BrepWithVoids S, Handle_Transfer_TransientProcess TP)
        Init(StepToTopoDS_Builder self, Handle_StepShape_FacetedBrep S, Handle_Transfer_TransientProcess TP)
        Init(StepToTopoDS_Builder self, Handle_StepShape_FacetedBrepAndBrepWithVoids S, Handle_Transfer_TransientProcess TP)
        Init(StepToTopoDS_Builder self, Handle_StepShape_ShellBasedSurfaceModel S, Handle_Transfer_TransientProcess TP, StepToTopoDS_NMTool NMTool)
        Init(StepToTopoDS_Builder self, Handle_StepShape_EdgeBasedWireframeModel S, Handle_Transfer_TransientProcess TP)
        Init(StepToTopoDS_Builder self, Handle_StepShape_FaceBasedSurfaceModel S, Handle_Transfer_TransientProcess TP)
        Init(StepToTopoDS_Builder self, Handle_StepShape_GeometricSet S, Handle_Transfer_TransientProcess TP, Handle_Transfer_ActorOfTransientProcess RA=0, Standard_Boolean const isManifold)

        :type S: OCC.wrapper.StepShape.Handle_StepShape_GeometricSet
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type RA: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess
        :type isManifold: bool

        """
        return _StepToTopoDS.StepToTopoDS_Builder_Init(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_Builder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_Builder self) -> StepToTopoDS_BuilderError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_BuilderError

        """
        return _StepToTopoDS.StepToTopoDS_Builder_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_Builder
StepToTopoDS_Builder_swigregister = _StepToTopoDS.StepToTopoDS_Builder_swigregister
StepToTopoDS_Builder_swigregister(StepToTopoDS_Builder)

class NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_TopologicalRepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_TopologicalRepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_TopologicalRepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< StepShape_TopologicalRepresentationItem >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _StepToTopoDS.new_NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepShape_TopologicalRepresentationItem theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepShape_TopologicalRepresentationItem theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepShape_TopologicalRepresentationItem theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepShape_TopologicalRepresentationItem theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepShape_TopologicalRepresentationItem theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepShape_TopologicalRepresentationItem theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_StepShape_TopologicalRepresentationItem theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher
NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_swigregister = _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepToTopoDS.new_NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister = _StepToTopoDS.NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper)


try:
	StepToTopoDS_DataMapOfTRI = NCollection_DataMap_Handle_StepShape_TopologicalRepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class StepToTopoDS_TranslateVertex(StepToTopoDS_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_TranslateVertex self) -> StepToTopoDS_TranslateVertex
        __init__(StepToTopoDS_TranslateVertex self, Handle_StepShape_Vertex V, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool) -> StepToTopoDS_TranslateVertex

        :type V: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        this = _StepToTopoDS.new_StepToTopoDS_TranslateVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_TranslateVertex self, Handle_StepShape_Vertex V, StepToTopoDS_Tool T, StepToTopoDS_NMTool NMTool)

        :type V: OCC.wrapper.StepShape.Handle_StepShape_Vertex
        :type T: OCC.wrapper.StepToTopoDS.StepToTopoDS_Tool
        :type NMTool: OCC.wrapper.StepToTopoDS.StepToTopoDS_NMTool

        """
        return _StepToTopoDS.StepToTopoDS_TranslateVertex_Init(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_TranslateVertex_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(StepToTopoDS_TranslateVertex self) -> StepToTopoDS_TranslateVertexError

        :rtype: OCC.wrapper.StepToTopoDS.StepToTopoDS_TranslateVertexError

        """
        return _StepToTopoDS.StepToTopoDS_TranslateVertex_Error(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_TranslateVertex
StepToTopoDS_TranslateVertex_swigregister = _StepToTopoDS.StepToTopoDS_TranslateVertex_swigregister
StepToTopoDS_TranslateVertex_swigregister(StepToTopoDS_TranslateVertex)

class StepToTopoDS_NMTool(object):
    """
    Provides data to process non-manifold topology when
    reading from STEP.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepToTopoDS_NMTool self) -> StepToTopoDS_NMTool
        __init__(StepToTopoDS_NMTool self, NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher MapOfRI, NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString MapOfRINames) -> StepToTopoDS_NMTool

        :type MapOfRI: OCC.wrapper.StepToTopoDS.StepToTopoDS_DataMapOfRI
        :type MapOfRINames: OCC.wrapper.StepToTopoDS.StepToTopoDS_DataMapOfRINames

        """
        this = _StepToTopoDS.new_StepToTopoDS_NMTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(StepToTopoDS_NMTool self, NCollection_DataMap_Handle_StepRepr_RepresentationItem_TopoDS_Shape_TColStd_MapTransientHasher MapOfRI, NCollection_DataMap_TCollection_AsciiString_TopoDS_Shape_TCollection_AsciiString MapOfRINames)

        :type MapOfRI: OCC.wrapper.StepToTopoDS.StepToTopoDS_DataMapOfRI
        :type MapOfRINames: OCC.wrapper.StepToTopoDS.StepToTopoDS_DataMapOfRINames

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_Init(self, *args)


    def SetActive(self, *args):
        """
        SetActive(StepToTopoDS_NMTool self, Standard_Boolean const isActive)

        :type isActive: bool

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_SetActive(self, *args)


    def IsActive(self, *args):
        """
        IsActive(StepToTopoDS_NMTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_IsActive(self, *args)


    def CleanUp(self, *args):
        """CleanUp(StepToTopoDS_NMTool self)"""
        return _StepToTopoDS.StepToTopoDS_NMTool_CleanUp(self, *args)


    def IsBound(self, *args):
        """
        IsBound(StepToTopoDS_NMTool self, Handle_StepRepr_RepresentationItem RI) -> Standard_Boolean
        IsBound(StepToTopoDS_NMTool self, TCollection_AsciiString RIName) -> Standard_Boolean

        :type RIName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_IsBound(self, *args)


    def Bind(self, *args):
        """
        Bind(StepToTopoDS_NMTool self, Handle_StepRepr_RepresentationItem RI, TopoDS_Shape S)
        Bind(StepToTopoDS_NMTool self, TCollection_AsciiString RIName, TopoDS_Shape S)

        :type RIName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_Bind(self, *args)


    def Find(self, *args):
        """
        :type RIName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _StepToTopoDS.StepToTopoDS_NMTool_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RegisterNMEdge(self, *args):
        """
        RegisterNMEdge(StepToTopoDS_NMTool self, TopoDS_Shape Edge)

        :type Edge: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_RegisterNMEdge(self, *args)


    def IsSuspectedAsClosing(self, *args):
        """
        IsSuspectedAsClosing(StepToTopoDS_NMTool self, TopoDS_Shape BaseShell, TopoDS_Shape SuspectedShell) -> Standard_Boolean

        :type BaseShell: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SuspectedShell: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_IsSuspectedAsClosing(self, *args)


    def IsPureNMShell(self, *args):
        """
        IsPureNMShell(StepToTopoDS_NMTool self, TopoDS_Shape Shell) -> Standard_Boolean

        :type Shell: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_IsPureNMShell(self, *args)


    def SetIDEASCase(self, *args):
        """
        SetIDEASCase(StepToTopoDS_NMTool self, Standard_Boolean const IDEASCase)

        :type IDEASCase: bool

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_SetIDEASCase(self, *args)


    def IsIDEASCase(self, *args):
        """
        IsIDEASCase(StepToTopoDS_NMTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.StepToTopoDS_NMTool_IsIDEASCase(self, *args)

    __swig_destroy__ = _StepToTopoDS.delete_StepToTopoDS_NMTool
StepToTopoDS_NMTool_swigregister = _StepToTopoDS.StepToTopoDS_NMTool_swigregister
StepToTopoDS_NMTool_swigregister(StepToTopoDS_NMTool)

class NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self) -> NCollection_DataMap< opencascade::handle< StepGeom_CartesianPoint >,TopoDS_Vertex,StepToTopoDS_CartesianPointHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self) -> NCollection_DataMap< opencascade::handle< StepGeom_CartesianPoint >,TopoDS_Vertex,StepToTopoDS_CartesianPointHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self) -> NCollection_DataMap< opencascade::handle< StepGeom_CartesianPoint >,TopoDS_Vertex,StepToTopoDS_CartesianPointHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self) -> NCollection_DataMap< opencascade::handle< StepGeom_CartesianPoint >,TopoDS_Vertex,StepToTopoDS_CartesianPointHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _StepToTopoDS.new_NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher theOther) -> NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher theOther) -> NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_StepGeom_CartesianPoint theKey, TopoDS_Vertex theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_StepGeom_CartesianPoint theKey, TopoDS_Vertex theItem) -> TopoDS_Vertex

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_StepGeom_CartesianPoint theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_StepGeom_CartesianPoint theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_StepGeom_CartesianPoint theKey) -> TopoDS_Vertex

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_StepGeom_CartesianPoint theKey) -> TopoDS_Vertex

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_StepGeom_CartesianPoint theKey) -> TopoDS_Vertex

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_Size(self, *args)


    def __iter__(self):
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher___iter__(self)
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher
NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_swigregister = _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_swigregister
NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_swigregister(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher)

class NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepToTopoDS.new_NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepToTopoDS.delete_NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper

    def __next__(self):
        return _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper_swigregister = _StepToTopoDS.NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher_IteratorHelper)


try:
	StepToTopoDS_PointVertexMap = NCollection_DataMap_Handle_StepGeom_CartesianPoint_TopoDS_Vertex_StepToTopoDS_CartesianPointHasher
except NameError:
	pass # does not exist, probably ignored




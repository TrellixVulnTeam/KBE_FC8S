# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_STEPSelections')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_STEPSelections')
    _STEPSelections = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_STEPSelections', [dirname(__file__)])
        except ImportError:
            import _STEPSelections
            return _STEPSelections
        try:
            _mod = imp.load_module('_STEPSelections', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _STEPSelections = swig_import_helper()
    del swig_import_helper
else:
    import _STEPSelections
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _STEPSelections.delete_SwigPyIterator

    def value(self):
        return _STEPSelections.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _STEPSelections.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _STEPSelections.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _STEPSelections.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _STEPSelections.SwigPyIterator_equal(self, x)

    def copy(self):
        return _STEPSelections.SwigPyIterator_copy(self)

    def next(self):
        return _STEPSelections.SwigPyIterator_next(self)

    def __next__(self):
        return _STEPSelections.SwigPyIterator___next__(self)

    def previous(self):
        return _STEPSelections.SwigPyIterator_previous(self)

    def advance(self, n):
        return _STEPSelections.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _STEPSelections.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _STEPSelections.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _STEPSelections.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _STEPSelections.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _STEPSelections.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _STEPSelections.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _STEPSelections.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPSelections.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_STEPSelections.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPSelections.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPSelections.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPSelections.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _STEPSelections.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _STEPSelections.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _STEPSelections.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPSelections.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_STEPSelections.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPSelections.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPSelections.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPSelections.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _STEPSelections.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _STEPSelections.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _STEPSelections.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _STEPSelections.ptr_to_number(item)
ptr_to_number = _STEPSelections.ptr_to_number

def HashCode(*args):
    return _STEPSelections.HashCode(*args)
HashCode = _STEPSelections.HashCode

def ptr_equal(a, b):
    return _STEPSelections.ptr_equal(a, b)
ptr_equal = _STEPSelections.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepShape
else:
    import StepShape
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepSelect
else:
    import StepSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFSelect
else:
    import IFSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XSControl
else:
    import XSControl
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Transfer
else:
    import Transfer
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
class STEPSelections_SelectInstances(IFSelect.IFSelect_SelectExplore):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_SelectInstances
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_SelectInstances(self) 
            return h


    def __init__(self, *args):
        """__init__(STEPSelections_SelectInstances self) -> STEPSelections_SelectInstances"""
        this = _STEPSelections.new_STEPSelections_SelectInstances(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(STEPSelections_SelectInstances self, Interface_Graph G) -> Interface_EntityIterator

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.STEPSelections_SelectInstances_RootResult(self, *args)


    def Explore(self, *args):
        """
        Explore(STEPSelections_SelectInstances self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.STEPSelections_SelectInstances_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(STEPSelections_SelectInstances self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Instances"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.STEPSelections_SelectInstances_ExploreLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_SelectInstances_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_SelectInstances_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_SelectInstances_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_SelectInstances
STEPSelections_SelectInstances_swigregister = _STEPSelections.STEPSelections_SelectInstances_swigregister
STEPSelections_SelectInstances_swigregister(STEPSelections_SelectInstances)

def STEPSelections_SelectInstances_get_type_name(*args):
    """
    STEPSelections_SelectInstances_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_SelectInstances_get_type_name(*args)

def STEPSelections_SelectInstances_get_type_descriptor(*args):
    """
    STEPSelections_SelectInstances_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_SelectInstances_get_type_descriptor(*args)

class Handle_STEPSelections_SelectInstances(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_SelectInstances self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_SelectInstances self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_SelectInstances self, STEPSelections_SelectInstances thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_SelectInstances self, Handle_STEPSelections_SelectInstances theHandle) -> Handle_STEPSelections_SelectInstances
        assign(Handle_STEPSelections_SelectInstances self, STEPSelections_SelectInstances thePtr) -> Handle_STEPSelections_SelectInstances
        assign(Handle_STEPSelections_SelectInstances self, Handle_STEPSelections_SelectInstances theHandle) -> Handle_STEPSelections_SelectInstances

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_SelectInstances self) -> STEPSelections_SelectInstances

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_SelectInstances self) -> STEPSelections_SelectInstances

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_SelectInstances self) -> STEPSelections_SelectInstances

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_SelectInstances___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_SelectInstances___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_SelectInstances(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_SelectInstances_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_SelectInstances

    def RootResult(self, *args):
        """
        RootResult(Handle_STEPSelections_SelectInstances self, Interface_Graph G) -> Interface_EntityIterator

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_RootResult(self, *args)


    def Explore(self, *args):
        """
        Explore(Handle_STEPSelections_SelectInstances self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_STEPSelections_SelectInstances self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Instances"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_ExploreLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_SelectInstances self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectInstances_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectInstances_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Level(self, *args):
        """
        Level(Handle_STEPSelections_SelectInstances self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_Level(self, *args)


    def Label(self, *args):
        """
        Label(Handle_STEPSelections_SelectInstances self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_STEPSelections_SelectInstances self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_STEPSelections_SelectInstances self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_STEPSelections_SelectInstances self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_STEPSelections_SelectInstances self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_STEPSelections_SelectInstances self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_STEPSelections_SelectInstances self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_STEPSelections_SelectInstances self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_STEPSelections_SelectInstances self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_STEPSelections_SelectInstances self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_SelectInstances self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_SelectInstances self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_SelectInstances self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_SelectInstances self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_SelectInstances self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_SelectInstances self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_SelectInstances self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_SelectInstances self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_SelectInstances self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectInstances_DecrementRefCounter(self, *args)

Handle_STEPSelections_SelectInstances_swigregister = _STEPSelections.Handle_STEPSelections_SelectInstances_swigregister
Handle_STEPSelections_SelectInstances_swigregister(Handle_STEPSelections_SelectInstances)

def Handle_STEPSelections_SelectInstances_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_SelectInstances_DownCast(thing)
Handle_STEPSelections_SelectInstances_DownCast = _STEPSelections.Handle_STEPSelections_SelectInstances_DownCast

class STEPSelections_SelectAssembly(IFSelect.IFSelect_SelectExplore):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_SelectAssembly
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_SelectAssembly(self) 
            return h


    def __init__(self, *args):
        """__init__(STEPSelections_SelectAssembly self) -> STEPSelections_SelectAssembly"""
        this = _STEPSelections.new_STEPSelections_SelectAssembly(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Explore(self, *args):
        """
        Explore(STEPSelections_SelectAssembly self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity, to take its faces
        Works recursively

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.STEPSelections_SelectAssembly_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(STEPSelections_SelectAssembly self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Assembly structures"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.STEPSelections_SelectAssembly_ExploreLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_SelectAssembly_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_SelectAssembly_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_SelectAssembly_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_SelectAssembly
STEPSelections_SelectAssembly_swigregister = _STEPSelections.STEPSelections_SelectAssembly_swigregister
STEPSelections_SelectAssembly_swigregister(STEPSelections_SelectAssembly)

def STEPSelections_SelectAssembly_get_type_name(*args):
    """
    STEPSelections_SelectAssembly_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_SelectAssembly_get_type_name(*args)

def STEPSelections_SelectAssembly_get_type_descriptor(*args):
    """
    STEPSelections_SelectAssembly_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_SelectAssembly_get_type_descriptor(*args)

class STEPSelections_SelectDerived(StepSelect.StepSelect_StepType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_SelectDerived
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_SelectDerived(self) 
            return h


    def __init__(self, *args):
        """__init__(STEPSelections_SelectDerived self) -> STEPSelections_SelectDerived"""
        this = _STEPSelections.new_STEPSelections_SelectDerived(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Matches(self, *args):
        """
        Matches(STEPSelections_SelectDerived self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.STEPSelections_SelectDerived_Matches(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_SelectDerived_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_SelectDerived_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_SelectDerived_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_SelectDerived
STEPSelections_SelectDerived_swigregister = _STEPSelections.STEPSelections_SelectDerived_swigregister
STEPSelections_SelectDerived_swigregister(STEPSelections_SelectDerived)

def STEPSelections_SelectDerived_get_type_name(*args):
    """
    STEPSelections_SelectDerived_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_SelectDerived_get_type_name(*args)

def STEPSelections_SelectDerived_get_type_descriptor(*args):
    """
    STEPSelections_SelectDerived_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_SelectDerived_get_type_descriptor(*args)

class STEPSelections_SelectForTransfer(XSControl.XSControl_SelectForTransfer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_SelectForTransfer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_SelectForTransfer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPSelections_SelectForTransfer self) -> STEPSelections_SelectForTransfer
        __init__(STEPSelections_SelectForTransfer self, Handle_XSControl_TransferReader TR) -> STEPSelections_SelectForTransfer

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        this = _STEPSelections.new_STEPSelections_SelectForTransfer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def RootResult(self, *args):
        """
        RootResult(STEPSelections_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.STEPSelections_SelectForTransfer_RootResult(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_SelectForTransfer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_SelectForTransfer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_SelectForTransfer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_SelectForTransfer
STEPSelections_SelectForTransfer_swigregister = _STEPSelections.STEPSelections_SelectForTransfer_swigregister
STEPSelections_SelectForTransfer_swigregister(STEPSelections_SelectForTransfer)

def STEPSelections_SelectForTransfer_get_type_name(*args):
    """
    STEPSelections_SelectForTransfer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_SelectForTransfer_get_type_name(*args)

def STEPSelections_SelectForTransfer_get_type_descriptor(*args):
    """
    STEPSelections_SelectForTransfer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_SelectForTransfer_get_type_descriptor(*args)

class STEPSelections_AssemblyLink(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_AssemblyLink
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_AssemblyLink(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPSelections_AssemblyLink self) -> STEPSelections_AssemblyLink
        __init__(STEPSelections_AssemblyLink self, Handle_StepRepr_NextAssemblyUsageOccurrence nauo, Handle_Standard_Transient item, Handle_STEPSelections_AssemblyComponent part) -> STEPSelections_AssemblyLink

        :type nauo: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence
        :type item: OCC.wrapper.Standard.Handle_Standard_Transient
        :type part: OCC.wrapper.STEPSelections.Handle_STEPSelections_AssemblyComponent

        """
        this = _STEPSelections.new_STEPSelections_AssemblyLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetNAUO(self, *args):
        """
        GetNAUO(STEPSelections_AssemblyLink self) -> Handle_StepRepr_NextAssemblyUsageOccurrence

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPSelections.STEPSelections_AssemblyLink_GetNAUO(self, *args)


    def GetItem(self, *args):
        """
        GetItem(STEPSelections_AssemblyLink self) -> Handle_Standard_Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPSelections.STEPSelections_AssemblyLink_GetItem(self, *args)


    def GetComponent(self, *args):
        """
        GetComponent(STEPSelections_AssemblyLink self) -> Handle_STEPSelections_AssemblyComponent

        :rtype: OCC.wrapper.STEPSelections.Handle_STEPSelections_AssemblyComponent

        """
        return _STEPSelections.STEPSelections_AssemblyLink_GetComponent(self, *args)


    def SetNAUO(self, *args):
        """
        SetNAUO(STEPSelections_AssemblyLink self, Handle_StepRepr_NextAssemblyUsageOccurrence nauo)

        :type nauo: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPSelections.STEPSelections_AssemblyLink_SetNAUO(self, *args)


    def SetItem(self, *args):
        """
        SetItem(STEPSelections_AssemblyLink self, Handle_Standard_Transient item)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPSelections.STEPSelections_AssemblyLink_SetItem(self, *args)


    def SetComponent(self, *args):
        """
        SetComponent(STEPSelections_AssemblyLink self, Handle_STEPSelections_AssemblyComponent part)

        :type part: OCC.wrapper.STEPSelections.Handle_STEPSelections_AssemblyComponent

        """
        return _STEPSelections.STEPSelections_AssemblyLink_SetComponent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_AssemblyLink_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_AssemblyLink_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_AssemblyLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_AssemblyLink
STEPSelections_AssemblyLink_swigregister = _STEPSelections.STEPSelections_AssemblyLink_swigregister
STEPSelections_AssemblyLink_swigregister(STEPSelections_AssemblyLink)

def STEPSelections_AssemblyLink_get_type_name(*args):
    """
    STEPSelections_AssemblyLink_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_AssemblyLink_get_type_name(*args)

def STEPSelections_AssemblyLink_get_type_descriptor(*args):
    """
    STEPSelections_AssemblyLink_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_AssemblyLink_get_type_descriptor(*args)

class STEPSelections_AssemblyComponent(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_AssemblyComponent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_AssemblyComponent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPSelections_AssemblyComponent self) -> STEPSelections_AssemblyComponent
        __init__(STEPSelections_AssemblyComponent self, Handle_StepShape_ShapeDefinitionRepresentation sdr, Handle_STEPSelections_HSequenceOfAssemblyLink list) -> STEPSelections_AssemblyComponent

        :type sdr: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type list: OCC.wrapper.STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink

        """
        this = _STEPSelections.new_STEPSelections_AssemblyComponent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetSDR(self, *args):
        """
        GetSDR(STEPSelections_AssemblyComponent self) -> Handle_StepShape_ShapeDefinitionRepresentation

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation

        """
        return _STEPSelections.STEPSelections_AssemblyComponent_GetSDR(self, *args)


    def GetList(self, *args):
        """
        GetList(STEPSelections_AssemblyComponent self) -> Handle_STEPSelections_HSequenceOfAssemblyLink

        :rtype: OCC.wrapper.STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink

        """
        return _STEPSelections.STEPSelections_AssemblyComponent_GetList(self, *args)


    def SetSDR(self, *args):
        """
        SetSDR(STEPSelections_AssemblyComponent self, Handle_StepShape_ShapeDefinitionRepresentation sdr)

        :type sdr: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation

        """
        return _STEPSelections.STEPSelections_AssemblyComponent_SetSDR(self, *args)


    def SetList(self, *args):
        """
        SetList(STEPSelections_AssemblyComponent self, Handle_STEPSelections_HSequenceOfAssemblyLink list)

        :type list: OCC.wrapper.STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink

        """
        return _STEPSelections.STEPSelections_AssemblyComponent_SetList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_AssemblyComponent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_AssemblyComponent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_AssemblyComponent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_AssemblyComponent
STEPSelections_AssemblyComponent_swigregister = _STEPSelections.STEPSelections_AssemblyComponent_swigregister
STEPSelections_AssemblyComponent_swigregister(STEPSelections_AssemblyComponent)

def STEPSelections_AssemblyComponent_get_type_name(*args):
    """
    STEPSelections_AssemblyComponent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_AssemblyComponent_get_type_name(*args)

def STEPSelections_AssemblyComponent_get_type_descriptor(*args):
    """
    STEPSelections_AssemblyComponent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_AssemblyComponent_get_type_descriptor(*args)

class STEPSelections_SelectFaces(IFSelect.IFSelect_SelectExplore):
    """This selection returns "STEP faces" """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_SelectFaces
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_SelectFaces(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPSelections_SelectFaces self) -> STEPSelections_SelectFaces

        This selection returns "STEP faces" 
        """
        this = _STEPSelections.new_STEPSelections_SelectFaces(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Explore(self, *args):
        """
        Explore(STEPSelections_SelectFaces self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity, to take its faces
        Works recursively

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.STEPSelections_SelectFaces_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(STEPSelections_SelectFaces self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Faces"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.STEPSelections_SelectFaces_ExploreLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_SelectFaces_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_SelectFaces_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_SelectFaces_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_SelectFaces
STEPSelections_SelectFaces_swigregister = _STEPSelections.STEPSelections_SelectFaces_swigregister
STEPSelections_SelectFaces_swigregister(STEPSelections_SelectFaces)

def STEPSelections_SelectFaces_get_type_name(*args):
    """
    STEPSelections_SelectFaces_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_SelectFaces_get_type_name(*args)

def STEPSelections_SelectFaces_get_type_descriptor(*args):
    """
    STEPSelections_SelectFaces_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_SelectFaces_get_type_descriptor(*args)

class Handle_STEPSelections_SelectForTransfer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_SelectForTransfer self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_SelectForTransfer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_SelectForTransfer self, STEPSelections_SelectForTransfer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_SelectForTransfer self, Handle_STEPSelections_SelectForTransfer theHandle) -> Handle_STEPSelections_SelectForTransfer
        assign(Handle_STEPSelections_SelectForTransfer self, STEPSelections_SelectForTransfer thePtr) -> Handle_STEPSelections_SelectForTransfer
        assign(Handle_STEPSelections_SelectForTransfer self, Handle_STEPSelections_SelectForTransfer theHandle) -> Handle_STEPSelections_SelectForTransfer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_SelectForTransfer self) -> STEPSelections_SelectForTransfer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_SelectForTransfer self) -> STEPSelections_SelectForTransfer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_SelectForTransfer self) -> STEPSelections_SelectForTransfer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_SelectForTransfer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_SelectForTransfer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_SelectForTransfer_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_SelectForTransfer

    def RootResult(self, *args):
        """
        RootResult(Handle_STEPSelections_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_RootResult(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_SelectForTransfer self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectForTransfer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectForTransfer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetReader(self, *args):
        """
        SetReader(Handle_STEPSelections_SelectForTransfer self, Handle_XSControl_TransferReader TR)

        Sets a TransferReader to sort entities : it brings the Actor,
        which may change, while the TransferReader does not

        :type TR: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_SetReader(self, *args)


    def SetActor(self, *args):
        """
        SetActor(Handle_STEPSelections_SelectForTransfer self, Handle_Transfer_ActorOfTransientProcess act)

        Sets a precise actor to sort entities
        This definition oversedes the creation with a TransferReader

        :type act: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_SetActor(self, *args)


    def Actor(self, *args):
        """
        Actor(Handle_STEPSelections_SelectForTransfer self) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor used as precised one.
        Returns a Null Handle for a creation from a TransferReader
        without any further setting

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Actor(self, *args)


    def Reader(self, *args):
        """
        Reader(Handle_STEPSelections_SelectForTransfer self) -> Handle_XSControl_TransferReader

        Returns the Reader (if created with a Reader)
        Returns a Null Handle if not created with a Reader

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_TransferReader

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Reader(self, *args)


    def Sort(self, *args):
        """
        Sort(Handle_STEPSelections_SelectForTransfer self, Standard_Integer const rank, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True for an Entity which is recognized by the Actor,
        either the precised one, or the one defined by TransferReader

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Sort(self, *args)


    def ExtractLabel(self, *args):
        """
        ExtractLabel(Handle_STEPSelections_SelectForTransfer self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Recognized for Transfer [(current actor)]"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_ExtractLabel(self, *args)


    def IsDirect(self, *args):
        """
        IsDirect(Handle_STEPSelections_SelectForTransfer self) -> Standard_Boolean

        Returns True if Sort criterium is Direct, False if Reverse

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_IsDirect(self, *args)


    def SetDirect(self, *args):
        """
        SetDirect(Handle_STEPSelections_SelectForTransfer self, Standard_Boolean const direct)

        Sets Sort criterium sense to a new value
        (True : Direct , False : Reverse)

        :type direct: bool

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_SetDirect(self, *args)


    def SortInGraph(self, *args):
        """
        SortInGraph(Handle_STEPSelections_SelectForTransfer self, Standard_Integer const rank, Handle_Standard_Transient ent, Interface_Graph G) -> Standard_Boolean

        Works as Sort but works on the Graph
        Default directly calls Sort, but it can be redefined
        If SortInGraph is redefined, Sort should be defined even if
        not called (to avoid deferred methods in a final class)

        :type rank: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_SortInGraph(self, *args)


    def Label(self, *args):
        """
        Label(Handle_STEPSelections_SelectForTransfer self) -> TCollection_AsciiString

        Returns a text saying "Picked" or "Removed", plus the
        specific criterium returned by ExtractLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_STEPSelections_SelectForTransfer self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_STEPSelections_SelectForTransfer self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_STEPSelections_SelectForTransfer self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_STEPSelections_SelectForTransfer self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_STEPSelections_SelectForTransfer self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_STEPSelections_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_STEPSelections_SelectForTransfer self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_STEPSelections_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_STEPSelections_SelectForTransfer self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_SelectForTransfer self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_SelectForTransfer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_SelectForTransfer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_SelectForTransfer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_SelectForTransfer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_SelectForTransfer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_SelectForTransfer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_SelectForTransfer self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_SelectForTransfer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectForTransfer_DecrementRefCounter(self, *args)

Handle_STEPSelections_SelectForTransfer_swigregister = _STEPSelections.Handle_STEPSelections_SelectForTransfer_swigregister
Handle_STEPSelections_SelectForTransfer_swigregister(Handle_STEPSelections_SelectForTransfer)

def Handle_STEPSelections_SelectForTransfer_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_SelectForTransfer_DownCast(thing)
Handle_STEPSelections_SelectForTransfer_DownCast = _STEPSelections.Handle_STEPSelections_SelectForTransfer_DownCast

class STEPSelections_HSequenceOfAssemblyLink(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_HSequenceOfAssemblyLink
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_HSequenceOfAssemblyLink(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPSelections_HSequenceOfAssemblyLink self) -> STEPSelections_HSequenceOfAssemblyLink
        __init__(STEPSelections_HSequenceOfAssemblyLink self, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theOther) -> STEPSelections_HSequenceOfAssemblyLink

        :type theOther: OCC.wrapper.STEPSelections.STEPSelections_SequenceOfAssemblyLink

        """
        this = _STEPSelections.new_STEPSelections_HSequenceOfAssemblyLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.STEPSelections.STEPSelections_SequenceOfAssemblyLink

        """
        res = _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(STEPSelections_HSequenceOfAssemblyLink self, Handle_STEPSelections_AssemblyLink theItem)
        Append(STEPSelections_HSequenceOfAssemblyLink self, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theSequence)

        :type theSequence: OCC.wrapper.STEPSelections.STEPSelections_SequenceOfAssemblyLink

        """
        return _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(STEPSelections_HSequenceOfAssemblyLink self) -> NCollection_Sequence_Handle_STEPSelections_AssemblyLink

        :rtype: OCC.wrapper.STEPSelections.STEPSelections_SequenceOfAssemblyLink

        """
        return _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_HSequenceOfAssemblyLink
STEPSelections_HSequenceOfAssemblyLink_swigregister = _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_swigregister
STEPSelections_HSequenceOfAssemblyLink_swigregister(STEPSelections_HSequenceOfAssemblyLink)

def STEPSelections_HSequenceOfAssemblyLink_get_type_name(*args):
    """
    STEPSelections_HSequenceOfAssemblyLink_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_get_type_name(*args)

def STEPSelections_HSequenceOfAssemblyLink_get_type_descriptor(*args):
    """
    STEPSelections_HSequenceOfAssemblyLink_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_HSequenceOfAssemblyLink_get_type_descriptor(*args)

class Handle_STEPSelections_SelectAssembly(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_SelectAssembly self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_SelectAssembly self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_SelectAssembly self, STEPSelections_SelectAssembly thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_SelectAssembly self, Handle_STEPSelections_SelectAssembly theHandle) -> Handle_STEPSelections_SelectAssembly
        assign(Handle_STEPSelections_SelectAssembly self, STEPSelections_SelectAssembly thePtr) -> Handle_STEPSelections_SelectAssembly
        assign(Handle_STEPSelections_SelectAssembly self, Handle_STEPSelections_SelectAssembly theHandle) -> Handle_STEPSelections_SelectAssembly

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_SelectAssembly self) -> STEPSelections_SelectAssembly

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_SelectAssembly self) -> STEPSelections_SelectAssembly

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_SelectAssembly self) -> STEPSelections_SelectAssembly

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_SelectAssembly___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_SelectAssembly___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_SelectAssembly(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_SelectAssembly_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_SelectAssembly

    def Explore(self, *args):
        """
        Explore(Handle_STEPSelections_SelectAssembly self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity, to take its faces
        Works recursively

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_STEPSelections_SelectAssembly self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Assembly structures"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_ExploreLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_SelectAssembly self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectAssembly_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectAssembly_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Level(self, *args):
        """
        Level(Handle_STEPSelections_SelectAssembly self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_STEPSelections_SelectAssembly self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_STEPSelections_SelectAssembly self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_STEPSelections_SelectAssembly self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_STEPSelections_SelectAssembly self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_STEPSelections_SelectAssembly self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_STEPSelections_SelectAssembly self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_STEPSelections_SelectAssembly self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_STEPSelections_SelectAssembly self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_STEPSelections_SelectAssembly self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_STEPSelections_SelectAssembly self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_STEPSelections_SelectAssembly self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_SelectAssembly self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_SelectAssembly self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_SelectAssembly self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_SelectAssembly self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_SelectAssembly self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_SelectAssembly self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_SelectAssembly self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_SelectAssembly self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_SelectAssembly self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectAssembly_DecrementRefCounter(self, *args)

Handle_STEPSelections_SelectAssembly_swigregister = _STEPSelections.Handle_STEPSelections_SelectAssembly_swigregister
Handle_STEPSelections_SelectAssembly_swigregister(Handle_STEPSelections_SelectAssembly)

def Handle_STEPSelections_SelectAssembly_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_SelectAssembly_DownCast(thing)
Handle_STEPSelections_SelectAssembly_DownCast = _STEPSelections.Handle_STEPSelections_SelectAssembly_DownCast

class Handle_STEPSelections_AssemblyLink(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_AssemblyLink self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_AssemblyLink self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_AssemblyLink self, STEPSelections_AssemblyLink thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_AssemblyLink self, Handle_STEPSelections_AssemblyLink theHandle) -> Handle_STEPSelections_AssemblyLink
        assign(Handle_STEPSelections_AssemblyLink self, STEPSelections_AssemblyLink thePtr) -> Handle_STEPSelections_AssemblyLink
        assign(Handle_STEPSelections_AssemblyLink self, Handle_STEPSelections_AssemblyLink theHandle) -> Handle_STEPSelections_AssemblyLink

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_AssemblyLink self) -> STEPSelections_AssemblyLink

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_AssemblyLink self) -> STEPSelections_AssemblyLink

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_AssemblyLink self) -> STEPSelections_AssemblyLink

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_AssemblyLink___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_AssemblyLink___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_AssemblyLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_AssemblyLink_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_AssemblyLink

    def GetNAUO(self, *args):
        """
        GetNAUO(Handle_STEPSelections_AssemblyLink self) -> Handle_StepRepr_NextAssemblyUsageOccurrence

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_GetNAUO(self, *args)


    def GetItem(self, *args):
        """
        GetItem(Handle_STEPSelections_AssemblyLink self) -> Handle_Standard_Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_GetItem(self, *args)


    def GetComponent(self, *args):
        """
        GetComponent(Handle_STEPSelections_AssemblyLink self) -> Handle_STEPSelections_AssemblyComponent

        :rtype: OCC.wrapper.STEPSelections.Handle_STEPSelections_AssemblyComponent

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_GetComponent(self, *args)


    def SetNAUO(self, *args):
        """
        SetNAUO(Handle_STEPSelections_AssemblyLink self, Handle_StepRepr_NextAssemblyUsageOccurrence nauo)

        :type nauo: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_SetNAUO(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_STEPSelections_AssemblyLink self, Handle_Standard_Transient item)

        :type item: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_SetItem(self, *args)


    def SetComponent(self, *args):
        """
        SetComponent(Handle_STEPSelections_AssemblyLink self, Handle_STEPSelections_AssemblyComponent part)

        :type part: OCC.wrapper.STEPSelections.Handle_STEPSelections_AssemblyComponent

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_SetComponent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_AssemblyLink self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_AssemblyLink_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_AssemblyLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_AssemblyLink self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_AssemblyLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_AssemblyLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_AssemblyLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_AssemblyLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_AssemblyLink self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_AssemblyLink self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_AssemblyLink self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_AssemblyLink self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyLink_DecrementRefCounter(self, *args)

Handle_STEPSelections_AssemblyLink_swigregister = _STEPSelections.Handle_STEPSelections_AssemblyLink_swigregister
Handle_STEPSelections_AssemblyLink_swigregister(Handle_STEPSelections_AssemblyLink)

def Handle_STEPSelections_AssemblyLink_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_AssemblyLink_DownCast(thing)
Handle_STEPSelections_AssemblyLink_DownCast = _STEPSelections.Handle_STEPSelections_AssemblyLink_DownCast

class Handle_STEPSelections_SelectFaces(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_SelectFaces self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_SelectFaces self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_SelectFaces self, STEPSelections_SelectFaces thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_SelectFaces self, Handle_STEPSelections_SelectFaces theHandle) -> Handle_STEPSelections_SelectFaces
        assign(Handle_STEPSelections_SelectFaces self, STEPSelections_SelectFaces thePtr) -> Handle_STEPSelections_SelectFaces
        assign(Handle_STEPSelections_SelectFaces self, Handle_STEPSelections_SelectFaces theHandle) -> Handle_STEPSelections_SelectFaces

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_SelectFaces self) -> STEPSelections_SelectFaces

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_SelectFaces self) -> STEPSelections_SelectFaces

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_SelectFaces self) -> STEPSelections_SelectFaces

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_SelectFaces___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_SelectFaces___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_SelectFaces(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_SelectFaces_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_SelectFaces

    def Explore(self, *args):
        """
        Explore(Handle_STEPSelections_SelectFaces self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        Explores an entity, to take its faces
        Works recursively

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_STEPSelections_SelectFaces self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Faces"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_ExploreLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_SelectFaces self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectFaces_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectFaces_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Level(self, *args):
        """
        Level(Handle_STEPSelections_SelectFaces self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_STEPSelections_SelectFaces self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_STEPSelections_SelectFaces self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_STEPSelections_SelectFaces self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_STEPSelections_SelectFaces self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_STEPSelections_SelectFaces self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_STEPSelections_SelectFaces self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_STEPSelections_SelectFaces self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_STEPSelections_SelectFaces self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_STEPSelections_SelectFaces self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_STEPSelections_SelectFaces self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_STEPSelections_SelectFaces self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_SelectFaces self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_SelectFaces self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_SelectFaces self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_SelectFaces self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_SelectFaces self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_SelectFaces self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_SelectFaces self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_SelectFaces self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_SelectFaces self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectFaces_DecrementRefCounter(self, *args)

Handle_STEPSelections_SelectFaces_swigregister = _STEPSelections.Handle_STEPSelections_SelectFaces_swigregister
Handle_STEPSelections_SelectFaces_swigregister(Handle_STEPSelections_SelectFaces)

def Handle_STEPSelections_SelectFaces_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_SelectFaces_DownCast(thing)
Handle_STEPSelections_SelectFaces_DownCast = _STEPSelections.Handle_STEPSelections_SelectFaces_DownCast

class Handle_STEPSelections_AssemblyComponent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_AssemblyComponent self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_AssemblyComponent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_AssemblyComponent self, STEPSelections_AssemblyComponent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_AssemblyComponent self, Handle_STEPSelections_AssemblyComponent theHandle) -> Handle_STEPSelections_AssemblyComponent
        assign(Handle_STEPSelections_AssemblyComponent self, STEPSelections_AssemblyComponent thePtr) -> Handle_STEPSelections_AssemblyComponent
        assign(Handle_STEPSelections_AssemblyComponent self, Handle_STEPSelections_AssemblyComponent theHandle) -> Handle_STEPSelections_AssemblyComponent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_AssemblyComponent self) -> STEPSelections_AssemblyComponent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_AssemblyComponent self) -> STEPSelections_AssemblyComponent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_AssemblyComponent self) -> STEPSelections_AssemblyComponent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_AssemblyComponent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_AssemblyComponent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_AssemblyComponent_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_AssemblyComponent

    def GetSDR(self, *args):
        """
        GetSDR(Handle_STEPSelections_AssemblyComponent self) -> Handle_StepShape_ShapeDefinitionRepresentation

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_GetSDR(self, *args)


    def GetList(self, *args):
        """
        GetList(Handle_STEPSelections_AssemblyComponent self) -> Handle_STEPSelections_HSequenceOfAssemblyLink

        :rtype: OCC.wrapper.STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_GetList(self, *args)


    def SetSDR(self, *args):
        """
        SetSDR(Handle_STEPSelections_AssemblyComponent self, Handle_StepShape_ShapeDefinitionRepresentation sdr)

        :type sdr: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_SetSDR(self, *args)


    def SetList(self, *args):
        """
        SetList(Handle_STEPSelections_AssemblyComponent self, Handle_STEPSelections_HSequenceOfAssemblyLink list)

        :type list: OCC.wrapper.STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_SetList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_AssemblyComponent self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_AssemblyComponent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_AssemblyComponent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_AssemblyComponent self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_AssemblyComponent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_AssemblyComponent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_AssemblyComponent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_AssemblyComponent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_AssemblyComponent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_AssemblyComponent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_AssemblyComponent self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_AssemblyComponent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_AssemblyComponent_DecrementRefCounter(self, *args)

Handle_STEPSelections_AssemblyComponent_swigregister = _STEPSelections.Handle_STEPSelections_AssemblyComponent_swigregister
Handle_STEPSelections_AssemblyComponent_swigregister(Handle_STEPSelections_AssemblyComponent)

def Handle_STEPSelections_AssemblyComponent_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_AssemblyComponent_DownCast(thing)
Handle_STEPSelections_AssemblyComponent_DownCast = _STEPSelections.Handle_STEPSelections_AssemblyComponent_DownCast

class Handle_STEPSelections_HSequenceOfAssemblyLink(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_HSequenceOfAssemblyLink self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_HSequenceOfAssemblyLink self, STEPSelections_HSequenceOfAssemblyLink thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_HSequenceOfAssemblyLink self, Handle_STEPSelections_HSequenceOfAssemblyLink theHandle) -> Handle_STEPSelections_HSequenceOfAssemblyLink
        assign(Handle_STEPSelections_HSequenceOfAssemblyLink self, STEPSelections_HSequenceOfAssemblyLink thePtr) -> Handle_STEPSelections_HSequenceOfAssemblyLink
        assign(Handle_STEPSelections_HSequenceOfAssemblyLink self, Handle_STEPSelections_HSequenceOfAssemblyLink theHandle) -> Handle_STEPSelections_HSequenceOfAssemblyLink

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> STEPSelections_HSequenceOfAssemblyLink

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> STEPSelections_HSequenceOfAssemblyLink

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> STEPSelections_HSequenceOfAssemblyLink

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_HSequenceOfAssemblyLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_HSequenceOfAssemblyLink

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.STEPSelections.STEPSelections_SequenceOfAssemblyLink

        """
        res = _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_STEPSelections_HSequenceOfAssemblyLink self, Handle_STEPSelections_AssemblyLink theItem)
        Append(Handle_STEPSelections_HSequenceOfAssemblyLink self, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theSequence)

        :type theSequence: OCC.wrapper.STEPSelections.STEPSelections_SequenceOfAssemblyLink

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> NCollection_Sequence_Handle_STEPSelections_AssemblyLink

        :rtype: OCC.wrapper.STEPSelections.STEPSelections_SequenceOfAssemblyLink

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_HSequenceOfAssemblyLink self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_HSequenceOfAssemblyLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_HSequenceOfAssemblyLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_HSequenceOfAssemblyLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_HSequenceOfAssemblyLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_HSequenceOfAssemblyLink self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_HSequenceOfAssemblyLink self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_DecrementRefCounter(self, *args)

Handle_STEPSelections_HSequenceOfAssemblyLink_swigregister = _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_swigregister
Handle_STEPSelections_HSequenceOfAssemblyLink_swigregister(Handle_STEPSelections_HSequenceOfAssemblyLink)

def Handle_STEPSelections_HSequenceOfAssemblyLink_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_DownCast(thing)
Handle_STEPSelections_HSequenceOfAssemblyLink_DownCast = _STEPSelections.Handle_STEPSelections_HSequenceOfAssemblyLink_DownCast

class STEPSelections_SelectGSCurves(IFSelect.IFSelect_SelectExplore):
    """This selection returns "curves in the geometric_set (except composite curves)" """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPSelections_SelectGSCurves
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPSelections_SelectGSCurves(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPSelections_SelectGSCurves self) -> STEPSelections_SelectGSCurves

        This selection returns "curves in the geometric_set (except composite curves)" 
        """
        this = _STEPSelections.new_STEPSelections_SelectGSCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Explore(self, *args):
        """
        Explore(STEPSelections_SelectGSCurves self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.STEPSelections_SelectGSCurves_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(STEPSelections_SelectGSCurves self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Curves"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.STEPSelections_SelectGSCurves_ExploreLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPSelections.STEPSelections_SelectGSCurves_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPSelections.STEPSelections_SelectGSCurves_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.STEPSelections_SelectGSCurves_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPSelections.delete_STEPSelections_SelectGSCurves
STEPSelections_SelectGSCurves_swigregister = _STEPSelections.STEPSelections_SelectGSCurves_swigregister
STEPSelections_SelectGSCurves_swigregister(STEPSelections_SelectGSCurves)

def STEPSelections_SelectGSCurves_get_type_name(*args):
    """
    STEPSelections_SelectGSCurves_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPSelections.STEPSelections_SelectGSCurves_get_type_name(*args)

def STEPSelections_SelectGSCurves_get_type_descriptor(*args):
    """
    STEPSelections_SelectGSCurves_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPSelections.STEPSelections_SelectGSCurves_get_type_descriptor(*args)

class Handle_STEPSelections_SelectGSCurves(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_SelectGSCurves self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_SelectGSCurves self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_SelectGSCurves self, STEPSelections_SelectGSCurves thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_SelectGSCurves self, Handle_STEPSelections_SelectGSCurves theHandle) -> Handle_STEPSelections_SelectGSCurves
        assign(Handle_STEPSelections_SelectGSCurves self, STEPSelections_SelectGSCurves thePtr) -> Handle_STEPSelections_SelectGSCurves
        assign(Handle_STEPSelections_SelectGSCurves self, Handle_STEPSelections_SelectGSCurves theHandle) -> Handle_STEPSelections_SelectGSCurves

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_SelectGSCurves self) -> STEPSelections_SelectGSCurves

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_SelectGSCurves self) -> STEPSelections_SelectGSCurves

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_SelectGSCurves self) -> STEPSelections_SelectGSCurves

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_SelectGSCurves___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_SelectGSCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_SelectGSCurves_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_SelectGSCurves

    def Explore(self, *args):
        """
        Explore(Handle_STEPSelections_SelectGSCurves self, Standard_Integer const level, Handle_Standard_Transient ent, Interface_Graph G, Interface_EntityIterator explored) -> Standard_Boolean

        :type level: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type G: OCC.wrapper.Interface.Interface_Graph
        :type explored: OCC.wrapper.Interface.Interface_EntityIterator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_Explore(self, *args)


    def ExploreLabel(self, *args):
        """
        ExploreLabel(Handle_STEPSelections_SelectGSCurves self) -> TCollection_AsciiString

        Returns a text defining the criterium : "Curves"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_ExploreLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_SelectGSCurves self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectGSCurves_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectGSCurves_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Level(self, *args):
        """
        Level(Handle_STEPSelections_SelectGSCurves self) -> Standard_Integer

        Returns the required exploring level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_Level(self, *args)


    def RootResult(self, *args):
        """
        RootResult(Handle_STEPSelections_SelectGSCurves self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities. Works by calling the
        method Explore on each input entity : it can be rejected,
        taken for output, or to explore. If the maximum level has not
        yet been attained, or if no max level is specified, entities
        to be explored are themselves used as if they were input

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_RootResult(self, *args)


    def Label(self, *args):
        """
        Label(Handle_STEPSelections_SelectGSCurves self) -> TCollection_AsciiString

        Returns a text saying "(Recursive)" or "(Level nn)" plus
        specific criterium returned by ExploreLabel (see below)

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_Label(self, *args)


    def SetInput(self, *args):
        """
        SetInput(Handle_STEPSelections_SelectGSCurves self, Handle_IFSelect_Selection sel)

        Defines or Changes the Input Selection

        :type sel: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_SetInput(self, *args)


    def Input(self, *args):
        """
        Input(Handle_STEPSelections_SelectGSCurves self) -> Handle_IFSelect_Selection

        Returns the Input Selection

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_Selection

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_Input(self, *args)


    def HasInput(self, *args):
        """
        HasInput(Handle_STEPSelections_SelectGSCurves self) -> Standard_Boolean

        Returns True if the Input Selection is defined, False else

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_HasInput(self, *args)


    def HasAlternate(self, *args):
        """
        HasAlternate(Handle_STEPSelections_SelectGSCurves self) -> Standard_Boolean

        Tells if an Alternate List has been set, i.e. : the Alternate
        Definition is present and set

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_HasAlternate(self, *args)


    def Alternate(self, *args):
        """
        Alternate(Handle_STEPSelections_SelectGSCurves self) -> Handle_IFSelect_SelectPointed

        Returns the Alternate Definition
        It is returned modifiable, hence an already defined
        SelectPointed can be used
        But if it was not yet defined, it is created the first time

        It is exploited by InputResult

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_SelectPointed

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_Alternate(self, *args)


    def InputResult(self, *args):
        """
        InputResult(Handle_STEPSelections_SelectGSCurves self, Interface_Graph G) -> Interface_EntityIterator

        Returns the Result determined by Input Selection, as Unique
        if Input Selection is not defined, returns an empty list.

        If Alternate is set, InputResult takes its definition instead
        of calling the Input Selection, then clears it

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_InputResult(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_STEPSelections_SelectGSCurves self, IFSelect_SelectionIterator iter)

        Puts in an Iterator the Selections from which "me" depends
        This list contains one Selection : the InputSelection

        :type iter: OCC.wrapper.IFSelect.IFSelect_SelectionIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_FillIterator(self, *args)


    def UniqueResult(self, *args):
        """
        UniqueResult(Handle_STEPSelections_SelectGSCurves self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of selected entities, each of them beeing
        unique. Default definition works from RootResult. According
        HasUniqueResult, UniqueResult returns directly RootResult,
        or build a Unique Result from it with a Graph.

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_UniqueResult(self, *args)


    def CompleteResult(self, *args):
        """
        CompleteResult(Handle_STEPSelections_SelectGSCurves self, Interface_Graph G) -> Interface_EntityIterator

        Returns the list of entities involved by a Selection, i.e.
        UniqueResult plus the shared entities (directly or not)

        :type G: OCC.wrapper.Interface.Interface_Graph
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_CompleteResult(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_SelectGSCurves self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_SelectGSCurves self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_SelectGSCurves self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_SelectGSCurves self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_SelectGSCurves self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_SelectGSCurves self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_SelectGSCurves self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_SelectGSCurves self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_SelectGSCurves self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectGSCurves_DecrementRefCounter(self, *args)

Handle_STEPSelections_SelectGSCurves_swigregister = _STEPSelections.Handle_STEPSelections_SelectGSCurves_swigregister
Handle_STEPSelections_SelectGSCurves_swigregister(Handle_STEPSelections_SelectGSCurves)

def Handle_STEPSelections_SelectGSCurves_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_SelectGSCurves_DownCast(thing)
Handle_STEPSelections_SelectGSCurves_DownCast = _STEPSelections.Handle_STEPSelections_SelectGSCurves_DownCast

class NCollection_Sequence_Handle_STEPSelections_AssemblyComponent(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyComponent > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyComponent > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyComponent > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyComponent > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _STEPSelections.new_NCollection_Sequence_Handle_STEPSelections_AssemblyComponent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self)

        Reverse sequence


        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, NCollection_Sequence_Handle_STEPSelections_AssemblyComponent theOther) -> NCollection_Sequence_Handle_STEPSelections_AssemblyComponent

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, NCollection_Sequence_Handle_STEPSelections_AssemblyComponent theOther) -> NCollection_Sequence_Handle_STEPSelections_AssemblyComponent

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyComponent > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Handle_STEPSelections_AssemblyComponent theItem)
        Append(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, NCollection_Sequence_Handle_STEPSelections_AssemblyComponent theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Handle_STEPSelections_AssemblyComponent theItem)
        Prepend(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, NCollection_Sequence_Handle_STEPSelections_AssemblyComponent theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex, Handle_STEPSelections_AssemblyComponent theItem)
        InsertBefore(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex, NCollection_Sequence_Handle_STEPSelections_AssemblyComponent theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyComponent > >::Iterator & thePosition, Handle_STEPSelections_AssemblyComponent theItem)
        InsertAfter(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex, NCollection_Sequence_Handle_STEPSelections_AssemblyComponent theSeq)
        InsertAfter(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex, Handle_STEPSelections_AssemblyComponent theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex, NCollection_Sequence_Handle_STEPSelections_AssemblyComponent theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> Handle_STEPSelections_AssemblyComponent

        First item access

        :rtype: TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self) -> Handle_STEPSelections_AssemblyComponent

        Last item access

        :rtype: TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex) -> Handle_STEPSelections_AssemblyComponent

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent self, Standard_Integer const theIndex, Handle_STEPSelections_AssemblyComponent theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_SetValue(self, *args)


    def __iter__(self):
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent___iter__(self)
    __swig_destroy__ = _STEPSelections.delete_NCollection_Sequence_Handle_STEPSelections_AssemblyComponent
NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_swigregister = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_swigregister
NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_swigregister(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent)

def NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_delNode(*args):
    """
    NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_delNode(*args)

class NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPSelections.new_NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPSelections.delete_NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper

    def __next__(self):
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper___next__(self)
NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper_swigregister = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper_swigregister
NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper_swigregister(NCollection_Sequence_Handle_STEPSelections_AssemblyComponent_IteratorHelper)


try:
	STEPSelections_SequenceOfAssemblyComponent = NCollection_Sequence_Handle_STEPSelections_AssemblyComponent
except NameError:
	pass # does not exist, probably ignored

class STEPSelections_AssemblyExplorer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPSelections_AssemblyExplorer self, Interface_Graph G) -> STEPSelections_AssemblyExplorer

        :type G: OCC.wrapper.Interface.Interface_Graph

        """
        this = _STEPSelections.new_STEPSelections_AssemblyExplorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPSelections_AssemblyExplorer self, Interface_Graph G)

        :type G: OCC.wrapper.Interface.Interface_Graph

        """
        return _STEPSelections.STEPSelections_AssemblyExplorer_Init(self, *args)


    def Dump(self, *args):
        """
        Dump(STEPSelections_AssemblyExplorer self, Standard_OStream & os)

        :type os: OCC.wrapper.Standard.Standard_OStream

        """
        return _STEPSelections.STEPSelections_AssemblyExplorer_Dump(self, *args)


    def FindSDRWithProduct(self, *args):
        """
        FindSDRWithProduct(STEPSelections_AssemblyExplorer self, Handle_StepBasic_ProductDefinition product) -> Handle_StepShape_ShapeDefinitionRepresentation

        :type product: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition
        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation

        """
        return _STEPSelections.STEPSelections_AssemblyExplorer_FindSDRWithProduct(self, *args)


    def FillListWithGraph(self, *args):
        """
        FillListWithGraph(STEPSelections_AssemblyExplorer self, Handle_STEPSelections_AssemblyComponent cmp)

        :type cmp: OCC.wrapper.STEPSelections.Handle_STEPSelections_AssemblyComponent

        """
        return _STEPSelections.STEPSelections_AssemblyExplorer_FillListWithGraph(self, *args)


    def FindItemWithNAUO(self, *args):
        """
        FindItemWithNAUO(STEPSelections_AssemblyExplorer self, Handle_StepRepr_NextAssemblyUsageOccurrence nauo) -> Handle_Standard_Transient

        :type nauo: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPSelections.STEPSelections_AssemblyExplorer_FindItemWithNAUO(self, *args)


    def NbAssemblies(self, *args):
        """
        NbAssemblies(STEPSelections_AssemblyExplorer self) -> Standard_Integer

        Returns the number of root assemblies;

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_AssemblyExplorer_NbAssemblies(self, *args)


    def Root(self, *args):
        """
        Root(STEPSelections_AssemblyExplorer self, Standard_Integer const rank=1) -> Handle_STEPSelections_AssemblyComponent

        Returns root of assenbly by its rank;

        :type rank: int
        :rtype: OCC.wrapper.STEPSelections.Handle_STEPSelections_AssemblyComponent

        """
        return _STEPSelections.STEPSelections_AssemblyExplorer_Root(self, *args)

    __swig_destroy__ = _STEPSelections.delete_STEPSelections_AssemblyExplorer
STEPSelections_AssemblyExplorer_swigregister = _STEPSelections.STEPSelections_AssemblyExplorer_swigregister
STEPSelections_AssemblyExplorer_swigregister(STEPSelections_AssemblyExplorer)

class STEPSelections_Counter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(STEPSelections_Counter self) -> STEPSelections_Counter"""
        this = _STEPSelections.new_STEPSelections_Counter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Count(self, *args):
        """
        Count(STEPSelections_Counter self, Interface_Graph graph, Handle_Standard_Transient start)

        :type graph: OCC.wrapper.Interface.Interface_Graph
        :type start: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPSelections.STEPSelections_Counter_Count(self, *args)


    def Clear(self, *args):
        """Clear(STEPSelections_Counter self)"""
        return _STEPSelections.STEPSelections_Counter_Clear(self, *args)


    def NbInstancesOfFaces(self, *args):
        """
        NbInstancesOfFaces(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbInstancesOfFaces(self, *args)


    def NbInstancesOfShells(self, *args):
        """
        NbInstancesOfShells(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbInstancesOfShells(self, *args)


    def NbInstancesOfSolids(self, *args):
        """
        NbInstancesOfSolids(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbInstancesOfSolids(self, *args)


    def NbInstancesOfEdges(self, *args):
        """
        NbInstancesOfEdges(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbInstancesOfEdges(self, *args)


    def NbInstancesOfWires(self, *args):
        """
        NbInstancesOfWires(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbInstancesOfWires(self, *args)


    def NbSourceFaces(self, *args):
        """
        NbSourceFaces(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbSourceFaces(self, *args)


    def NbSourceShells(self, *args):
        """
        NbSourceShells(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbSourceShells(self, *args)


    def NbSourceSolids(self, *args):
        """
        NbSourceSolids(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbSourceSolids(self, *args)


    def NbSourceEdges(self, *args):
        """
        NbSourceEdges(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbSourceEdges(self, *args)


    def NbSourceWires(self, *args):
        """
        NbSourceWires(STEPSelections_Counter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.STEPSelections_Counter_NbSourceWires(self, *args)

    __swig_destroy__ = _STEPSelections.delete_STEPSelections_Counter
STEPSelections_Counter_swigregister = _STEPSelections.STEPSelections_Counter_swigregister
STEPSelections_Counter_swigregister(STEPSelections_Counter)

class Handle_STEPSelections_SelectDerived(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPSelections_SelectDerived self)

        Nullify the handle


        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPSelections_SelectDerived self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPSelections_SelectDerived self, STEPSelections_SelectDerived thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPSelections_SelectDerived self, Handle_STEPSelections_SelectDerived theHandle) -> Handle_STEPSelections_SelectDerived
        assign(Handle_STEPSelections_SelectDerived self, STEPSelections_SelectDerived thePtr) -> Handle_STEPSelections_SelectDerived
        assign(Handle_STEPSelections_SelectDerived self, Handle_STEPSelections_SelectDerived theHandle) -> Handle_STEPSelections_SelectDerived

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPSelections_SelectDerived self) -> STEPSelections_SelectDerived

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPSelections_SelectDerived self) -> STEPSelections_SelectDerived

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPSelections_SelectDerived self) -> STEPSelections_SelectDerived

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived___ref__(self, *args)


    def __hash__(self):
        return _STEPSelections.Handle_STEPSelections_SelectDerived___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPSelections.Handle_STEPSelections_SelectDerived___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPSelections.new_Handle_STEPSelections_SelectDerived(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPSelections.Handle_STEPSelections_SelectDerived_DownCast)
    __swig_destroy__ = _STEPSelections.delete_Handle_STEPSelections_SelectDerived

    def Matches(self, *args):
        """
        Matches(Handle_STEPSelections_SelectDerived self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_Matches(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPSelections_SelectDerived self) -> char const *

        :rtype: const char *

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectDerived_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPSelections.Handle_STEPSelections_SelectDerived_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetProtocol(self, *args):
        """
        SetProtocol(Handle_STEPSelections_SelectDerived self, Handle_Interface_Protocol proto)

        Sets the StepType signature to work with a Protocol : this
        initialises the library

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_SetProtocol(self, *args)


    def Value(self, *args):
        """
        Value(Handle_STEPSelections_SelectDerived self, Handle_Standard_Transient ent, Handle_Interface_InterfaceModel model) -> Standard_CString

        Returns the Step Type defined from the Protocol (see above).
        If <ent> is not recognised, produces "..NOT FROM SCHEMA <name>.."

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_Value(self, *args)


    def SetIntCase(self, *args):
        """
        SetIntCase(Handle_STEPSelections_SelectDerived self, Standard_Boolean const hasmin, Standard_Integer const valmin, Standard_Boolean const hasmax, Standard_Integer const valmax)

        Sets the information data to tell "integer cases" with
        possible min and max values
        To be called when creating

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_SetIntCase(self, *args)


    def IsIntCase(self, *args):
        """
        IsIntCase(Handle_STEPSelections_SelectDerived self) -> Standard_Boolean

        Tells if this Signature gives integer values
        and returns values from SetIntCase if True

        :type hasmin: bool
        :type valmin: int
        :type hasmax: bool
        :type valmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_IsIntCase(self, *args)


    def AddCase(self, *args):
        """
        AddCase(Handle_STEPSelections_SelectDerived self, Standard_CString const acase)

        Adds a possible case
        To be called when creating, IF the list of possible cases for
        Value is known when starting
        For instance, for CDL types, rather do not fill this,
        but for a specific enumeration (such as a status), can be used

        :type acase: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_AddCase(self, *args)


    def CaseList(self, *args):
        """
        CaseList(Handle_STEPSelections_SelectDerived self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the predefined list of possible cases, filled by AddCase
        Null Handle if no predefined list (hence, to be counted)
        Useful to filter on  really possible vase, for instance, or
        for a help

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_CaseList(self, *args)


    def Name(self, *args):
        """
        Name(Handle_STEPSelections_SelectDerived self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time
        Returns the Signature for a Transient object. It is specific
        of each sub-class of Signature. For a Null Handle, it should
        provide ""
        It can work with the model which contains the entity

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_Name(self, *args)


    def Label(self, *args):
        """
        Label(Handle_STEPSelections_SelectDerived self) -> TCollection_AsciiString

        The label of a Signature uses its name as follow :
        "Signature : <name>"

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_Label(self, *args)


    def MatchValue(self, *args):
        """
        MatchValue(Handle_STEPSelections_SelectDerived self, Standard_CString const val, TCollection_AsciiString text, Standard_Boolean const exact) -> Standard_Boolean

        Default procedure to tell if a value <val> matches a text
        with a criterium <exact>. <exact> = True requires equality,
        else only contained (no reg-exp)

        :type val: OCC.wrapper.Standard.Standard_CString
        :type text: OCC.wrapper.TCollection.TCollection_AsciiString
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_MatchValue(self, *args)


    def IntValue(self, *args):
        """
        IntValue(Handle_STEPSelections_SelectDerived self, Standard_Integer const val) -> Standard_CString

        This procedure converts an Integer to a CString
        It is a convenient way when the value of a signature has the
        form of a simple integer value
        The value is to be used immediately (one buffer only, no copy)

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_IntValue(self, *args)


    def Text(self, *args):
        """
        Text(Handle_STEPSelections_SelectDerived self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns an identification of the Signature (a word), given at
        initialization time
        Specialised to consider context as an InterfaceModel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_Text(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_STEPSelections_SelectDerived self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_ClassName(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_STEPSelections_SelectDerived self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPSelections_SelectDerived self)

        Memory deallocator for transient classes


        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPSelections_SelectDerived self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPSelections_SelectDerived self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPSelections_SelectDerived self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPSelections_SelectDerived self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPSelections_SelectDerived self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPSelections_SelectDerived self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPSelections_SelectDerived self)

        Increments the reference counter of this object


        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPSelections_SelectDerived self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.Handle_STEPSelections_SelectDerived_DecrementRefCounter(self, *args)

Handle_STEPSelections_SelectDerived_swigregister = _STEPSelections.Handle_STEPSelections_SelectDerived_swigregister
Handle_STEPSelections_SelectDerived_swigregister(Handle_STEPSelections_SelectDerived)

def Handle_STEPSelections_SelectDerived_DownCast(thing):
    return _STEPSelections.Handle_STEPSelections_SelectDerived_DownCast(thing)
Handle_STEPSelections_SelectDerived_DownCast = _STEPSelections.Handle_STEPSelections_SelectDerived_DownCast

class NCollection_Sequence_Handle_STEPSelections_AssemblyLink(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyLink > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyLink > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyLink > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyLink > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _STEPSelections.new_NCollection_Sequence_Handle_STEPSelections_AssemblyLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self)

        Reverse sequence


        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theOther) -> NCollection_Sequence_Handle_STEPSelections_AssemblyLink

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theOther) -> NCollection_Sequence_Handle_STEPSelections_AssemblyLink

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyLink > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Handle_STEPSelections_AssemblyLink theItem)
        Append(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Handle_STEPSelections_AssemblyLink theItem)
        Prepend(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex, Handle_STEPSelections_AssemblyLink theItem)
        InsertBefore(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, NCollection_Sequence< opencascade::handle< STEPSelections_AssemblyLink > >::Iterator & thePosition, Handle_STEPSelections_AssemblyLink theItem)
        InsertAfter(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theSeq)
        InsertAfter(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex, Handle_STEPSelections_AssemblyLink theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex, NCollection_Sequence_Handle_STEPSelections_AssemblyLink theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> Handle_STEPSelections_AssemblyLink

        First item access

        :rtype: TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self) -> Handle_STEPSelections_AssemblyLink

        Last item access

        :rtype: TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex) -> Handle_STEPSelections_AssemblyLink

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_STEPSelections_AssemblyLink self, Standard_Integer const theIndex, Handle_STEPSelections_AssemblyLink theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_SetValue(self, *args)


    def __iter__(self):
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink___iter__(self)
    __swig_destroy__ = _STEPSelections.delete_NCollection_Sequence_Handle_STEPSelections_AssemblyLink
NCollection_Sequence_Handle_STEPSelections_AssemblyLink_swigregister = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_swigregister
NCollection_Sequence_Handle_STEPSelections_AssemblyLink_swigregister(NCollection_Sequence_Handle_STEPSelections_AssemblyLink)

def NCollection_Sequence_Handle_STEPSelections_AssemblyLink_delNode(*args):
    """
    NCollection_Sequence_Handle_STEPSelections_AssemblyLink_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_delNode(*args)

class NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPSelections.new_NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPSelections.delete_NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper

    def __next__(self):
        return _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper___next__(self)
NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper_swigregister = _STEPSelections.NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper_swigregister
NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper_swigregister(NCollection_Sequence_Handle_STEPSelections_AssemblyLink_IteratorHelper)


try:
	STEPSelections_SequenceOfAssemblyLink = NCollection_Sequence_Handle_STEPSelections_AssemblyLink
except NameError:
	pass # does not exist, probably ignored




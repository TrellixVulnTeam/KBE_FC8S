# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MoniTool')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MoniTool')
    _MoniTool = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MoniTool', [dirname(__file__)])
        except ImportError:
            import _MoniTool
            return _MoniTool
        try:
            _mod = imp.load_module('_MoniTool', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MoniTool = swig_import_helper()
    del swig_import_helper
else:
    import _MoniTool
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MoniTool.delete_SwigPyIterator

    def value(self):
        return _MoniTool.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _MoniTool.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _MoniTool.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _MoniTool.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _MoniTool.SwigPyIterator_equal(self, x)

    def copy(self):
        return _MoniTool.SwigPyIterator_copy(self)

    def next(self):
        return _MoniTool.SwigPyIterator_next(self)

    def __next__(self):
        return _MoniTool.SwigPyIterator___next__(self)

    def previous(self):
        return _MoniTool.SwigPyIterator_previous(self)

    def advance(self, n):
        return _MoniTool.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _MoniTool.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _MoniTool.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _MoniTool.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _MoniTool.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _MoniTool.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _MoniTool.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _MoniTool.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MoniTool.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_MoniTool.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _MoniTool.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MoniTool.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _MoniTool.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _MoniTool.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _MoniTool.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MoniTool.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_MoniTool.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _MoniTool.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MoniTool.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _MoniTool.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _MoniTool.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _MoniTool.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _MoniTool.ptr_to_number(item)
ptr_to_number = _MoniTool.ptr_to_number

def HashCode(*args):
    return _MoniTool.HashCode(*args)
HashCode = _MoniTool.HashCode

def ptr_equal(a, b):
    return _MoniTool.ptr_equal(a, b)
ptr_equal = _MoniTool.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
MoniTool_ValueMisc = _MoniTool.MoniTool_ValueMisc
MoniTool_ValueInteger = _MoniTool.MoniTool_ValueInteger
MoniTool_ValueReal = _MoniTool.MoniTool_ValueReal
MoniTool_ValueIdent = _MoniTool.MoniTool_ValueIdent
MoniTool_ValueVoid = _MoniTool.MoniTool_ValueVoid
MoniTool_ValueText = _MoniTool.MoniTool_ValueText
MoniTool_ValueEnum = _MoniTool.MoniTool_ValueEnum
MoniTool_ValueLogical = _MoniTool.MoniTool_ValueLogical
MoniTool_ValueSub = _MoniTool.MoniTool_ValueSub
MoniTool_ValueHexa = _MoniTool.MoniTool_ValueHexa
MoniTool_ValueBinary = _MoniTool.MoniTool_ValueBinary
class MoniTool_HSequenceOfElement(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_HSequenceOfElement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_HSequenceOfElement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_HSequenceOfElement self) -> MoniTool_HSequenceOfElement
        __init__(MoniTool_HSequenceOfElement self, NCollection_Sequence_Handle_MoniTool_Element theOther) -> MoniTool_HSequenceOfElement

        :type theOther: OCC.wrapper.MoniTool.MoniTool_SequenceOfElement

        """
        this = _MoniTool.new_MoniTool_HSequenceOfElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.MoniTool.MoniTool_SequenceOfElement

        """
        res = _MoniTool.MoniTool_HSequenceOfElement_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(MoniTool_HSequenceOfElement self, Handle_MoniTool_Element theItem)
        Append(MoniTool_HSequenceOfElement self, NCollection_Sequence_Handle_MoniTool_Element theSequence)

        :type theSequence: OCC.wrapper.MoniTool.MoniTool_SequenceOfElement

        """
        return _MoniTool.MoniTool_HSequenceOfElement_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(MoniTool_HSequenceOfElement self) -> NCollection_Sequence_Handle_MoniTool_Element

        :rtype: OCC.wrapper.MoniTool.MoniTool_SequenceOfElement

        """
        return _MoniTool.MoniTool_HSequenceOfElement_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_HSequenceOfElement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_HSequenceOfElement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_HSequenceOfElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_HSequenceOfElement
MoniTool_HSequenceOfElement_swigregister = _MoniTool.MoniTool_HSequenceOfElement_swigregister
MoniTool_HSequenceOfElement_swigregister(MoniTool_HSequenceOfElement)

def MoniTool_HSequenceOfElement_get_type_name(*args):
    """
    MoniTool_HSequenceOfElement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_HSequenceOfElement_get_type_name(*args)

def MoniTool_HSequenceOfElement_get_type_descriptor(*args):
    """
    MoniTool_HSequenceOfElement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_HSequenceOfElement_get_type_descriptor(*args)

class MoniTool_Element(Standard.Standard_Transient):
    """
    a Element allows to map any kind of object as a Key for a Map.
    This works by defining, for a Hash Code, that of the real Key,
    not of the Element which acts only as an intermediate.
    When a Map asks for the HashCode of a Element, this one returns
    the code it has determined at creation time
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_Element
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_Element(self) 
            return h


    def GetHashCode(self, *args):
        """
        GetHashCode(MoniTool_Element self) -> Standard_Integer

        Returns the HashCode which has been stored by SetHashCode
        (remark that HashCode could be deferred then be defined by
        sub-classes, the result is the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_Element_GetHashCode(self, *args)


    def Equates(self, *args):
        """
        Equates(MoniTool_Element self, Handle_MoniTool_Element other) -> Standard_Boolean

        Specific testof equallity : to be defined by each sub-class,
        must be False if Elements have not the same true Type, else
        their contents must be compared

        :type other: OCC.wrapper.MoniTool.Handle_MoniTool_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_Element_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(MoniTool_Element self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_Element_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(MoniTool_Element self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_Element_ValueTypeName(self, *args)


    def ListAttr(self, *args):
        """
        Returns (readonly) the Attribute List

        :rtype: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        res = _MoniTool.MoniTool_Element_ListAttr(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeAttr(self, *args):
        """
        ChangeAttr(MoniTool_Element self) -> MoniTool_AttrList

        Returns (modifiable) the Attribute List

        :rtype: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        return _MoniTool.MoniTool_Element_ChangeAttr(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_Element_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_Element_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_Element_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_Element
MoniTool_Element_swigregister = _MoniTool.MoniTool_Element_swigregister
MoniTool_Element_swigregister(MoniTool_Element)

def MoniTool_Element_get_type_name(*args):
    """
    MoniTool_Element_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_Element_get_type_name(*args)

def MoniTool_Element_get_type_descriptor(*args):
    """
    MoniTool_Element_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_Element_get_type_descriptor(*args)

class MoniTool_Timer(Standard.Standard_Transient):
    """
    Provides convenient service on global timers
    accessed by string name, mostly aimed for debugging purposes

    As an instance, envelopes the OSD_Timer to have it as Handle

    As a tool, supports static dictionary of timers
    and provides static methods to easily access them
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_Timer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_Timer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_Timer self) -> MoniTool_Timer

        Create timer in empty state


        """
        this = _MoniTool.new_MoniTool_Timer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reset(self, *args):
        """
        Reset(MoniTool_Timer self)

        Start, Stop and reset the timer
        In addition to doing that to embedded OSD_Timer,
        manage also counter of hits


        """
        return _MoniTool.MoniTool_Timer_Reset(self, *args)


    def Count(self, *args):
        """
        Count(MoniTool_Timer self) -> Standard_Integer

        Return value of hits counter (count of Start/Stop pairs)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_Timer_Count(self, *args)


    def IsRunning(self, *args):
        """
        IsRunning(MoniTool_Timer self) -> Standard_Integer

        Returns value of nesting counter

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_Timer_IsRunning(self, *args)


    def CPU(self, *args):
        """
        CPU(MoniTool_Timer self) -> Standard_Real

        Return value of CPU time minus accumulated amendment

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_Timer_CPU(self, *args)


    def Amend(self, *args):
        """
        Amend(MoniTool_Timer self) -> Standard_Real

        Return value of accumulated amendment on CPU time

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_Timer_Amend(self, *args)


    def Dump(self, *args):
        """
        Dump(MoniTool_Timer self, Standard_OStream & ostr)

        Dumps current state of a timer shortly (one-line output)

        :type ostr: OCC.wrapper.Standard.Standard_OStream

        """
        return _MoniTool.MoniTool_Timer_Dump(self, *args)


    def Timer(*args):
        """
        Timer() -> OSD_Timer
        Timer() -> OSD_Timer
        Timer(Standard_CString const name) -> Handle_MoniTool_Timer

        Returns a timer from a dictionary by its name
        If timer not existed, creates a new one

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_Timer

        """
        return _MoniTool.MoniTool_Timer_Timer(*args)

    Timer = staticmethod(Timer)

    def Start(*args):
        """
        Start()
        Start(Standard_CString const name)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_Timer_Start(*args)

    Start = staticmethod(Start)

    def Stop(*args):
        """
        Stop()
        Stop(Standard_CString const name)

        Inline methods to conveniently start/stop timer by name
        Shortcut to Timer(name)->Start/Stop()

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_Timer_Stop(*args)

    Stop = staticmethod(Stop)

    def Dictionary(*args):
        """
        Dictionary() -> NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher

        Returns map of timers

        :rtype: OCC.wrapper.MoniTool.MoniTool_DataMapOfTimer

        """
        return _MoniTool.MoniTool_Timer_Dictionary(*args)

    Dictionary = staticmethod(Dictionary)

    def ClearTimers(*args):
        """
        ClearTimers()

        Clears map of timers


        """
        return _MoniTool.MoniTool_Timer_ClearTimers(*args)

    ClearTimers = staticmethod(ClearTimers)

    def DumpTimers(*args):
        """
        DumpTimers(Standard_OStream & ostr)

        Dumps contents of the whole dictionary

        :type ostr: OCC.wrapper.Standard.Standard_OStream

        """
        return _MoniTool.MoniTool_Timer_DumpTimers(*args)

    DumpTimers = staticmethod(DumpTimers)

    def ComputeAmendments(*args):
        """
        ComputeAmendments()

        Computes and remembers amendments for times to
        access, start, and stop of timer, and estimates
        second-order error measured by 10 nested timers


        """
        return _MoniTool.MoniTool_Timer_ComputeAmendments(*args)

    ComputeAmendments = staticmethod(ComputeAmendments)

    def GetAmendments(*args):
        """
        GetAmendments()

        The computed amendmens are returned (for information only)

        :type Access: float
        :type Internal: float
        :type External: float
        :type Error10: float

        """
        return _MoniTool.MoniTool_Timer_GetAmendments(*args)

    GetAmendments = staticmethod(GetAmendments)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_Timer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_Timer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_Timer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_Timer
MoniTool_Timer_swigregister = _MoniTool.MoniTool_Timer_swigregister
MoniTool_Timer_swigregister(MoniTool_Timer)

def MoniTool_Timer_Timer(*args):
    """
    Timer() -> OSD_Timer
    Timer() -> OSD_Timer
    MoniTool_Timer_Timer(Standard_CString const name) -> Handle_MoniTool_Timer

    Returns a timer from a dictionary by its name
    If timer not existed, creates a new one

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_Timer

    """
    return _MoniTool.MoniTool_Timer_Timer(*args)

def MoniTool_Timer_Start(*args):
    """
    Start()
    MoniTool_Timer_Start(Standard_CString const name)

    :type name: OCC.wrapper.Standard.Standard_CString

    """
    return _MoniTool.MoniTool_Timer_Start(*args)

def MoniTool_Timer_Stop(*args):
    """
    Stop()
    MoniTool_Timer_Stop(Standard_CString const name)

    Inline methods to conveniently start/stop timer by name
    Shortcut to Timer(name)->Start/Stop()

    :type name: OCC.wrapper.Standard.Standard_CString

    """
    return _MoniTool.MoniTool_Timer_Stop(*args)

def MoniTool_Timer_Dictionary(*args):
    """
    MoniTool_Timer_Dictionary() -> NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher

    Returns map of timers

    :rtype: OCC.wrapper.MoniTool.MoniTool_DataMapOfTimer

    """
    return _MoniTool.MoniTool_Timer_Dictionary(*args)

def MoniTool_Timer_ClearTimers(*args):
    """
    MoniTool_Timer_ClearTimers()

    Clears map of timers


    """
    return _MoniTool.MoniTool_Timer_ClearTimers(*args)

def MoniTool_Timer_DumpTimers(*args):
    """
    MoniTool_Timer_DumpTimers(Standard_OStream & ostr)

    Dumps contents of the whole dictionary

    :type ostr: OCC.wrapper.Standard.Standard_OStream

    """
    return _MoniTool.MoniTool_Timer_DumpTimers(*args)

def MoniTool_Timer_ComputeAmendments(*args):
    """
    MoniTool_Timer_ComputeAmendments()

    Computes and remembers amendments for times to
    access, start, and stop of timer, and estimates
    second-order error measured by 10 nested timers


    """
    return _MoniTool.MoniTool_Timer_ComputeAmendments(*args)

def MoniTool_Timer_GetAmendments(*args):
    """
    MoniTool_Timer_GetAmendments()

    The computed amendmens are returned (for information only)

    :type Access: float
    :type Internal: float
    :type External: float
    :type Error10: float

    """
    return _MoniTool.MoniTool_Timer_GetAmendments(*args)

def MoniTool_Timer_get_type_name(*args):
    """
    MoniTool_Timer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_Timer_get_type_name(*args)

def MoniTool_Timer_get_type_descriptor(*args):
    """
    MoniTool_Timer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_Timer_get_type_descriptor(*args)

class MoniTool_SignText(Standard.Standard_Transient):
    """
    Provides the basic service to get a text which identifies
    an object in a context
    It can be used for other classes (general signatures ...)
    It can also be used to build a message in which an object
    is to be identified
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_SignText
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_SignText(self) 
            return h


    def Name(self, *args):
        """
        Name(MoniTool_SignText self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_SignText_Name(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(MoniTool_SignText self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.MoniTool_SignText_TextAlone(self, *args)


    def Text(self, *args):
        """
        Text(MoniTool_SignText self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Gives a text as a signature for a transient object in a context
        If the context is senseless, it can be given as Null Handle
        empty result if nothing to give (at least the DynamicType could
        be sent ?)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.MoniTool_SignText_Text(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_SignText_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_SignText_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_SignText_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_SignText
MoniTool_SignText_swigregister = _MoniTool.MoniTool_SignText_swigregister
MoniTool_SignText_swigregister(MoniTool_SignText)

def MoniTool_SignText_get_type_name(*args):
    """
    MoniTool_SignText_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_SignText_get_type_name(*args)

def MoniTool_SignText_get_type_descriptor(*args):
    """
    MoniTool_SignText_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_SignText_get_type_descriptor(*args)

class MoniTool_TransientElem(MoniTool_Element):
    """
    an TransientElem defines an Element for a specific input class
    its definition includes the value of the Key to be mapped,
    and the HashCoder associated to the class of the Key

    Transient from Standard defines the class to be keyed
    MapTransientHasher from TColStd is the associated Hasher
    DataInfo from MoniTool   is an additionnal class which helps to provide
    informations on the value (template : see DataInfo)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_TransientElem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_TransientElem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_TransientElem self, Handle_Standard_Transient akey) -> MoniTool_TransientElem

        Creates a TransientElem with a Value. This Value can then not be
        changed. It is used by the Hasher to compute the HashCode,
        which will then be stored for an immediate reading.

        :type akey: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        this = _MoniTool.new_MoniTool_TransientElem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Returns the contained value

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _MoniTool.MoniTool_TransientElem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Equates(self, *args):
        """
        Equates(MoniTool_TransientElem self, Handle_MoniTool_Element other) -> Standard_Boolean

        Specific testof equallity : defined as False if <other> has
        not the same true Type, else contents are compared (by
        C++ operator ==)

        :type other: OCC.wrapper.MoniTool.Handle_MoniTool_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TransientElem_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(MoniTool_TransientElem self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_TransientElem_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(MoniTool_TransientElem self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TransientElem_ValueTypeName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_TransientElem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_TransientElem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_TransientElem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_TransientElem
MoniTool_TransientElem_swigregister = _MoniTool.MoniTool_TransientElem_swigregister
MoniTool_TransientElem_swigregister(MoniTool_TransientElem)

def MoniTool_TransientElem_get_type_name(*args):
    """
    MoniTool_TransientElem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_TransientElem_get_type_name(*args)

def MoniTool_TransientElem_get_type_descriptor(*args):
    """
    MoniTool_TransientElem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_TransientElem_get_type_descriptor(*args)

class MoniTool_MTHasher(object):
    """The auxiliary class provides hash code for mapping objects"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(Standard_CString const Str, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value for the CString <Str>  in the
        range 0..Upper.
        Default ::HashCode(Str,Upper)

        :type Str: OCC.wrapper.Standard.Standard_CString
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_MTHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Standard_CString const Str1, Standard_CString const Str2) -> Standard_Boolean

        Returns True  when the two CString are the same. Two
        same strings must have the same hashcode, the
        contrary is not necessary.
        Default Str1 == Str2

        :type Str1: OCC.wrapper.Standard.Standard_CString
        :type Str2: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_MTHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """The auxiliary class provides hash code for mapping objects"""
        this = _MoniTool.new_MoniTool_MTHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_MoniTool_MTHasher
MoniTool_MTHasher_swigregister = _MoniTool.MoniTool_MTHasher_swigregister
MoniTool_MTHasher_swigregister(MoniTool_MTHasher)

def MoniTool_MTHasher_HashCode(*args):
    """
    MoniTool_MTHasher_HashCode(Standard_CString const Str, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value for the CString <Str>  in the
    range 0..Upper.
    Default ::HashCode(Str,Upper)

    :type Str: OCC.wrapper.Standard.Standard_CString
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _MoniTool.MoniTool_MTHasher_HashCode(*args)

def MoniTool_MTHasher_IsEqual(*args):
    """
    MoniTool_MTHasher_IsEqual(Standard_CString const Str1, Standard_CString const Str2) -> Standard_Boolean

    Returns True  when the two CString are the same. Two
    same strings must have the same hashcode, the
    contrary is not necessary.
    Default Str1 == Str2

    :type Str1: OCC.wrapper.Standard.Standard_CString
    :type Str2: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _MoniTool.MoniTool_MTHasher_IsEqual(*args)

class Handle_MoniTool_HSequenceOfElement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_HSequenceOfElement self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_HSequenceOfElement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_HSequenceOfElement self, MoniTool_HSequenceOfElement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_HSequenceOfElement self, Handle_MoniTool_HSequenceOfElement theHandle) -> Handle_MoniTool_HSequenceOfElement
        assign(Handle_MoniTool_HSequenceOfElement self, MoniTool_HSequenceOfElement thePtr) -> Handle_MoniTool_HSequenceOfElement
        assign(Handle_MoniTool_HSequenceOfElement self, Handle_MoniTool_HSequenceOfElement theHandle) -> Handle_MoniTool_HSequenceOfElement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_HSequenceOfElement self) -> MoniTool_HSequenceOfElement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_HSequenceOfElement self) -> MoniTool_HSequenceOfElement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_HSequenceOfElement self) -> MoniTool_HSequenceOfElement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_HSequenceOfElement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_HSequenceOfElement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_HSequenceOfElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_HSequenceOfElement_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_HSequenceOfElement

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.MoniTool.MoniTool_SequenceOfElement

        """
        res = _MoniTool.Handle_MoniTool_HSequenceOfElement_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_MoniTool_HSequenceOfElement self, Handle_MoniTool_Element theItem)
        Append(Handle_MoniTool_HSequenceOfElement self, NCollection_Sequence_Handle_MoniTool_Element theSequence)

        :type theSequence: OCC.wrapper.MoniTool.MoniTool_SequenceOfElement

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_MoniTool_HSequenceOfElement self) -> NCollection_Sequence_Handle_MoniTool_Element

        :rtype: OCC.wrapper.MoniTool.MoniTool_SequenceOfElement

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_HSequenceOfElement self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_HSequenceOfElement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_HSequenceOfElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_HSequenceOfElement self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_HSequenceOfElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_HSequenceOfElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_HSequenceOfElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_HSequenceOfElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_HSequenceOfElement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_HSequenceOfElement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_HSequenceOfElement self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_HSequenceOfElement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_HSequenceOfElement_DecrementRefCounter(self, *args)

Handle_MoniTool_HSequenceOfElement_swigregister = _MoniTool.Handle_MoniTool_HSequenceOfElement_swigregister
Handle_MoniTool_HSequenceOfElement_swigregister(Handle_MoniTool_HSequenceOfElement)

def Handle_MoniTool_HSequenceOfElement_DownCast(thing):
    return _MoniTool.Handle_MoniTool_HSequenceOfElement_DownCast(thing)
Handle_MoniTool_HSequenceOfElement_DownCast = _MoniTool.Handle_MoniTool_HSequenceOfElement_DownCast

class NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _MoniTool.new_NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, Handle_Standard_Transient theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, Handle_Standard_Transient theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> Handle_Standard_Transient

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Handle_Standard_Transient

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _MoniTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_swigregister = _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MoniTool.new_NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _MoniTool.NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper)


try:
	MoniTool_IndexedDataMapOfShapeTransient = NCollection_IndexedDataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class MoniTool_ElemHasher(object):
    """
    ElemHasher defines HashCode for Element, which is : ask a
    Element its HashCode !  Because this is the Element itself
    which brings the HashCode for its Key

    This class complies to the template given in TCollection by
    MapHasher itself
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(Handle_MoniTool_Element K, Standard_Integer const Upper) -> Standard_Integer

        Returns a HashCode in the range <0,Upper> for a Element :
        asks the Element its HashCode then transforms it to be in the
        required range

        :type K: OCC.wrapper.MoniTool.Handle_MoniTool_Element
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_ElemHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Handle_MoniTool_Element K1, Handle_MoniTool_Element K2) -> Standard_Boolean

        Returns True if two keys are the same.
        The test does not work on the Elements themselves but by
        calling their methods Equates

        :type K1: OCC.wrapper.MoniTool.Handle_MoniTool_Element
        :type K2: OCC.wrapper.MoniTool.Handle_MoniTool_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_ElemHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        ElemHasher defines HashCode for Element, which is : ask a
        Element its HashCode !  Because this is the Element itself
        which brings the HashCode for its Key

        This class complies to the template given in TCollection by
        MapHasher itself
        """
        this = _MoniTool.new_MoniTool_ElemHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_MoniTool_ElemHasher
MoniTool_ElemHasher_swigregister = _MoniTool.MoniTool_ElemHasher_swigregister
MoniTool_ElemHasher_swigregister(MoniTool_ElemHasher)

def MoniTool_ElemHasher_HashCode(*args):
    """
    MoniTool_ElemHasher_HashCode(Handle_MoniTool_Element K, Standard_Integer const Upper) -> Standard_Integer

    Returns a HashCode in the range <0,Upper> for a Element :
    asks the Element its HashCode then transforms it to be in the
    required range

    :type K: OCC.wrapper.MoniTool.Handle_MoniTool_Element
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _MoniTool.MoniTool_ElemHasher_HashCode(*args)

def MoniTool_ElemHasher_IsEqual(*args):
    """
    MoniTool_ElemHasher_IsEqual(Handle_MoniTool_Element K1, Handle_MoniTool_Element K2) -> Standard_Boolean

    Returns True if two keys are the same.
    The test does not work on the Elements themselves but by
    calling their methods Equates

    :type K1: OCC.wrapper.MoniTool.Handle_MoniTool_Element
    :type K2: OCC.wrapper.MoniTool.Handle_MoniTool_Element
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _MoniTool.MoniTool_ElemHasher_IsEqual(*args)

class Handle_MoniTool_Timer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_Timer self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_Timer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_Timer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_Timer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_Timer self, MoniTool_Timer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_Timer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_Timer self, Handle_MoniTool_Timer theHandle) -> Handle_MoniTool_Timer
        assign(Handle_MoniTool_Timer self, MoniTool_Timer thePtr) -> Handle_MoniTool_Timer
        assign(Handle_MoniTool_Timer self, Handle_MoniTool_Timer theHandle) -> Handle_MoniTool_Timer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_Timer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_Timer self) -> MoniTool_Timer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_Timer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_Timer self) -> MoniTool_Timer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_Timer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_Timer self) -> MoniTool_Timer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_Timer___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_Timer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_Timer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_Timer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_Timer_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_Timer

    def Timer(self, *args):
        """
        :rtype: OCC.wrapper.OSD.OSD_Timer

        """
        res = _MoniTool.Handle_MoniTool_Timer_Timer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Start(self, *args):
        """
        Start(Handle_MoniTool_Timer self)
        Start(Handle_MoniTool_Timer self, Standard_CString const name)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_Timer_Start(self, *args)


    def Stop(self, *args):
        """
        Stop(Handle_MoniTool_Timer self)
        Stop(Handle_MoniTool_Timer self, Standard_CString const name)

        Inline methods to conveniently start/stop timer by name
        Shortcut to Timer(name)->Start/Stop()

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_Timer_Stop(self, *args)


    def Reset(self, *args):
        """
        Reset(Handle_MoniTool_Timer self)

        Start, Stop and reset the timer
        In addition to doing that to embedded OSD_Timer,
        manage also counter of hits


        """
        return _MoniTool.Handle_MoniTool_Timer_Reset(self, *args)


    def Count(self, *args):
        """
        Count(Handle_MoniTool_Timer self) -> Standard_Integer

        Return value of hits counter (count of Start/Stop pairs)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_Timer_Count(self, *args)


    def IsRunning(self, *args):
        """
        IsRunning(Handle_MoniTool_Timer self) -> Standard_Integer

        Returns value of nesting counter

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_Timer_IsRunning(self, *args)


    def CPU(self, *args):
        """
        CPU(Handle_MoniTool_Timer self) -> Standard_Real

        Return value of CPU time minus accumulated amendment

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.Handle_MoniTool_Timer_CPU(self, *args)


    def Amend(self, *args):
        """
        Amend(Handle_MoniTool_Timer self) -> Standard_Real

        Return value of accumulated amendment on CPU time

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.Handle_MoniTool_Timer_Amend(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_MoniTool_Timer self, Standard_OStream & ostr)

        Dumps current state of a timer shortly (one-line output)

        :type ostr: OCC.wrapper.Standard.Standard_OStream

        """
        return _MoniTool.Handle_MoniTool_Timer_Dump(self, *args)


    def Dictionary(self, *args):
        """
        Dictionary(Handle_MoniTool_Timer self) -> NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher

        Returns map of timers

        :rtype: OCC.wrapper.MoniTool.MoniTool_DataMapOfTimer

        """
        return _MoniTool.Handle_MoniTool_Timer_Dictionary(self, *args)


    def ClearTimers(self, *args):
        """
        ClearTimers(Handle_MoniTool_Timer self)

        Clears map of timers


        """
        return _MoniTool.Handle_MoniTool_Timer_ClearTimers(self, *args)


    def DumpTimers(self, *args):
        """
        DumpTimers(Handle_MoniTool_Timer self, Standard_OStream & ostr)

        Dumps contents of the whole dictionary

        :type ostr: OCC.wrapper.Standard.Standard_OStream

        """
        return _MoniTool.Handle_MoniTool_Timer_DumpTimers(self, *args)


    def ComputeAmendments(self, *args):
        """
        ComputeAmendments(Handle_MoniTool_Timer self)

        Computes and remembers amendments for times to
        access, start, and stop of timer, and estimates
        second-order error measured by 10 nested timers


        """
        return _MoniTool.Handle_MoniTool_Timer_ComputeAmendments(self, *args)


    def GetAmendments(self, *args):
        """
        GetAmendments(Handle_MoniTool_Timer self)

        The computed amendmens are returned (for information only)

        :type Access: float
        :type Internal: float
        :type External: float
        :type Error10: float

        """
        return _MoniTool.Handle_MoniTool_Timer_GetAmendments(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_Timer self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_Timer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_Timer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_Timer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_Timer self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_Timer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_Timer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_Timer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_Timer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_Timer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_Timer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_Timer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_Timer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_Timer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_Timer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_Timer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_Timer self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_Timer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_Timer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_Timer_DecrementRefCounter(self, *args)

Handle_MoniTool_Timer_swigregister = _MoniTool.Handle_MoniTool_Timer_swigregister
Handle_MoniTool_Timer_swigregister(Handle_MoniTool_Timer)

def Handle_MoniTool_Timer_DownCast(thing):
    return _MoniTool.Handle_MoniTool_Timer_DownCast(thing)
Handle_MoniTool_Timer_DownCast = _MoniTool.Handle_MoniTool_Timer_DownCast

class MoniTool_SignShape(MoniTool_SignText):
    """
    Signs HShape according to its real content (type of Shape)
    Context is not used
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_SignShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_SignShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_SignShape self) -> MoniTool_SignShape

        Signs HShape according to its real content (type of Shape)
        Context is not used
        """
        this = _MoniTool.new_MoniTool_SignShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        Name(MoniTool_SignShape self) -> Standard_CString

        Returns "SHAPE"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_SignShape_Name(self, *args)


    def Text(self, *args):
        """
        Text(MoniTool_SignShape self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns for a HShape, the string of its ShapeEnum
        The Model is absolutely useless (may be null)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.MoniTool_SignShape_Text(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_SignShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_SignShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_SignShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_SignShape
MoniTool_SignShape_swigregister = _MoniTool.MoniTool_SignShape_swigregister
MoniTool_SignShape_swigregister(MoniTool_SignShape)

def MoniTool_SignShape_get_type_name(*args):
    """
    MoniTool_SignShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_SignShape_get_type_name(*args)

def MoniTool_SignShape_get_type_descriptor(*args):
    """
    MoniTool_SignShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_SignShape_get_type_descriptor(*args)

class NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Standard_Transient >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MoniTool.new_NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_Standard_Transient theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_Standard_Transient theItem) -> Handle_Standard_Transient

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_Standard_Transient

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _MoniTool.delete_NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_swigregister = _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MoniTool.new_NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _MoniTool.NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher_IteratorHelper)


try:
	MoniTool_DataMapOfShapeTransient = NCollection_DataMap_TopoDS_Shape_Handle_Standard_Transient_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MoniTool_SignShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_SignShape self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_SignShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_SignShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_SignShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_SignShape self, MoniTool_SignShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_SignShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_SignShape self, Handle_MoniTool_SignShape theHandle) -> Handle_MoniTool_SignShape
        assign(Handle_MoniTool_SignShape self, MoniTool_SignShape thePtr) -> Handle_MoniTool_SignShape
        assign(Handle_MoniTool_SignShape self, Handle_MoniTool_SignShape theHandle) -> Handle_MoniTool_SignShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_SignShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_SignShape self) -> MoniTool_SignShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_SignShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_SignShape self) -> MoniTool_SignShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_SignShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_SignShape self) -> MoniTool_SignShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_SignShape___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_SignShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_SignShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_SignShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_SignShape_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_SignShape

    def Name(self, *args):
        """
        Name(Handle_MoniTool_SignShape self) -> Standard_CString

        Returns "SHAPE"

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_SignShape_Name(self, *args)


    def Text(self, *args):
        """
        Text(Handle_MoniTool_SignShape self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Returns for a HShape, the string of its ShapeEnum
        The Model is absolutely useless (may be null)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.Handle_MoniTool_SignShape_Text(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_SignShape self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_SignShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_SignShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_SignShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TextAlone(self, *args):
        """
        TextAlone(Handle_MoniTool_SignShape self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.Handle_MoniTool_SignShape_TextAlone(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_SignShape self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_SignShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_SignShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_SignShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_SignShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_SignShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_SignShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_SignShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_SignShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_SignShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_SignShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_SignShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_SignShape self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_SignShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_SignShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_SignShape_DecrementRefCounter(self, *args)

Handle_MoniTool_SignShape_swigregister = _MoniTool.Handle_MoniTool_SignShape_swigregister
Handle_MoniTool_SignShape_swigregister(Handle_MoniTool_SignShape)

def Handle_MoniTool_SignShape_DownCast(thing):
    return _MoniTool.Handle_MoniTool_SignShape_DownCast(thing)
Handle_MoniTool_SignShape_DownCast = _MoniTool.Handle_MoniTool_SignShape_DownCast

class Handle_MoniTool_Element(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_Element self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_Element_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_Element self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_Element_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_Element self, MoniTool_Element thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_Element_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_Element self, Handle_MoniTool_Element theHandle) -> Handle_MoniTool_Element
        assign(Handle_MoniTool_Element self, MoniTool_Element thePtr) -> Handle_MoniTool_Element
        assign(Handle_MoniTool_Element self, Handle_MoniTool_Element theHandle) -> Handle_MoniTool_Element

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_Element_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_Element self) -> MoniTool_Element

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_Element_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_Element self) -> MoniTool_Element

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_Element___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_Element self) -> MoniTool_Element

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_Element___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_Element___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_Element___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_Element(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_Element_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_Element

    def GetHashCode(self, *args):
        """
        GetHashCode(Handle_MoniTool_Element self) -> Standard_Integer

        Returns the HashCode which has been stored by SetHashCode
        (remark that HashCode could be deferred then be defined by
        sub-classes, the result is the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_Element_GetHashCode(self, *args)


    def Equates(self, *args):
        """
        Equates(Handle_MoniTool_Element self, Handle_MoniTool_Element other) -> Standard_Boolean

        Specific testof equallity : to be defined by each sub-class,
        must be False if Elements have not the same true Type, else
        their contents must be compared

        :type other: OCC.wrapper.MoniTool.Handle_MoniTool_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_Element_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Handle_MoniTool_Element self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.Handle_MoniTool_Element_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(Handle_MoniTool_Element self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_Element_ValueTypeName(self, *args)


    def ListAttr(self, *args):
        """
        Returns (readonly) the Attribute List

        :rtype: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        res = _MoniTool.Handle_MoniTool_Element_ListAttr(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeAttr(self, *args):
        """
        ChangeAttr(Handle_MoniTool_Element self) -> MoniTool_AttrList

        Returns (modifiable) the Attribute List

        :rtype: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        return _MoniTool.Handle_MoniTool_Element_ChangeAttr(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_Element self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_Element_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_Element_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_Element_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_Element self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_Element_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_Element self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_Element self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_Element_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_Element self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_Element self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_Element_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_Element self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_Element_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_Element self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_Element_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_Element self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_Element_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_Element self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_Element_DecrementRefCounter(self, *args)

Handle_MoniTool_Element_swigregister = _MoniTool.Handle_MoniTool_Element_swigregister
Handle_MoniTool_Element_swigregister(Handle_MoniTool_Element)

def Handle_MoniTool_Element_DownCast(thing):
    return _MoniTool.Handle_MoniTool_Element_DownCast(thing)
Handle_MoniTool_Element_DownCast = _MoniTool.Handle_MoniTool_Element_DownCast

class MoniTool_AttrList(object):
    """
    a AttrList allows to record a list of attributes as Transients
    which can be edited, changed ...
    Each one is identified by a name
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(MoniTool_AttrList self) -> MoniTool_AttrList
        __init__(MoniTool_AttrList self, MoniTool_AttrList other) -> MoniTool_AttrList

        Creates an AttrList from another one, definitions are shared
        (calls SameAttributes)

        :type other: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        this = _MoniTool.new_MoniTool_AttrList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAttribute(self, *args):
        """
        SetAttribute(MoniTool_AttrList self, Standard_CString const name, Handle_Standard_Transient val)

        Adds an attribute with a given name (replaces the former one
        with the same name if already exists)

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.MoniTool_AttrList_SetAttribute(self, *args)


    def RemoveAttribute(self, *args):
        """
        RemoveAttribute(MoniTool_AttrList self, Standard_CString const name) -> Standard_Boolean

        Removes an attribute
        Returns True when done, False if this attribute did not exist

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_AttrList_RemoveAttribute(self, *args)


    def GetAttribute(self, *args):
        """
        GetAttribute(MoniTool_AttrList self, Standard_CString const name, Handle_Standard_Type type, Handle_Standard_Transient val) -> Standard_Boolean

        Returns an attribute from its name, filtered by a type
        If no attribute has this name, or if it is not kind of this
        type, <val> is Null and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_AttrList_GetAttribute(self, *args)


    def Attribute(self, *args):
        """
        Attribute(MoniTool_AttrList self, Standard_CString const name) -> Handle_Standard_Transient

        Returns an attribute from its name. Null Handle if not
        recorded         (whatever Transient, Integer, Real ...)
        Integer is recorded as IntVal
        Real is recorded as RealVal
        Text is recorded as HAsciiString

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.MoniTool_AttrList_Attribute(self, *args)


    def AttributeType(self, *args):
        """
        AttributeType(MoniTool_AttrList self, Standard_CString const name) -> MoniTool_ValueType

        Returns the type of an attribute :
        ValueInt , ValueReal , ValueText (String) , ValueIdent (any)
        or ValueVoid (not recorded)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _MoniTool.MoniTool_AttrList_AttributeType(self, *args)


    def SetIntegerAttribute(self, *args):
        """
        SetIntegerAttribute(MoniTool_AttrList self, Standard_CString const name, Standard_Integer const val)

        Adds an integer value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int

        """
        return _MoniTool.MoniTool_AttrList_SetIntegerAttribute(self, *args)


    def GetIntegerAttribute(self, *args):
        """
        GetIntegerAttribute(MoniTool_AttrList self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as integer
        If no attribute has this name, or not an integer,
        <val> is 0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_AttrList_GetIntegerAttribute(self, *args)


    def IntegerAttribute(self, *args):
        """
        IntegerAttribute(MoniTool_AttrList self, Standard_CString const name) -> Standard_Integer

        Returns an integer attribute from its name. 0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_AttrList_IntegerAttribute(self, *args)


    def SetRealAttribute(self, *args):
        """
        SetRealAttribute(MoniTool_AttrList self, Standard_CString const name, Standard_Real const val)

        Adds a real value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float

        """
        return _MoniTool.MoniTool_AttrList_SetRealAttribute(self, *args)


    def GetRealAttribute(self, *args):
        """
        GetRealAttribute(MoniTool_AttrList self, Standard_CString const name) -> Standard_Boolean

        Returns an attribute from its name, as real
        If no attribute has this name, or not a real
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_AttrList_GetRealAttribute(self, *args)


    def RealAttribute(self, *args):
        """
        RealAttribute(MoniTool_AttrList self, Standard_CString const name) -> Standard_Real

        Returns a real attribute from its name. 0.0 if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_AttrList_RealAttribute(self, *args)


    def SetStringAttribute(self, *args):
        """
        SetStringAttribute(MoniTool_AttrList self, Standard_CString const name, Standard_CString const val)

        Adds a String value for an attribute

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_AttrList_SetStringAttribute(self, *args)


    def GetStringAttribute(self, *args):
        """
        GetStringAttribute(MoniTool_AttrList self, Standard_CString const name, Standard_CString & val) -> Standard_Boolean

        Returns an attribute from its name, as String
        If no attribute has this name, or not a String
        <val> is 0.0 and returned value is False
        Else, it is True

        :type name: OCC.wrapper.Standard.Standard_CString
        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_AttrList_GetStringAttribute(self, *args)


    def StringAttribute(self, *args):
        """
        StringAttribute(MoniTool_AttrList self, Standard_CString const name) -> Standard_CString

        Returns a String attribute from its name. "" if not recorded

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_AttrList_StringAttribute(self, *args)


    def AttrList(self, *args):
        """
        Returns the exhaustive list of attributes

        :rtype: OCC.wrapper.MoniTool.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _MoniTool.MoniTool_AttrList_AttrList(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SameAttributes(self, *args):
        """
        SameAttributes(MoniTool_AttrList self, MoniTool_AttrList other)

        Gets the list of attributes from <other>, as such, i.e.
        not copied : attributes are shared, any attribute edited,
        added, or removed in <other> is also in <me> and vice versa
        The former list of attributes of <me> is dropped

        :type other: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        return _MoniTool.MoniTool_AttrList_SameAttributes(self, *args)


    def GetAttributes(self, *args):
        """
        GetAttributes(MoniTool_AttrList self, MoniTool_AttrList other, Standard_CString const fromname, Standard_Boolean const copied)

        Gets the list of attributes from <other>, by copying it
        By default, considers all the attributes from <other>
        If <fromname> is given, considers only the attributes with
        name beginning by <fromname>

        For each attribute, if <copied> is True (D), its value is also
        copied if it is a basic type (Integer,Real,String), else it
        remains shared between <other> and <me>

        These new attributes are added to the existing ones in <me>,
        in case of same name, they replace the existing ones

        :type other: OCC.wrapper.MoniTool.MoniTool_AttrList
        :type fromname: OCC.wrapper.Standard.Standard_CString
        :type copied: bool

        """
        return _MoniTool.MoniTool_AttrList_GetAttributes(self, *args)

    __swig_destroy__ = _MoniTool.delete_MoniTool_AttrList
MoniTool_AttrList_swigregister = _MoniTool.MoniTool_AttrList_swigregister
MoniTool_AttrList_swigregister(MoniTool_AttrList)

class MoniTool_RealVal(Standard.Standard_Transient):
    """A Real through a Handle (i.e. managed as TShared)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_RealVal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_RealVal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_RealVal self, Standard_Real const val=0.0) -> MoniTool_RealVal

        :type val: float

        """
        this = _MoniTool.new_MoniTool_RealVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(MoniTool_RealVal self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_RealVal_Value(self, *args)


    def CValue(self, *args):
        """
        CValue(MoniTool_RealVal self) -> Standard_Real &

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_RealVal_CValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_RealVal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_RealVal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_RealVal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_RealVal
MoniTool_RealVal_swigregister = _MoniTool.MoniTool_RealVal_swigregister
MoniTool_RealVal_swigregister(MoniTool_RealVal)

def MoniTool_RealVal_get_type_name(*args):
    """
    MoniTool_RealVal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_RealVal_get_type_name(*args)

def MoniTool_RealVal_get_type_descriptor(*args):
    """
    MoniTool_RealVal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_RealVal_get_type_descriptor(*args)

class MoniTool_CaseData(Standard.Standard_Transient):
    """
    This class is intended to record data attached to a case to be
    exploited.
    Cases can be :
    * internal, i.e. for immediate debug
    for instance, on an abnormal exception, fill a CaseData
    in a DB (see class DB) then look at its content by XSDRAW
    * to record abnormal situation, which cause a warning or fail
    message, for instance during a transfer
    This will allow, firstly to build a more comprehensive
    message (with associated data), secondly to help seeing
    "what happened"
    * to record data in order to fix a problem
    If a CASE is well defined and its fix is well known too,
    recording a CaseData which identifies the CASE will allow
    to furstherly call the appropriate fix routine

    A CaseData is defined by
    * an optional CASE identifier
    If it is defined, this will allow systematic exploitation
    such as calling a fix routine
    * an optional Check Status, Warning or Fail, else it is Info
    * a NAME : it just allows to identify where this CaseData was
    created (help to debug)
    * a LIST OF DATA

    Each Data has a type (integer, real etc...) and can have a name
    Hence, each data may be identified by :
    * its absolute rank (from 1 to NbData)
    * its name if it has one (exact matching)
    * else, an interpreted identifier, which gives the type and
    the rank in the type (for instance, first integer; etc)
    (See NameRank)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_CaseData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_CaseData(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_CaseData self, Standard_CString const caseid, Standard_CString const name) -> MoniTool_CaseData

        Creates a CaseData with a CaseId and a Name
        (by default not defined)

        :type caseid: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        this = _MoniTool.new_MoniTool_CaseData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCaseId(self, *args):
        """
        SetCaseId(MoniTool_CaseData self, Standard_CString const caseid)

        Sets a CaseId

        :type caseid: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_SetCaseId(self, *args)


    def SetName(self, *args):
        """
        SetName(MoniTool_CaseData self, Standard_CString const name)

        Sets a Name

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_SetName(self, *args)


    def CaseId(self, *args):
        """
        CaseId(MoniTool_CaseData self) -> Standard_CString

        Returns the CaseId

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_CaseId(self, *args)


    def IsCheck(self, *args):
        """
        IsCheck(MoniTool_CaseData self) -> Standard_Boolean

        Tells if <me> is Check (Warning or Fail), else it is Info

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_IsCheck(self, *args)


    def IsWarning(self, *args):
        """
        IsWarning(MoniTool_CaseData self) -> Standard_Boolean

        Tells if <me> is Warning

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_IsWarning(self, *args)


    def IsFail(self, *args):
        """
        IsFail(MoniTool_CaseData self) -> Standard_Boolean

        Tells if <me> is Fail

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_IsFail(self, *args)


    def ResetCheck(self, *args):
        """
        ResetCheck(MoniTool_CaseData self)

        Resets Check Status, i.e. sets <me> as Info


        """
        return _MoniTool.MoniTool_CaseData_ResetCheck(self, *args)


    def SetWarning(self, *args):
        """
        SetWarning(MoniTool_CaseData self)

        Sets <me> as Warning


        """
        return _MoniTool.MoniTool_CaseData_SetWarning(self, *args)


    def SetFail(self, *args):
        """
        SetFail(MoniTool_CaseData self)

        Sets <me> as Fail


        """
        return _MoniTool.MoniTool_CaseData_SetFail(self, *args)


    def SetChange(self, *args):
        """
        SetChange(MoniTool_CaseData self)

        Sets the next Add... not to add but to change the data item
        designated by its name.
        If next Add... is not called with a name, SetChange is ignored
        Reset by next Add... , whatever <num> is correct or not


        """
        return _MoniTool.MoniTool_CaseData_SetChange(self, *args)


    def SetReplace(self, *args):
        """
        SetReplace(MoniTool_CaseData self, Standard_Integer const num)

        Sets the next Add... not to add but to replace the data item
        <num>, if <num> is between 1 and NbData.
        Reset by next Add... , whatever <num> is correct or not

        :type num: int

        """
        return _MoniTool.MoniTool_CaseData_SetReplace(self, *args)


    def AddData(self, *args):
        """
        AddData(MoniTool_CaseData self, Handle_Standard_Transient val, Standard_Integer const kind, Standard_CString const name)

        Unitary adding a data; rather internal

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :type kind: int
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddData(self, *args)


    def AddRaised(self, *args):
        """
        AddRaised(MoniTool_CaseData self, Handle_Standard_Failure theException, Standard_CString const name)

        Adds the currently caught exception

        :type theException: OCC.wrapper.Standard.Handle_Standard_Failure
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddRaised(self, *args)


    def AddShape(self, *args):
        """
        AddShape(MoniTool_CaseData self, TopoDS_Shape sh, Standard_CString const name)

        Adds a Shape (recorded as a HShape)

        :type sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddShape(self, *args)


    def AddXYZ(self, *args):
        """
        AddXYZ(MoniTool_CaseData self, gp_XYZ aXYZ, Standard_CString const name)

        Adds a XYZ

        :type aXYZ: OCC.wrapper.gp.gp_XYZ
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddXYZ(self, *args)


    def AddXY(self, *args):
        """
        AddXY(MoniTool_CaseData self, gp_XY aXY, Standard_CString const name)

        Adds a XY

        :type aXY: OCC.wrapper.gp.gp_XY
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddXY(self, *args)


    def AddReal(self, *args):
        """
        AddReal(MoniTool_CaseData self, Standard_Real const val, Standard_CString const name)

        Adds a Real

        :type val: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddReal(self, *args)


    def AddReals(self, *args):
        """
        AddReals(MoniTool_CaseData self, Standard_Real const v1, Standard_Real const v2, Standard_CString const name)

        Adds two reals (for instance, two parameters)

        :type v1: float
        :type v2: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddReals(self, *args)


    def AddCPU(self, *args):
        """
        AddCPU(MoniTool_CaseData self, Standard_Real const lastCPU, Standard_Real const curCPU=0, Standard_CString const name)

        Adds the CPU time between lastCPU and now
        if <curCPU> is given, the CPU amount is  curCPU-lastCPU
        else it is currently measured CPU - lastCPU
        lastCPU has been read by call to GetCPU
        See GetCPU to get amount, and LargeCPU to test large amount

        :type lastCPU: float
        :type curCPU: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddCPU(self, *args)


    def GetCPU(self, *args):
        """
        GetCPU(MoniTool_CaseData self) -> Standard_Real

        Returns the current amount of CPU
        This allows to laterly test and record CPU amount
        Its value has to be given to LargeCPU and AddCPU

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_CaseData_GetCPU(self, *args)


    def LargeCPU(self, *args):
        """
        LargeCPU(MoniTool_CaseData self, Standard_Real const maxCPU, Standard_Real const lastCPU, Standard_Real const curCPU=0) -> Standard_Boolean

        Tells if a CPU time amount is large
        <maxCPU>  gives the amount over which an amount is large
        <lastCPU> gives the start CPU amount
        if <curCPU> is given, the tested CPU amount is curCPU-lastCPU
        else it is currently measured CPU - lastCPU

        :type maxCPU: float
        :type lastCPU: float
        :type curCPU: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_LargeCPU(self, *args)


    def AddGeom(self, *args):
        """
        AddGeom(MoniTool_CaseData self, Handle_Standard_Transient geom, Standard_CString const name)

        Adds a Geometric as a Transient (Curve, Surface ...)

        :type geom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddGeom(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(MoniTool_CaseData self, Handle_Standard_Transient ent, Standard_CString const name)

        Adds a Transient, as an Entity from an InterfaceModel for
        instance : it will then be printed with the help of a DBPE

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddEntity(self, *args)


    def AddText(self, *args):
        """
        AddText(MoniTool_CaseData self, Standard_CString const text, Standard_CString const name)

        Adds a Text (as HAsciiString)

        :type text: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddText(self, *args)


    def AddInteger(self, *args):
        """
        AddInteger(MoniTool_CaseData self, Standard_Integer const val, Standard_CString const name)

        Adds an Integer

        :type val: int
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddInteger(self, *args)


    def AddAny(self, *args):
        """
        AddAny(MoniTool_CaseData self, Handle_Standard_Transient val, Standard_CString const name)

        Adds a Transient, with no more meaning

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_AddAny(self, *args)


    def RemoveData(self, *args):
        """
        RemoveData(MoniTool_CaseData self, Standard_Integer const num)

        Removes a Data from its rank. Does nothing if out of range

        :type num: int

        """
        return _MoniTool.MoniTool_CaseData_RemoveData(self, *args)


    def NbData(self, *args):
        """
        NbData(MoniTool_CaseData self) -> Standard_Integer

        Returns the count of data recorded to a set

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_CaseData_NbData(self, *args)


    def Data(self, *args):
        """
        Data(MoniTool_CaseData self, Standard_Integer const nd) -> Handle_Standard_Transient

        Returns a data item (n0 <nd> in the set <num>)

        :type nd: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.MoniTool_CaseData_Data(self, *args)


    def GetData(self, *args):
        """
        GetData(MoniTool_CaseData self, Standard_Integer const nd, Handle_Standard_Type type, Handle_Standard_Transient val) -> Standard_Boolean

        Returns a data item, under control of a Type
        If the data item is kind of this type, it is returned in <val>
        and the returned value is True
        Else, <val> is unchanged and the returned value is False

        :type nd: int
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_GetData(self, *args)


    def Kind(self, *args):
        """
        Kind(MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Integer

        Returns the kind of a data :
        KIND TYPE      MEANING
        0  ANY       any (not one of the followings)
        1  EX        raised exception
        2  EN        entity
        3  G         geom
        4  SH        shape
        5  XYZ       XYZ
        6  XY or UV  XY
        7  RR        2 reals
        8  R         1 real
        9  CPU       CPU (1 real)
        10 T         text
        11 I         integer

        For NameNum, these codes for TYPE must be given exact
        i.e. SH for a Shape, not S nor SHAPE nor SOLID etc

        :type nd: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_CaseData_Kind(self, *args)


    def Name(self, *args):
        """
        Returns the name of a data. If it has no name, the string is
        empty (length = 0)

        :type nd: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _MoniTool.MoniTool_CaseData_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NameNum(self, *args):
        """
        NameNum(MoniTool_CaseData self, Standard_CString const name) -> Standard_Integer

        Returns the first suitable data rank for a given name
        Exact maching (exact case, no completion) is required
        Firstly checks the recorded names
        If not found, considers the name as follows :
        Name = "TYPE" : search for the first item with this TYPE
        Name = "TYPE:nn" : search for the nn.th item with this TYPE
        See allowed values in method Kind

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_CaseData_NameNum(self, *args)


    def Shape(self, *args):
        """
        Shape(MoniTool_CaseData self, Standard_Integer const nd) -> TopoDS_Shape

        Returns a data as a shape, Null if not a shape

        :type nd: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _MoniTool.MoniTool_CaseData_Shape(self, *args)


    def XYZ(self, *args):
        """
        XYZ(MoniTool_CaseData self, Standard_Integer const nd, gp_XYZ val) -> Standard_Boolean

        Returns a data as a XYZ (i.e. Geom_CartesianPoint)
        Returns False if not the good type

        :type nd: int
        :type val: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_XYZ(self, *args)


    def XY(self, *args):
        """
        XY(MoniTool_CaseData self, Standard_Integer const nd, gp_XY val) -> Standard_Boolean

        Returns a data as a XY  (i.e. Geom2d_CartesianPoint)
        Returns False if not the good type

        :type nd: int
        :type val: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_XY(self, *args)


    def Reals(self, *args):
        """
        Reals(MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Boolean

        Returns a couple of reals  (stored in Geom2d_CartesianPoint)

        :type nd: int
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_Reals(self, *args)


    def Real(self, *args):
        """
        Real(MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Boolean

        Returns a real or CPU amount (stored in Geom2d_CartesianPoint)
        (allows an Integer converted to a Real)

        :type nd: int
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_Real(self, *args)


    def Text(self, *args):
        """
        Text(MoniTool_CaseData self, Standard_Integer const nd, Standard_CString & text) -> Standard_Boolean

        Returns a text (stored in TCollection_HAsciiString)

        :type nd: int
        :type text: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_Text(self, *args)


    def Integer(self, *args):
        """
        Integer(MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Boolean

        Returns an Integer

        :type nd: int
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_CaseData_Integer(self, *args)


    def Msg(self, *args):
        """
        Msg(MoniTool_CaseData self) -> Message_Msg

        Returns a Msg from a CaseData : it is build from DefMsg, which
        gives the message code plus the designation of items of the
        CaseData to be added to the Msg
        Empty if no message attached

        Remains to be implemented

        :rtype: OCC.wrapper.Message.Message_Msg

        """
        return _MoniTool.MoniTool_CaseData_Msg(self, *args)


    def SetDefWarning(*args):
        """
        SetDefWarning(Standard_CString const acode)

        Sets a Code to give a Warning

        :type acode: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_SetDefWarning(*args)

    SetDefWarning = staticmethod(SetDefWarning)

    def SetDefFail(*args):
        """
        SetDefFail(Standard_CString const acode)

        Sets a Code to give a Fail

        :type acode: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_SetDefFail(*args)

    SetDefFail = staticmethod(SetDefFail)

    def DefCheck(*args):
        """
        DefCheck(Standard_CString const acode) -> Standard_Integer

        Returns Check Status for a Code : 0 non/info (default),
        1 warning, 2 fail

        Remark : DefCheck is used to set the check status of a
        CaseData when it is attached to a case code, it can be changed
        later (by SetFail, SetWarning, ResetCheck)

        :type acode: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_CaseData_DefCheck(*args)

    DefCheck = staticmethod(DefCheck)

    def SetDefMsg(*args):
        """
        SetDefMsg(Standard_CString const casecode, Standard_CString const mesdef)

        Attaches a message definition to a case code
        This definition includes the message code plus designation of
        items of the CaseData to be added to the message (this part
        not yet implemented)

        :type casecode: OCC.wrapper.Standard.Standard_CString
        :type mesdef: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_SetDefMsg(*args)

    SetDefMsg = staticmethod(SetDefMsg)

    def DefMsg(*args):
        """
        DefMsg(Standard_CString const casecode) -> Standard_CString

        Returns the message definition for a case code
        Empty if no message attached

        :type casecode: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_CaseData_DefMsg(*args)

    DefMsg = staticmethod(DefMsg)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_CaseData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_CaseData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_CaseData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_CaseData
MoniTool_CaseData_swigregister = _MoniTool.MoniTool_CaseData_swigregister
MoniTool_CaseData_swigregister(MoniTool_CaseData)

def MoniTool_CaseData_SetDefWarning(*args):
    """
    MoniTool_CaseData_SetDefWarning(Standard_CString const acode)

    Sets a Code to give a Warning

    :type acode: OCC.wrapper.Standard.Standard_CString

    """
    return _MoniTool.MoniTool_CaseData_SetDefWarning(*args)

def MoniTool_CaseData_SetDefFail(*args):
    """
    MoniTool_CaseData_SetDefFail(Standard_CString const acode)

    Sets a Code to give a Fail

    :type acode: OCC.wrapper.Standard.Standard_CString

    """
    return _MoniTool.MoniTool_CaseData_SetDefFail(*args)

def MoniTool_CaseData_DefCheck(*args):
    """
    MoniTool_CaseData_DefCheck(Standard_CString const acode) -> Standard_Integer

    Returns Check Status for a Code : 0 non/info (default),
    1 warning, 2 fail

    Remark : DefCheck is used to set the check status of a
    CaseData when it is attached to a case code, it can be changed
    later (by SetFail, SetWarning, ResetCheck)

    :type acode: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _MoniTool.MoniTool_CaseData_DefCheck(*args)

def MoniTool_CaseData_SetDefMsg(*args):
    """
    MoniTool_CaseData_SetDefMsg(Standard_CString const casecode, Standard_CString const mesdef)

    Attaches a message definition to a case code
    This definition includes the message code plus designation of
    items of the CaseData to be added to the message (this part
    not yet implemented)

    :type casecode: OCC.wrapper.Standard.Standard_CString
    :type mesdef: OCC.wrapper.Standard.Standard_CString

    """
    return _MoniTool.MoniTool_CaseData_SetDefMsg(*args)

def MoniTool_CaseData_DefMsg(*args):
    """
    MoniTool_CaseData_DefMsg(Standard_CString const casecode) -> Standard_CString

    Returns the message definition for a case code
    Empty if no message attached

    :type casecode: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _MoniTool.MoniTool_CaseData_DefMsg(*args)

def MoniTool_CaseData_get_type_name(*args):
    """
    MoniTool_CaseData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_CaseData_get_type_name(*args)

def MoniTool_CaseData_get_type_descriptor(*args):
    """
    MoniTool_CaseData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_CaseData_get_type_descriptor(*args)

class Handle_MoniTool_TransientElem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_TransientElem self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_TransientElem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_TransientElem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_TransientElem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_TransientElem self, MoniTool_TransientElem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_TransientElem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_TransientElem self, Handle_MoniTool_TransientElem theHandle) -> Handle_MoniTool_TransientElem
        assign(Handle_MoniTool_TransientElem self, MoniTool_TransientElem thePtr) -> Handle_MoniTool_TransientElem
        assign(Handle_MoniTool_TransientElem self, Handle_MoniTool_TransientElem theHandle) -> Handle_MoniTool_TransientElem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_TransientElem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_TransientElem self) -> MoniTool_TransientElem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_TransientElem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_TransientElem self) -> MoniTool_TransientElem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_TransientElem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_TransientElem self) -> MoniTool_TransientElem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_TransientElem___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_TransientElem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_TransientElem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_TransientElem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_TransientElem_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_TransientElem

    def Value(self, *args):
        """
        Returns the contained value

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _MoniTool.Handle_MoniTool_TransientElem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Equates(self, *args):
        """
        Equates(Handle_MoniTool_TransientElem self, Handle_MoniTool_Element other) -> Standard_Boolean

        Specific testof equallity : defined as False if <other> has
        not the same true Type, else contents are compared (by
        C++ operator ==)

        :type other: OCC.wrapper.MoniTool.Handle_MoniTool_Element
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TransientElem_Equates(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Handle_MoniTool_TransientElem self) -> Handle_Standard_Type

        Returns the Type of the Value. By default, returns the
        DynamicType of <me>, but can be redefined

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.Handle_MoniTool_TransientElem_ValueType(self, *args)


    def ValueTypeName(self, *args):
        """
        ValueTypeName(Handle_MoniTool_TransientElem self) -> Standard_CString

        Returns the name of the Type of the Value. Default is name
        of ValueType, unless it is for a non-handled object

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TransientElem_ValueTypeName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_TransientElem self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_TransientElem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_TransientElem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_TransientElem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetHashCode(self, *args):
        """
        GetHashCode(Handle_MoniTool_TransientElem self) -> Standard_Integer

        Returns the HashCode which has been stored by SetHashCode
        (remark that HashCode could be deferred then be defined by
        sub-classes, the result is the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TransientElem_GetHashCode(self, *args)


    def ListAttr(self, *args):
        """
        Returns (readonly) the Attribute List

        :rtype: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        res = _MoniTool.Handle_MoniTool_TransientElem_ListAttr(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeAttr(self, *args):
        """
        ChangeAttr(Handle_MoniTool_TransientElem self) -> MoniTool_AttrList

        Returns (modifiable) the Attribute List

        :rtype: OCC.wrapper.MoniTool.MoniTool_AttrList

        """
        return _MoniTool.Handle_MoniTool_TransientElem_ChangeAttr(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_TransientElem self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_TransientElem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_TransientElem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_TransientElem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TransientElem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_TransientElem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_TransientElem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TransientElem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_TransientElem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_TransientElem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_TransientElem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TransientElem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_TransientElem self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_TransientElem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_TransientElem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TransientElem_DecrementRefCounter(self, *args)

Handle_MoniTool_TransientElem_swigregister = _MoniTool.Handle_MoniTool_TransientElem_swigregister
Handle_MoniTool_TransientElem_swigregister(Handle_MoniTool_TransientElem)

def Handle_MoniTool_TransientElem_DownCast(thing):
    return _MoniTool.Handle_MoniTool_TransientElem_DownCast(thing)
Handle_MoniTool_TransientElem_DownCast = _MoniTool.Handle_MoniTool_TransientElem_DownCast

class MoniTool_IntVal(Standard.Standard_Transient):
    """An Integer through a Handle (i.e. managed as TShared)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_IntVal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_IntVal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_IntVal self, Standard_Integer const val=0) -> MoniTool_IntVal

        :type val: int

        """
        this = _MoniTool.new_MoniTool_IntVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(MoniTool_IntVal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_IntVal_Value(self, *args)


    def CValue(self, *args):
        """
        CValue(MoniTool_IntVal self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_IntVal_CValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_IntVal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_IntVal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_IntVal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_IntVal
MoniTool_IntVal_swigregister = _MoniTool.MoniTool_IntVal_swigregister
MoniTool_IntVal_swigregister(MoniTool_IntVal)

def MoniTool_IntVal_get_type_name(*args):
    """
    MoniTool_IntVal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_IntVal_get_type_name(*args)

def MoniTool_IntVal_get_type_descriptor(*args):
    """
    MoniTool_IntVal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_IntVal_get_type_descriptor(*args)

class MoniTool_Stat(object):
    """
    This class manages Statistics to be queried asynchronously.

    It is organized as a stack of counters, identified by their
    levels, from one to ... . Each one has a total account of
    items to be counted, a count of already passed items, plus a
    count of "current items". The counters of higher level play on
    these current items.
    For instance, if a counter has been opened for 100 items, 40
    already passed, 20 current, its own percent is 40, but there
    is the contribution of higher level counters, rated for 20 %
    of this counter.

    Hence, a counter is opened, items are added. Also items can be
    add for sub-counter (of higher level), they will be added
    definitively when the sub-counter will be closed. When the
    count has ended, this counter is closed, the counter of
    lower level cumulates it and goes on. As follows :

    Way of use :
    Open(nbitems);
    Add(..)  :  direct adding
    Add(..)
    AddSub (nsub)  :  for sub-counter
    Open (nbsubs)  :  nbsubs for this sub-counter
    Add (..)
    Close        : the sub-counter
    AddEnd()
    etc...
    Close          : the starting counter

    This means that a counter can be opened in a Stat, regardless
    to the already opened ones :: this will be cumulated

    A Current Stat is available, but it is possible to have others
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(MoniTool_Stat self, Standard_CString const title) -> MoniTool_Stat
        __init__(MoniTool_Stat self, MoniTool_Stat other) -> MoniTool_Stat

        used when starting

        :type other: OCC.wrapper.MoniTool.MoniTool_Stat

        """
        this = _MoniTool.new_MoniTool_Stat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Current(*args):
        """
        Current() -> MoniTool_Stat

        :rtype: OCC.wrapper.MoniTool.MoniTool_Stat

        """
        return _MoniTool.MoniTool_Stat_Current(*args)

    Current = staticmethod(Current)

    def Open(self, *args):
        """
        Open(MoniTool_Stat self, Standard_Integer const nb=100) -> Standard_Integer

        Opens a new counter with a starting count of items

        :type nb: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_Stat_Open(self, *args)


    def OpenMore(self, *args):
        """
        OpenMore(MoniTool_Stat self, Standard_Integer const id, Standard_Integer const nb)

        Adds more items to be counted by Add... on current level

        :type id: int
        :type nb: int

        """
        return _MoniTool.MoniTool_Stat_OpenMore(self, *args)


    def Add(self, *args):
        """
        Add(MoniTool_Stat self, Standard_Integer const nb=1)

        Directly addes items

        :type nb: int

        """
        return _MoniTool.MoniTool_Stat_Add(self, *args)


    def AddSub(self, *args):
        """
        AddSub(MoniTool_Stat self, Standard_Integer const nb=1)

        Declares a count of items to be added later. If a sub-counter
        is opened, its percentage multiplies this sub-count to compute
        the percent of current level

        :type nb: int

        """
        return _MoniTool.MoniTool_Stat_AddSub(self, *args)


    def AddEnd(self, *args):
        """
        AddEnd(MoniTool_Stat self)

        Ends the AddSub and cumulates the sub-count to current level


        """
        return _MoniTool.MoniTool_Stat_AddEnd(self, *args)


    def Close(self, *args):
        """
        Close(MoniTool_Stat self, Standard_Integer const id)

        :type id: int

        """
        return _MoniTool.MoniTool_Stat_Close(self, *args)


    def Level(self, *args):
        """
        Level(MoniTool_Stat self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_Stat_Level(self, *args)


    def Percent(self, *args):
        """
        Percent(MoniTool_Stat self, Standard_Integer const fromlev=0) -> Standard_Real

        :type fromlev: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_Stat_Percent(self, *args)

    __swig_destroy__ = _MoniTool.delete_MoniTool_Stat
MoniTool_Stat_swigregister = _MoniTool.MoniTool_Stat_swigregister
MoniTool_Stat_swigregister(MoniTool_Stat)

def MoniTool_Stat_Current(*args):
    """
    MoniTool_Stat_Current() -> MoniTool_Stat

    :rtype: OCC.wrapper.MoniTool.MoniTool_Stat

    """
    return _MoniTool.MoniTool_Stat_Current(*args)

class MoniTool_TypedValue(Standard.Standard_Transient):
    """
    This class allows to dynamically manage .. typed values, i.e.
    values which have an alphanumeric expression, but with
    controls. Such as "must be an Integer" or "Enumerative Text"
    etc

    Hence, a TypedValue brings a specification (type + constraints
    if any) and a value. Its basic form is a string, it can be
    specified as integer or real or enumerative string, then
    queried as such.
    Its string content, which is a Handle(HAsciiString) can be
    shared by other data structures, hence gives a direct on line
    access to its value.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MoniTool_TypedValue
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MoniTool_TypedValue(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MoniTool_TypedValue self, Standard_CString const name, MoniTool_ValueType const type=MoniTool_ValueText, Standard_CString const init) -> MoniTool_TypedValue
        __init__(MoniTool_TypedValue self, Handle_MoniTool_TypedValue other) -> MoniTool_TypedValue

        Creates a TypedValue from another one, by duplication

        :type other: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        this = _MoniTool.new_MoniTool_TypedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Internals(self, *args):
        """
        Internals(MoniTool_TypedValue self, MoniTool_ValueInterpret & interp, MoniTool_ValueSatisfies & satisf, Standard_CString & satisname, NCollection_DataMap< TCollection_AsciiString,Standard_Integer > & enums)

        Access to internal data which have no other access

        :type interp: OCC.wrapper.MoniTool.MoniTool_ValueInterpret
        :type satisf: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type satisname: OCC.wrapper.Standard.Standard_CString
        :type enums: OCC.wrapper.MoniTool.NCollection_DataMap_TCollection_AsciiString_Standard_Integer

        """
        return _MoniTool.MoniTool_TypedValue_Internals(self, *args)


    def Name(self, *args):
        """
        Name(MoniTool_TypedValue self) -> Standard_CString

        Returns the name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_Name(self, *args)


    def ValueType(self, *args):
        """
        ValueType(MoniTool_TypedValue self) -> MoniTool_ValueType

        Returns the type of the value

        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _MoniTool.MoniTool_TypedValue_ValueType(self, *args)


    def Definition(self, *args):
        """
        Definition(MoniTool_TypedValue self) -> TCollection_AsciiString

        Returns the Definition
        By priority, the enforced one, else an automatic one, computed
        from the specification

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.MoniTool_TypedValue_Definition(self, *args)


    def SetDefinition(self, *args):
        """
        SetDefinition(MoniTool_TypedValue self, Standard_CString const deftext)

        Enforces a Definition

        :type deftext: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_SetDefinition(self, *args)


    def Print(self, *args):
        """
        Print(MoniTool_TypedValue self, Handle_Message_Messenger S)

        Prints definition, specification, and actual status and value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _MoniTool.MoniTool_TypedValue_Print(self, *args)


    def PrintValue(self, *args):
        """
        PrintValue(MoniTool_TypedValue self, Handle_Message_Messenger S)

        Prints only the Value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _MoniTool.MoniTool_TypedValue_PrintValue(self, *args)


    def AddDef(self, *args):
        """
        AddDef(MoniTool_TypedValue self, Standard_CString const initext) -> Standard_Boolean

        Completes the definition of a TypedValue by command <initext>,
        once created with its type
        Returns True if done, False if could not be interpreted
        <initext> may be :
        imin ival : minimum value for an integer
        imax ival : maximum value for an integer
        rmin rval : minimum value for a real
        rmax rval : maximum value for a real
        unit name : name of unit
        ematch i  : enum from integer value i, match required
        enum   i  : enum from integer value i, match not required
        eval text : add an enumerative value (increments max by 1)
        eval ??   : add a non-authorised enum value (to be skipped)
        tmax   l  : maximum length for a text

        :type initext: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_AddDef(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(MoniTool_TypedValue self, Standard_CString const label)

        Sets a label, which can then be displayed

        :type label: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_SetLabel(self, *args)


    def Label(self, *args):
        """
        Label(MoniTool_TypedValue self) -> Standard_CString

        Returns the label, if set; else returns an empty string

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_Label(self, *args)


    def SetMaxLength(self, *args):
        """
        SetMaxLength(MoniTool_TypedValue self, Standard_Integer const max)

        Sets a maximum length for a text (active only for a free text)

        :type max: int

        """
        return _MoniTool.MoniTool_TypedValue_SetMaxLength(self, *args)


    def MaxLength(self, *args):
        """
        MaxLength(MoniTool_TypedValue self) -> Standard_Integer

        Returns the maximum length, 0 if not set

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_TypedValue_MaxLength(self, *args)


    def SetIntegerLimit(self, *args):
        """
        SetIntegerLimit(MoniTool_TypedValue self, Standard_Boolean const max, Standard_Integer const val)

        Sets an Integer limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: int

        """
        return _MoniTool.MoniTool_TypedValue_SetIntegerLimit(self, *args)


    def IntegerLimit(self, *args):
        """
        IntegerLimit(MoniTool_TypedValue self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Integer Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Integer)

        :type max: bool
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_IntegerLimit(self, *args)


    def SetRealLimit(self, *args):
        """
        SetRealLimit(MoniTool_TypedValue self, Standard_Boolean const max, Standard_Real const val)

        Sets a Real limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: float

        """
        return _MoniTool.MoniTool_TypedValue_SetRealLimit(self, *args)


    def RealLimit(self, *args):
        """
        RealLimit(MoniTool_TypedValue self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Real Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Real)

        :type max: bool
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_RealLimit(self, *args)


    def SetUnitDef(self, *args):
        """
        SetUnitDef(MoniTool_TypedValue self, Standard_CString const arg2)

        Sets (Clears if <def> empty) a unit definition, as an equation
        of dimensions. TypedValue just records this definition, does
        not exploit it, to be done as required by user applications

        :type def: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_SetUnitDef(self, *args)


    def UnitDef(self, *args):
        """
        UnitDef(MoniTool_TypedValue self) -> Standard_CString

        Returns the recorded unit definition, empty if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_UnitDef(self, *args)


    def StartEnum(self, *args):
        """
        StartEnum(MoniTool_TypedValue self, Standard_Integer const start=0, Standard_Boolean const match)

        For an enumeration, precises the starting value (default 0)
        and the match condition : if True (D), the string value must
        match the definition, else it may take another value : in that
        case, the Integer Value will be  Start - 1.
        (empty value remains allowed)

        :type start: int
        :type match: bool

        """
        return _MoniTool.MoniTool_TypedValue_StartEnum(self, *args)


    def AddEnum(self, *args):
        """
        AddEnum(MoniTool_TypedValue self, Standard_CString const v1, Standard_CString const v2, Standard_CString const v3, Standard_CString const v4, Standard_CString const v5, Standard_CString const v6, Standard_CString const v7, Standard_CString const v8, Standard_CString const v9, Standard_CString const v10)

        Adds enumerative definitions. For more than 10, several calls

        :type v1: OCC.wrapper.Standard.Standard_CString
        :type v2: OCC.wrapper.Standard.Standard_CString
        :type v3: OCC.wrapper.Standard.Standard_CString
        :type v4: OCC.wrapper.Standard.Standard_CString
        :type v5: OCC.wrapper.Standard.Standard_CString
        :type v6: OCC.wrapper.Standard.Standard_CString
        :type v7: OCC.wrapper.Standard.Standard_CString
        :type v8: OCC.wrapper.Standard.Standard_CString
        :type v9: OCC.wrapper.Standard.Standard_CString
        :type v10: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_AddEnum(self, *args)


    def AddEnumValue(self, *args):
        """
        AddEnumValue(MoniTool_TypedValue self, Standard_CString const val, Standard_Integer const num)

        Adds an enumeration definition, by its string and numeric
        values. If it is the first setting for this value, it is
        recorded as main value. Else, it is recognized as alternate
        string for this numeric value

        :type val: OCC.wrapper.Standard.Standard_CString
        :type num: int

        """
        return _MoniTool.MoniTool_TypedValue_AddEnumValue(self, *args)


    def EnumDef(self, *args):
        """
        EnumDef(MoniTool_TypedValue self) -> Standard_Boolean

        Gives the Enum definitions : start value, end value, match
        status. Returns True for an Enum, False else.

        :type startcase: int
        :type endcase: int
        :type match: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_EnumDef(self, *args)


    def EnumVal(self, *args):
        """
        EnumVal(MoniTool_TypedValue self, Standard_Integer const num) -> Standard_CString

        Returns the value of an enumerative definition, from its rank
        Empty string if out of range or not an Enum

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_EnumVal(self, *args)


    def EnumCase(self, *args):
        """
        EnumCase(MoniTool_TypedValue self, Standard_CString const val) -> Standard_Integer

        Returns the case number which cooresponds to a string value
        Works with main and additionnal values
        Returns (StartEnum - 1) if not OK, -1 if not an Enum

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_TypedValue_EnumCase(self, *args)


    def SetObjectType(self, *args):
        """
        SetObjectType(MoniTool_TypedValue self, Handle_Standard_Type typ)

        Sets type of which an Object TypedValue must be kind of
        Error for a TypedValue not an Object (Entity)

        :type typ: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_TypedValue_SetObjectType(self, *args)


    def ObjectType(self, *args):
        """
        ObjectType(MoniTool_TypedValue self) -> Handle_Standard_Type

        Returns the type of which an Object TypedValue must be kind of
        Default is Standard_Transient
        Null for a TypedValue not an Object

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_TypedValue_ObjectType(self, *args)


    def SetInterpret(self, *args):
        """
        SetInterpret(MoniTool_TypedValue self, MoniTool_ValueInterpret const func)

        Sets a specific Interpret function

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueInterpret

        """
        return _MoniTool.MoniTool_TypedValue_SetInterpret(self, *args)


    def HasInterpret(self, *args):
        """
        HasInterpret(MoniTool_TypedValue self) -> Standard_Boolean

        Tells if a TypedValue has an Interpret

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_HasInterpret(self, *args)


    def SetSatisfies(self, *args):
        """
        SetSatisfies(MoniTool_TypedValue self, MoniTool_ValueSatisfies const func, Standard_CString const name)

        Sets a specific Satisfies function : it is added to the
        already defined criteria
        It must match the form :
        statisfies (val : HAsciiString) returns Boolean

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_SetSatisfies(self, *args)


    def SatisfiesName(self, *args):
        """
        SatisfiesName(MoniTool_TypedValue self) -> Standard_CString

        Returns name of specific satisfy, empty string if none

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_SatisfiesName(self, *args)


    def IsSetValue(self, *args):
        """
        IsSetValue(MoniTool_TypedValue self) -> Standard_Boolean

        Returns True if the value is set (not empty/not null object)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_IsSetValue(self, *args)


    def CStringValue(self, *args):
        """
        CStringValue(MoniTool_TypedValue self) -> Standard_CString

        Returns the value, as a cstring. Empty if not set.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_CStringValue(self, *args)


    def HStringValue(self, *args):
        """
        HStringValue(MoniTool_TypedValue self) -> Handle_TCollection_HAsciiString

        Returns the value, as a Handle (can then be shared)
        Null if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _MoniTool.MoniTool_TypedValue_HStringValue(self, *args)


    def Interpret(self, *args):
        """
        Interpret(MoniTool_TypedValue self, Handle_TCollection_HAsciiString hval, Standard_Boolean const native) -> Handle_TCollection_HAsciiString

        Interprets a value.
        <native> True  : returns a native value
        <native> False : returns a coded  value
        If the Interpret function is set, calls it
        Else, for an Enum, Native returns the Text, Coded returns
        the number
        STANDARD RETURNS : = hval means no specific interpretation
        Null means senseless
        Can also be redefined

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type native: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _MoniTool.MoniTool_TypedValue_Interpret(self, *args)


    def Satisfies(self, *args):
        """
        Satisfies(MoniTool_TypedValue self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Returns True if a value statifies the specification
        (remark : does not apply to Entity : see ObjectType, for this
        type, the string is just a comment)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_Satisfies(self, *args)


    def ClearValue(self, *args):
        """
        ClearValue(MoniTool_TypedValue self)

        Clears the recorded Value : it is now unset


        """
        return _MoniTool.MoniTool_TypedValue_ClearValue(self, *args)


    def SetCStringValue(self, *args):
        """
        SetCStringValue(MoniTool_TypedValue self, Standard_CString const val) -> Standard_Boolean

        Changes the value. The new one must satisfy the specification
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_SetCStringValue(self, *args)


    def SetHStringValue(self, *args):
        """
        SetHStringValue(MoniTool_TypedValue self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Forces a new Handle for the Value
        It can be empty, else (if Type is not free Text), it must
        satisfy the specification.
        Not only the value is changed, but also the way it is shared
        Remark : for Type=Object, this value is not controlled, it can
        be set as a comment
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_SetHStringValue(self, *args)


    def IntegerValue(self, *args):
        """
        IntegerValue(MoniTool_TypedValue self) -> Standard_Integer

        Returns the value as integer, i.e. :
        For type = Integer, the integer itself; 0 if not set
        For type = Enum, the designated rank (see Enum definition)
        StartEnum - 1 if not set or not in the definition
        Else, returns 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.MoniTool_TypedValue_IntegerValue(self, *args)


    def SetIntegerValue(self, *args):
        """
        SetIntegerValue(MoniTool_TypedValue self, Standard_Integer const ival) -> Standard_Boolean

        Changes the value as an integer, only for Integer or Enum

        :type ival: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_SetIntegerValue(self, *args)


    def RealValue(self, *args):
        """
        RealValue(MoniTool_TypedValue self) -> Standard_Real

        Returns the value as real,  for a Real type TypedValue
        Else, returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.MoniTool_TypedValue_RealValue(self, *args)


    def SetRealValue(self, *args):
        """
        SetRealValue(MoniTool_TypedValue self, Standard_Real const rval) -> Standard_Boolean

        Changes the value as a real, only for Real

        :type rval: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_SetRealValue(self, *args)


    def ObjectValue(self, *args):
        """
        ObjectValue(MoniTool_TypedValue self) -> Handle_Standard_Transient

        Returns the value as Transient Object, only for Object/Entity
        Remark that the "HString value" is IGNORED here
        Null if not set; remains to be casted

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.MoniTool_TypedValue_ObjectValue(self, *args)


    def GetObjectValue(self, *args):
        """
        GetObjectValue(MoniTool_TypedValue self, Handle_Standard_Transient val)

        Same as ObjectValue, but avoids DownCast : the receiving
        variable is directly loaded. It is assumed that it complies
        with the definition of ObjectType ! Otherwise, big trouble

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.MoniTool_TypedValue_GetObjectValue(self, *args)


    def SetObjectValue(self, *args):
        """
        SetObjectValue(MoniTool_TypedValue self, Handle_Standard_Transient obj) -> Standard_Boolean

        Changes the value as Transient Object, only for Object/Entity
        Returns False if DynamicType does not satisfy ObjectType
        Can be redefined to be managed (in a subclass)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_SetObjectValue(self, *args)


    def ObjectTypeName(self, *args):
        """
        ObjectTypeName(MoniTool_TypedValue self) -> Standard_CString

        Returns the type name of the ObjectValue, or an empty string
        if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_TypedValue_ObjectTypeName(self, *args)


    def AddLib(*args):
        """
        AddLib(Handle_MoniTool_TypedValue tv, Standard_CString const arg2) -> Standard_Boolean

        Adds a TypedValue in the library.
        It is recorded then will be accessed by its Name
        Its Definition may be imposed, else it is computed as usual
        By default it will be accessed by its Definition (string)
        Returns True if done, False if tv is Null or brings no
        Definition or <def> not defined

        If a TypedValue was already recorded under this name, it is
        replaced

        :type tv: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue
        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.MoniTool_TypedValue_AddLib(*args)

    AddLib = staticmethod(AddLib)

    def Lib(*args):
        """
        Lib(Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns the TypedValue bound with a given Name
        Null Handle if none recorded
        Warning : it is the original, not duplicated

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _MoniTool.MoniTool_TypedValue_Lib(*args)

    Lib = staticmethod(Lib)

    def FromLib(*args):
        """
        FromLib(Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns a COPY of the TypedValue bound with a given Name
        Null Handle if none recorded

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _MoniTool.MoniTool_TypedValue_FromLib(*args)

    FromLib = staticmethod(FromLib)

    def LibList(*args):
        """
        LibList() -> Handle_TColStd_HSequenceOfAsciiString

        Returns the list of names of items of the Library of Types
        --    Library of TypedValue as Valued Parameters,    -- --
        accessed by parameter name
        for use by management of Static Parameters

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _MoniTool.MoniTool_TypedValue_LibList(*args)

    LibList = staticmethod(LibList)

    def StaticValue(*args):
        """
        StaticValue(Standard_CString const name) -> Handle_MoniTool_TypedValue

        Returns a static value from its name, null if unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _MoniTool.MoniTool_TypedValue_StaticValue(*args)

    StaticValue = staticmethod(StaticValue)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MoniTool.MoniTool_TypedValue_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_TypedValue_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.MoniTool_TypedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MoniTool.delete_MoniTool_TypedValue
MoniTool_TypedValue_swigregister = _MoniTool.MoniTool_TypedValue_swigregister
MoniTool_TypedValue_swigregister(MoniTool_TypedValue)

def MoniTool_TypedValue_AddLib(*args):
    """
    MoniTool_TypedValue_AddLib(Handle_MoniTool_TypedValue tv, Standard_CString const arg3) -> Standard_Boolean

    Adds a TypedValue in the library.
    It is recorded then will be accessed by its Name
    Its Definition may be imposed, else it is computed as usual
    By default it will be accessed by its Definition (string)
    Returns True if done, False if tv is Null or brings no
    Definition or <def> not defined

    If a TypedValue was already recorded under this name, it is
    replaced

    :type tv: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue
    :type def: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _MoniTool.MoniTool_TypedValue_AddLib(*args)

def MoniTool_TypedValue_Lib(*args):
    """
    MoniTool_TypedValue_Lib(Standard_CString const arg2) -> Handle_MoniTool_TypedValue

    Returns the TypedValue bound with a given Name
    Null Handle if none recorded
    Warning : it is the original, not duplicated

    :type def: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

    """
    return _MoniTool.MoniTool_TypedValue_Lib(*args)

def MoniTool_TypedValue_FromLib(*args):
    """
    MoniTool_TypedValue_FromLib(Standard_CString const arg2) -> Handle_MoniTool_TypedValue

    Returns a COPY of the TypedValue bound with a given Name
    Null Handle if none recorded

    :type def: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

    """
    return _MoniTool.MoniTool_TypedValue_FromLib(*args)

def MoniTool_TypedValue_LibList(*args):
    """
    MoniTool_TypedValue_LibList() -> Handle_TColStd_HSequenceOfAsciiString

    Returns the list of names of items of the Library of Types
    --    Library of TypedValue as Valued Parameters,    -- --
    accessed by parameter name
    for use by management of Static Parameters

    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

    """
    return _MoniTool.MoniTool_TypedValue_LibList(*args)

def MoniTool_TypedValue_StaticValue(*args):
    """
    MoniTool_TypedValue_StaticValue(Standard_CString const name) -> Handle_MoniTool_TypedValue

    Returns a static value from its name, null if unknown

    :type name: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

    """
    return _MoniTool.MoniTool_TypedValue_StaticValue(*args)

def MoniTool_TypedValue_get_type_name(*args):
    """
    MoniTool_TypedValue_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MoniTool.MoniTool_TypedValue_get_type_name(*args)

def MoniTool_TypedValue_get_type_descriptor(*args):
    """
    MoniTool_TypedValue_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_TypedValue_get_type_descriptor(*args)

class Handle_MoniTool_CaseData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_CaseData self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_CaseData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_CaseData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_CaseData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_CaseData self, MoniTool_CaseData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_CaseData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_CaseData self, Handle_MoniTool_CaseData theHandle) -> Handle_MoniTool_CaseData
        assign(Handle_MoniTool_CaseData self, MoniTool_CaseData thePtr) -> Handle_MoniTool_CaseData
        assign(Handle_MoniTool_CaseData self, Handle_MoniTool_CaseData theHandle) -> Handle_MoniTool_CaseData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_CaseData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_CaseData self) -> MoniTool_CaseData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_CaseData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_CaseData self) -> MoniTool_CaseData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_CaseData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_CaseData self) -> MoniTool_CaseData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_CaseData___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_CaseData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_CaseData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_CaseData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_CaseData_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_CaseData

    def SetCaseId(self, *args):
        """
        SetCaseId(Handle_MoniTool_CaseData self, Standard_CString const caseid)

        Sets a CaseId

        :type caseid: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_SetCaseId(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_MoniTool_CaseData self, Standard_CString const name)

        Sets a Name

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_SetName(self, *args)


    def CaseId(self, *args):
        """
        CaseId(Handle_MoniTool_CaseData self) -> Standard_CString

        Returns the CaseId

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_CaseId(self, *args)


    def Name(self, *args):
        """
        Returns the name of a data. If it has no name, the string is
        empty (length = 0)

        :type nd: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _MoniTool.Handle_MoniTool_CaseData_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCheck(self, *args):
        """
        IsCheck(Handle_MoniTool_CaseData self) -> Standard_Boolean

        Tells if <me> is Check (Warning or Fail), else it is Info

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_IsCheck(self, *args)


    def IsWarning(self, *args):
        """
        IsWarning(Handle_MoniTool_CaseData self) -> Standard_Boolean

        Tells if <me> is Warning

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_IsWarning(self, *args)


    def IsFail(self, *args):
        """
        IsFail(Handle_MoniTool_CaseData self) -> Standard_Boolean

        Tells if <me> is Fail

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_IsFail(self, *args)


    def ResetCheck(self, *args):
        """
        ResetCheck(Handle_MoniTool_CaseData self)

        Resets Check Status, i.e. sets <me> as Info


        """
        return _MoniTool.Handle_MoniTool_CaseData_ResetCheck(self, *args)


    def SetWarning(self, *args):
        """
        SetWarning(Handle_MoniTool_CaseData self)

        Sets <me> as Warning


        """
        return _MoniTool.Handle_MoniTool_CaseData_SetWarning(self, *args)


    def SetFail(self, *args):
        """
        SetFail(Handle_MoniTool_CaseData self)

        Sets <me> as Fail


        """
        return _MoniTool.Handle_MoniTool_CaseData_SetFail(self, *args)


    def SetChange(self, *args):
        """
        SetChange(Handle_MoniTool_CaseData self)

        Sets the next Add... not to add but to change the data item
        designated by its name.
        If next Add... is not called with a name, SetChange is ignored
        Reset by next Add... , whatever <num> is correct or not


        """
        return _MoniTool.Handle_MoniTool_CaseData_SetChange(self, *args)


    def SetReplace(self, *args):
        """
        SetReplace(Handle_MoniTool_CaseData self, Standard_Integer const num)

        Sets the next Add... not to add but to replace the data item
        <num>, if <num> is between 1 and NbData.
        Reset by next Add... , whatever <num> is correct or not

        :type num: int

        """
        return _MoniTool.Handle_MoniTool_CaseData_SetReplace(self, *args)


    def AddData(self, *args):
        """
        AddData(Handle_MoniTool_CaseData self, Handle_Standard_Transient val, Standard_Integer const kind, Standard_CString const name)

        Unitary adding a data; rather internal

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :type kind: int
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddData(self, *args)


    def AddRaised(self, *args):
        """
        AddRaised(Handle_MoniTool_CaseData self, Handle_Standard_Failure theException, Standard_CString const name)

        Adds the currently caught exception

        :type theException: OCC.wrapper.Standard.Handle_Standard_Failure
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddRaised(self, *args)


    def AddShape(self, *args):
        """
        AddShape(Handle_MoniTool_CaseData self, TopoDS_Shape sh, Standard_CString const name)

        Adds a Shape (recorded as a HShape)

        :type sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddShape(self, *args)


    def AddXYZ(self, *args):
        """
        AddXYZ(Handle_MoniTool_CaseData self, gp_XYZ aXYZ, Standard_CString const name)

        Adds a XYZ

        :type aXYZ: OCC.wrapper.gp.gp_XYZ
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddXYZ(self, *args)


    def AddXY(self, *args):
        """
        AddXY(Handle_MoniTool_CaseData self, gp_XY aXY, Standard_CString const name)

        Adds a XY

        :type aXY: OCC.wrapper.gp.gp_XY
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddXY(self, *args)


    def AddReal(self, *args):
        """
        AddReal(Handle_MoniTool_CaseData self, Standard_Real const val, Standard_CString const name)

        Adds a Real

        :type val: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddReal(self, *args)


    def AddReals(self, *args):
        """
        AddReals(Handle_MoniTool_CaseData self, Standard_Real const v1, Standard_Real const v2, Standard_CString const name)

        Adds two reals (for instance, two parameters)

        :type v1: float
        :type v2: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddReals(self, *args)


    def AddCPU(self, *args):
        """
        AddCPU(Handle_MoniTool_CaseData self, Standard_Real const lastCPU, Standard_Real const curCPU=0, Standard_CString const name)

        Adds the CPU time between lastCPU and now
        if <curCPU> is given, the CPU amount is  curCPU-lastCPU
        else it is currently measured CPU - lastCPU
        lastCPU has been read by call to GetCPU
        See GetCPU to get amount, and LargeCPU to test large amount

        :type lastCPU: float
        :type curCPU: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddCPU(self, *args)


    def GetCPU(self, *args):
        """
        GetCPU(Handle_MoniTool_CaseData self) -> Standard_Real

        Returns the current amount of CPU
        This allows to laterly test and record CPU amount
        Its value has to be given to LargeCPU and AddCPU

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.Handle_MoniTool_CaseData_GetCPU(self, *args)


    def LargeCPU(self, *args):
        """
        LargeCPU(Handle_MoniTool_CaseData self, Standard_Real const maxCPU, Standard_Real const lastCPU, Standard_Real const curCPU=0) -> Standard_Boolean

        Tells if a CPU time amount is large
        <maxCPU>  gives the amount over which an amount is large
        <lastCPU> gives the start CPU amount
        if <curCPU> is given, the tested CPU amount is curCPU-lastCPU
        else it is currently measured CPU - lastCPU

        :type maxCPU: float
        :type lastCPU: float
        :type curCPU: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_LargeCPU(self, *args)


    def AddGeom(self, *args):
        """
        AddGeom(Handle_MoniTool_CaseData self, Handle_Standard_Transient geom, Standard_CString const name)

        Adds a Geometric as a Transient (Curve, Surface ...)

        :type geom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddGeom(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Handle_MoniTool_CaseData self, Handle_Standard_Transient ent, Standard_CString const name)

        Adds a Transient, as an Entity from an InterfaceModel for
        instance : it will then be printed with the help of a DBPE

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddEntity(self, *args)


    def AddText(self, *args):
        """
        AddText(Handle_MoniTool_CaseData self, Standard_CString const text, Standard_CString const name)

        Adds a Text (as HAsciiString)

        :type text: OCC.wrapper.Standard.Standard_CString
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddText(self, *args)


    def AddInteger(self, *args):
        """
        AddInteger(Handle_MoniTool_CaseData self, Standard_Integer const val, Standard_CString const name)

        Adds an Integer

        :type val: int
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddInteger(self, *args)


    def AddAny(self, *args):
        """
        AddAny(Handle_MoniTool_CaseData self, Handle_Standard_Transient val, Standard_CString const name)

        Adds a Transient, with no more meaning

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_AddAny(self, *args)


    def RemoveData(self, *args):
        """
        RemoveData(Handle_MoniTool_CaseData self, Standard_Integer const num)

        Removes a Data from its rank. Does nothing if out of range

        :type num: int

        """
        return _MoniTool.Handle_MoniTool_CaseData_RemoveData(self, *args)


    def NbData(self, *args):
        """
        NbData(Handle_MoniTool_CaseData self) -> Standard_Integer

        Returns the count of data recorded to a set

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_CaseData_NbData(self, *args)


    def Data(self, *args):
        """
        Data(Handle_MoniTool_CaseData self, Standard_Integer const nd) -> Handle_Standard_Transient

        Returns a data item (n0 <nd> in the set <num>)

        :type nd: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_CaseData_Data(self, *args)


    def GetData(self, *args):
        """
        GetData(Handle_MoniTool_CaseData self, Standard_Integer const nd, Handle_Standard_Type type, Handle_Standard_Transient val) -> Standard_Boolean

        Returns a data item, under control of a Type
        If the data item is kind of this type, it is returned in <val>
        and the returned value is True
        Else, <val> is unchanged and the returned value is False

        :type nd: int
        :type type: OCC.wrapper.Standard.Handle_Standard_Type
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_GetData(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Integer

        Returns the kind of a data :
        KIND TYPE      MEANING
        0  ANY       any (not one of the followings)
        1  EX        raised exception
        2  EN        entity
        3  G         geom
        4  SH        shape
        5  XYZ       XYZ
        6  XY or UV  XY
        7  RR        2 reals
        8  R         1 real
        9  CPU       CPU (1 real)
        10 T         text
        11 I         integer

        For NameNum, these codes for TYPE must be given exact
        i.e. SH for a Shape, not S nor SHAPE nor SOLID etc

        :type nd: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_CaseData_Kind(self, *args)


    def NameNum(self, *args):
        """
        NameNum(Handle_MoniTool_CaseData self, Standard_CString const name) -> Standard_Integer

        Returns the first suitable data rank for a given name
        Exact maching (exact case, no completion) is required
        Firstly checks the recorded names
        If not found, considers the name as follows :
        Name = "TYPE" : search for the first item with this TYPE
        Name = "TYPE:nn" : search for the nn.th item with this TYPE
        See allowed values in method Kind

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_CaseData_NameNum(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_MoniTool_CaseData self, Standard_Integer const nd) -> TopoDS_Shape

        Returns a data as a shape, Null if not a shape

        :type nd: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _MoniTool.Handle_MoniTool_CaseData_Shape(self, *args)


    def XYZ(self, *args):
        """
        XYZ(Handle_MoniTool_CaseData self, Standard_Integer const nd, gp_XYZ val) -> Standard_Boolean

        Returns a data as a XYZ (i.e. Geom_CartesianPoint)
        Returns False if not the good type

        :type nd: int
        :type val: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_XYZ(self, *args)


    def XY(self, *args):
        """
        XY(Handle_MoniTool_CaseData self, Standard_Integer const nd, gp_XY val) -> Standard_Boolean

        Returns a data as a XY  (i.e. Geom2d_CartesianPoint)
        Returns False if not the good type

        :type nd: int
        :type val: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_XY(self, *args)


    def Reals(self, *args):
        """
        Reals(Handle_MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Boolean

        Returns a couple of reals  (stored in Geom2d_CartesianPoint)

        :type nd: int
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_Reals(self, *args)


    def Real(self, *args):
        """
        Real(Handle_MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Boolean

        Returns a real or CPU amount (stored in Geom2d_CartesianPoint)
        (allows an Integer converted to a Real)

        :type nd: int
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_Real(self, *args)


    def Text(self, *args):
        """
        Text(Handle_MoniTool_CaseData self, Standard_Integer const nd, Standard_CString & text) -> Standard_Boolean

        Returns a text (stored in TCollection_HAsciiString)

        :type nd: int
        :type text: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_Text(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_MoniTool_CaseData self, Standard_Integer const nd) -> Standard_Boolean

        Returns an Integer

        :type nd: int
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_Integer(self, *args)


    def Msg(self, *args):
        """
        Msg(Handle_MoniTool_CaseData self) -> Message_Msg

        Returns a Msg from a CaseData : it is build from DefMsg, which
        gives the message code plus the designation of items of the
        CaseData to be added to the Msg
        Empty if no message attached

        Remains to be implemented

        :rtype: OCC.wrapper.Message.Message_Msg

        """
        return _MoniTool.Handle_MoniTool_CaseData_Msg(self, *args)


    def SetDefWarning(self, *args):
        """
        SetDefWarning(Handle_MoniTool_CaseData self, Standard_CString const acode)

        Sets a Code to give a Warning

        :type acode: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_SetDefWarning(self, *args)


    def SetDefFail(self, *args):
        """
        SetDefFail(Handle_MoniTool_CaseData self, Standard_CString const acode)

        Sets a Code to give a Fail

        :type acode: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_SetDefFail(self, *args)


    def DefCheck(self, *args):
        """
        DefCheck(Handle_MoniTool_CaseData self, Standard_CString const acode) -> Standard_Integer

        Returns Check Status for a Code : 0 non/info (default),
        1 warning, 2 fail

        Remark : DefCheck is used to set the check status of a
        CaseData when it is attached to a case code, it can be changed
        later (by SetFail, SetWarning, ResetCheck)

        :type acode: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_CaseData_DefCheck(self, *args)


    def SetDefMsg(self, *args):
        """
        SetDefMsg(Handle_MoniTool_CaseData self, Standard_CString const casecode, Standard_CString const mesdef)

        Attaches a message definition to a case code
        This definition includes the message code plus designation of
        items of the CaseData to be added to the message (this part
        not yet implemented)

        :type casecode: OCC.wrapper.Standard.Standard_CString
        :type mesdef: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_SetDefMsg(self, *args)


    def DefMsg(self, *args):
        """
        DefMsg(Handle_MoniTool_CaseData self, Standard_CString const casecode) -> Standard_CString

        Returns the message definition for a case code
        Empty if no message attached

        :type casecode: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_CaseData_DefMsg(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_CaseData self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_CaseData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_CaseData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_CaseData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_CaseData self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_CaseData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_CaseData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_CaseData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_CaseData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_CaseData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_CaseData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_CaseData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_CaseData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_CaseData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_CaseData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_CaseData self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_CaseData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_CaseData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_CaseData_DecrementRefCounter(self, *args)

Handle_MoniTool_CaseData_swigregister = _MoniTool.Handle_MoniTool_CaseData_swigregister
Handle_MoniTool_CaseData_swigregister(Handle_MoniTool_CaseData)

def Handle_MoniTool_CaseData_DownCast(thing):
    return _MoniTool.Handle_MoniTool_CaseData_DownCast(thing)
Handle_MoniTool_CaseData_DownCast = _MoniTool.Handle_MoniTool_CaseData_DownCast

class NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self) -> NCollection_DataMap< char *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self) -> NCollection_DataMap< char *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self) -> NCollection_DataMap< char *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self) -> NCollection_DataMap< char *,opencascade::handle< MoniTool_Timer >,MoniTool_MTHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MoniTool.new_NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher theOther) -> NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher theOther) -> NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, char *const & theKey, Handle_MoniTool_Timer theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, char *const & theKey, Handle_MoniTool_Timer theItem) -> Handle_MoniTool_Timer

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, char *const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, char *const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, char *const & theKey) -> Handle_MoniTool_Timer

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, char *const & theKey) -> Handle_MoniTool_Timer

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, char *const & theKey) -> Handle_MoniTool_Timer

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_Size(self, *args)


    def __iter__(self):
        return _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher___iter__(self)
    __swig_destroy__ = _MoniTool.delete_NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher
NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_swigregister = _MoniTool.NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_swigregister
NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher_swigregister(NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher)


try:
	MoniTool_DataMapOfTimer = NCollection_DataMap_Standard_CString_Handle_MoniTool_Timer_MoniTool_MTHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MoniTool_SignText(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_SignText self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_SignText_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_SignText self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_SignText_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_SignText self, MoniTool_SignText thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_SignText_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_SignText self, Handle_MoniTool_SignText theHandle) -> Handle_MoniTool_SignText
        assign(Handle_MoniTool_SignText self, MoniTool_SignText thePtr) -> Handle_MoniTool_SignText
        assign(Handle_MoniTool_SignText self, Handle_MoniTool_SignText theHandle) -> Handle_MoniTool_SignText

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_SignText_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_SignText self) -> MoniTool_SignText

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_SignText_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_SignText self) -> MoniTool_SignText

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_SignText___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_SignText self) -> MoniTool_SignText

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_SignText___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_SignText___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_SignText___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_SignText(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_SignText_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_SignText

    def Name(self, *args):
        """
        Name(Handle_MoniTool_SignText self) -> Standard_CString

        Returns an identification of the Signature (a word), given at
        initialization time

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_SignText_Name(self, *args)


    def TextAlone(self, *args):
        """
        TextAlone(Handle_MoniTool_SignText self, Handle_Standard_Transient ent) -> TCollection_AsciiString

        Gives a text as a signature for a transient object alone, i.e.
        without defined context.
        By default, calls Text with undefined context (Null Handle) and
        if empty, then returns DynamicType

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.Handle_MoniTool_SignText_TextAlone(self, *args)


    def Text(self, *args):
        """
        Text(Handle_MoniTool_SignText self, Handle_Standard_Transient ent, Handle_Standard_Transient context) -> TCollection_AsciiString

        Gives a text as a signature for a transient object in a context
        If the context is senseless, it can be given as Null Handle
        empty result if nothing to give (at least the DynamicType could
        be sent ?)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type context: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.Handle_MoniTool_SignText_Text(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_SignText self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_SignText_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_SignText_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_SignText_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_SignText self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_SignText_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_SignText self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_SignText self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_SignText_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_SignText self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_SignText self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_SignText_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_SignText self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_SignText_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_SignText self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_SignText_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_SignText self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_SignText_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_SignText self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_SignText_DecrementRefCounter(self, *args)

Handle_MoniTool_SignText_swigregister = _MoniTool.Handle_MoniTool_SignText_swigregister
Handle_MoniTool_SignText_swigregister(Handle_MoniTool_SignText)

def Handle_MoniTool_SignText_DownCast(thing):
    return _MoniTool.Handle_MoniTool_SignText_DownCast(thing)
Handle_MoniTool_SignText_DownCast = _MoniTool.Handle_MoniTool_SignText_DownCast

class MoniTool_DataInfo(object):
    """
    Gives informations on an object
    Used as template to instantiate Elem, etc
    This class is for Transient
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Type(*args):
        """
        Type(Handle_Standard_Transient ent) -> Handle_Standard_Type

        Returns the Type attached to an object
        Here, the Dynamic Type of a Transient. Null Type if unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.MoniTool_DataInfo_Type(*args)

    Type = staticmethod(Type)

    def TypeName(*args):
        """
        TypeName(Handle_Standard_Transient ent) -> Standard_CString

        Returns Type Name (string)
        Allows to name type of non-handled objects

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.MoniTool_DataInfo_TypeName(*args)

    TypeName = staticmethod(TypeName)

    def __init__(self):
        """
        Gives informations on an object
        Used as template to instantiate Elem, etc
        This class is for Transient
        """
        this = _MoniTool.new_MoniTool_DataInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_MoniTool_DataInfo
MoniTool_DataInfo_swigregister = _MoniTool.MoniTool_DataInfo_swigregister
MoniTool_DataInfo_swigregister(MoniTool_DataInfo)

def MoniTool_DataInfo_Type(*args):
    """
    MoniTool_DataInfo_Type(Handle_Standard_Transient ent) -> Handle_Standard_Type

    Returns the Type attached to an object
    Here, the Dynamic Type of a Transient. Null Type if unknown

    :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MoniTool.MoniTool_DataInfo_Type(*args)

def MoniTool_DataInfo_TypeName(*args):
    """
    MoniTool_DataInfo_TypeName(Handle_Standard_Transient ent) -> Standard_CString

    Returns Type Name (string)
    Allows to name type of non-handled objects

    :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _MoniTool.MoniTool_DataInfo_TypeName(*args)

class MoniTool_TimerSentry(object):
    """
    A tool to facilitate using MoniTool_Timer functionality
    by automatically ensuring consistency of start/stop actions

    When instance of TimerSentry is created, a timer
    with corresponding name is started
    When instance is deleted, timer stops
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(MoniTool_TimerSentry self, Standard_CString const cname) -> MoniTool_TimerSentry
        __init__(MoniTool_TimerSentry self, Handle_MoniTool_Timer timer) -> MoniTool_TimerSentry

        Constructor creates an instance and runs the corresponding timer

        :type timer: OCC.wrapper.MoniTool.Handle_MoniTool_Timer

        """
        this = _MoniTool.new_MoniTool_TimerSentry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Timer(self, *args):
        """
        Timer(MoniTool_TimerSentry self) -> Handle_MoniTool_Timer

        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_Timer

        """
        return _MoniTool.MoniTool_TimerSentry_Timer(self, *args)


    def Stop(self, *args):
        """
        Stop(MoniTool_TimerSentry self)

        Manually stops the timer


        """
        return _MoniTool.MoniTool_TimerSentry_Stop(self, *args)

    __swig_destroy__ = _MoniTool.delete_MoniTool_TimerSentry
MoniTool_TimerSentry_swigregister = _MoniTool.MoniTool_TimerSentry_swigregister
MoniTool_TimerSentry_swigregister(MoniTool_TimerSentry)

class Handle_MoniTool_IntVal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_IntVal self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_IntVal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_IntVal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_IntVal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_IntVal self, MoniTool_IntVal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_IntVal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_IntVal self, Handle_MoniTool_IntVal theHandle) -> Handle_MoniTool_IntVal
        assign(Handle_MoniTool_IntVal self, MoniTool_IntVal thePtr) -> Handle_MoniTool_IntVal
        assign(Handle_MoniTool_IntVal self, Handle_MoniTool_IntVal theHandle) -> Handle_MoniTool_IntVal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_IntVal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_IntVal self) -> MoniTool_IntVal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_IntVal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_IntVal self) -> MoniTool_IntVal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_IntVal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_IntVal self) -> MoniTool_IntVal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_IntVal___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_IntVal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_IntVal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_IntVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_IntVal_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_IntVal

    def Value(self, *args):
        """
        Value(Handle_MoniTool_IntVal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_IntVal_Value(self, *args)


    def CValue(self, *args):
        """
        CValue(Handle_MoniTool_IntVal self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_IntVal_CValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_IntVal self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_IntVal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_IntVal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_IntVal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_IntVal self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_IntVal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_IntVal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_IntVal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_IntVal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_IntVal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_IntVal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_IntVal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_IntVal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_IntVal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_IntVal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_IntVal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_IntVal self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_IntVal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_IntVal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_IntVal_DecrementRefCounter(self, *args)

Handle_MoniTool_IntVal_swigregister = _MoniTool.Handle_MoniTool_IntVal_swigregister
Handle_MoniTool_IntVal_swigregister(Handle_MoniTool_IntVal)

def Handle_MoniTool_IntVal_DownCast(thing):
    return _MoniTool.Handle_MoniTool_IntVal_DownCast(thing)
Handle_MoniTool_IntVal_DownCast = _MoniTool.Handle_MoniTool_IntVal_DownCast

class NCollection_Sequence_Handle_MoniTool_Element(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_MoniTool_Element self) -> NCollection_Sequence< opencascade::handle< MoniTool_Element > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_MoniTool_Element self) -> NCollection_Sequence< opencascade::handle< MoniTool_Element > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_MoniTool_Element self) -> NCollection_Sequence< opencascade::handle< MoniTool_Element > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_MoniTool_Element self) -> NCollection_Sequence< opencascade::handle< MoniTool_Element > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _MoniTool.new_NCollection_Sequence_Handle_MoniTool_Element(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_MoniTool_Element self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_MoniTool_Element self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_MoniTool_Element self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_MoniTool_Element self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_MoniTool_Element self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_MoniTool_Element self)

        Reverse sequence


        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_MoniTool_Element self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_MoniTool_Element self, NCollection_Sequence_Handle_MoniTool_Element theOther) -> NCollection_Sequence_Handle_MoniTool_Element

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_MoniTool_Element self, NCollection_Sequence_Handle_MoniTool_Element theOther) -> NCollection_Sequence_Handle_MoniTool_Element

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_MoniTool_Element self, NCollection_Sequence< opencascade::handle< MoniTool_Element > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_MoniTool_Element self, Handle_MoniTool_Element theItem)
        Append(NCollection_Sequence_Handle_MoniTool_Element self, NCollection_Sequence_Handle_MoniTool_Element theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_MoniTool_Element self, Handle_MoniTool_Element theItem)
        Prepend(NCollection_Sequence_Handle_MoniTool_Element self, NCollection_Sequence_Handle_MoniTool_Element theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex, Handle_MoniTool_Element theItem)
        InsertBefore(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MoniTool_Element theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_MoniTool_Element self, NCollection_Sequence< opencascade::handle< MoniTool_Element > >::Iterator & thePosition, Handle_MoniTool_Element theItem)
        InsertAfter(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MoniTool_Element theSeq)
        InsertAfter(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex, Handle_MoniTool_Element theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MoniTool_Element theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_MoniTool_Element self) -> Handle_MoniTool_Element

        First item access

        :rtype: TheItemType &

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_MoniTool_Element self) -> Handle_MoniTool_Element

        Last item access

        :rtype: TheItemType &

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex) -> Handle_MoniTool_Element

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MoniTool.NCollection_Sequence_Handle_MoniTool_Element___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_MoniTool_Element self, Standard_Integer const theIndex, Handle_MoniTool_Element theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_SetValue(self, *args)


    def __iter__(self):
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element___iter__(self)
    __swig_destroy__ = _MoniTool.delete_NCollection_Sequence_Handle_MoniTool_Element
NCollection_Sequence_Handle_MoniTool_Element_swigregister = _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_swigregister
NCollection_Sequence_Handle_MoniTool_Element_swigregister(NCollection_Sequence_Handle_MoniTool_Element)

def NCollection_Sequence_Handle_MoniTool_Element_delNode(*args):
    """
    NCollection_Sequence_Handle_MoniTool_Element_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_delNode(*args)

class NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MoniTool.new_NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MoniTool.delete_NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper

    def __next__(self):
        return _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper___next__(self)
NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper_swigregister = _MoniTool.NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper_swigregister
NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper_swigregister(NCollection_Sequence_Handle_MoniTool_Element_IteratorHelper)


try:
	MoniTool_SequenceOfElement = NCollection_Sequence_Handle_MoniTool_Element
except NameError:
	pass # does not exist, probably ignored

class Handle_MoniTool_TypedValue(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_TypedValue self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_TypedValue_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_TypedValue self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_TypedValue_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_TypedValue self, MoniTool_TypedValue thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_TypedValue_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_TypedValue self, Handle_MoniTool_TypedValue theHandle) -> Handle_MoniTool_TypedValue
        assign(Handle_MoniTool_TypedValue self, MoniTool_TypedValue thePtr) -> Handle_MoniTool_TypedValue
        assign(Handle_MoniTool_TypedValue self, Handle_MoniTool_TypedValue theHandle) -> Handle_MoniTool_TypedValue

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_TypedValue_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_TypedValue self) -> MoniTool_TypedValue

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_TypedValue_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_TypedValue self) -> MoniTool_TypedValue

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_TypedValue___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_TypedValue self) -> MoniTool_TypedValue

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_TypedValue___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_TypedValue___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_TypedValue___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_TypedValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_TypedValue_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_TypedValue

    def Internals(self, *args):
        """
        Internals(Handle_MoniTool_TypedValue self, MoniTool_ValueInterpret & interp, MoniTool_ValueSatisfies & satisf, Standard_CString & satisname, NCollection_DataMap< TCollection_AsciiString,Standard_Integer > & enums)

        Access to internal data which have no other access

        :type interp: OCC.wrapper.MoniTool.MoniTool_ValueInterpret
        :type satisf: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type satisname: OCC.wrapper.Standard.Standard_CString
        :type enums: OCC.wrapper.MoniTool.NCollection_DataMap_TCollection_AsciiString_Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Internals(self, *args)


    def Name(self, *args):
        """
        Name(Handle_MoniTool_TypedValue self) -> Standard_CString

        Returns the name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Name(self, *args)


    def ValueType(self, *args):
        """
        ValueType(Handle_MoniTool_TypedValue self) -> MoniTool_ValueType

        Returns the type of the value

        :rtype: OCC.wrapper.MoniTool.MoniTool_ValueType

        """
        return _MoniTool.Handle_MoniTool_TypedValue_ValueType(self, *args)


    def Definition(self, *args):
        """
        Definition(Handle_MoniTool_TypedValue self) -> TCollection_AsciiString

        Returns the Definition
        By priority, the enforced one, else an automatic one, computed
        from the specification

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Definition(self, *args)


    def SetDefinition(self, *args):
        """
        SetDefinition(Handle_MoniTool_TypedValue self, Standard_CString const deftext)

        Enforces a Definition

        :type deftext: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetDefinition(self, *args)


    def Print(self, *args):
        """
        Print(Handle_MoniTool_TypedValue self, Handle_Message_Messenger S)

        Prints definition, specification, and actual status and value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Print(self, *args)


    def PrintValue(self, *args):
        """
        PrintValue(Handle_MoniTool_TypedValue self, Handle_Message_Messenger S)

        Prints only the Value

        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _MoniTool.Handle_MoniTool_TypedValue_PrintValue(self, *args)


    def AddDef(self, *args):
        """
        AddDef(Handle_MoniTool_TypedValue self, Standard_CString const initext) -> Standard_Boolean

        Completes the definition of a TypedValue by command <initext>,
        once created with its type
        Returns True if done, False if could not be interpreted
        <initext> may be :
        imin ival : minimum value for an integer
        imax ival : maximum value for an integer
        rmin rval : minimum value for a real
        rmax rval : maximum value for a real
        unit name : name of unit
        ematch i  : enum from integer value i, match required
        enum   i  : enum from integer value i, match not required
        eval text : add an enumerative value (increments max by 1)
        eval ??   : add a non-authorised enum value (to be skipped)
        tmax   l  : maximum length for a text

        :type initext: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_AddDef(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_MoniTool_TypedValue self, Standard_CString const label)

        Sets a label, which can then be displayed

        :type label: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetLabel(self, *args)


    def Label(self, *args):
        """
        Label(Handle_MoniTool_TypedValue self) -> Standard_CString

        Returns the label, if set; else returns an empty string

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Label(self, *args)


    def SetMaxLength(self, *args):
        """
        SetMaxLength(Handle_MoniTool_TypedValue self, Standard_Integer const max)

        Sets a maximum length for a text (active only for a free text)

        :type max: int

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetMaxLength(self, *args)


    def MaxLength(self, *args):
        """
        MaxLength(Handle_MoniTool_TypedValue self) -> Standard_Integer

        Returns the maximum length, 0 if not set

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TypedValue_MaxLength(self, *args)


    def SetIntegerLimit(self, *args):
        """
        SetIntegerLimit(Handle_MoniTool_TypedValue self, Standard_Boolean const max, Standard_Integer const val)

        Sets an Integer limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: int

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetIntegerLimit(self, *args)


    def IntegerLimit(self, *args):
        """
        IntegerLimit(Handle_MoniTool_TypedValue self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Integer Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Integer)

        :type max: bool
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_IntegerLimit(self, *args)


    def SetRealLimit(self, *args):
        """
        SetRealLimit(Handle_MoniTool_TypedValue self, Standard_Boolean const max, Standard_Real const val)

        Sets a Real limit (included) to <val>, the upper limit
        if <max> is True, the lower limit if <max> is False

        :type max: bool
        :type val: float

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetRealLimit(self, *args)


    def RealLimit(self, *args):
        """
        RealLimit(Handle_MoniTool_TypedValue self, Standard_Boolean const max) -> Standard_Boolean

        Gives an Real Limit (upper if <max> True, lower if <max>
        False). Returns True if this limit is defined, False else
        (in that case, gives the natural limit for Real)

        :type max: bool
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_RealLimit(self, *args)


    def SetUnitDef(self, *args):
        """
        SetUnitDef(Handle_MoniTool_TypedValue self, Standard_CString const arg2)

        Sets (Clears if <def> empty) a unit definition, as an equation
        of dimensions. TypedValue just records this definition, does
        not exploit it, to be done as required by user applications

        :type def: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetUnitDef(self, *args)


    def UnitDef(self, *args):
        """
        UnitDef(Handle_MoniTool_TypedValue self) -> Standard_CString

        Returns the recorded unit definition, empty if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_UnitDef(self, *args)


    def StartEnum(self, *args):
        """
        StartEnum(Handle_MoniTool_TypedValue self, Standard_Integer const start=0, Standard_Boolean const match)

        For an enumeration, precises the starting value (default 0)
        and the match condition : if True (D), the string value must
        match the definition, else it may take another value : in that
        case, the Integer Value will be  Start - 1.
        (empty value remains allowed)

        :type start: int
        :type match: bool

        """
        return _MoniTool.Handle_MoniTool_TypedValue_StartEnum(self, *args)


    def AddEnum(self, *args):
        """
        AddEnum(Handle_MoniTool_TypedValue self, Standard_CString const v1, Standard_CString const v2, Standard_CString const v3, Standard_CString const v4, Standard_CString const v5, Standard_CString const v6, Standard_CString const v7, Standard_CString const v8, Standard_CString const v9, Standard_CString const v10)

        Adds enumerative definitions. For more than 10, several calls

        :type v1: OCC.wrapper.Standard.Standard_CString
        :type v2: OCC.wrapper.Standard.Standard_CString
        :type v3: OCC.wrapper.Standard.Standard_CString
        :type v4: OCC.wrapper.Standard.Standard_CString
        :type v5: OCC.wrapper.Standard.Standard_CString
        :type v6: OCC.wrapper.Standard.Standard_CString
        :type v7: OCC.wrapper.Standard.Standard_CString
        :type v8: OCC.wrapper.Standard.Standard_CString
        :type v9: OCC.wrapper.Standard.Standard_CString
        :type v10: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_AddEnum(self, *args)


    def AddEnumValue(self, *args):
        """
        AddEnumValue(Handle_MoniTool_TypedValue self, Standard_CString const val, Standard_Integer const num)

        Adds an enumeration definition, by its string and numeric
        values. If it is the first setting for this value, it is
        recorded as main value. Else, it is recognized as alternate
        string for this numeric value

        :type val: OCC.wrapper.Standard.Standard_CString
        :type num: int

        """
        return _MoniTool.Handle_MoniTool_TypedValue_AddEnumValue(self, *args)


    def EnumDef(self, *args):
        """
        EnumDef(Handle_MoniTool_TypedValue self) -> Standard_Boolean

        Gives the Enum definitions : start value, end value, match
        status. Returns True for an Enum, False else.

        :type startcase: int
        :type endcase: int
        :type match: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_EnumDef(self, *args)


    def EnumVal(self, *args):
        """
        EnumVal(Handle_MoniTool_TypedValue self, Standard_Integer const num) -> Standard_CString

        Returns the value of an enumerative definition, from its rank
        Empty string if out of range or not an Enum

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_EnumVal(self, *args)


    def EnumCase(self, *args):
        """
        EnumCase(Handle_MoniTool_TypedValue self, Standard_CString const val) -> Standard_Integer

        Returns the case number which cooresponds to a string value
        Works with main and additionnal values
        Returns (StartEnum - 1) if not OK, -1 if not an Enum

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TypedValue_EnumCase(self, *args)


    def SetObjectType(self, *args):
        """
        SetObjectType(Handle_MoniTool_TypedValue self, Handle_Standard_Type typ)

        Sets type of which an Object TypedValue must be kind of
        Error for a TypedValue not an Object (Entity)

        :type typ: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetObjectType(self, *args)


    def ObjectType(self, *args):
        """
        ObjectType(Handle_MoniTool_TypedValue self) -> Handle_Standard_Type

        Returns the type of which an Object TypedValue must be kind of
        Default is Standard_Transient
        Null for a TypedValue not an Object

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MoniTool.Handle_MoniTool_TypedValue_ObjectType(self, *args)


    def SetInterpret(self, *args):
        """
        SetInterpret(Handle_MoniTool_TypedValue self, MoniTool_ValueInterpret const func)

        Sets a specific Interpret function

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueInterpret

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetInterpret(self, *args)


    def HasInterpret(self, *args):
        """
        HasInterpret(Handle_MoniTool_TypedValue self) -> Standard_Boolean

        Tells if a TypedValue has an Interpret

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_HasInterpret(self, *args)


    def SetSatisfies(self, *args):
        """
        SetSatisfies(Handle_MoniTool_TypedValue self, MoniTool_ValueSatisfies const func, Standard_CString const name)

        Sets a specific Satisfies function : it is added to the
        already defined criteria
        It must match the form :
        statisfies (val : HAsciiString) returns Boolean

        :type func: OCC.wrapper.MoniTool.MoniTool_ValueSatisfies
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetSatisfies(self, *args)


    def SatisfiesName(self, *args):
        """
        SatisfiesName(Handle_MoniTool_TypedValue self) -> Standard_CString

        Returns name of specific satisfy, empty string if none

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SatisfiesName(self, *args)


    def IsSetValue(self, *args):
        """
        IsSetValue(Handle_MoniTool_TypedValue self) -> Standard_Boolean

        Returns True if the value is set (not empty/not null object)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_IsSetValue(self, *args)


    def CStringValue(self, *args):
        """
        CStringValue(Handle_MoniTool_TypedValue self) -> Standard_CString

        Returns the value, as a cstring. Empty if not set.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_CStringValue(self, *args)


    def HStringValue(self, *args):
        """
        HStringValue(Handle_MoniTool_TypedValue self) -> Handle_TCollection_HAsciiString

        Returns the value, as a Handle (can then be shared)
        Null if not defined

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_HStringValue(self, *args)


    def Interpret(self, *args):
        """
        Interpret(Handle_MoniTool_TypedValue self, Handle_TCollection_HAsciiString hval, Standard_Boolean const native) -> Handle_TCollection_HAsciiString

        Interprets a value.
        <native> True  : returns a native value
        <native> False : returns a coded  value
        If the Interpret function is set, calls it
        Else, for an Enum, Native returns the Text, Coded returns
        the number
        STANDARD RETURNS : = hval means no specific interpretation
        Null means senseless
        Can also be redefined

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type native: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Interpret(self, *args)


    def Satisfies(self, *args):
        """
        Satisfies(Handle_MoniTool_TypedValue self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Returns True if a value statifies the specification
        (remark : does not apply to Entity : see ObjectType, for this
        type, the string is just a comment)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Satisfies(self, *args)


    def ClearValue(self, *args):
        """
        ClearValue(Handle_MoniTool_TypedValue self)

        Clears the recorded Value : it is now unset


        """
        return _MoniTool.Handle_MoniTool_TypedValue_ClearValue(self, *args)


    def SetCStringValue(self, *args):
        """
        SetCStringValue(Handle_MoniTool_TypedValue self, Standard_CString const val) -> Standard_Boolean

        Changes the value. The new one must satisfy the specification
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type val: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetCStringValue(self, *args)


    def SetHStringValue(self, *args):
        """
        SetHStringValue(Handle_MoniTool_TypedValue self, Handle_TCollection_HAsciiString hval) -> Standard_Boolean

        Forces a new Handle for the Value
        It can be empty, else (if Type is not free Text), it must
        satisfy the specification.
        Not only the value is changed, but also the way it is shared
        Remark : for Type=Object, this value is not controlled, it can
        be set as a comment
        Returns False (and did not set) if the new value
        does not satisfy the specification
        Can be redefined to be managed (in a subclass)

        :type hval: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetHStringValue(self, *args)


    def IntegerValue(self, *args):
        """
        IntegerValue(Handle_MoniTool_TypedValue self) -> Standard_Integer

        Returns the value as integer, i.e. :
        For type = Integer, the integer itself; 0 if not set
        For type = Enum, the designated rank (see Enum definition)
        StartEnum - 1 if not set or not in the definition
        Else, returns 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TypedValue_IntegerValue(self, *args)


    def SetIntegerValue(self, *args):
        """
        SetIntegerValue(Handle_MoniTool_TypedValue self, Standard_Integer const ival) -> Standard_Boolean

        Changes the value as an integer, only for Integer or Enum

        :type ival: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetIntegerValue(self, *args)


    def RealValue(self, *args):
        """
        RealValue(Handle_MoniTool_TypedValue self) -> Standard_Real

        Returns the value as real,  for a Real type TypedValue
        Else, returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.Handle_MoniTool_TypedValue_RealValue(self, *args)


    def SetRealValue(self, *args):
        """
        SetRealValue(Handle_MoniTool_TypedValue self, Standard_Real const rval) -> Standard_Boolean

        Changes the value as a real, only for Real

        :type rval: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetRealValue(self, *args)


    def ObjectValue(self, *args):
        """
        ObjectValue(Handle_MoniTool_TypedValue self) -> Handle_Standard_Transient

        Returns the value as Transient Object, only for Object/Entity
        Remark that the "HString value" is IGNORED here
        Null if not set; remains to be casted

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_TypedValue_ObjectValue(self, *args)


    def GetObjectValue(self, *args):
        """
        GetObjectValue(Handle_MoniTool_TypedValue self, Handle_Standard_Transient val)

        Same as ObjectValue, but avoids DownCast : the receiving
        variable is directly loaded. It is assumed that it complies
        with the definition of ObjectType ! Otherwise, big trouble

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_TypedValue_GetObjectValue(self, *args)


    def SetObjectValue(self, *args):
        """
        SetObjectValue(Handle_MoniTool_TypedValue self, Handle_Standard_Transient obj) -> Standard_Boolean

        Changes the value as Transient Object, only for Object/Entity
        Returns False if DynamicType does not satisfy ObjectType
        Can be redefined to be managed (in a subclass)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_SetObjectValue(self, *args)


    def ObjectTypeName(self, *args):
        """
        ObjectTypeName(Handle_MoniTool_TypedValue self) -> Standard_CString

        Returns the type name of the ObjectValue, or an empty string
        if not set

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_ObjectTypeName(self, *args)


    def AddLib(self, *args):
        """
        AddLib(Handle_MoniTool_TypedValue self, Handle_MoniTool_TypedValue tv, Standard_CString const arg2) -> Standard_Boolean

        Adds a TypedValue in the library.
        It is recorded then will be accessed by its Name
        Its Definition may be imposed, else it is computed as usual
        By default it will be accessed by its Definition (string)
        Returns True if done, False if tv is Null or brings no
        Definition or <def> not defined

        If a TypedValue was already recorded under this name, it is
        replaced

        :type tv: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue
        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_AddLib(self, *args)


    def Lib(self, *args):
        """
        Lib(Handle_MoniTool_TypedValue self, Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns the TypedValue bound with a given Name
        Null Handle if none recorded
        Warning : it is the original, not duplicated

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _MoniTool.Handle_MoniTool_TypedValue_Lib(self, *args)


    def FromLib(self, *args):
        """
        FromLib(Handle_MoniTool_TypedValue self, Standard_CString const arg1) -> Handle_MoniTool_TypedValue

        Returns a COPY of the TypedValue bound with a given Name
        Null Handle if none recorded

        :type def: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _MoniTool.Handle_MoniTool_TypedValue_FromLib(self, *args)


    def LibList(self, *args):
        """
        LibList(Handle_MoniTool_TypedValue self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the list of names of items of the Library of Types
        --    Library of TypedValue as Valued Parameters,    -- --
        accessed by parameter name
        for use by management of Static Parameters

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _MoniTool.Handle_MoniTool_TypedValue_LibList(self, *args)


    def StaticValue(self, *args):
        """
        StaticValue(Handle_MoniTool_TypedValue self, Standard_CString const name) -> Handle_MoniTool_TypedValue

        Returns a static value from its name, null if unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MoniTool.Handle_MoniTool_TypedValue

        """
        return _MoniTool.Handle_MoniTool_TypedValue_StaticValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_TypedValue self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_TypedValue_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_TypedValue_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_TypedValue_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_TypedValue self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_TypedValue_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_TypedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_TypedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_TypedValue self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_TypedValue self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_TypedValue_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_TypedValue self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_TypedValue_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_TypedValue self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TypedValue_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_TypedValue self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_TypedValue_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_TypedValue self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_TypedValue_DecrementRefCounter(self, *args)

Handle_MoniTool_TypedValue_swigregister = _MoniTool.Handle_MoniTool_TypedValue_swigregister
Handle_MoniTool_TypedValue_swigregister(Handle_MoniTool_TypedValue)

def Handle_MoniTool_TypedValue_DownCast(thing):
    return _MoniTool.Handle_MoniTool_TypedValue_DownCast(thing)
Handle_MoniTool_TypedValue_DownCast = _MoniTool.Handle_MoniTool_TypedValue_DownCast

class Handle_MoniTool_RealVal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MoniTool_RealVal self)

        Nullify the handle


        """
        return _MoniTool.Handle_MoniTool_RealVal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MoniTool_RealVal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MoniTool.Handle_MoniTool_RealVal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MoniTool_RealVal self, MoniTool_RealVal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MoniTool.Handle_MoniTool_RealVal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MoniTool_RealVal self, Handle_MoniTool_RealVal theHandle) -> Handle_MoniTool_RealVal
        assign(Handle_MoniTool_RealVal self, MoniTool_RealVal thePtr) -> Handle_MoniTool_RealVal
        assign(Handle_MoniTool_RealVal self, Handle_MoniTool_RealVal theHandle) -> Handle_MoniTool_RealVal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MoniTool.Handle_MoniTool_RealVal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MoniTool_RealVal self) -> MoniTool_RealVal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_RealVal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MoniTool_RealVal self) -> MoniTool_RealVal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MoniTool.Handle_MoniTool_RealVal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MoniTool_RealVal self) -> MoniTool_RealVal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MoniTool.Handle_MoniTool_RealVal___ref__(self, *args)


    def __hash__(self):
        return _MoniTool.Handle_MoniTool_RealVal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MoniTool.Handle_MoniTool_RealVal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MoniTool.new_Handle_MoniTool_RealVal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MoniTool.Handle_MoniTool_RealVal_DownCast)
    __swig_destroy__ = _MoniTool.delete_Handle_MoniTool_RealVal

    def Value(self, *args):
        """
        Value(Handle_MoniTool_RealVal self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.Handle_MoniTool_RealVal_Value(self, *args)


    def CValue(self, *args):
        """
        CValue(Handle_MoniTool_RealVal self) -> Standard_Real &

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MoniTool.Handle_MoniTool_RealVal_CValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MoniTool_RealVal self) -> char const *

        :rtype: const char *

        """
        return _MoniTool.Handle_MoniTool_RealVal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_RealVal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MoniTool.Handle_MoniTool_RealVal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MoniTool_RealVal self)

        Memory deallocator for transient classes


        """
        return _MoniTool.Handle_MoniTool_RealVal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MoniTool_RealVal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MoniTool_RealVal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_RealVal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MoniTool_RealVal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MoniTool_RealVal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MoniTool.Handle_MoniTool_RealVal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MoniTool_RealVal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MoniTool.Handle_MoniTool_RealVal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MoniTool_RealVal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_RealVal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MoniTool_RealVal self)

        Increments the reference counter of this object


        """
        return _MoniTool.Handle_MoniTool_RealVal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MoniTool_RealVal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MoniTool.Handle_MoniTool_RealVal_DecrementRefCounter(self, *args)

Handle_MoniTool_RealVal_swigregister = _MoniTool.Handle_MoniTool_RealVal_swigregister
Handle_MoniTool_RealVal_swigregister(Handle_MoniTool_RealVal)

def Handle_MoniTool_RealVal_DownCast(thing):
    return _MoniTool.Handle_MoniTool_RealVal_DownCast(thing)
Handle_MoniTool_RealVal_DownCast = _MoniTool.Handle_MoniTool_RealVal_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopExp')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopExp')
    _TopExp = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopExp', [dirname(__file__)])
        except ImportError:
            import _TopExp
            return _TopExp
        try:
            _mod = imp.load_module('_TopExp', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopExp = swig_import_helper()
    del swig_import_helper
else:
    import _TopExp
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopExp.delete_SwigPyIterator

    def value(self):
        return _TopExp.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopExp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopExp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopExp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopExp.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopExp.SwigPyIterator_copy(self)

    def next(self):
        return _TopExp.SwigPyIterator_next(self)

    def __next__(self):
        return _TopExp.SwigPyIterator___next__(self)

    def previous(self):
        return _TopExp.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopExp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopExp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopExp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopExp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopExp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopExp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopExp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopExp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopExp.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopExp.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopExp.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopExp.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopExp.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopExp.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopExp.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopExp.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopExp.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopExp.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopExp.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopExp.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopExp.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopExp.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopExp.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopExp.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopExp.ptr_to_number(item)
ptr_to_number = _TopExp.ptr_to_number

def HashCode(*args):
    return _TopExp.HashCode(*args)
HashCode = _TopExp.HashCode

def ptr_equal(a, b):
    return _TopExp.ptr_equal(a, b)
ptr_equal = _TopExp.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class TopExp_(object):
    """
    This package   provides  basic tools  to   explore the
    topological data structures.

    * Explorer : A tool to find all sub-shapes of  a given
    type. e.g. all faces of a solid.

    * Package methods to map sub-shapes of a shape.

    Level : Public
    All methods of all  classes will be public.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MapShapes(*args):
        """
        MapShapes(TopoDS_Shape S, TopAbs_ShapeEnum const T, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher M)
        MapShapes(TopoDS_Shape S, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher M)
        MapShapes(TopoDS_Shape S, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher M)

        Stores in the map <M> all  the sub-shapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _TopExp.TopExp__MapShapes(*args)

    MapShapes = staticmethod(MapShapes)

    def MapShapesAndAncestors(*args):
        """
        MapShapesAndAncestors(TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher M)

        Stores in the map <M> all the subshape of <S> of
        type <TS>  for each one append  to  the list all
        the ancestors of type <TA>.  For example map all
        the edges and bind the list of faces.
        Warning: The map is not cleared at first.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type M: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        return _TopExp.TopExp__MapShapesAndAncestors(*args)

    MapShapesAndAncestors = staticmethod(MapShapesAndAncestors)

    def MapShapesAndUniqueAncestors(*args):
        """
        MapShapesAndUniqueAncestors(TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher M, Standard_Boolean const useOrientation)

        Stores in the map <M> all the subshape of <S> of
        type <TS> for each one append to the list all
        unique ancestors of type <TA>.  For example map all
        the edges and bind the list of faces.
        useOrientation = True : taking account the ancestor orientation
        Warning: The map is not cleared at first.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type M: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
        :type useOrientation: bool

        """
        return _TopExp.TopExp__MapShapesAndUniqueAncestors(*args)

    MapShapesAndUniqueAncestors = staticmethod(MapShapesAndUniqueAncestors)

    def FirstVertex(*args):
        """
        FirstVertex(TopoDS_Edge E, Standard_Boolean const CumOri) -> TopoDS_Vertex

        Returns the Vertex of orientation FORWARD in E. If
        there is none returns a Null Shape.
        CumOri = True : taking account the edge orientation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type CumOri: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _TopExp.TopExp__FirstVertex(*args)

    FirstVertex = staticmethod(FirstVertex)

    def LastVertex(*args):
        """
        LastVertex(TopoDS_Edge E, Standard_Boolean const CumOri) -> TopoDS_Vertex

        Returns the Vertex of orientation REVERSED in E. If
        there is none returns a Null Shape.
        CumOri = True : taking account the edge orientation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type CumOri: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _TopExp.TopExp__LastVertex(*args)

    LastVertex = staticmethod(LastVertex)

    def Vertices(*args):
        """
        Vertices(TopoDS_Edge E, TopoDS_Vertex Vfirst, TopoDS_Vertex Vlast, Standard_Boolean const CumOri)
        Vertices(TopoDS_Wire W, TopoDS_Vertex Vfirst, TopoDS_Vertex Vlast)

        Returns  in  Vfirst,  Vlast   the first   and last
        vertices of the open wire <W>. May be null shapes.
        if   <W>  is closed Vfirst and Vlast  are a same
        vertex on <W>.
        if <W> is no manifold. VFirst and VLast are null
        shapes.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Vfirst: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Vlast: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _TopExp.TopExp__Vertices(*args)

    Vertices = staticmethod(Vertices)

    def CommonVertex(*args):
        """
        CommonVertex(TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Vertex V) -> Standard_Boolean

        Finds   the  vertex <V> common   to  the two edges
        <E1,E2>, returns True if this vertex exists.

        Warning: <V> has sense only if the value <True> is returned

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopExp.TopExp__CommonVertex(*args)

    CommonVertex = staticmethod(CommonVertex)

    def __init__(self):
        """
        This package   provides  basic tools  to   explore the
        topological data structures.

        * Explorer : A tool to find all sub-shapes of  a given
        type. e.g. all faces of a solid.

        * Package methods to map sub-shapes of a shape.

        Level : Public
        All methods of all  classes will be public.
        """
        this = _TopExp.new_TopExp_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopExp.delete_TopExp_
TopExp__swigregister = _TopExp.TopExp__swigregister
TopExp__swigregister(TopExp_)

def TopExp__MapShapes(*args):
    """
    MapShapes(TopoDS_Shape S, TopAbs_ShapeEnum const T, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher M)
    MapShapes(TopoDS_Shape S, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher M)
    TopExp__MapShapes(TopoDS_Shape S, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher M)

    Stores in the map <M> all  the sub-shapes of <S>.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type M: OCC.wrapper.TopTools.TopTools_MapOfShape

    """
    return _TopExp.TopExp__MapShapes(*args)

def TopExp__MapShapesAndAncestors(*args):
    """
    TopExp__MapShapesAndAncestors(TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher M)

    Stores in the map <M> all the subshape of <S> of
    type <TS>  for each one append  to  the list all
    the ancestors of type <TA>.  For example map all
    the edges and bind the list of faces.
    Warning: The map is not cleared at first.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type M: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

    """
    return _TopExp.TopExp__MapShapesAndAncestors(*args)

def TopExp__MapShapesAndUniqueAncestors(*args):
    """
    TopExp__MapShapesAndUniqueAncestors(TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher M, Standard_Boolean const useOrientation)

    Stores in the map <M> all the subshape of <S> of
    type <TS> for each one append to the list all
    unique ancestors of type <TA>.  For example map all
    the edges and bind the list of faces.
    useOrientation = True : taking account the ancestor orientation
    Warning: The map is not cleared at first.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type M: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
    :type useOrientation: bool

    """
    return _TopExp.TopExp__MapShapesAndUniqueAncestors(*args)

def TopExp__FirstVertex(*args):
    """
    TopExp__FirstVertex(TopoDS_Edge E, Standard_Boolean const CumOri) -> TopoDS_Vertex

    Returns the Vertex of orientation FORWARD in E. If
    there is none returns a Null Shape.
    CumOri = True : taking account the edge orientation

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type CumOri: bool
    :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _TopExp.TopExp__FirstVertex(*args)

def TopExp__LastVertex(*args):
    """
    TopExp__LastVertex(TopoDS_Edge E, Standard_Boolean const CumOri) -> TopoDS_Vertex

    Returns the Vertex of orientation REVERSED in E. If
    there is none returns a Null Shape.
    CumOri = True : taking account the edge orientation

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type CumOri: bool
    :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _TopExp.TopExp__LastVertex(*args)

def TopExp__Vertices(*args):
    """
    Vertices(TopoDS_Edge E, TopoDS_Vertex Vfirst, TopoDS_Vertex Vlast, Standard_Boolean const CumOri)
    TopExp__Vertices(TopoDS_Wire W, TopoDS_Vertex Vfirst, TopoDS_Vertex Vlast)

    Returns  in  Vfirst,  Vlast   the first   and last
    vertices of the open wire <W>. May be null shapes.
    if   <W>  is closed Vfirst and Vlast  are a same
    vertex on <W>.
    if <W> is no manifold. VFirst and VLast are null
    shapes.

    :type W: OCC.wrapper.TopoDS.TopoDS_Wire
    :type Vfirst: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type Vlast: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _TopExp.TopExp__Vertices(*args)

def TopExp__CommonVertex(*args):
    """
    TopExp__CommonVertex(TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Vertex V) -> Standard_Boolean

    Finds   the  vertex <V> common   to  the two edges
    <E1,E2>, returns True if this vertex exists.

    Warning: <V> has sense only if the value <True> is returned

    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopExp.TopExp__CommonVertex(*args)

class TopExp_Explorer(object):
    """
    An Explorer is a Tool to visit  a Topological Data
    Structure form the TopoDS package.

    An Explorer is built with :

    * The Shape to explore.

    * The type of Shapes to find : e.g VERTEX, EDGE.
    This type cannot be SHAPE.

    * The type of Shapes to avoid. e.g  SHELL, EDGE.
    By default   this type is  SHAPE which  means no
    restriction on the exploration.

    The Explorer  visits  all the  structure   to find
    shapes of the   requested  type  which   are   not
    contained in the type to avoid.

    Example to find all the Faces in the Shape S :

    TopExp_Explorer Ex;
    for (Ex.Init(S,TopAbs_FACE); Ex.More(); Ex.Next()) {
    ProcessFace(Ex.Current());
    }

    // an other way
    TopExp_Explorer Ex(S,TopAbs_FACE);
    while (Ex.More()) {
    ProcessFace(Ex.Current());
    Ex.Next();
    }

    To find all the vertices which are not in an edge :

    for (Ex.Init(S,TopAbs_VERTEX,TopAbs_EDGE); ...)

    To  find all the faces  in   a SHELL, then all the
    faces not in a SHELL :

    TopExp_Explorer Ex1, Ex2;

    for (Ex1.Init(S,TopAbs_SHELL),...) {
    // visit all shells
    for (Ex2.Init(Ex1.Current(),TopAbs_FACE),...) {
    // visit all the faces of the current shell
    }
    }

    for (Ex1.Init(S,TopAbs_FACE,TopAbs_SHELL),...) {
    // visit all faces not in a shell
    }

    If   the type  to avoid  is   the same  or is less
    complex than the type to find it has no effect.

    For example searching edges  not in a vertex  does
    not make a difference.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopExp_Explorer self) -> TopExp_Explorer
        __init__(TopExp_Explorer self, TopoDS_Shape S, TopAbs_ShapeEnum const ToFind, TopAbs_ShapeEnum const ToAvoid=TopAbs_SHAPE) -> TopExp_Explorer

        Creates an Explorer on the Shape <S>.

        <ToFind> is the type of shapes to search.
        TopAbs_VERTEX, TopAbs_EDGE, ...

        <ToAvoid>   is the type   of shape to  skip in the
        exploration.   If   <ToAvoid>  is  equal  or  less
        complex than <ToFind> or if  <ToAVoid> is SHAPE it
        has no effect on the exploration.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ToFind: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type ToAvoid: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        this = _TopExp.new_TopExp_Explorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopExp_Explorer self, TopoDS_Shape S, TopAbs_ShapeEnum const ToFind, TopAbs_ShapeEnum const ToAvoid=TopAbs_SHAPE)

        Resets this explorer on the shape S. It is initialized to
        search the shape S, for shapes of type ToFind, that
        are not part of a shape ToAvoid.
        If the shape ToAvoid is equal to TopAbs_SHAPE, or
        if it is the same as, or less complex than, the shape
        ToFind it has no effect on the search.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ToFind: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type ToAvoid: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopExp.TopExp_Explorer_Init(self, *args)


    def More(self, *args):
        """
        More(TopExp_Explorer self) -> Standard_Boolean

        Returns  True if  there are   more  shapes in  the
        exploration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopExp.TopExp_Explorer_More(self, *args)


    def Next(self, *args):
        """
        Next(TopExp_Explorer self)

        Moves to the next Shape in the exploration.
        Exceptions
        Standard_NoMoreObject if there are no more shapes to explore.


        """
        return _TopExp.TopExp_Explorer_Next(self, *args)


    def Current(self, *args):
        """
        Returns the current shape in the exploration.
        Exceptions
        Standard_NoSuchObject if this explorer has no more shapes to explore.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopExp.TopExp_Explorer_Current(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReInit(self, *args):
        """
        ReInit(TopExp_Explorer self)

        Reinitialize  the    exploration with the original
        arguments.


        """
        return _TopExp.TopExp_Explorer_ReInit(self, *args)


    def Depth(self, *args):
        """
        Depth(TopExp_Explorer self) -> Standard_Integer

        Returns the current depth of the exploration. 0 is
        the shape to explore itself.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopExp.TopExp_Explorer_Depth(self, *args)


    def Clear(self, *args):
        """
        Clear(TopExp_Explorer self)

        Clears the content of the explorer. It will return
        False on More().


        """
        return _TopExp.TopExp_Explorer_Clear(self, *args)


    def Destroy(self, *args):
        """Destroy(TopExp_Explorer self)"""
        return _TopExp.TopExp_Explorer_Destroy(self, *args)

    __swig_destroy__ = _TopExp.delete_TopExp_Explorer
TopExp_Explorer_swigregister = _TopExp.TopExp_Explorer_swigregister
TopExp_Explorer_swigregister(TopExp_Explorer)




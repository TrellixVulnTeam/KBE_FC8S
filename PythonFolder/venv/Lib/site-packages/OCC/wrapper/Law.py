# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Law')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Law')
    _Law = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Law', [dirname(__file__)])
        except ImportError:
            import _Law
            return _Law
        try:
            _mod = imp.load_module('_Law', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Law = swig_import_helper()
    del swig_import_helper
else:
    import _Law
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Law.delete_SwigPyIterator

    def value(self):
        return _Law.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Law.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Law.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Law.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Law.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Law.SwigPyIterator_copy(self)

    def next(self):
        return _Law.SwigPyIterator_next(self)

    def __next__(self):
        return _Law.SwigPyIterator___next__(self)

    def previous(self):
        return _Law.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Law.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Law.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Law.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Law.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Law.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Law.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Law.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Law.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Law.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Law.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Law.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Law.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Law.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Law.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Law.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Law.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Law.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Law.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Law.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Law.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Law.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Law.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Law.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Law.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Law.ptr_to_number(item)
ptr_to_number = _Law.ptr_to_number

def HashCode(*args):
    return _Law.HashCode(*args)
HashCode = _Law.HashCode

def ptr_equal(a, b):
    return _Law.ptr_equal(a, b)
ptr_equal = _Law.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
class Law_Function(Standard.Standard_Transient):
    """Root class for evolution laws."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_Function
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_Function(self) 
            return h


    def Continuity(self, *args):
        """
        Continuity(Law_Function self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Function_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Law_Function self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_Function_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Law_Function self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Function_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Law_Function self, Standard_Real const X) -> Standard_Real

        Returns the value of the function at the point of parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_Function_Value(self, *args)


    def D1(self, *args):
        """
        D1(Law_Function self, Standard_Real const X)

        Returns the value F and the first derivative D of the
        function at the point of parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Law_Function_D1(self, *args)


    def D2(self, *args):
        """
        D2(Law_Function self, Standard_Real const X)

        Returns the value, first and seconde derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Law_Function_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Law_Function self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Law_Function_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Law_Function self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Law_Function_Bounds(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_Function_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_Function_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_Function_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_Function
Law_Function_swigregister = _Law.Law_Function_swigregister
Law_Function_swigregister(Law_Function)

def Law_Function_get_type_name(*args):
    """
    Law_Function_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_Function_get_type_name(*args)

def Law_Function_get_type_descriptor(*args):
    """
    Law_Function_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_Function_get_type_descriptor(*args)

class Law_BSpFunc(Law_Function):
    """
    Law Function based on a BSpline curve 1d.  Package
    methods and classes are implemented in package Law
    to    construct  the  basis    curve with  several
    constraints.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_BSpFunc
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_BSpFunc(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Law_BSpFunc self) -> Law_BSpFunc
        __init__(Law_BSpFunc self, Handle_Law_BSpline C, Standard_Real const First, Standard_Real const Last) -> Law_BSpFunc

        :type C: OCC.wrapper.Law.Handle_Law_BSpline
        :type First: float
        :type Last: float

        """
        this = _Law.new_Law_BSpFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Continuity(self, *args):
        """
        Continuity(Law_BSpFunc self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_BSpFunc_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Law_BSpFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Law_BSpFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_BSpFunc_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Law_BSpFunc self, Standard_Real const X) -> Standard_Real

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpFunc_Value(self, *args)


    def D1(self, *args):
        """
        D1(Law_BSpFunc self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Law_BSpFunc_D1(self, *args)


    def D2(self, *args):
        """
        D2(Law_BSpFunc self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Law_BSpFunc_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Law_BSpFunc self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Law_BSpFunc_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Law_BSpFunc self)

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Law_BSpFunc_Bounds(self, *args)


    def Curve(self, *args):
        """
        Curve(Law_BSpFunc self) -> Handle_Law_BSpline

        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Law_BSpFunc_Curve(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Law_BSpFunc self, Handle_Law_BSpline C)

        :type C: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Law_BSpFunc_SetCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_BSpFunc_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_BSpFunc_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_BSpFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_BSpFunc
Law_BSpFunc_swigregister = _Law.Law_BSpFunc_swigregister
Law_BSpFunc_swigregister(Law_BSpFunc)

def Law_BSpFunc_get_type_name(*args):
    """
    Law_BSpFunc_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_BSpFunc_get_type_name(*args)

def Law_BSpFunc_get_type_descriptor(*args):
    """
    Law_BSpFunc_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_BSpFunc_get_type_descriptor(*args)

class Law_Constant(Law_Function):
    """Loi constante"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_Constant
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_Constant(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Law_Constant self) -> Law_Constant

        Loi constante
        """
        this = _Law.new_Law_Constant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(Law_Constant self, Standard_Real const Radius, Standard_Real const PFirst, Standard_Real const PLast)

        Set the radius and the range of the constant Law.

        :type Radius: float
        :type PFirst: float
        :type PLast: float

        """
        return _Law.Law_Constant_Set(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Law_Constant self) -> GeomAbs_Shape

        Returns GeomAbs_CN

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Constant_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Law_Constant self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  1

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_Constant_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Law_Constant self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Constant_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Law_Constant self, Standard_Real const X) -> Standard_Real

        Returns the value at parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_Constant_Value(self, *args)


    def D1(self, *args):
        """
        D1(Law_Constant self, Standard_Real const X)

        Returns the value and the first derivative at parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Law_Constant_D1(self, *args)


    def D2(self, *args):
        """
        D2(Law_Constant self, Standard_Real const X)

        Returns the value, first and second derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Law_Constant_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Law_Constant self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Law_Constant_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Law_Constant self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Law_Constant_Bounds(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_Constant_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_Constant_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_Constant_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_Constant
Law_Constant_swigregister = _Law.Law_Constant_swigregister
Law_Constant_swigregister(Law_Constant)

def Law_Constant_get_type_name(*args):
    """
    Law_Constant_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_Constant_get_type_name(*args)

def Law_Constant_get_type_descriptor(*args):
    """
    Law_Constant_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_Constant_get_type_descriptor(*args)

class Law_Interpol(Law_BSpFunc):
    """
    Provides an evolution law that interpolates a set
    of parameter and value pairs (wi, radi)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_Interpol
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_Interpol(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Law_Interpol self) -> Law_Interpol

        Constructs an empty interpolative evolution law.
        The function Set is used to define the law.


        """
        this = _Law.new_Law_Interpol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Boolean const Periodic)
        Set(Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Real const Dd, Standard_Real const Df, Standard_Boolean const Periodic)

        Defines this evolution law by interpolating the set of 2D
        points ParAndRad. The Y coordinate of a point of
        ParAndRad is the value of the function at the parameter
        point given by its X coordinate.
        If Periodic is true, this function is assumed to be periodic.
        In the second syntax, Dd and Df define the values of
        the first derivative of the function at its first and last points.
        Warning
        -   The X coordinates of points in the table ParAndRad
        must be given in ascendant order.
        -   If Periodic is true, the first and last Y coordinates of
        points in the table ParAndRad are assumed to be
        equal. In addition, with the second syntax, Dd and Df
        are also assumed to be equal. If this is not the case,
        Set uses the first value(s) as last value(s).

        :type ParAndRad: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Dd: float
        :type Df: float
        :type Periodic: bool

        """
        return _Law.Law_Interpol_Set(self, *args)


    def SetInRelative(self, *args):
        """
        SetInRelative(Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Real const Ud, Standard_Real const Uf, Standard_Boolean const Periodic)
        SetInRelative(Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Real const Ud, Standard_Real const Uf, Standard_Real const Dd, Standard_Real const Df, Standard_Boolean const Periodic)

        :type ParAndRad: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Ud: float
        :type Uf: float
        :type Dd: float
        :type Df: float
        :type Periodic: bool

        """
        return _Law.Law_Interpol_SetInRelative(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_Interpol_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_Interpol_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_Interpol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_Interpol
Law_Interpol_swigregister = _Law.Law_Interpol_swigregister
Law_Interpol_swigregister(Law_Interpol)

def Law_Interpol_get_type_name(*args):
    """
    Law_Interpol_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_Interpol_get_type_name(*args)

def Law_Interpol_get_type_descriptor(*args):
    """
    Law_Interpol_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_Interpol_get_type_descriptor(*args)

class Law_Linear(Law_Function):
    """Describes an linear evolution law."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_Linear
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_Linear(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Law_Linear self) -> Law_Linear

        Constructs an empty linear evolution law.


        """
        this = _Law.new_Law_Linear(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(Law_Linear self, Standard_Real const Pdeb, Standard_Real const Valdeb, Standard_Real const Pfin, Standard_Real const Valfin)

        Defines this linear evolution law by assigning both:
        -   the bounds Pdeb and Pfin of the parameter, and
        -   the values Valdeb and Valfin of the function at these
        two parametric bounds.

        :type Pdeb: float
        :type Valdeb: float
        :type Pfin: float
        :type Valfin: float

        """
        return _Law.Law_Linear_Set(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Law_Linear self) -> GeomAbs_Shape

        Returns GeomAbs_CN

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Linear_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Law_Linear self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  1

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_Linear_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Law_Linear self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Linear_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Law_Linear self, Standard_Real const X) -> Standard_Real

        Returns the value of this function at the point of parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_Linear_Value(self, *args)


    def D1(self, *args):
        """
        D1(Law_Linear self, Standard_Real const X)

        Returns the value F and the first derivative D of this
        function at the point of parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Law_Linear_D1(self, *args)


    def D2(self, *args):
        """
        D2(Law_Linear self, Standard_Real const X)

        Returns the value, first and second derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Law_Linear_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Law_Linear self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Law_Linear_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Law_Linear self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Law_Linear_Bounds(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_Linear_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_Linear_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_Linear_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_Linear
Law_Linear_swigregister = _Law.Law_Linear_swigregister
Law_Linear_swigregister(Law_Linear)

def Law_Linear_get_type_name(*args):
    """
    Law_Linear_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_Linear_get_type_name(*args)

def Law_Linear_get_type_descriptor(*args):
    """
    Law_Linear_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_Linear_get_type_descriptor(*args)

class Law_Composite(Law_Function):
    """
    Loi  composite constituee  d une liste  de lois de
    ranges consecutifs.
    Cette implementation un peu lourde permet de reunir
    en une seule loi des portions de loi construites de
    facon independantes (par exemple en interactif) et
    de lancer le walking d un coup a l echelle d une
    ElSpine.
    CET OBJET REPOND DONC A UN PROBLEME D IMPLEMENTATION
    SPECIFIQUE AUX CONGES!!!
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_Composite
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_Composite(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Law_Composite self) -> Law_Composite
        __init__(Law_Composite self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Law_Composite

        Construct an empty, trimed Law

        :type First: float
        :type Last: float
        :type Tol: float

        """
        this = _Law.new_Law_Composite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Continuity(self, *args):
        """
        Continuity(Law_Composite self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Composite_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Law_Composite self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_Composite_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Law_Composite self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_Composite_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Law_Composite self, Standard_Real const X) -> Standard_Real

        Returns the value at parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_Composite_Value(self, *args)


    def D1(self, *args):
        """
        D1(Law_Composite self, Standard_Real const X)

        Returns the value and the first derivative at parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Law_Composite_D1(self, *args)


    def D2(self, *args):
        """
        D2(Law_Composite self, Standard_Real const X)

        Returns the value, first and second derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Law_Composite_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Law_Composite self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Law_Composite_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Law_Composite self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Law_Composite_Bounds(self, *args)


    def ChangeElementaryLaw(self, *args):
        """
        ChangeElementaryLaw(Law_Composite self, Standard_Real const W) -> Handle_Law_Function

        Returns the elementary  function of the composite used
        to compute at parameter W.

        :type W: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Law_Composite_ChangeElementaryLaw(self, *args)


    def ChangeLaws(self, *args):
        """
        ChangeLaws(Law_Composite self) -> NCollection_List_Handle_Law_Function

        :rtype: OCC.wrapper.Law.Law_Laws

        """
        return _Law.Law_Composite_ChangeLaws(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Law_Composite self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Law_Composite_IsPeriodic(self, *args)


    def SetPeriodic(self, *args):
        """SetPeriodic(Law_Composite self)"""
        return _Law.Law_Composite_SetPeriodic(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_Composite_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_Composite_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_Composite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_Composite
Law_Composite_swigregister = _Law.Law_Composite_swigregister
Law_Composite_swigregister(Law_Composite)

def Law_Composite_get_type_name(*args):
    """
    Law_Composite_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_Composite_get_type_name(*args)

def Law_Composite_get_type_descriptor(*args):
    """
    Law_Composite_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_Composite_get_type_descriptor(*args)

class Law_BSpline(Standard.Standard_Transient):
    """
    Definition of the 1D B_spline curve.

    Uniform  or non-uniform
    Rational or non-rational
    Periodic or non-periodic

    a b-spline curve is defined by :

    The Degree (up to 25)

    The Poles  (and the weights if it is rational)

    The Knots and Multiplicities

    The knot vector   is an  increasing  sequence  of
    reals without  repetition. The multiplicities are
    the repetition of the knots.

    If the knots are regularly spaced (the difference
    of two  consecutive  knots  is a   constant), the
    knots repartition is :

    - Uniform if all multiplicities are 1.

    -  Quasi-uniform if  all multiplicities are  1
    but the first and the last which are Degree+1.

    -   PiecewiseBezier if  all multiplicites  are
    Degree but the   first and the  last which are
    Degree+1.

    The curve may be periodic.

    On a periodic curve if there are k knots and p
    poles. the period is knot(k) - knot(1)

    the poles and knots are infinite vectors with :

    knot(i+k) = knot(i) + period

    pole(i+p) = pole(i)

    References :
    . A survey of curve and surface methods in CADG Wolfgang BOHM
    CAGD 1 (1984)
    . On de Boor-like algorithms and blossoming Wolfgang BOEHM
    cagd 5 (1988)
    . Blossoming and knot insertion algorithms for B-spline curves
    Ronald N. GOLDMAN
    . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
    . Curves and Surfaces for Computer Aided Geometric Design,
    a practical guide Gerald Farin
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_BSpline
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_BSpline(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Law_BSpline self, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Multiplicities, Standard_Integer const Degree, Standard_Boolean const Periodic) -> Law_BSpline
        __init__(Law_BSpline self, NCollection_Array1_Standard_Real Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Multiplicities, Standard_Integer const Degree, Standard_Boolean const Periodic) -> Law_BSpline

        Creates  a rational B_spline  curve  on the basis
        <Knots, Multiplicities> of degree <Degree>.

        :type Poles: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Multiplicities: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree: int
        :type Periodic: bool

        """
        this = _Law.new_Law_BSpline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Law_BSpline self, Standard_Integer const Degree)

        Increase the degree to  <Degree>. Nothing is  done
        if  <Degree>   is lower or  equal  to the  current
        degree.

        :type Degree: int

        """
        return _Law.Law_BSpline_IncreaseDegree(self, *args)


    def IncreaseMultiplicity(self, *args):
        """
        IncreaseMultiplicity(Law_BSpline self, Standard_Integer const Index, Standard_Integer const M)
        IncreaseMultiplicity(Law_BSpline self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases  the  multiplicities   of  the knots  in
        [I1,I2] to <M>.

        For each knot if  <M>  is  lower  or equal  to  the
        current multiplicity  nothing  is  done. If <M>  is
        higher than the degree the degree is used.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Law.Law_BSpline_IncreaseMultiplicity(self, *args)


    def IncrementMultiplicity(self, *args):
        """
        IncrementMultiplicity(Law_BSpline self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increment  the  multiplicities   of  the knots  in
        [I1,I2] by <M>.

        If <M> is not positive nithing is done.

        For   each  knot   the resulting   multiplicity  is
        limited to the Degree.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Law.Law_BSpline_IncrementMultiplicity(self, *args)


    def InsertKnot(self, *args):
        """
        InsertKnot(Law_BSpline self, Standard_Real const U, Standard_Integer const M=1, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a knot value in the sequence of knots.  If
        <U>  is an  existing knot     the multiplicity  is
        increased by <M>.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type U: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Law.Law_BSpline_InsertKnot(self, *args)


    def InsertKnots(self, *args):
        """
        InsertKnots(Law_BSpline self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a set of knots  values in  the sequence of
        knots.

        For each U = Knots(i), M = Mults(i)

        If <U>  is an existing  knot  the  multiplicity is
        increased by  <M> if  <Add>  is True, increased to
        <M> if <Add> is False.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Law.Law_BSpline_InsertKnots(self, *args)


    def RemoveKnot(self, *args):
        """
        RemoveKnot(Law_BSpline self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Decrement the knots multiplicity to <M>. If  M is
        0 the knot   is  removed. The  Poles  sequence   is
        modified.

        As there are two ways to  compute the new poles the
        average is  computed if  the distance is lower than
        the <Tolerance>, else False is returned.

        A low tolerance is used to prevent the modification
        of the curve.

        A high tolerance is used to "smooth" the curve.

        Raised if Index is not in the range
        [FirstUKnotIndex, LastUKnotIndex]
        pole insertion and pole removing
        this operation is limited to the Uniform or QuasiUniform
        BSplineCurve. The knot values are modified . If the BSpline is
        NonUniform or Piecewise Bezier an exception Construction error
        is raised.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Law_BSpline_RemoveKnot(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Law_BSpline self)

        Changes the direction of parametrization of <me>. The Knot
        sequence is modified, the FirstParameter and the
        LastParameter are not modified. The StartPoint of the
        initial curve becomes the EndPoint of the reversed curve
        and the EndPoint of the initial curve becomes the StartPoint
        of the reversed curve.


        """
        return _Law.Law_BSpline_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Law_BSpline self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns UFirst + ULast - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Law_BSpline self, Standard_Real const U1, Standard_Real const U2)

        Segments the curve between U1 and U2.
        The control points are modified, the first and the last point
        are not the same.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.
        raises if U2 < U1.

        :type U1: float
        :type U2: float

        """
        return _Law.Law_BSpline_Segment(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(Law_BSpline self, NCollection_Array1_Standard_Real K)

        Changes all the knots of the curve
        The multiplicity of the knots are not modified.

        Raised if there is an index such that K (Index+1) <= K (Index).

        Raised if  K.Lower() < 1 or K.Upper() > NbKnots

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Law_BSpline_SetKnots(self, *args)


    def SetKnot(self, *args):
        """
        SetKnot(Law_BSpline self, Standard_Integer const Index, Standard_Real const K)
        SetKnot(Law_BSpline self, Standard_Integer const Index, Standard_Real const K, Standard_Integer const M)

        Changes the knot of range Index with its multiplicity.
        You can increase the multiplicity of a knot but it is
        not allowed to decrease the multiplicity of an existing knot.

        Raised if K >= Knots(Index+1) or K <= Knots(Index-1).
        Raised if M is greater than Degree or lower than the previous
        multiplicity of knot of range Index.
        Raised if Index < 1 || Index > NbKnots

        :type Index: int
        :type K: float
        :type M: int

        """
        return _Law.Law_BSpline_SetKnot(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Law_BSpline self)

        returns the parameter normalized within
        the period if the curve is periodic : otherwise
        does not do anything

        :type U: float

        """
        return _Law.Law_BSpline_PeriodicNormalization(self, *args)


    def SetPeriodic(self, *args):
        """
        SetPeriodic(Law_BSpline self)

        Makes a closed B-spline into a periodic curve. The curve is
        periodic if the knot sequence is periodic and if the curve is
        closed (The tolerance criterion is Resolution from gp).
        The period T is equal to Knot(LastUKnotIndex) -
        Knot(FirstUKnotIndex). A periodic B-spline can be uniform
        or not.
        Raised if the curve is not closed.


        """
        return _Law.Law_BSpline_SetPeriodic(self, *args)


    def SetOrigin(self, *args):
        """
        SetOrigin(Law_BSpline self, Standard_Integer const Index)

        Set the origin of a periodic curve at Knot(index)
        KnotVector and poles are modified.
        Raised if the curve is not periodic
        Raised if index not in the range
        [FirstUKnotIndex , LastUKnotIndex]

        :type Index: int

        """
        return _Law.Law_BSpline_SetOrigin(self, *args)


    def SetNotPeriodic(self, *args):
        """
        SetNotPeriodic(Law_BSpline self)

        Makes a non periodic curve. If the curve was non periodic
        the curve is not modified.


        """
        return _Law.Law_BSpline_SetNotPeriodic(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Law_BSpline self, Standard_Integer const Index, Standard_Real const P)
        SetPole(Law_BSpline self, Standard_Integer const Index, Standard_Real const P, Standard_Real const Weight)

        Substitutes the pole and the weight of range Index.
        If the curve <me> is not rational it can become rational
        If the curve was rational it can become non rational

        Raised if Index < 1 || Index > NbPoles
        Raised if Weight <= 0.0

        :type Index: int
        :type P: float
        :type Weight: float

        """
        return _Law.Law_BSpline_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Law_BSpline self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight for the pole of range Index.
        If the curve was non rational it can become rational.
        If the curve was rational it can become non rational.

        Raised if Index < 1 || Index > NbPoles
        Raised if Weight <= 0.0

        :type Index: int
        :type Weight: float

        """
        return _Law.Law_BSpline_SetWeight(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Law_BSpline self, Standard_Integer const N) -> Standard_Boolean

        Returns the continuity of the curve, the curve is at least C0.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Law_BSpline_IsCN(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Law_BSpline self) -> Standard_Boolean

        Returns true if the distance between the first point and the
        last point of the curve is lower or equal to Resolution
        from package gp.
        Warnings :
        The first and the last point can be different from the first
        pole and the last pole of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Law_BSpline_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Law_BSpline self) -> Standard_Boolean

        Returns True if the curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Law_BSpline_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Law_BSpline self) -> Standard_Boolean

        Returns True if the weights are not identical.
        The tolerance criterion is Epsilon of the class Real.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Law_BSpline_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Law_BSpline self) -> GeomAbs_Shape

        Returns the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.
        For a B-spline curve of degree d if a knot Ui has a
        multiplicity p the B-spline curve is only Cd-p continuous
        at Ui. So the global continuity of the curve can't be greater
        than Cd-p where p is the maximum multiplicity of the interior
        Knots. In the interior of a knot span the curve is infinitely
        continuously differentiable.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Law_BSpline_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Law_BSpline self) -> Standard_Integer

        Computation of value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpline_Degree(self, *args)


    def Value(self, *args):
        """
        Value(Law_BSpline self, Standard_Real const U) -> Standard_Real

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_Value(self, *args)


    def D0(self, *args):
        """
        D0(Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float

        """
        return _Law.Law_BSpline_D0(self, *args)


    def D1(self, *args):
        """
        D1(Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float
        :type V1: float

        """
        return _Law.Law_BSpline_D1(self, *args)


    def D2(self, *args):
        """
        D2(Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float
        :type V1: float
        :type V2: float

        """
        return _Law.Law_BSpline_D2(self, *args)


    def D3(self, *args):
        """
        D3(Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float
        :type V1: float
        :type V2: float
        :type V3: float

        """
        return _Law.Law_BSpline_D3(self, *args)


    def DN(self, *args):
        """
        DN(Law_BSpline self, Standard_Real const U, Standard_Integer const N) -> Standard_Real

        The following functions computes the point  of parameter U and
        the  derivatives at   this  point on  the  B-spline curve  arc
        defined between the knot FromK1  and the knot  ToK2.  U can be
        out of bounds   [Knot  (FromK1), Knot   (ToK2)] but   for  the
        computation we only  use  the definition of the  curve between
        these  two  knots. This  method is  useful  to  compute  local
        derivative,  if the order of  continuity of the whole curve is
        not   greater  enough.   Inside   the parametric   domain Knot
        (FromK1), Knot (ToK2)  the evaluations are the  same as if  we
        consider  the whole  definition of the  curve.   Of course the
        evaluations are different outside this parametric domain.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_DN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2) -> Standard_Real

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_LocalValue(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float

        """
        return _Law.Law_BSpline_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float
        :type V1: float

        """
        return _Law.Law_BSpline_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float
        :type V1: float
        :type V2: float

        """
        return _Law.Law_BSpline_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float
        :type V1: float
        :type V2: float
        :type V3: float

        """
        return _Law.Law_BSpline_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Integer const N) -> Standard_Real

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_LocalDN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Law_BSpline self) -> Standard_Real

        Returns the last point of the curve.
        Warnings :
        The last point of the curve is different from the last
        pole of the curve if the multiplicity of the last knot
        is lower than Degree.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_EndPoint(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Law_BSpline self) -> Standard_Integer

        For a B-spline curve the first parameter (which gives the start
        point of the curve) is a knot value but if the multiplicity of
        the first knot index is lower than Degree + 1 it is not the
        first knot of the curve. This method computes the index of the
        knot corresponding to the first parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpline_FirstUKnotIndex(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Law_BSpline self) -> Standard_Real

        Computes the parametric value of the start point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_FirstParameter(self, *args)


    def Knot(self, *args):
        """
        Knot(Law_BSpline self, Standard_Integer const Index) -> Standard_Real

        Returns the knot of range Index. When there is a knot
        with a multiplicity greater than 1 the knot is not repeated.
        The method Multiplicity can be used to get the multiplicity
        of the Knot.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_Knot(self, *args)


    def Knots(self, *args):
        """
        Knots(Law_BSpline self, NCollection_Array1_Standard_Real K)

        returns the knot values of the B-spline curve;

        Raised if the length of K is not equal to the number of knots.

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Law_BSpline_Knots(self, *args)


    def KnotSequence(self, *args):
        """
        KnotSequence(Law_BSpline self, NCollection_Array1_Standard_Real K)

        Returns the knots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        K = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        Raised if the length of K is not equal to NbPoles + Degree + 1

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Law_BSpline_KnotSequence(self, *args)


    def KnotDistribution(self, *args):
        """
        KnotDistribution(Law_BSpline self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier.
        If all the knots differ by a positive constant from the
        preceding knot the BSpline Curve can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1 except for
        the first and last knot which are of multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have multiplicity
        Degree + 1 and if interior knots have multiplicity Degree
        A piecewise Bezier with only two knots is a BezierCurve.
        else the curve is non uniform.
        The tolerance criterion is Epsilon from class Real.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Law.Law_BSpline_KnotDistribution(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Law_BSpline self) -> Standard_Integer

        For a BSpline curve the last parameter (which gives the
        end point of the curve) is a knot value but if the
        multiplicity of the last knot index is lower than
        Degree + 1 it is not the last knot of the curve. This
        method computes the index of the knot corresponding to
        the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpline_LastUKnotIndex(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Law_BSpline self) -> Standard_Real

        Computes the parametric value of the end point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_LastParameter(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Law_BSpline self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        Knots (I1) <= U <= Knots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < Knots (1) - Abs(ParametricTolerance)
        . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Law.Law_BSpline_LocateU(self, *args)


    def Multiplicity(self, *args):
        """
        Multiplicity(Law_BSpline self, Standard_Integer const Index) -> Standard_Integer

        Returns the multiplicity of the knots of range Index.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpline_Multiplicity(self, *args)


    def Multiplicities(self, *args):
        """
        Multiplicities(Law_BSpline self, NCollection_Array1_Standard_Integer M)

        Returns the multiplicity of the knots of the curve.

        Raised if the length of M is not equal to NbKnots.

        :type M: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Law.Law_BSpline_Multiplicities(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Law_BSpline self) -> Standard_Integer

        Returns the number of knots. This method returns the number of
        knot without repetition of multiple knots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpline_NbKnots(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Law_BSpline self) -> Standard_Integer

        Returns the number of poles

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpline_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Pole(Law_BSpline self, Standard_Integer const Index) -> Standard_Real

        Returns the pole of range Index.
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_Pole(self, *args)


    def Poles(self, *args):
        """
        Poles(Law_BSpline self, NCollection_Array1_Standard_Real P)

        Returns the poles of the B-spline curve;

        Raised if the length of P is not equal to the number of poles.

        :type P: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Law_BSpline_Poles(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Law_BSpline self) -> Standard_Real

        Returns the start point of the curve.
        Warnings :
        This point is different from the first pole of the curve if the
        multiplicity of the first knot is lower than Degree.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Law_BSpline self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of the pole of range Index .
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Law_BSpline_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Law_BSpline self, NCollection_Array1_Standard_Real W)

        Returns the weights of the B-spline curve;

        Raised if the length of W is not equal to NbPoles.

        :type W: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Law_BSpline_Weights(self, *args)


    def MaxDegree(*args):
        """
        MaxDegree() -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in this package.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSpline_MaxDegree(*args)

    MaxDegree = staticmethod(MaxDegree)

    def MovePointAndTangent(self, *args):
        """
        MovePointAndTangent(Law_BSpline self, Standard_Real const U, Standard_Real const NewValue, Standard_Real const Derivative, Standard_Real const Tolerance, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition)

        Changes the value of the Law at parameter U to NewValue.
        and makes its derivative at U be derivative.
        StartingCondition = -1 means first can move
        EndingCondition   = -1 means last point can move
        StartingCondition = 0 means the first point cannot move
        EndingCondition   = 0 means the last point cannot move
        StartingCondition = 1 means the first point and tangent cannot move
        EndingCondition   = 1 means the last point and tangent cannot move
        and so forth
        ErrorStatus != 0 means that there are not enought degree of freedom
        with the constrain to deform the curve accordingly

        :type U: float
        :type NewValue: float
        :type Derivative: float
        :type Tolerance: float
        :type StartingCondition: int
        :type EndingCondition: int
        :type ErrorStatus: int

        """
        return _Law.Law_BSpline_MovePointAndTangent(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Law_BSpline self, Standard_Real const Tolerance3D)

        given Tolerance3D returns UTolerance
        such that if f(t) is the curve we have
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float

        """
        return _Law.Law_BSpline_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Law_BSpline self) -> Handle_Law_BSpline

        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Law_BSpline_Copy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_BSpline_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_BSpline_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_BSpline_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_BSpline
Law_BSpline_swigregister = _Law.Law_BSpline_swigregister
Law_BSpline_swigregister(Law_BSpline)

def Law_BSpline_MaxDegree(*args):
    """
    Law_BSpline_MaxDegree() -> Standard_Integer

    Returns the value of the maximum degree of the normalized
    B-spline basis functions in this package.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Law.Law_BSpline_MaxDegree(*args)

def Law_BSpline_get_type_name(*args):
    """
    Law_BSpline_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_BSpline_get_type_name(*args)

def Law_BSpline_get_type_descriptor(*args):
    """
    Law_BSpline_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_BSpline_get_type_descriptor(*args)

class Law_S(Law_BSpFunc):
    """Describes an "S" evolution law."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Law_S
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Law_S(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Law_S self) -> Law_S

        Constructs an empty "S" evolution law.


        """
        this = _Law.new_Law_S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(Law_S self, Standard_Real const Pdeb, Standard_Real const Valdeb, Standard_Real const Pfin, Standard_Real const Valfin)
        Set(Law_S self, Standard_Real const Pdeb, Standard_Real const Valdeb, Standard_Real const Ddeb, Standard_Real const Pfin, Standard_Real const Valfin, Standard_Real const Dfin)

        Defines this S evolution law by assigning
        -   the bounds Pdeb and Pfin of the parameter,
        -   the values Valdeb and Valfin of the function at these
        two parametric bounds, and
        -   the values Ddeb and Dfin of the first derivative of the
        function at these two parametric bounds.

        :type Pdeb: float
        :type Valdeb: float
        :type Ddeb: float
        :type Pfin: float
        :type Valfin: float
        :type Dfin: float

        """
        return _Law.Law_S_Set(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Law.Law_S_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Law.Law_S_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Law_S_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Law.delete_Law_S
Law_S_swigregister = _Law.Law_S_swigregister
Law_S_swigregister(Law_S)

def Law_S_get_type_name(*args):
    """
    Law_S_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Law.Law_S_get_type_name(*args)

def Law_S_get_type_descriptor(*args):
    """
    Law_S_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Law.Law_S_get_type_descriptor(*args)

class Handle_Law_Constant(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_Constant self)

        Nullify the handle


        """
        return _Law.Handle_Law_Constant_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_Constant self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_Constant_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_Constant self, Law_Constant thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_Constant_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_Constant self, Handle_Law_Constant theHandle) -> Handle_Law_Constant
        assign(Handle_Law_Constant self, Law_Constant thePtr) -> Handle_Law_Constant
        assign(Handle_Law_Constant self, Handle_Law_Constant theHandle) -> Handle_Law_Constant

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_Constant_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_Constant self) -> Law_Constant

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_Constant_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_Constant self) -> Law_Constant

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_Constant___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_Constant self) -> Law_Constant

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_Constant___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_Constant___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_Constant___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_Constant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_Constant_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_Constant

    def Set(self, *args):
        """
        Set(Handle_Law_Constant self, Standard_Real const Radius, Standard_Real const PFirst, Standard_Real const PLast)

        Set the radius and the range of the constant Law.

        :type Radius: float
        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_Constant_Set(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Law_Constant self) -> GeomAbs_Shape

        Returns GeomAbs_CN

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Constant_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Law_Constant self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  1

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Constant_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Law_Constant self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Constant_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_Constant self, Standard_Real const X) -> Standard_Real

        Returns the value at parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_Constant_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_Constant self, Standard_Real const X)

        Returns the value and the first derivative at parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Handle_Law_Constant_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_Constant self, Standard_Real const X)

        Returns the value, first and second derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Handle_Law_Constant_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Law_Constant self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_Constant_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Law_Constant self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_Constant_Bounds(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_Constant self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_Constant_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Constant_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Constant_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Law_Constant self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_Constant_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_Constant self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_Constant self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Constant_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_Constant self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_Constant self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Constant_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_Constant self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_Constant_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_Constant self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Constant_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_Constant self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_Constant_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_Constant self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Constant_DecrementRefCounter(self, *args)

Handle_Law_Constant_swigregister = _Law.Handle_Law_Constant_swigregister
Handle_Law_Constant_swigregister(Handle_Law_Constant)

def Handle_Law_Constant_DownCast(thing):
    return _Law.Handle_Law_Constant_DownCast(thing)
Handle_Law_Constant_DownCast = _Law.Handle_Law_Constant_DownCast

class Handle_Law_Linear(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_Linear self)

        Nullify the handle


        """
        return _Law.Handle_Law_Linear_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_Linear self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_Linear_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_Linear self, Law_Linear thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_Linear_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_Linear self, Handle_Law_Linear theHandle) -> Handle_Law_Linear
        assign(Handle_Law_Linear self, Law_Linear thePtr) -> Handle_Law_Linear
        assign(Handle_Law_Linear self, Handle_Law_Linear theHandle) -> Handle_Law_Linear

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_Linear_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_Linear self) -> Law_Linear

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_Linear_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_Linear self) -> Law_Linear

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_Linear___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_Linear self) -> Law_Linear

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_Linear___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_Linear___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_Linear___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_Linear(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_Linear_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_Linear

    def Set(self, *args):
        """
        Set(Handle_Law_Linear self, Standard_Real const Pdeb, Standard_Real const Valdeb, Standard_Real const Pfin, Standard_Real const Valfin)

        Defines this linear evolution law by assigning both:
        -   the bounds Pdeb and Pfin of the parameter, and
        -   the values Valdeb and Valfin of the function at these
        two parametric bounds.

        :type Pdeb: float
        :type Valdeb: float
        :type Pfin: float
        :type Valfin: float

        """
        return _Law.Handle_Law_Linear_Set(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Law_Linear self) -> GeomAbs_Shape

        Returns GeomAbs_CN

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Linear_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Law_Linear self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  1

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Linear_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Law_Linear self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Linear_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_Linear self, Standard_Real const X) -> Standard_Real

        Returns the value of this function at the point of parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_Linear_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_Linear self, Standard_Real const X)

        Returns the value F and the first derivative D of this
        function at the point of parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Handle_Law_Linear_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_Linear self, Standard_Real const X)

        Returns the value, first and second derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Handle_Law_Linear_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Law_Linear self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_Linear_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Law_Linear self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_Linear_Bounds(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_Linear self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_Linear_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Linear_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Linear_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Law_Linear self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_Linear_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_Linear self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_Linear self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Linear_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_Linear self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_Linear self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Linear_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_Linear self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_Linear_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_Linear self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Linear_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_Linear self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_Linear_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_Linear self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Linear_DecrementRefCounter(self, *args)

Handle_Law_Linear_swigregister = _Law.Handle_Law_Linear_swigregister
Handle_Law_Linear_swigregister(Handle_Law_Linear)

def Handle_Law_Linear_DownCast(thing):
    return _Law.Handle_Law_Linear_DownCast(thing)
Handle_Law_Linear_DownCast = _Law.Handle_Law_Linear_DownCast

class Handle_Law_Interpol(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_Interpol self)

        Nullify the handle


        """
        return _Law.Handle_Law_Interpol_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_Interpol self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_Interpol_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_Interpol self, Law_Interpol thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_Interpol_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_Interpol self, Handle_Law_Interpol theHandle) -> Handle_Law_Interpol
        assign(Handle_Law_Interpol self, Law_Interpol thePtr) -> Handle_Law_Interpol
        assign(Handle_Law_Interpol self, Handle_Law_Interpol theHandle) -> Handle_Law_Interpol

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_Interpol_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_Interpol self) -> Law_Interpol

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_Interpol_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_Interpol self) -> Law_Interpol

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_Interpol___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_Interpol self) -> Law_Interpol

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_Interpol___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_Interpol___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_Interpol___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_Interpol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_Interpol_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_Interpol

    def Set(self, *args):
        """
        Set(Handle_Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Boolean const Periodic)
        Set(Handle_Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Real const Dd, Standard_Real const Df, Standard_Boolean const Periodic)

        Defines this evolution law by interpolating the set of 2D
        points ParAndRad. The Y coordinate of a point of
        ParAndRad is the value of the function at the parameter
        point given by its X coordinate.
        If Periodic is true, this function is assumed to be periodic.
        In the second syntax, Dd and Df define the values of
        the first derivative of the function at its first and last points.
        Warning
        -   The X coordinates of points in the table ParAndRad
        must be given in ascendant order.
        -   If Periodic is true, the first and last Y coordinates of
        points in the table ParAndRad are assumed to be
        equal. In addition, with the second syntax, Dd and Df
        are also assumed to be equal. If this is not the case,
        Set uses the first value(s) as last value(s).

        :type ParAndRad: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Dd: float
        :type Df: float
        :type Periodic: bool

        """
        return _Law.Handle_Law_Interpol_Set(self, *args)


    def SetInRelative(self, *args):
        """
        SetInRelative(Handle_Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Real const Ud, Standard_Real const Uf, Standard_Boolean const Periodic)
        SetInRelative(Handle_Law_Interpol self, NCollection_Array1_gp_Pnt2d ParAndRad, Standard_Real const Ud, Standard_Real const Uf, Standard_Real const Dd, Standard_Real const Df, Standard_Boolean const Periodic)

        :type ParAndRad: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Ud: float
        :type Uf: float
        :type Dd: float
        :type Df: float
        :type Periodic: bool

        """
        return _Law.Handle_Law_Interpol_SetInRelative(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_Interpol self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_Interpol_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Interpol_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Interpol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        Continuity(Handle_Law_Interpol self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Interpol_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Law_Interpol self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Interpol_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Law_Interpol self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Interpol_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_Interpol self, Standard_Real const X) -> Standard_Real

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_Interpol_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_Interpol self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Handle_Law_Interpol_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_Interpol self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Handle_Law_Interpol_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Law_Interpol self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_Interpol_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Law_Interpol self)

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_Interpol_Bounds(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_Law_Interpol self) -> Handle_Law_BSpline

        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Handle_Law_Interpol_Curve(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_Law_Interpol self, Handle_Law_BSpline C)

        :type C: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Handle_Law_Interpol_SetCurve(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Law_Interpol self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_Interpol_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_Interpol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_Interpol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Interpol_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_Interpol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_Interpol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Interpol_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_Interpol self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_Interpol_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_Interpol self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Interpol_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_Interpol self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_Interpol_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_Interpol self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Interpol_DecrementRefCounter(self, *args)

Handle_Law_Interpol_swigregister = _Law.Handle_Law_Interpol_swigregister
Handle_Law_Interpol_swigregister(Handle_Law_Interpol)

def Handle_Law_Interpol_DownCast(thing):
    return _Law.Handle_Law_Interpol_DownCast(thing)
Handle_Law_Interpol_DownCast = _Law.Handle_Law_Interpol_DownCast

class Handle_Law_Function(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_Function self)

        Nullify the handle


        """
        return _Law.Handle_Law_Function_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_Function self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_Function_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_Function self, Law_Function thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_Function_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_Function self, Handle_Law_Function theHandle) -> Handle_Law_Function
        assign(Handle_Law_Function self, Law_Function thePtr) -> Handle_Law_Function
        assign(Handle_Law_Function self, Handle_Law_Function theHandle) -> Handle_Law_Function

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_Function_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_Function self) -> Law_Function

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_Function_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_Function self) -> Law_Function

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_Function___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_Function self) -> Law_Function

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_Function___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_Function___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_Function___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_Function(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_Function_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_Function

    def Continuity(self, *args):
        """
        Continuity(Handle_Law_Function self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Function_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Law_Function self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Function_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Law_Function self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Function_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_Function self, Standard_Real const X) -> Standard_Real

        Returns the value of the function at the point of parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_Function_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_Function self, Standard_Real const X)

        Returns the value F and the first derivative D of the
        function at the point of parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Handle_Law_Function_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_Function self, Standard_Real const X)

        Returns the value, first and seconde derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Handle_Law_Function_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Law_Function self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_Function_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Law_Function self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_Function_Bounds(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_Function self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_Function_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Function_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Function_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Law_Function self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_Function_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_Function self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_Function self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Function_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_Function self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_Function self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Function_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_Function self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_Function_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_Function self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Function_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_Function self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_Function_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_Function self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Function_DecrementRefCounter(self, *args)

Handle_Law_Function_swigregister = _Law.Handle_Law_Function_swigregister
Handle_Law_Function_swigregister(Handle_Law_Function)

def Handle_Law_Function_DownCast(thing):
    return _Law.Handle_Law_Function_DownCast(thing)
Handle_Law_Function_DownCast = _Law.Handle_Law_Function_DownCast

class Law_Interpolate(object):
    """
    This  class   is used  to   interpolate a BsplineCurve
    passing through    an  array of  points,   with   a C2
    Continuity if tangency  is not requested at the point.
    If tangency is  requested at the  point the continuity
    will be C1.  If Perodicity is requested the curve will
    be  closed  and the junction will  be  the first point
    given. The curve will than be only C1
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Law_Interpolate self, Handle_TColStd_HArray1OfReal Points, Standard_Boolean const PeriodicFlag, Standard_Real const Tolerance) -> Law_Interpolate
        __init__(Law_Interpolate self, Handle_TColStd_HArray1OfReal Points, Handle_TColStd_HArray1OfReal Parameters, Standard_Boolean const PeriodicFlag, Standard_Real const Tolerance) -> Law_Interpolate

        Tolerance is to check if  the points are not too close
        to one an  other.  It is  also  used to check   if the
        tangent vector  is not too small.   There should be at
        least 2 points. If PeriodicFlag is True then the curve
        will be periodic be periodic

        :type Points: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type Parameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type PeriodicFlag: bool
        :type Tolerance: float

        """
        this = _Law.new_Law_Interpolate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(Law_Interpolate self, Standard_Real const InitialTangent, Standard_Real const FinalTangent)
        Load(Law_Interpolate self, NCollection_Array1_Standard_Real Tangents, Handle_TColStd_HArray1OfBoolean TangentFlags)

        loads the tangents. We should have as many tangents as
        they are points  in the array if TangentFlags.Value(i)
        is    Standard_True  use the tangent Tangents.Value(i)
        otherwise the tangent is not constrained.

        :type Tangents: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TangentFlags: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfBoolean

        """
        return _Law.Law_Interpolate_Load(self, *args)


    def Perform(self, *args):
        """
        Perform(Law_Interpolate self)

        Makes the interpolation


        """
        return _Law.Law_Interpolate_Perform(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        res = _Law.Law_Interpolate_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(Law_Interpolate self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Law_Interpolate_IsDone(self, *args)

    __swig_destroy__ = _Law.delete_Law_Interpolate
Law_Interpolate_swigregister = _Law.Law_Interpolate_swigregister
Law_Interpolate_swigregister(Law_Interpolate)

class NCollection_List_Handle_Law_Function(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Law_Function self) -> NCollection_List< opencascade::handle< Law_Function > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _Law.NCollection_List_Handle_Law_Function_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Law_Function self) -> NCollection_List< opencascade::handle< Law_Function > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _Law.NCollection_List_Handle_Law_Function_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Law_Function self) -> NCollection_List< opencascade::handle< Law_Function > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _Law.NCollection_List_Handle_Law_Function_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Law_Function self) -> NCollection_List< opencascade::handle< Law_Function > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _Law.NCollection_List_Handle_Law_Function_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _Law.new_NCollection_List_Handle_Law_Function(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Law_Function self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.NCollection_List_Handle_Law_Function_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Law_Function self, NCollection_List_Handle_Law_Function theOther) -> NCollection_List_Handle_Law_Function

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _Law.NCollection_List_Handle_Law_Function_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Law_Function self, NCollection_List_Handle_Law_Function theOther) -> NCollection_List_Handle_Law_Function

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _Law.NCollection_List_Handle_Law_Function_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Law_Function self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Law.NCollection_List_Handle_Law_Function_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _Law.NCollection_List_Handle_Law_Function_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _Law.NCollection_List_Handle_Law_Function_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Law_Function self, Handle_Law_Function theItem) -> Handle_Law_Function
        Append(NCollection_List_Handle_Law_Function self, Handle_Law_Function theItem, NCollection_List< opencascade::handle< Law_Function > >::Iterator & theIter)
        Append(NCollection_List_Handle_Law_Function self, NCollection_List_Handle_Law_Function theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _Law.NCollection_List_Handle_Law_Function_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Law_Function self, Handle_Law_Function theItem) -> Handle_Law_Function
        Prepend(NCollection_List_Handle_Law_Function self, NCollection_List_Handle_Law_Function theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _Law.NCollection_List_Handle_Law_Function_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Law_Function self)

        RemoveFirst item


        """
        return _Law.NCollection_List_Handle_Law_Function_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Law_Function self, NCollection_List< opencascade::handle< Law_Function > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _Law.NCollection_List_Handle_Law_Function_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Law_Function self, Handle_Law_Function theItem, NCollection_List< opencascade::handle< Law_Function > >::Iterator & theIter) -> Handle_Law_Function
        InsertBefore(NCollection_List_Handle_Law_Function self, NCollection_List_Handle_Law_Function theOther, NCollection_List< opencascade::handle< Law_Function > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _Law.NCollection_List_Handle_Law_Function_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Law_Function self, Handle_Law_Function theItem, NCollection_List< opencascade::handle< Law_Function > >::Iterator & theIter) -> Handle_Law_Function
        InsertAfter(NCollection_List_Handle_Law_Function self, NCollection_List_Handle_Law_Function theOther, NCollection_List< opencascade::handle< Law_Function > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _Law.NCollection_List_Handle_Law_Function_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Law_Function self)

        Reverse the list


        """
        return _Law.NCollection_List_Handle_Law_Function_Reverse(self, *args)


    def __iter__(self):
        return _Law.NCollection_List_Handle_Law_Function___iter__(self)
    __swig_destroy__ = _Law.delete_NCollection_List_Handle_Law_Function
NCollection_List_Handle_Law_Function_swigregister = _Law.NCollection_List_Handle_Law_Function_swigregister
NCollection_List_Handle_Law_Function_swigregister(NCollection_List_Handle_Law_Function)

class NCollection_List_Handle_Law_Function_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Law.new_NCollection_List_Handle_Law_Function_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Law.delete_NCollection_List_Handle_Law_Function_IteratorHelper

    def __next__(self):
        return _Law.NCollection_List_Handle_Law_Function_IteratorHelper___next__(self)
NCollection_List_Handle_Law_Function_IteratorHelper_swigregister = _Law.NCollection_List_Handle_Law_Function_IteratorHelper_swigregister
NCollection_List_Handle_Law_Function_IteratorHelper_swigregister(NCollection_List_Handle_Law_Function_IteratorHelper)


try:
	Law_Laws = NCollection_List_Handle_Law_Function
except NameError:
	pass # does not exist, probably ignored

class Law_(object):
    """Multiple services concerning 1d functions."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MixBnd(*args):
        """
        MixBnd(Handle_Law_Linear Lin) -> Handle_Law_BSpFunc
        MixBnd(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Handle_Law_Linear Lin) -> Handle_TColStd_HArray1OfReal

        Builds  the poles of the 1d  bspline that is near from
        Lin with null derivatives at the extremities.

        :type Degree: int
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Lin: OCC.wrapper.Law.Handle_Law_Linear
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Law.Law__MixBnd(*args)

    MixBnd = staticmethod(MixBnd)

    def MixTgt(*args):
        """
        MixTgt(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Boolean const NulOnTheRight, Standard_Integer const Index) -> Handle_TColStd_HArray1OfReal

        Builds the poles of the 1d bspline that is null on the
        rigth    side   of   Knots(Index)  (on  the    left if
        NulOnTheRight  is  false)    and   that is     like  a
        t*(1-t)(1-t) curve  on the  left side of  Knots(Index)
        (on the rigth  if NulOnTheRight is false).  The result
        curve is  C1 with  a derivative  equal  to 1. at first
        parameter (-1 at last  parameter  if  NulOnTheRight is
        false).
        Warning: Mults(Index) must greater or equal to degree-1.

        :type Degree: int
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NulOnTheRight: bool
        :type Index: int
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Law.Law__MixTgt(*args)

    MixTgt = staticmethod(MixTgt)

    def Reparametrize(*args):
        """
        Reparametrize(Adaptor3d_Curve Curve, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DFirst, Standard_Real const DLast, Standard_Boolean const Rev, Standard_Integer const NbPoints) -> Handle_Law_BSpline

        Computes a 1 d curve to  reparametrize a curve. Its an
        interpolation of NbPoints  points calculated  at quasi
        constant abscissa.

        :type Curve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DFirst: float
        :type DLast: float
        :type Rev: bool
        :type NbPoints: int
        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Law__Reparametrize(*args)

    Reparametrize = staticmethod(Reparametrize)

    def Scale(*args):
        """
        Scale(Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasF, Standard_Boolean const HasL, Standard_Real const VFirst, Standard_Real const VLast) -> Handle_Law_BSpline

        Computes a 1  d curve to  scale  a field of  tangency.
        Value is 1. for t = (First+Last)/2 .
        If HasFirst value for t = First is VFirst (null derivative).
        If HasLast value for t = Last is VLast (null derivative).

        1.                   _
        _/ \_
        __/     \__
        /           
        VFirst    ____/             
        VLast                        \____
        First                    Last

        :type First: float
        :type Last: float
        :type HasF: bool
        :type HasL: bool
        :type VFirst: float
        :type VLast: float
        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Law__Scale(*args)

    Scale = staticmethod(Scale)

    def ScaleCub(*args):
        """
        ScaleCub(Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasF, Standard_Boolean const HasL, Standard_Real const VFirst, Standard_Real const VLast) -> Handle_Law_BSpline

        :type First: float
        :type Last: float
        :type HasF: bool
        :type HasL: bool
        :type VFirst: float
        :type VLast: float
        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Law__ScaleCub(*args)

    ScaleCub = staticmethod(ScaleCub)

    def __init__(self):
        """Multiple services concerning 1d functions."""
        this = _Law.new_Law_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Law.delete_Law_
Law__swigregister = _Law.Law__swigregister
Law__swigregister(Law_)

def Law__MixBnd(*args):
    """
    MixBnd(Handle_Law_Linear Lin) -> Handle_Law_BSpFunc
    Law__MixBnd(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Handle_Law_Linear Lin) -> Handle_TColStd_HArray1OfReal

    Builds  the poles of the 1d  bspline that is near from
    Lin with null derivatives at the extremities.

    :type Degree: int
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Lin: OCC.wrapper.Law.Handle_Law_Linear
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _Law.Law__MixBnd(*args)

def Law__MixTgt(*args):
    """
    Law__MixTgt(Standard_Integer const Degree, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Boolean const NulOnTheRight, Standard_Integer const Index) -> Handle_TColStd_HArray1OfReal

    Builds the poles of the 1d bspline that is null on the
    rigth    side   of   Knots(Index)  (on  the    left if
    NulOnTheRight  is  false)    and   that is     like  a
    t*(1-t)(1-t) curve  on the  left side of  Knots(Index)
    (on the rigth  if NulOnTheRight is false).  The result
    curve is  C1 with  a derivative  equal  to 1. at first
    parameter (-1 at last  parameter  if  NulOnTheRight is
    false).
    Warning: Mults(Index) must greater or equal to degree-1.

    :type Degree: int
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NulOnTheRight: bool
    :type Index: int
    :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _Law.Law__MixTgt(*args)

def Law__Reparametrize(*args):
    """
    Law__Reparametrize(Adaptor3d_Curve Curve, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DFirst, Standard_Real const DLast, Standard_Boolean const Rev, Standard_Integer const NbPoints) -> Handle_Law_BSpline

    Computes a 1 d curve to  reparametrize a curve. Its an
    interpolation of NbPoints  points calculated  at quasi
    constant abscissa.

    :type Curve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type First: float
    :type Last: float
    :type HasDF: bool
    :type HasDL: bool
    :type DFirst: float
    :type DLast: float
    :type Rev: bool
    :type NbPoints: int
    :rtype: OCC.wrapper.Law.Handle_Law_BSpline

    """
    return _Law.Law__Reparametrize(*args)

def Law__Scale(*args):
    """
    Law__Scale(Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasF, Standard_Boolean const HasL, Standard_Real const VFirst, Standard_Real const VLast) -> Handle_Law_BSpline

    Computes a 1  d curve to  scale  a field of  tangency.
    Value is 1. for t = (First+Last)/2 .
    If HasFirst value for t = First is VFirst (null derivative).
    If HasLast value for t = Last is VLast (null derivative).

    1.                   _
    _/ \_
    __/     \__
    /           
    VFirst    ____/             
    VLast                        \____
    First                    Last

    :type First: float
    :type Last: float
    :type HasF: bool
    :type HasL: bool
    :type VFirst: float
    :type VLast: float
    :rtype: OCC.wrapper.Law.Handle_Law_BSpline

    """
    return _Law.Law__Scale(*args)

def Law__ScaleCub(*args):
    """
    Law__ScaleCub(Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasF, Standard_Boolean const HasL, Standard_Real const VFirst, Standard_Real const VLast) -> Handle_Law_BSpline

    :type First: float
    :type Last: float
    :type HasF: bool
    :type HasL: bool
    :type VFirst: float
    :type VLast: float
    :rtype: OCC.wrapper.Law.Handle_Law_BSpline

    """
    return _Law.Law__ScaleCub(*args)

class Handle_Law_BSpline(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_BSpline self)

        Nullify the handle


        """
        return _Law.Handle_Law_BSpline_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_BSpline self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_BSpline_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_BSpline self, Law_BSpline thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_BSpline_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_BSpline self, Handle_Law_BSpline theHandle) -> Handle_Law_BSpline
        assign(Handle_Law_BSpline self, Law_BSpline thePtr) -> Handle_Law_BSpline
        assign(Handle_Law_BSpline self, Handle_Law_BSpline theHandle) -> Handle_Law_BSpline

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_BSpline_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_BSpline self) -> Law_BSpline

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_BSpline_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_BSpline self) -> Law_BSpline

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_BSpline___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_BSpline self) -> Law_BSpline

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_BSpline___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_BSpline___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_BSpline___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_BSpline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_BSpline_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_BSpline

    def IncreaseDegree(self, *args):
        """
        IncreaseDegree(Handle_Law_BSpline self, Standard_Integer const Degree)

        Increase the degree to  <Degree>. Nothing is  done
        if  <Degree>   is lower or  equal  to the  current
        degree.

        :type Degree: int

        """
        return _Law.Handle_Law_BSpline_IncreaseDegree(self, *args)


    def IncreaseMultiplicity(self, *args):
        """
        IncreaseMultiplicity(Handle_Law_BSpline self, Standard_Integer const Index, Standard_Integer const M)
        IncreaseMultiplicity(Handle_Law_BSpline self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increases  the  multiplicities   of  the knots  in
        [I1,I2] to <M>.

        For each knot if  <M>  is  lower  or equal  to  the
        current multiplicity  nothing  is  done. If <M>  is
        higher than the degree the degree is used.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Law.Handle_Law_BSpline_IncreaseMultiplicity(self, *args)


    def IncrementMultiplicity(self, *args):
        """
        IncrementMultiplicity(Handle_Law_BSpline self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const M)

        Increment  the  multiplicities   of  the knots  in
        [I1,I2] by <M>.

        If <M> is not positive nithing is done.

        For   each  knot   the resulting   multiplicity  is
        limited to the Degree.
        If <I1,I2> are not in [FirstUKnotIndex, LastUKnotIndex]

        :type I1: int
        :type I2: int
        :type M: int

        """
        return _Law.Handle_Law_BSpline_IncrementMultiplicity(self, *args)


    def InsertKnot(self, *args):
        """
        InsertKnot(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const M=1, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a knot value in the sequence of knots.  If
        <U>  is an  existing knot     the multiplicity  is
        increased by <M>.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type U: float
        :type M: int
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Law.Handle_Law_BSpline_InsertKnot(self, *args)


    def InsertKnots(self, *args):
        """
        InsertKnots(Handle_Law_BSpline self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Real const ParametricTolerance=0.0, Standard_Boolean const Add)

        Inserts a set of knots  values in  the sequence of
        knots.

        For each U = Knots(i), M = Mults(i)

        If <U>  is an existing  knot  the  multiplicity is
        increased by  <M> if  <Add>  is True, increased to
        <M> if <Add> is False.

        If U  is  not  on the parameter  range  nothing is
        done.

        If the multiplicity is negative or null nothing is
        done. The  new   multiplicity  is limited  to  the
        degree.

        The  tolerance criterion  for  knots  equality  is
        the max of Epsilon(U) and ParametricTolerance.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type ParametricTolerance: float
        :type Add: bool

        """
        return _Law.Handle_Law_BSpline_InsertKnots(self, *args)


    def RemoveKnot(self, *args):
        """
        RemoveKnot(Handle_Law_BSpline self, Standard_Integer const Index, Standard_Integer const M, Standard_Real const Tolerance) -> Standard_Boolean

        Decrement the knots multiplicity to <M>. If  M is
        0 the knot   is  removed. The  Poles  sequence   is
        modified.

        As there are two ways to  compute the new poles the
        average is  computed if  the distance is lower than
        the <Tolerance>, else False is returned.

        A low tolerance is used to prevent the modification
        of the curve.

        A high tolerance is used to "smooth" the curve.

        Raised if Index is not in the range
        [FirstUKnotIndex, LastUKnotIndex]
        pole insertion and pole removing
        this operation is limited to the Uniform or QuasiUniform
        BSplineCurve. The knot values are modified . If the BSpline is
        NonUniform or Piecewise Bezier an exception Construction error
        is raised.

        :type Index: int
        :type M: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpline_RemoveKnot(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_Law_BSpline self)

        Changes the direction of parametrization of <me>. The Knot
        sequence is modified, the FirstParameter and the
        LastParameter are not modified. The StartPoint of the
        initial curve becomes the EndPoint of the reversed curve
        and the EndPoint of the initial curve becomes the StartPoint
        of the reversed curve.


        """
        return _Law.Handle_Law_BSpline_Reverse(self, *args)


    def ReversedParameter(self, *args):
        """
        ReversedParameter(Handle_Law_BSpline self, Standard_Real const U) -> Standard_Real

        Returns the  parameter on the  reversed  curve for
        the point of parameter U on <me>.

        returns UFirst + ULast - U

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_ReversedParameter(self, *args)


    def Segment(self, *args):
        """
        Segment(Handle_Law_BSpline self, Standard_Real const U1, Standard_Real const U2)

        Segments the curve between U1 and U2.
        The control points are modified, the first and the last point
        are not the same.
        Warnings :
        Even if <me> is not closed it can become closed after the
        segmentation for example if U1 or U2 are out of the bounds
        of the curve <me> or if the curve makes loop.
        After the segmentation the length of a curve can be null.
        raises if U2 < U1.

        :type U1: float
        :type U2: float

        """
        return _Law.Handle_Law_BSpline_Segment(self, *args)


    def SetKnot(self, *args):
        """
        SetKnot(Handle_Law_BSpline self, Standard_Integer const Index, Standard_Real const K)
        SetKnot(Handle_Law_BSpline self, Standard_Integer const Index, Standard_Real const K, Standard_Integer const M)

        Changes the knot of range Index with its multiplicity.
        You can increase the multiplicity of a knot but it is
        not allowed to decrease the multiplicity of an existing knot.

        Raised if K >= Knots(Index+1) or K <= Knots(Index-1).
        Raised if M is greater than Degree or lower than the previous
        multiplicity of knot of range Index.
        Raised if Index < 1 || Index > NbKnots

        :type Index: int
        :type K: float
        :type M: int

        """
        return _Law.Handle_Law_BSpline_SetKnot(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(Handle_Law_BSpline self, NCollection_Array1_Standard_Real K)

        Changes all the knots of the curve
        The multiplicity of the knots are not modified.

        Raised if there is an index such that K (Index+1) <= K (Index).

        Raised if  K.Lower() < 1 or K.Upper() > NbKnots

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Handle_Law_BSpline_SetKnots(self, *args)


    def PeriodicNormalization(self, *args):
        """
        PeriodicNormalization(Handle_Law_BSpline self)

        returns the parameter normalized within
        the period if the curve is periodic : otherwise
        does not do anything

        :type U: float

        """
        return _Law.Handle_Law_BSpline_PeriodicNormalization(self, *args)


    def SetPeriodic(self, *args):
        """
        SetPeriodic(Handle_Law_BSpline self)

        Makes a closed B-spline into a periodic curve. The curve is
        periodic if the knot sequence is periodic and if the curve is
        closed (The tolerance criterion is Resolution from gp).
        The period T is equal to Knot(LastUKnotIndex) -
        Knot(FirstUKnotIndex). A periodic B-spline can be uniform
        or not.
        Raised if the curve is not closed.


        """
        return _Law.Handle_Law_BSpline_SetPeriodic(self, *args)


    def SetOrigin(self, *args):
        """
        SetOrigin(Handle_Law_BSpline self, Standard_Integer const Index)

        Set the origin of a periodic curve at Knot(index)
        KnotVector and poles are modified.
        Raised if the curve is not periodic
        Raised if index not in the range
        [FirstUKnotIndex , LastUKnotIndex]

        :type Index: int

        """
        return _Law.Handle_Law_BSpline_SetOrigin(self, *args)


    def SetNotPeriodic(self, *args):
        """
        SetNotPeriodic(Handle_Law_BSpline self)

        Makes a non periodic curve. If the curve was non periodic
        the curve is not modified.


        """
        return _Law.Handle_Law_BSpline_SetNotPeriodic(self, *args)


    def SetPole(self, *args):
        """
        SetPole(Handle_Law_BSpline self, Standard_Integer const Index, Standard_Real const P)
        SetPole(Handle_Law_BSpline self, Standard_Integer const Index, Standard_Real const P, Standard_Real const Weight)

        Substitutes the pole and the weight of range Index.
        If the curve <me> is not rational it can become rational
        If the curve was rational it can become non rational

        Raised if Index < 1 || Index > NbPoles
        Raised if Weight <= 0.0

        :type Index: int
        :type P: float
        :type Weight: float

        """
        return _Law.Handle_Law_BSpline_SetPole(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_Law_BSpline self, Standard_Integer const Index, Standard_Real const Weight)

        Changes the weight for the pole of range Index.
        If the curve was non rational it can become rational.
        If the curve was rational it can become non rational.

        Raised if Index < 1 || Index > NbPoles
        Raised if Weight <= 0.0

        :type Index: int
        :type Weight: float

        """
        return _Law.Handle_Law_BSpline_SetWeight(self, *args)


    def IsCN(self, *args):
        """
        IsCN(Handle_Law_BSpline self, Standard_Integer const N) -> Standard_Boolean

        Returns the continuity of the curve, the curve is at least C0.
        Raised if N < 0.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpline_IsCN(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Law_BSpline self) -> Standard_Boolean

        Returns true if the distance between the first point and the
        last point of the curve is lower or equal to Resolution
        from package gp.
        Warnings :
        The first and the last point can be different from the first
        pole and the last pole of the curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpline_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Law_BSpline self) -> Standard_Boolean

        Returns True if the curve is periodic.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpline_IsPeriodic(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Law_BSpline self) -> Standard_Boolean

        Returns True if the weights are not identical.
        The tolerance criterion is Epsilon of the class Real.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpline_IsRational(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Law_BSpline self) -> GeomAbs_Shape

        Returns the global continuity of the curve :
        C0 : only geometric continuity,
        C1 : continuity of the first derivative all along the Curve,
        C2 : continuity of the second derivative all along the Curve,
        C3 : continuity of the third derivative all along the Curve,
        CN : the order of continuity is infinite.
        For a B-spline curve of degree d if a knot Ui has a
        multiplicity p the B-spline curve is only Cd-p continuous
        at Ui. So the global continuity of the curve can't be greater
        than Cd-p where p is the maximum multiplicity of the interior
        Knots. In the interior of a knot span the curve is infinitely
        continuously differentiable.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_BSpline_Continuity(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Law_BSpline self) -> Standard_Integer

        Computation of value and derivatives

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_Degree(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_BSpline self, Standard_Real const U) -> Standard_Real

        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float

        """
        return _Law.Handle_Law_BSpline_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float
        :type V1: float

        """
        return _Law.Handle_Law_BSpline_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float
        :type V1: float
        :type V2: float

        """
        return _Law.Handle_Law_BSpline_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Law_BSpline self, Standard_Real const U)

        :type U: float
        :type P: float
        :type V1: float
        :type V2: float
        :type V3: float

        """
        return _Law.Handle_Law_BSpline_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const N) -> Standard_Real

        The following functions computes the point  of parameter U and
        the  derivatives at   this  point on  the  B-spline curve  arc
        defined between the knot FromK1  and the knot  ToK2.  U can be
        out of bounds   [Knot  (FromK1), Knot   (ToK2)] but   for  the
        computation we only  use  the definition of the  curve between
        these  two  knots. This  method is  useful  to  compute  local
        derivative,  if the order of  continuity of the whole curve is
        not   greater  enough.   Inside   the parametric   domain Knot
        (FromK1), Knot (ToK2)  the evaluations are the  same as if  we
        consider  the whole  definition of the  curve.   Of course the
        evaluations are different outside this parametric domain.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_DN(self, *args)


    def LocalValue(self, *args):
        """
        LocalValue(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2) -> Standard_Real

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_LocalValue(self, *args)


    def LocalD0(self, *args):
        """
        LocalD0(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float

        """
        return _Law.Handle_Law_BSpline_LocalD0(self, *args)


    def LocalD1(self, *args):
        """
        LocalD1(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float
        :type V1: float

        """
        return _Law.Handle_Law_BSpline_LocalD1(self, *args)


    def LocalD2(self, *args):
        """
        LocalD2(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float
        :type V1: float
        :type V2: float

        """
        return _Law.Handle_Law_BSpline_LocalD2(self, *args)


    def LocalD3(self, *args):
        """
        LocalD3(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2)

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type P: float
        :type V1: float
        :type V2: float
        :type V3: float

        """
        return _Law.Handle_Law_BSpline_LocalD3(self, *args)


    def LocalDN(self, *args):
        """
        LocalDN(Handle_Law_BSpline self, Standard_Real const U, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Integer const N) -> Standard_Real

        :type U: float
        :type FromK1: int
        :type ToK2: int
        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_LocalDN(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_Law_BSpline self) -> Standard_Real

        Returns the last point of the curve.
        Warnings :
        The last point of the curve is different from the last
        pole of the curve if the multiplicity of the last knot
        is lower than Degree.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_EndPoint(self, *args)


    def FirstUKnotIndex(self, *args):
        """
        FirstUKnotIndex(Handle_Law_BSpline self) -> Standard_Integer

        For a B-spline curve the first parameter (which gives the start
        point of the curve) is a knot value but if the multiplicity of
        the first knot index is lower than Degree + 1 it is not the
        first knot of the curve. This method computes the index of the
        knot corresponding to the first parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_FirstUKnotIndex(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Law_BSpline self) -> Standard_Real

        Computes the parametric value of the start point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_FirstParameter(self, *args)


    def Knot(self, *args):
        """
        Knot(Handle_Law_BSpline self, Standard_Integer const Index) -> Standard_Real

        Returns the knot of range Index. When there is a knot
        with a multiplicity greater than 1 the knot is not repeated.
        The method Multiplicity can be used to get the multiplicity
        of the Knot.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_Knot(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_Law_BSpline self, NCollection_Array1_Standard_Real K)

        returns the knot values of the B-spline curve;

        Raised if the length of K is not equal to the number of knots.

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Handle_Law_BSpline_Knots(self, *args)


    def KnotSequence(self, *args):
        """
        KnotSequence(Handle_Law_BSpline self, NCollection_Array1_Standard_Real K)

        Returns the knots sequence.
        In this sequence the knots with a multiplicity greater than 1
        are repeated.
        Example :
        K = {k1, k1, k1, k2, k3, k3, k4, k4, k4}

        Raised if the length of K is not equal to NbPoles + Degree + 1

        :type K: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Handle_Law_BSpline_KnotSequence(self, *args)


    def KnotDistribution(self, *args):
        """
        KnotDistribution(Handle_Law_BSpline self) -> GeomAbs_BSplKnotDistribution

        Returns NonUniform or Uniform or QuasiUniform or PiecewiseBezier.
        If all the knots differ by a positive constant from the
        preceding knot the BSpline Curve can be :
        - Uniform if all the knots are of multiplicity 1,
        - QuasiUniform if all the knots are of multiplicity 1 except for
        the first and last knot which are of multiplicity Degree + 1,
        - PiecewiseBezier if the first and last knots have multiplicity
        Degree + 1 and if interior knots have multiplicity Degree
        A piecewise Bezier with only two knots is a BezierCurve.
        else the curve is non uniform.
        The tolerance criterion is Epsilon from class Real.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_BSplKnotDistribution

        """
        return _Law.Handle_Law_BSpline_KnotDistribution(self, *args)


    def LastUKnotIndex(self, *args):
        """
        LastUKnotIndex(Handle_Law_BSpline self) -> Standard_Integer

        For a BSpline curve the last parameter (which gives the
        end point of the curve) is a knot value but if the
        multiplicity of the last knot index is lower than
        Degree + 1 it is not the last knot of the curve. This
        method computes the index of the knot corresponding to
        the last parameter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_LastUKnotIndex(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Law_BSpline self) -> Standard_Real

        Computes the parametric value of the end point of the curve.
        It is a knot value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_LastParameter(self, *args)


    def LocateU(self, *args):
        """
        LocateU(Handle_Law_BSpline self, Standard_Real const U, Standard_Real const ParametricTolerance, Standard_Boolean const WithKnotRepetition)

        Locates the parametric value U in the sequence of knots.
        If "WithKnotRepetition" is True we consider the knot's
        representation with repetition of multiple knot value,
        otherwise  we consider the knot's representation with
        no repetition of multiple knot values.
        Knots (I1) <= U <= Knots (I2)
        . if I1 = I2  U is a knot value (the tolerance criterion
        ParametricTolerance is used).
        . if I1 < 1  => U < Knots (1) - Abs(ParametricTolerance)
        . if I2 > NbKnots => U > Knots (NbKnots) + Abs(ParametricTolerance)

        :type U: float
        :type ParametricTolerance: float
        :type I1: int
        :type I2: int
        :type WithKnotRepetition: bool

        """
        return _Law.Handle_Law_BSpline_LocateU(self, *args)


    def Multiplicity(self, *args):
        """
        Multiplicity(Handle_Law_BSpline self, Standard_Integer const Index) -> Standard_Integer

        Returns the multiplicity of the knots of range Index.
        Raised if Index < 1 or Index > NbKnots

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_Multiplicity(self, *args)


    def Multiplicities(self, *args):
        """
        Multiplicities(Handle_Law_BSpline self, NCollection_Array1_Standard_Integer M)

        Returns the multiplicity of the knots of the curve.

        Raised if the length of M is not equal to NbKnots.

        :type M: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Law.Handle_Law_BSpline_Multiplicities(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Handle_Law_BSpline self) -> Standard_Integer

        Returns the number of knots. This method returns the number of
        knot without repetition of multiple knots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_NbKnots(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Law_BSpline self) -> Standard_Integer

        Returns the number of poles

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_NbPoles(self, *args)


    def Pole(self, *args):
        """
        Pole(Handle_Law_BSpline self, Standard_Integer const Index) -> Standard_Real

        Returns the pole of range Index.
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_Pole(self, *args)


    def Poles(self, *args):
        """
        Poles(Handle_Law_BSpline self, NCollection_Array1_Standard_Real P)

        Returns the poles of the B-spline curve;

        Raised if the length of P is not equal to the number of poles.

        :type P: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Handle_Law_BSpline_Poles(self, *args)


    def StartPoint(self, *args):
        """
        StartPoint(Handle_Law_BSpline self) -> Standard_Real

        Returns the start point of the curve.
        Warnings :
        This point is different from the first pole of the curve if the
        multiplicity of the first knot is lower than Degree.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_StartPoint(self, *args)


    def Weight(self, *args):
        """
        Weight(Handle_Law_BSpline self, Standard_Integer const Index) -> Standard_Real

        Returns the weight of the pole of range Index .
        Raised if Index < 1 or Index > NbPoles.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpline_Weight(self, *args)


    def Weights(self, *args):
        """
        Weights(Handle_Law_BSpline self, NCollection_Array1_Standard_Real W)

        Returns the weights of the B-spline curve;

        Raised if the length of W is not equal to NbPoles.

        :type W: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Law.Handle_Law_BSpline_Weights(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(Handle_Law_BSpline self) -> Standard_Integer

        Returns the value of the maximum degree of the normalized
        B-spline basis functions in this package.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_MaxDegree(self, *args)


    def MovePointAndTangent(self, *args):
        """
        MovePointAndTangent(Handle_Law_BSpline self, Standard_Real const U, Standard_Real const NewValue, Standard_Real const Derivative, Standard_Real const Tolerance, Standard_Integer const StartingCondition, Standard_Integer const EndingCondition)

        Changes the value of the Law at parameter U to NewValue.
        and makes its derivative at U be derivative.
        StartingCondition = -1 means first can move
        EndingCondition   = -1 means last point can move
        StartingCondition = 0 means the first point cannot move
        EndingCondition   = 0 means the last point cannot move
        StartingCondition = 1 means the first point and tangent cannot move
        EndingCondition   = 1 means the last point and tangent cannot move
        and so forth
        ErrorStatus != 0 means that there are not enought degree of freedom
        with the constrain to deform the curve accordingly

        :type U: float
        :type NewValue: float
        :type Derivative: float
        :type Tolerance: float
        :type StartingCondition: int
        :type EndingCondition: int
        :type ErrorStatus: int

        """
        return _Law.Handle_Law_BSpline_MovePointAndTangent(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Law_BSpline self, Standard_Real const Tolerance3D)

        given Tolerance3D returns UTolerance
        such that if f(t) is the curve we have
        | t1 - t0| < Utolerance ===>
        |f(t1) - f(t0)| < Tolerance3D

        :type Tolerance3D: float
        :type UTolerance: float

        """
        return _Law.Handle_Law_BSpline_Resolution(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_Law_BSpline self) -> Handle_Law_BSpline

        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Handle_Law_BSpline_Copy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_BSpline self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_BSpline_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_BSpline_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_BSpline_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Law_BSpline self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_BSpline_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_BSpline self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_BSpline self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpline_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_BSpline self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_BSpline self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpline_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_BSpline self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_BSpline_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_BSpline self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_BSpline self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_BSpline_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_BSpline self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpline_DecrementRefCounter(self, *args)

Handle_Law_BSpline_swigregister = _Law.Handle_Law_BSpline_swigregister
Handle_Law_BSpline_swigregister(Handle_Law_BSpline)

def Handle_Law_BSpline_DownCast(thing):
    return _Law.Handle_Law_BSpline_DownCast(thing)
Handle_Law_BSpline_DownCast = _Law.Handle_Law_BSpline_DownCast

class Handle_Law_Composite(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_Composite self)

        Nullify the handle


        """
        return _Law.Handle_Law_Composite_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_Composite self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_Composite_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_Composite self, Law_Composite thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_Composite_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_Composite self, Handle_Law_Composite theHandle) -> Handle_Law_Composite
        assign(Handle_Law_Composite self, Law_Composite thePtr) -> Handle_Law_Composite
        assign(Handle_Law_Composite self, Handle_Law_Composite theHandle) -> Handle_Law_Composite

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_Composite_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_Composite self) -> Law_Composite

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_Composite_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_Composite self) -> Law_Composite

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_Composite___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_Composite self) -> Law_Composite

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_Composite___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_Composite___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_Composite___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_Composite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_Composite_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_Composite

    def Continuity(self, *args):
        """
        Continuity(Handle_Law_Composite self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Composite_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Law_Composite self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Composite_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Law_Composite self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_Composite_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_Composite self, Standard_Real const X) -> Standard_Real

        Returns the value at parameter X.

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_Composite_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_Composite self, Standard_Real const X)

        Returns the value and the first derivative at parameter X.

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Handle_Law_Composite_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_Composite self, Standard_Real const X)

        Returns the value, first and second derivatives
        at parameter X.

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Handle_Law_Composite_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Law_Composite self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_Composite_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Law_Composite self)

        Returns the parametric bounds of the function.

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_Composite_Bounds(self, *args)


    def ChangeElementaryLaw(self, *args):
        """
        ChangeElementaryLaw(Handle_Law_Composite self, Standard_Real const W) -> Handle_Law_Function

        Returns the elementary  function of the composite used
        to compute at parameter W.

        :type W: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_Composite_ChangeElementaryLaw(self, *args)


    def ChangeLaws(self, *args):
        """
        ChangeLaws(Handle_Law_Composite self) -> NCollection_List_Handle_Law_Function

        :rtype: OCC.wrapper.Law.Law_Laws

        """
        return _Law.Handle_Law_Composite_ChangeLaws(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Law_Composite self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Composite_IsPeriodic(self, *args)


    def SetPeriodic(self, *args):
        """SetPeriodic(Handle_Law_Composite self)"""
        return _Law.Handle_Law_Composite_SetPeriodic(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_Composite self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_Composite_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Composite_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_Composite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Law_Composite self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_Composite_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_Composite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_Composite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Composite_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_Composite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_Composite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_Composite_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_Composite self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_Composite_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_Composite self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Composite_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_Composite self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_Composite_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_Composite self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_Composite_DecrementRefCounter(self, *args)

Handle_Law_Composite_swigregister = _Law.Handle_Law_Composite_swigregister
Handle_Law_Composite_swigregister(Handle_Law_Composite)

def Handle_Law_Composite_DownCast(thing):
    return _Law.Handle_Law_Composite_DownCast(thing)
Handle_Law_Composite_DownCast = _Law.Handle_Law_Composite_DownCast

class Handle_Law_S(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_S self)

        Nullify the handle


        """
        return _Law.Handle_Law_S_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_S self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_S_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_S self, Law_S thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_S_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_S self, Handle_Law_S theHandle) -> Handle_Law_S
        assign(Handle_Law_S self, Law_S thePtr) -> Handle_Law_S
        assign(Handle_Law_S self, Handle_Law_S theHandle) -> Handle_Law_S

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_S_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_S self) -> Law_S

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_S_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_S self) -> Law_S

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_S___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_S self) -> Law_S

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_S___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_S___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_S___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_S_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_S

    def Set(self, *args):
        """
        Set(Handle_Law_S self, Standard_Real const Pdeb, Standard_Real const Valdeb, Standard_Real const Pfin, Standard_Real const Valfin)
        Set(Handle_Law_S self, Standard_Real const Pdeb, Standard_Real const Valdeb, Standard_Real const Ddeb, Standard_Real const Pfin, Standard_Real const Valfin, Standard_Real const Dfin)

        Defines this S evolution law by assigning
        -   the bounds Pdeb and Pfin of the parameter,
        -   the values Valdeb and Valfin of the function at these
        two parametric bounds, and
        -   the values Ddeb and Dfin of the first derivative of the
        function at these two parametric bounds.

        :type Pdeb: float
        :type Valdeb: float
        :type Ddeb: float
        :type Pfin: float
        :type Valfin: float
        :type Dfin: float

        """
        return _Law.Handle_Law_S_Set(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_S self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_S_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_S_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_S_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Continuity(self, *args):
        """
        Continuity(Handle_Law_S self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_S_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Law_S self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_S_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Law_S self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_S_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_S self, Standard_Real const X) -> Standard_Real

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_S_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_S self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Handle_Law_S_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_S self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Handle_Law_S_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Law_S self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_S_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Law_S self)

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_S_Bounds(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_Law_S self) -> Handle_Law_BSpline

        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Handle_Law_S_Curve(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_Law_S self, Handle_Law_BSpline C)

        :type C: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Handle_Law_S_SetCurve(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Law_S self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_S_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_S self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_S self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_S_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_S self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_S self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_S_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_S self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_S_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_S self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_S_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_S self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_S_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_S self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_S_DecrementRefCounter(self, *args)

Handle_Law_S_swigregister = _Law.Handle_Law_S_swigregister
Handle_Law_S_swigregister(Handle_Law_S)

def Handle_Law_S_DownCast(thing):
    return _Law.Handle_Law_S_DownCast(thing)
Handle_Law_S_DownCast = _Law.Handle_Law_S_DownCast

class Law_BSplineKnotSplitting(object):
    """
    For a B-spline curve the discontinuities are localised at the
    knot values and between two knots values the B-spline is
    infinitely continuously differentiable.
    At a knot of range index the continuity is equal to :
    Degree - Mult (Index)   where  Degree is the degree of the
    basis B-spline functions and Mult the multiplicity of the knot
    of range Index.
    If for your computation you need to have B-spline curves with a
    minima of continuity it can be interesting to know between which
    knot values, a B-spline curve arc, has a continuity of given order.
    This algorithm computes the indexes of the knots where you should
    split the curve, to obtain arcs with a constant continuity given
    at the construction time. The splitting values are in the range
    [FirstUKnotValue, LastUKnotValue] (See class B-spline curve from
    package Geom).
    If you just want to compute the local derivatives on the curve you
    don't need to create the B-spline curve arcs, you can use the
    functions LocalD1, LocalD2, LocalD3, LocalDN of the class
    BSplineCurve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Law_BSplineKnotSplitting self, Handle_Law_BSpline BasisLaw, Standard_Integer const ContinuityRange) -> Law_BSplineKnotSplitting

        Locates the knot values which correspond to the segmentation of
        the curve into arcs with a continuity equal to ContinuityRange.

        Raised if ContinuityRange is not greater or equal zero.

        :type BasisLaw: OCC.wrapper.Law.Handle_Law_BSpline
        :type ContinuityRange: int

        """
        this = _Law.new_Law_BSplineKnotSplitting(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbSplits(self, *args):
        """
        NbSplits(Law_BSplineKnotSplitting self) -> Standard_Integer

        Returns the number of knots corresponding to the splitting.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSplineKnotSplitting_NbSplits(self, *args)


    def Splitting(self, *args):
        """
        Splitting(Law_BSplineKnotSplitting self, NCollection_Array1_Standard_Integer SplitValues)

        Returns the indexes of the BSpline curve knots corresponding to
        the splitting.

        Raised if the length of SplitValues is not equal to NbSPlit.

        :type SplitValues: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Law.Law_BSplineKnotSplitting_Splitting(self, *args)


    def SplitValue(self, *args):
        """
        SplitValue(Law_BSplineKnotSplitting self, Standard_Integer const Index) -> Standard_Integer

        Returns the index of the knot corresponding to the splitting
        of range Index.

        Raised if Index < 1 or Index > NbSplits

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Law_BSplineKnotSplitting_SplitValue(self, *args)

    __swig_destroy__ = _Law.delete_Law_BSplineKnotSplitting
Law_BSplineKnotSplitting_swigregister = _Law.Law_BSplineKnotSplitting_swigregister
Law_BSplineKnotSplitting_swigregister(Law_BSplineKnotSplitting)

class Handle_Law_BSpFunc(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Law_BSpFunc self)

        Nullify the handle


        """
        return _Law.Handle_Law_BSpFunc_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Law_BSpFunc self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Law.Handle_Law_BSpFunc_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Law_BSpFunc self, Law_BSpFunc thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Law.Handle_Law_BSpFunc_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Law_BSpFunc self, Handle_Law_BSpFunc theHandle) -> Handle_Law_BSpFunc
        assign(Handle_Law_BSpFunc self, Law_BSpFunc thePtr) -> Handle_Law_BSpFunc
        assign(Handle_Law_BSpFunc self, Handle_Law_BSpFunc theHandle) -> Handle_Law_BSpFunc

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Law.Handle_Law_BSpFunc_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Law_BSpFunc self) -> Law_BSpFunc

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Law.Handle_Law_BSpFunc_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Law_BSpFunc self) -> Law_BSpFunc

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Law.Handle_Law_BSpFunc___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Law_BSpFunc self) -> Law_BSpFunc

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Law.Handle_Law_BSpFunc___ref__(self, *args)


    def __hash__(self):
        return _Law.Handle_Law_BSpFunc___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Law.Handle_Law_BSpFunc___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Law.new_Handle_Law_BSpFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Law.Handle_Law_BSpFunc_DownCast)
    __swig_destroy__ = _Law.delete_Handle_Law_BSpFunc

    def Continuity(self, *args):
        """
        Continuity(Handle_Law_BSpFunc self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_BSpFunc_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Law_BSpFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Law_BSpFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Law.Handle_Law_BSpFunc_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Law_BSpFunc self, Standard_Real const X) -> Standard_Real

        :type X: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Law.Handle_Law_BSpFunc_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Law_BSpFunc self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float

        """
        return _Law.Handle_Law_BSpFunc_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Law_BSpFunc self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D: float
        :type D2: float

        """
        return _Law.Handle_Law_BSpFunc_D2(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Law_BSpFunc self, Standard_Real const PFirst, Standard_Real const PLast, Standard_Real const Tol) -> Handle_Law_Function

        Returns a  law equivalent of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        It is usfule to determines the derivatives
        in these values <First> and <Last> if
        the Law is not Cn.

        :type PFirst: float
        :type PLast: float
        :type Tol: float
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _Law.Handle_Law_BSpFunc_Trim(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_Law_BSpFunc self)

        :type PFirst: float
        :type PLast: float

        """
        return _Law.Handle_Law_BSpFunc_Bounds(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_Law_BSpFunc self) -> Handle_Law_BSpline

        :rtype: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Handle_Law_BSpFunc_Curve(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_Law_BSpFunc self, Handle_Law_BSpline C)

        :type C: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _Law.Handle_Law_BSpFunc_SetCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Law_BSpFunc self) -> char const *

        :rtype: const char *

        """
        return _Law.Handle_Law_BSpFunc_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_BSpFunc_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Law.Handle_Law_BSpFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Law_BSpFunc self)

        Memory deallocator for transient classes


        """
        return _Law.Handle_Law_BSpFunc_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Law_BSpFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Law_BSpFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpFunc_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Law_BSpFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Law_BSpFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Law.Handle_Law_BSpFunc_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Law_BSpFunc self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Law.Handle_Law_BSpFunc_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Law_BSpFunc self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpFunc_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Law_BSpFunc self)

        Increments the reference counter of this object


        """
        return _Law.Handle_Law_BSpFunc_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Law_BSpFunc self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Law.Handle_Law_BSpFunc_DecrementRefCounter(self, *args)

Handle_Law_BSpFunc_swigregister = _Law.Handle_Law_BSpFunc_swigregister
Handle_Law_BSpFunc_swigregister(Handle_Law_BSpFunc)

def Handle_Law_BSpFunc_DownCast(thing):
    return _Law.Handle_Law_BSpFunc_DownCast(thing)
Handle_Law_BSpFunc_DownCast = _Law.Handle_Law_BSpFunc_DownCast




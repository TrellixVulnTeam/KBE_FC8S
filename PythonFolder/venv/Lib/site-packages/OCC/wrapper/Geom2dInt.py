# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Geom2dInt')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Geom2dInt')
    _Geom2dInt = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom2dInt', [dirname(__file__)])
        except ImportError:
            import _Geom2dInt
            return _Geom2dInt
        try:
            _mod = imp.load_module('_Geom2dInt', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Geom2dInt = swig_import_helper()
    del swig_import_helper
else:
    import _Geom2dInt
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2dInt.delete_SwigPyIterator

    def value(self):
        return _Geom2dInt.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Geom2dInt.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Geom2dInt.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Geom2dInt.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Geom2dInt.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Geom2dInt.SwigPyIterator_copy(self)

    def next(self):
        return _Geom2dInt.SwigPyIterator_next(self)

    def __next__(self):
        return _Geom2dInt.SwigPyIterator___next__(self)

    def previous(self):
        return _Geom2dInt.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Geom2dInt.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Geom2dInt.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Geom2dInt.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Geom2dInt.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Geom2dInt.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Geom2dInt.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Geom2dInt.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Geom2dInt.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dInt.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Geom2dInt.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dInt.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dInt.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dInt.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Geom2dInt.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Geom2dInt.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Geom2dInt.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dInt.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Geom2dInt.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dInt.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dInt.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dInt.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Geom2dInt.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Geom2dInt.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Geom2dInt.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Geom2dInt.ptr_to_number(item)
ptr_to_number = _Geom2dInt.ptr_to_number

def HashCode(*args):
    return _Geom2dInt.HashCode(*args)
HashCode = _Geom2dInt.HashCode

def ptr_equal(a, b):
    return _Geom2dInt.ptr_equal(a, b)
ptr_equal = _Geom2dInt.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
class Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self) -> Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter
        __init__(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const TolU) -> Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter
        __init__(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self, gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU) -> Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter

        Calculates the distance with a close point.
        The close point is defined by the parameter value
        U0.
        The function F(u)=distance(P,C(u)) has an extremum
        when g(u)=dF/du=0. The algorithm searchs a zero
        near the close point.
        Zeros are searched between Umin et Usup.
        TolU is used to decide to stop the iterations.
        At the nth iteration, the criteria is:
        abs(Un - Un-1) < TolU.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U0: float
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        this = _Geom2dInt.new_Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self, Adaptor2d_Curve2d C, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const TolU)

        sets the fields of the algorithm.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Umin: float
        :type Usup: float
        :type TolU: float

        """
        return _Geom2dInt.Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self, gp_Pnt2d P, Standard_Real const U0)

        the algorithm is done with the point P.
        An exception is raised if the fields have not
        been initialized.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type U0: float

        """
        return _Geom2dInt.Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self) -> Standard_Boolean

        Returns True if the distance is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_IsDone(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self) -> Standard_Real

        Returns the value of the extremum square distance.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter self) -> Standard_Boolean

        Returns True if the extremum distance is a minimum.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the point of the extremum distance.

        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Geom2dInt.Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter
Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_swigregister = _Geom2dInt.Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_swigregister
Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter_swigregister(Geom2dInt_TheLocateExtPCOfTheProjPCurOfGInter)

class Geom2dInt_GInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_GInter self) -> Geom2dInt_GInter
        __init__(Geom2dInt_GInter self, Adaptor2d_Curve2d C, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_GInter
        __init__(Geom2dInt_GInter self, Adaptor2d_Curve2d C, IntRes2d_Domain D, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_GInter
        __init__(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_GInter
        __init__(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, IntRes2d_Domain D1, Adaptor2d_Curve2d C2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_GInter
        __init__(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_GInter
        __init__(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, IntRes2d_Domain D1, Adaptor2d_Curve2d C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_GInter

        Intersection between 2 curves.

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _Geom2dInt.new_Geom2dInt_GInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, IntRes2d_Domain D1, Adaptor2d_Curve2d C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, IntRes2d_Domain D1, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, IntRes2d_Domain D1, Adaptor2d_Curve2d C2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between 2 curves.

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _Geom2dInt.Geom2dInt_GInter_Perform(self, *args)


    def ComputeDomain(self, *args):
        """
        ComputeDomain(Geom2dInt_GInter self, Adaptor2d_Curve2d C1, Standard_Real const TolDomain) -> IntRes2d_Domain

        Create a domain from a curve

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type TolDomain: float
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Domain

        """
        return _Geom2dInt.Geom2dInt_GInter_ComputeDomain(self, *args)


    def SetMinNbSamples(self, *args):
        """
        SetMinNbSamples(Geom2dInt_GInter self, Standard_Integer const theMinNbSamples)

        Set / get minimum number of points in polygon intersection.

        :type theMinNbSamples: int

        """
        return _Geom2dInt.Geom2dInt_GInter_SetMinNbSamples(self, *args)


    def GetMinNbSamples(self, *args):
        """
        GetMinNbSamples(Geom2dInt_GInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_GInter_GetMinNbSamples(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_GInter
Geom2dInt_GInter_swigregister = _Geom2dInt.Geom2dInt_GInter_swigregister
Geom2dInt_GInter_swigregister(Geom2dInt_GInter)

class Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter self, Adaptor2d_Curve2d C1, Adaptor2d_Curve2d C2, Standard_Real const Tol) -> Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter

        :type C1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type C2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Tol: float

        """
        this = _Geom2dInt.new_Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter self, Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter Poly1, Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter Poly2)
        Perform(Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter self, Standard_Real const Uo, Standard_Real const Vo, Standard_Real const UInf, Standard_Real const VInf, Standard_Real const USup, Standard_Real const VSup)

        :type Uo: float
        :type Vo: float
        :type UInf: float
        :type VInf: float
        :type USup: float
        :type VSup: float

        """
        return _Geom2dInt.Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter_Perform(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter_NbRoots(self, *args)


    def Roots(self, *args):
        """
        Roots(Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter self)

        :type U: float
        :type V: float

        """
        return _Geom2dInt.Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter_Roots(self, *args)


    def AnErrorOccurred(self, *args):
        """
        AnErrorOccurred(Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter_AnErrorOccurred(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter
Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter_swigregister
Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter_swigregister(Geom2dInt_ExactIntersectionPointOfTheIntPCurvePCurveOfGInter)

class Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter self) -> Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter
        __init__(Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter self, IntCurve_IConicTool ITool, IntRes2d_Domain Dom1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain Dom2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter

        Intersection between an implicit curve and
        a parametrised curve.
        The exception ConstructionError is raised if the domain
        of the parametrised curve does not verify HasFirstPoint
        and HasLastPoint return True.

        :type ITool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type Dom1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Dom2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _Geom2dInt.new_Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter self, IntCurve_IConicTool ITool, IntRes2d_Domain Dom1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain Dom2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between an implicit curve and
        a parametrised curve.
        The exception ConstructionError is raised if the domain
        of the parametrised curve does not verify HasFirstPoint
        and HasLastPoint return True.

        :type ITool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type Dom1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Dom2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _Geom2dInt.Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter_Perform(self, *args)


    def FindU(self, *args):
        """
        FindU(Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter self, Standard_Real const parameter, gp_Pnt2d point, Adaptor2d_Curve2d TheParCurev, IntCurve_IConicTool IntCurve_IConicTool) -> Standard_Real

        :type parameter: float
        :type point: OCC.wrapper.gp.gp_Pnt2d
        :type TheParCurev: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type IntCurve_IConicTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter_FindU(self, *args)


    def FindV(self, *args):
        """
        FindV(Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter self, Standard_Real const parameter, gp_Pnt2d point, IntCurve_IConicTool IntCurve_IConicTool, Adaptor2d_Curve2d ParCurve, IntRes2d_Domain TheParCurveDomain, Standard_Real const V0, Standard_Real const V1, Standard_Real const Tolerance) -> Standard_Real

        :type parameter: float
        :type point: OCC.wrapper.gp.gp_Pnt2d
        :type IntCurve_IConicTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type ParCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type TheParCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type V0: float
        :type V1: float
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter_FindV(self, *args)


    def And_Domaine_Objet1_Intersections(self, *args):
        """
        And_Domaine_Objet1_Intersections(Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter self, IntCurve_IConicTool IntCurve_IConicTool, Adaptor2d_Curve2d TheParCurve, IntRes2d_Domain TheImpCurveDomain, IntRes2d_Domain TheParCurveDomain, NCollection_Array1_Standard_Real Inter2_And_Domain2, NCollection_Array1_Standard_Real Inter1, NCollection_Array1_Standard_Real Resultat1, NCollection_Array1_Standard_Real Resultat2, Standard_Real const EpsNul)

        :type IntCurve_IConicTool: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type TheParCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type TheImpCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TheParCurveDomain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type NbResultats: int
        :type Inter2_And_Domain2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Inter1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Resultat1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Resultat2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type EpsNul: float

        """
        return _Geom2dInt.Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter_And_Domaine_Objet1_Intersections(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter
Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter_swigregister
Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter_swigregister(Geom2dInt_TheIntersectorOfTheIntConicCurveOfGInter)

class Geom2dInt_TheIntConicCurveOfGInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_TheIntConicCurveOfGInter self) -> Geom2dInt_TheIntConicCurveOfGInter
        __init__(Geom2dInt_TheIntConicCurveOfGInter self, gp_Lin2d L, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_TheIntConicCurveOfGInter
        __init__(Geom2dInt_TheIntConicCurveOfGInter self, gp_Circ2d C, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_TheIntConicCurveOfGInter
        __init__(Geom2dInt_TheIntConicCurveOfGInter self, gp_Elips2d E, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_TheIntConicCurveOfGInter
        __init__(Geom2dInt_TheIntConicCurveOfGInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_TheIntConicCurveOfGInter
        __init__(Geom2dInt_TheIntConicCurveOfGInter self, gp_Hypr2d H, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_TheIntConicCurveOfGInter

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _Geom2dInt.new_Geom2dInt_TheIntConicCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dInt_TheIntConicCurveOfGInter self, gp_Lin2d L, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_TheIntConicCurveOfGInter self, gp_Circ2d C, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_TheIntConicCurveOfGInter self, gp_Elips2d E, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_TheIntConicCurveOfGInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_TheIntConicCurveOfGInter self, gp_Hypr2d H, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _Geom2dInt.Geom2dInt_TheIntConicCurveOfGInter_Perform(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_TheIntConicCurveOfGInter
Geom2dInt_TheIntConicCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_TheIntConicCurveOfGInter_swigregister
Geom2dInt_TheIntConicCurveOfGInter_swigregister(Geom2dInt_TheIntConicCurveOfGInter)

class Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter self, Adaptor2d_Curve2d curve1, Adaptor2d_Curve2d curve2) -> Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter

        :type curve1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type curve2: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Geom2dInt.new_Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter self) -> Standard_Integer

        returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter self) -> Standard_Integer

        returns 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_Values(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter
Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_swigregister
Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter_swigregister(Geom2dInt_TheDistBetweenPCurvesOfTheIntPCurvePCurveOfGInter)

class Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Locate(*args):
        """
        Locate(gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Extrema_POnCurv2d Papp)
        Locate(gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Extrema_POnCurv2d Papp)

        Among a set of points {C(ui),i=1,NbU}, locate the point
        P=C(uj) such that:
        distance(P,C) = Min{distance(P,C(ui))}
        The research is done between umin and usup.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbU: int
        :type Umin: float
        :type Usup: float
        :type Papp: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        return _Geom2dInt.Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter_Locate(*args)

    Locate = staticmethod(Locate)

    def __init__(self):
        this = _Geom2dInt.new_Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter
Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter_swigregister = _Geom2dInt.Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter_swigregister
Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter_swigregister(Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter)

def Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter_Locate(*args):
    """
    Locate(gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Extrema_POnCurv2d Papp)
    Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter_Locate(gp_Pnt2d P, Adaptor2d_Curve2d C, Standard_Integer const NbU, Standard_Real const Umin, Standard_Real const Usup, Extrema_POnCurv2d Papp)

    Among a set of points {C(ui),i=1,NbU}, locate the point
    P=C(uj) such that:
    distance(P,C) = Min{distance(P,C(ui))}
    The research is done between umin and usup.

    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type NbU: int
    :type Umin: float
    :type Usup: float
    :type Papp: OCC.wrapper.Extrema.Extrema_POnCurv2d

    """
    return _Geom2dInt.Geom2dInt_TheCurveLocatorOfTheProjPCurOfGInter_Locate(*args)

class Geom2dInt_IntConicCurveOfGInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_IntConicCurveOfGInter self) -> Geom2dInt_IntConicCurveOfGInter
        __init__(Geom2dInt_IntConicCurveOfGInter self, gp_Lin2d L, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_IntConicCurveOfGInter
        __init__(Geom2dInt_IntConicCurveOfGInter self, gp_Circ2d C, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_IntConicCurveOfGInter
        __init__(Geom2dInt_IntConicCurveOfGInter self, gp_Elips2d E, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_IntConicCurveOfGInter
        __init__(Geom2dInt_IntConicCurveOfGInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_IntConicCurveOfGInter
        __init__(Geom2dInt_IntConicCurveOfGInter self, gp_Hypr2d H, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol) -> Geom2dInt_IntConicCurveOfGInter

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        this = _Geom2dInt.new_Geom2dInt_IntConicCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dInt_IntConicCurveOfGInter self, gp_Lin2d L, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_IntConicCurveOfGInter self, gp_Circ2d C, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_IntConicCurveOfGInter self, gp_Elips2d E, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_IntConicCurveOfGInter self, gp_Parab2d Prb, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_IntConicCurveOfGInter self, gp_Hypr2d H, IntRes2d_Domain D1, Adaptor2d_Curve2d PCurve, IntRes2d_Domain D2, Standard_Real const TolConf, Standard_Real const Tol)

        Intersection between the main branch of an hyperbola
        and a parametric curve.

        :type H: OCC.wrapper.gp.gp_Hypr2d
        :type D1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type PCurve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type D2: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _Geom2dInt.Geom2dInt_IntConicCurveOfGInter_Perform(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_IntConicCurveOfGInter
Geom2dInt_IntConicCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_IntConicCurveOfGInter_swigregister
Geom2dInt_IntConicCurveOfGInter_swigregister(Geom2dInt_IntConicCurveOfGInter)

class Geom2dInt_Geom2dCurveTool(object):
    """
    This class provides a Geom2dCurveTool as < Geom2dCurveTool from IntCurve >
    from a Tool as < Geom2dCurveTool from Adaptor3d > .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetType(*args):
        """
        GetType(Adaptor2d_Curve2d C) -> GeomAbs_CurveType

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(Adaptor2d_Curve2d C) -> gp_Lin2d

        Returns the Lin2d from gp corresponding to the curve C.
        This method is called only when TheType returns
        GeomAbs_Line.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Adaptor2d_Curve2d C) -> gp_Circ2d

        Returns the Circ2d from gp corresponding to the curve C.
        This method is called only when TheType returns
        GeomAbs_Circle.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Adaptor2d_Curve2d C) -> gp_Elips2d

        Returns the Elips2d from gp corresponding to the curve C.
        This method is called only when TheType returns
        GeomAbs_Ellipse.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Parabola(*args):
        """
        Parabola(Adaptor2d_Curve2d C) -> gp_Parab2d

        Returns the Parab2d from gp corresponding to the curve C.
        This method is called only when TheType returns
        GeomAbs_Parabola.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Hyperbola(*args):
        """
        Hyperbola(Adaptor2d_Curve2d C) -> gp_Hypr2d

        Returns the Hypr2d from gp corresponding to the curve C.
        This method is called only when TheType returns
        GeomAbs_Hyperbola.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def EpsX(*args):
        """
        EpsX(Adaptor2d_Curve2d C) -> Standard_Real
        EpsX(Adaptor2d_Curve2d C, Standard_Real const Eps_XYZ) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Eps_XYZ: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_EpsX(*args)

    EpsX = staticmethod(EpsX)

    def NbSamples(*args):
        """
        NbSamples(Adaptor2d_Curve2d C) -> Standard_Integer
        NbSamples(Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def FirstParameter(*args):
        """
        FirstParameter(Adaptor2d_Curve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Adaptor2d_Curve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Value(*args):
        """
        Value(Adaptor2d_Curve2d C, Standard_Real const X) -> gp_Pnt2d

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type X: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P)

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T)

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N)

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d
        :type N: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N, gp_Vec2d V)

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type T: OCC.wrapper.gp.gp_Vec2d
        :type N: OCC.wrapper.gp.gp_Vec2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Adaptor2d_Curve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_DN(*args)

    DN = staticmethod(DN)

    def NbIntervals(*args):
        """
        NbIntervals(Adaptor2d_Curve2d C) -> Standard_Integer

        output the number of interval of continuity C2 of
        the curve

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Adaptor2d_Curve2d C, NCollection_Array1_Standard_Real Tab)

        compute Tab.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Tab: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def GetInterval(*args):
        """
        GetInterval(Adaptor2d_Curve2d C, Standard_Integer const Index, NCollection_Array1_Standard_Real Tab)

        output the bounds of interval of index <Index>
        used if Type == Composite.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Index: int
        :type Tab: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type U1: float
        :type U2: float

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_GetInterval(*args)

    GetInterval = staticmethod(GetInterval)

    def Degree(*args):
        """
        Degree(Adaptor2d_Curve2d C) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Degree(*args)

    Degree = staticmethod(Degree)

    def __init__(self):
        """
        This class provides a Geom2dCurveTool as < Geom2dCurveTool from IntCurve >
        from a Tool as < Geom2dCurveTool from Adaptor3d > .
        """
        this = _Geom2dInt.new_Geom2dInt_Geom2dCurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_Geom2dCurveTool
Geom2dInt_Geom2dCurveTool_swigregister = _Geom2dInt.Geom2dInt_Geom2dCurveTool_swigregister
Geom2dInt_Geom2dCurveTool_swigregister(Geom2dInt_Geom2dCurveTool)

def Geom2dInt_Geom2dCurveTool_GetType(*args):
    """
    Geom2dInt_Geom2dCurveTool_GetType(Adaptor2d_Curve2d C) -> GeomAbs_CurveType

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_GetType(*args)

def Geom2dInt_Geom2dCurveTool_Line(*args):
    """
    Geom2dInt_Geom2dCurveTool_Line(Adaptor2d_Curve2d C) -> gp_Lin2d

    Returns the Lin2d from gp corresponding to the curve C.
    This method is called only when TheType returns
    GeomAbs_Line.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Lin2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Line(*args)

def Geom2dInt_Geom2dCurveTool_Circle(*args):
    """
    Geom2dInt_Geom2dCurveTool_Circle(Adaptor2d_Curve2d C) -> gp_Circ2d

    Returns the Circ2d from gp corresponding to the curve C.
    This method is called only when TheType returns
    GeomAbs_Circle.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Circ2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Circle(*args)

def Geom2dInt_Geom2dCurveTool_Ellipse(*args):
    """
    Geom2dInt_Geom2dCurveTool_Ellipse(Adaptor2d_Curve2d C) -> gp_Elips2d

    Returns the Elips2d from gp corresponding to the curve C.
    This method is called only when TheType returns
    GeomAbs_Ellipse.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Elips2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Ellipse(*args)

def Geom2dInt_Geom2dCurveTool_Parabola(*args):
    """
    Geom2dInt_Geom2dCurveTool_Parabola(Adaptor2d_Curve2d C) -> gp_Parab2d

    Returns the Parab2d from gp corresponding to the curve C.
    This method is called only when TheType returns
    GeomAbs_Parabola.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Parab2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Parabola(*args)

def Geom2dInt_Geom2dCurveTool_Hyperbola(*args):
    """
    Geom2dInt_Geom2dCurveTool_Hyperbola(Adaptor2d_Curve2d C) -> gp_Hypr2d

    Returns the Hypr2d from gp corresponding to the curve C.
    This method is called only when TheType returns
    GeomAbs_Hyperbola.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.gp.gp_Hypr2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Hyperbola(*args)

def Geom2dInt_Geom2dCurveTool_EpsX(*args):
    """
    EpsX(Adaptor2d_Curve2d C) -> Standard_Real
    Geom2dInt_Geom2dCurveTool_EpsX(Adaptor2d_Curve2d C, Standard_Real const Eps_XYZ) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type Eps_XYZ: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_EpsX(*args)

def Geom2dInt_Geom2dCurveTool_NbSamples(*args):
    """
    NbSamples(Adaptor2d_Curve2d C) -> Standard_Integer
    Geom2dInt_Geom2dCurveTool_NbSamples(Adaptor2d_Curve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_NbSamples(*args)

def Geom2dInt_Geom2dCurveTool_FirstParameter(*args):
    """
    Geom2dInt_Geom2dCurveTool_FirstParameter(Adaptor2d_Curve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_FirstParameter(*args)

def Geom2dInt_Geom2dCurveTool_LastParameter(*args):
    """
    Geom2dInt_Geom2dCurveTool_LastParameter(Adaptor2d_Curve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_LastParameter(*args)

def Geom2dInt_Geom2dCurveTool_Value(*args):
    """
    Geom2dInt_Geom2dCurveTool_Value(Adaptor2d_Curve2d C, Standard_Real const X) -> gp_Pnt2d

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type X: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Value(*args)

def Geom2dInt_Geom2dCurveTool_D0(*args):
    """
    Geom2dInt_Geom2dCurveTool_D0(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P)

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D0(*args)

def Geom2dInt_Geom2dCurveTool_D1(*args):
    """
    Geom2dInt_Geom2dCurveTool_D1(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T)

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D1(*args)

def Geom2dInt_Geom2dCurveTool_D2(*args):
    """
    Geom2dInt_Geom2dCurveTool_D2(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N)

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d
    :type N: OCC.wrapper.gp.gp_Vec2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D2(*args)

def Geom2dInt_Geom2dCurveTool_D3(*args):
    """
    Geom2dInt_Geom2dCurveTool_D3(Adaptor2d_Curve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d T, gp_Vec2d N, gp_Vec2d V)

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type T: OCC.wrapper.gp.gp_Vec2d
    :type N: OCC.wrapper.gp.gp_Vec2d
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_D3(*args)

def Geom2dInt_Geom2dCurveTool_DN(*args):
    """
    Geom2dInt_Geom2dCurveTool_DN(Adaptor2d_Curve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_DN(*args)

def Geom2dInt_Geom2dCurveTool_NbIntervals(*args):
    """
    Geom2dInt_Geom2dCurveTool_NbIntervals(Adaptor2d_Curve2d C) -> Standard_Integer

    output the number of interval of continuity C2 of
    the curve

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_NbIntervals(*args)

def Geom2dInt_Geom2dCurveTool_Intervals(*args):
    """
    Geom2dInt_Geom2dCurveTool_Intervals(Adaptor2d_Curve2d C, NCollection_Array1_Standard_Real Tab)

    compute Tab.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type Tab: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Intervals(*args)

def Geom2dInt_Geom2dCurveTool_GetInterval(*args):
    """
    Geom2dInt_Geom2dCurveTool_GetInterval(Adaptor2d_Curve2d C, Standard_Integer const Index, NCollection_Array1_Standard_Real Tab)

    output the bounds of interval of index <Index>
    used if Type == Composite.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type Index: int
    :type Tab: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type U1: float
    :type U2: float

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_GetInterval(*args)

def Geom2dInt_Geom2dCurveTool_Degree(*args):
    """
    Geom2dInt_Geom2dCurveTool_Degree(Adaptor2d_Curve2d C) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Geom2dInt.Geom2dInt_Geom2dCurveTool_Degree(*args)

class Geom2dInt_TheIntPCurvePCurveOfGInter(IntRes2d.IntRes2d_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(Geom2dInt_TheIntPCurvePCurveOfGInter self) -> Geom2dInt_TheIntPCurvePCurveOfGInter"""
        this = _Geom2dInt.new_Geom2dInt_TheIntPCurvePCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Geom2dInt_TheIntPCurvePCurveOfGInter self, Adaptor2d_Curve2d Curve1, IntRes2d_Domain Domain1, Adaptor2d_Curve2d Curve2, IntRes2d_Domain Domain2, Standard_Real const TolConf, Standard_Real const Tol)
        Perform(Geom2dInt_TheIntPCurvePCurveOfGInter self, Adaptor2d_Curve2d Curve1, IntRes2d_Domain Domain1, Standard_Real const TolConf, Standard_Real const Tol)

        :type Curve1: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Domain1: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type TolConf: float
        :type Tol: float

        """
        return _Geom2dInt.Geom2dInt_TheIntPCurvePCurveOfGInter_Perform(self, *args)


    def SetMinNbSamples(self, *args):
        """
        SetMinNbSamples(Geom2dInt_TheIntPCurvePCurveOfGInter self, Standard_Integer const theMinNbSamples)

        Set / get minimum number of points in polygon for intersection.

        :type theMinNbSamples: int

        """
        return _Geom2dInt.Geom2dInt_TheIntPCurvePCurveOfGInter_SetMinNbSamples(self, *args)


    def GetMinNbSamples(self, *args):
        """
        GetMinNbSamples(Geom2dInt_TheIntPCurvePCurveOfGInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_TheIntPCurvePCurveOfGInter_GetMinNbSamples(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_TheIntPCurvePCurveOfGInter
Geom2dInt_TheIntPCurvePCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_TheIntPCurvePCurveOfGInter_swigregister
Geom2dInt_TheIntPCurvePCurveOfGInter_swigregister(Geom2dInt_TheIntPCurvePCurveOfGInter)

class Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter self, IntCurve_IConicTool IT, Adaptor2d_Curve2d PC) -> Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter

        Constructor of the class.

        :type IT: OCC.wrapper.IntCurve.IntCurve_IConicTool
        :type PC: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Geom2dInt.new_Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the value of the signed distance between
        the implicit curve and the point at parameter Param
        on the parametrised curve.

        :type Param: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the derivative of the previous function at
        parameter Param.

        :type Param: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the value and the derivative of the function.

        :type Param: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter_Values(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter
Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter_swigregister
Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter_swigregister(Geom2dInt_MyImpParToolOfTheIntersectorOfTheIntConicCurveOfGInter)

class Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self) -> Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter
        __init__(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, gp_Pnt2d P, Adaptor2d_Curve2d C) -> Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        this = _Geom2dInt.new_Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, Adaptor2d_Curve2d C)

        sets the field mycurve of the function.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_Initialize(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, gp_Pnt2d P)

        sets the field P of the function.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_SetPoint(self, *args)


    def Value(self, *args):
        """
        Value(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U).

        :type U: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, Standard_Real const U) -> Standard_Boolean

        Calculation of F'(U).

        :type U: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, Standard_Real const U) -> Standard_Boolean

        Calculation of F(U) and F'(U).

        :type U: float
        :type F: float
        :type DF: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self) -> Standard_Integer

        Save the found extremum.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_GetStateNumber(self, *args)


    def NbExt(self, *args):
        """
        NbExt(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self) -> Standard_Integer

        Return the nunber of found extrema.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_NbExt(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, Standard_Integer const N) -> Standard_Real

        Returns the Nth distance.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_SquareDistance(self, *args)


    def IsMin(self, *args):
        """
        IsMin(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, Standard_Integer const N) -> Standard_Boolean

        Shows if the Nth distance is a minimum.

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_IsMin(self, *args)


    def Point(self, *args):
        """
        Returns the Nth extremum.

        :type N: int
        :rtype: OCC.wrapper.Extrema.Extrema_POnCurv2d

        """
        res = _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SubIntervalInitialize(self, *args):
        """
        SubIntervalInitialize(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self, Standard_Real const theUfirst, Standard_Real const theUlast)

        Determines boundaries of subinterval for find of root.

        :type theUfirst: float
        :type theUlast: float

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_SubIntervalInitialize(self, *args)


    def SearchOfTolerance(self, *args):
        """
        SearchOfTolerance(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter self) -> Standard_Real

        Computes a Tol value. If 1st derivative of curve
        |D1|<Tol, it is considered D1=0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_SearchOfTolerance(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter
Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_swigregister = _Geom2dInt.Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_swigregister
Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter_swigregister(Geom2dInt_PCLocFOfTheLocateExtPCOfTheProjPCurOfGInter)

class Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter(Intf.Intf_Polygon2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self, Adaptor2d_Curve2d Curve, Standard_Integer const NbPnt, IntRes2d_Domain Domain, Standard_Real const Tol) -> Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter

        Compute a polygon on the domain of the curve.

        :type Curve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type NbPnt: int
        :type Domain: OCC.wrapper.IntRes2d.IntRes2d_Domain
        :type Tol: float

        """
        this = _Geom2dInt.new_Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ComputeWithBox(self, *args):
        """
        ComputeWithBox(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self, Adaptor2d_Curve2d Curve, Bnd_Box2d OtherBox)

        The current polygon is modified if most
        of the  points of the  polygon  are are
        outside  the  box  <OtherBox>.  In this
        situation, bounds are computed to build
        a polygon inside or near the OtherBox.

        :type Curve: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type OtherBox: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_ComputeWithBox(self, *args)


    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_DeflectionOverEstimation(self, *args)


    def SetDeflectionOverEstimation(self, *args):
        """
        SetDeflectionOverEstimation(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self, Standard_Real const x)

        :type x: float

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_SetDeflectionOverEstimation(self, *args)


    def Closed(self, *args):
        """
        Closed(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self, Standard_Boolean const clos)
        Closed(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self) -> Standard_Boolean

        Returns True if the polyline is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_Closed(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self) -> Standard_Integer

        Give the number of Segments in the polyline.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self, Standard_Integer const theIndex, gp_Pnt2d theBegin, gp_Pnt2d theEnd)

        Returns the points of the segment <Index> in the Polygon.

        :type theIndex: int
        :type theBegin: OCC.wrapper.gp.gp_Pnt2d
        :type theEnd: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_Segment(self, *args)


    def InfParameter(self, *args):
        """
        InfParameter(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self) -> Standard_Real

        Returns the parameter (On the curve)
        of the first point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_InfParameter(self, *args)


    def SupParameter(self, *args):
        """
        SupParameter(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self) -> Standard_Real

        Returns the parameter (On the curve)
        of the last point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_SupParameter(self, *args)


    def AutoIntersectionIsPossible(self, *args):
        """
        AutoIntersectionIsPossible(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_AutoIntersectionIsPossible(self, *args)


    def ApproxParamOnCurve(self, *args):
        """
        ApproxParamOnCurve(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self, Standard_Integer const Index, Standard_Real const ParamOnLine) -> Standard_Real

        Give an approximation of the parameter on the curve
        according to the discretization of the Curve.

        :type Index: int
        :type ParamOnLine: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_ApproxParamOnCurve(self, *args)


    def CalculRegion(self, *args):
        """
        CalculRegion(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self, Standard_Real const x, Standard_Real const y, Standard_Real const x1, Standard_Real const x2, Standard_Real const y1, Standard_Real const y2) -> Standard_Integer

        :type x: float
        :type y: float
        :type x1: float
        :type x2: float
        :type y1: float
        :type y2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_CalculRegion(self, *args)


    def Dump(self, *args):
        """Dump(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter self)"""
        return _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_Dump(self, *args)

    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter
Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_swigregister = _Geom2dInt.Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_swigregister
Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter_swigregister(Geom2dInt_ThePolygon2dOfTheIntPCurvePCurveOfGInter)

class Geom2dInt_TheProjPCurOfGInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FindParameter(*args):
        """
        FindParameter(Adaptor2d_Curve2d C, gp_Pnt2d Pnt, Standard_Real const Tol) -> Standard_Real
        FindParameter(Adaptor2d_Curve2d C, gp_Pnt2d Pnt, Standard_Real const LowParameter, Standard_Real const HighParameter, Standard_Real const Tol) -> Standard_Real

        Returns the parameter V of the point on the
        parametric curve corresponding to the Point Pnt.
        The Correspondance between Pnt and the point P(V)
        on the parametric curve must be coherent with the
        way of determination of the signed distance
        between a point and the implicit curve.
        Tol is the tolerance on the distance between a point
        and the parametrised curve.
        LowParameter and HighParameter give the
        boundaries of the interval in wich the parameter
        certainly lies. These parameters are given to
        implement a more efficient algoritm. So, it is not
        necessary to check that the returned value verifies
        LowParameter <= Value <= HighParameter.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Pnt: OCC.wrapper.gp.gp_Pnt2d
        :type LowParameter: float
        :type HighParameter: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dInt.Geom2dInt_TheProjPCurOfGInter_FindParameter(*args)

    FindParameter = staticmethod(FindParameter)

    def __init__(self):
        this = _Geom2dInt.new_Geom2dInt_TheProjPCurOfGInter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dInt.delete_Geom2dInt_TheProjPCurOfGInter
Geom2dInt_TheProjPCurOfGInter_swigregister = _Geom2dInt.Geom2dInt_TheProjPCurOfGInter_swigregister
Geom2dInt_TheProjPCurOfGInter_swigregister(Geom2dInt_TheProjPCurOfGInter)

def Geom2dInt_TheProjPCurOfGInter_FindParameter(*args):
    """
    FindParameter(Adaptor2d_Curve2d C, gp_Pnt2d Pnt, Standard_Real const Tol) -> Standard_Real
    Geom2dInt_TheProjPCurOfGInter_FindParameter(Adaptor2d_Curve2d C, gp_Pnt2d Pnt, Standard_Real const LowParameter, Standard_Real const HighParameter, Standard_Real const Tol) -> Standard_Real

    Returns the parameter V of the point on the
    parametric curve corresponding to the Point Pnt.
    The Correspondance between Pnt and the point P(V)
    on the parametric curve must be coherent with the
    way of determination of the signed distance
    between a point and the implicit curve.
    Tol is the tolerance on the distance between a point
    and the parametrised curve.
    LowParameter and HighParameter give the
    boundaries of the interval in wich the parameter
    certainly lies. These parameters are given to
    implement a more efficient algoritm. So, it is not
    necessary to check that the returned value verifies
    LowParameter <= Value <= HighParameter.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type Pnt: OCC.wrapper.gp.gp_Pnt2d
    :type LowParameter: float
    :type HighParameter: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Geom2dInt.Geom2dInt_TheProjPCurOfGInter_FindParameter(*args)




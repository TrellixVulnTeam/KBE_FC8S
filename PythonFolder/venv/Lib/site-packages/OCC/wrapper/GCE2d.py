# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GCE2d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GCE2d')
    _GCE2d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GCE2d', [dirname(__file__)])
        except ImportError:
            import _GCE2d
            return _GCE2d
        try:
            _mod = imp.load_module('_GCE2d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GCE2d = swig_import_helper()
    del swig_import_helper
else:
    import _GCE2d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GCE2d.delete_SwigPyIterator

    def value(self):
        return _GCE2d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GCE2d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GCE2d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GCE2d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GCE2d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GCE2d.SwigPyIterator_copy(self)

    def next(self):
        return _GCE2d.SwigPyIterator_next(self)

    def __next__(self):
        return _GCE2d.SwigPyIterator___next__(self)

    def previous(self):
        return _GCE2d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GCE2d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GCE2d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GCE2d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GCE2d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GCE2d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GCE2d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GCE2d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GCE2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GCE2d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GCE2d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GCE2d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GCE2d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GCE2d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GCE2d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GCE2d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GCE2d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GCE2d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GCE2d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GCE2d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GCE2d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GCE2d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GCE2d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GCE2d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GCE2d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GCE2d.ptr_to_number(item)
ptr_to_number = _GCE2d.ptr_to_number

def HashCode(*args):
    return _GCE2d.HashCode(*args)
HashCode = _GCE2d.HashCode

def ptr_equal(a, b):
    return _GCE2d.ptr_equal(a, b)
ptr_equal = _GCE2d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gce
else:
    import gce
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class GCE2d_Root(object):
    """
    This class implements the common services for
    all classes of gce which report error.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(GCE2d_Root self) -> Standard_Boolean

        Returns true if the construction is successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GCE2d.GCE2d_Root_IsDone(self, *args)


    def Status(self, *args):
        """
        Status(GCE2d_Root self) -> gce_ErrorType

        Returns the status of the construction
        -   gce_Done, if the construction is successful, or
        -   another value of the gce_ErrorType enumeration
        indicating why the construction failed.

        :rtype: OCC.wrapper.gce.gce_ErrorType

        """
        return _GCE2d.GCE2d_Root_Status(self, *args)


    def __init__(self):
        """
        This class implements the common services for
        all classes of gce which report error.
        """
        this = _GCE2d.new_GCE2d_Root()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GCE2d.delete_GCE2d_Root
GCE2d_Root_swigregister = _GCE2d.GCE2d_Root_swigregister
GCE2d_Root_swigregister(GCE2d_Root)

class GCE2d_MakeTranslation(object):
    """
    This class implements elementary construction algorithms for a
    translation in 2D space. The result is a
    Geom2d_Transformation transformation.
    A MakeTranslation object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeTranslation self, gp_Vec2d Vect) -> GCE2d_MakeTranslation
        __init__(GCE2d_MakeTranslation self, gp_Pnt2d Point1, gp_Pnt2d Point2) -> GCE2d_MakeTranslation

        Constructs a translation along the vector
        (Point1,Point2) defined from the point Point1 to the point Point2.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GCE2d.new_GCE2d_MakeTranslation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        res = _GCE2d.GCE2d_MakeTranslation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeTranslation
GCE2d_MakeTranslation_swigregister = _GCE2d.GCE2d_MakeTranslation_swigregister
GCE2d_MakeTranslation_swigregister(GCE2d_MakeTranslation)

class GCE2d_MakeArcOfHyperbola(GCE2d_Root):
    """
    Implements construction algorithms for an arc of
    hyperbola in the plane. The result is a Geom2d_TrimmedCurve curve.
    A MakeArcOfHyperbola object provides a framework for:
    -   defining the construction of the arc of hyperbola,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed arc of hyperbola.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeArcOfHyperbola self, gp_Hypr2d Hypr, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfHyperbola
        __init__(GCE2d_MakeArcOfHyperbola self, gp_Hypr2d Hypr, gp_Pnt2d P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GCE2d_MakeArcOfHyperbola
        __init__(GCE2d_MakeArcOfHyperbola self, gp_Hypr2d Hypr, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfHyperbola

        Makes an arc of Hyperbola (TrimmedCurve from Geom2d) from
        a Hyperbola between two points P1 and P2.
        Note: the orientation of the arc of hyperbola is:
        -   the trigonometric sense if Sense is not defined or
        is true (default value), or
        -   the opposite sense if Sense is false.
        - IsDone always returns true.

        :type Hypr: OCC.wrapper.gp.gp_Hypr2d
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type Sense: bool

        """
        this = _GCE2d.new_GCE2d_MakeArcOfHyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of hyperbola.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        res = _GCE2d.GCE2d_MakeArcOfHyperbola_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeArcOfHyperbola
GCE2d_MakeArcOfHyperbola_swigregister = _GCE2d.GCE2d_MakeArcOfHyperbola_swigregister
GCE2d_MakeArcOfHyperbola_swigregister(GCE2d_MakeArcOfHyperbola)

class GCE2d_MakeScale(object):
    """
    This class implements an elementary construction algorithm for
    a scaling transformation in 2D space. The result is a
    Geom2d_Transformation transformation.
    A MakeScale object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeScale self, gp_Pnt2d Point, Standard_Real const Scale) -> GCE2d_MakeScale

        Constructs a scaling transformation with
        -   Point as the center of the transformation, and
        -   Scale as the scale factor.

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Scale: float

        """
        this = _GCE2d.new_GCE2d_MakeScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        res = _GCE2d.GCE2d_MakeScale_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeScale
GCE2d_MakeScale_swigregister = _GCE2d.GCE2d_MakeScale_swigregister
GCE2d_MakeScale_swigregister(GCE2d_MakeScale)

class GCE2d_MakeLine(GCE2d_Root):
    """
    This class implements the following algorithms used
    to create a Line from Geom2d.
    * Create a Line parallel to another and passing
    through a point.
    * Create a Line passing through 2 points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeLine self, gp_Ax2d A) -> GCE2d_MakeLine
        __init__(GCE2d_MakeLine self, gp_Lin2d L) -> GCE2d_MakeLine
        __init__(GCE2d_MakeLine self, gp_Pnt2d P, gp_Dir2d V) -> GCE2d_MakeLine
        __init__(GCE2d_MakeLine self, gp_Lin2d Lin, gp_Pnt2d Point) -> GCE2d_MakeLine
        __init__(GCE2d_MakeLine self, gp_Lin2d Lin, Standard_Real const Dist) -> GCE2d_MakeLine
        __init__(GCE2d_MakeLine self, gp_Pnt2d P1, gp_Pnt2d P2) -> GCE2d_MakeLine

        Make a Line from Geom2d <TheLin> passing through 2
        Pnt <P1>,<P2>.
        It returns false if <p1> and <P2> are confused.
        Warning
        If points P1 and P2 coincident (that is, when IsDone
        returns false), the Status function returns gce_ConfusedPoints.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GCE2d.new_GCE2d_MakeLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed line.
        Exceptions StdFail_NotDone if no line is constructed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Line

        """
        res = _GCE2d.GCE2d_MakeLine_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeLine
GCE2d_MakeLine_swigregister = _GCE2d.GCE2d_MakeLine_swigregister
GCE2d_MakeLine_swigregister(GCE2d_MakeLine)

class GCE2d_MakeEllipse(GCE2d_Root):
    """
    This class implements the following algorithms used to
    create Ellipse from Geom2d.
    * Create an Ellipse from two apex  and the center.
    Defines an ellipse in 2D space.
    The parametrization range is [0,2*PI].
    The ellipse is a closed and periodic curve.
    The center of the ellipse is the "Location" point of its
    axis placement "XAxis".
    The "XAxis" of the ellipse defines the origin of the
    parametrization, it is the major axis of the ellipse.
    The YAxis is the minor axis of the ellipse.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeEllipse self, gp_Elips2d E) -> GCE2d_MakeEllipse
        __init__(GCE2d_MakeEllipse self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> GCE2d_MakeEllipse
        __init__(GCE2d_MakeEllipse self, gp_Ax22d Axis, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> GCE2d_MakeEllipse
        __init__(GCE2d_MakeEllipse self, gp_Pnt2d S1, gp_Pnt2d S2, gp_Pnt2d Center) -> GCE2d_MakeEllipse

        Make an Ellipse centered on the point Center, where
        -   the major axis of the ellipse is defined by Center and S1,
        -   its major radius is the distance between Center and S1, and
        -   its minor radius is the distance between S2 and the major axis.
        The implicit orientation of the ellipse is:
        -   the sense defined by Axis or E,
        -   the sense defined by points Center, S1 and S2,
        -   the trigonometric sense if Sense is not given or is true, or
        -   the opposite sense if Sense is false.

        :type S1: OCC.wrapper.gp.gp_Pnt2d
        :type S2: OCC.wrapper.gp.gp_Pnt2d
        :type Center: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GCE2d.new_GCE2d_MakeEllipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed ellipse.
        Exceptions StdFail_NotDone if no ellipse is constructed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Ellipse

        """
        res = _GCE2d.GCE2d_MakeEllipse_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeEllipse
GCE2d_MakeEllipse_swigregister = _GCE2d.GCE2d_MakeEllipse_swigregister
GCE2d_MakeEllipse_swigregister(GCE2d_MakeEllipse)

class GCE2d_MakeArcOfCircle(GCE2d_Root):
    """
    Implements construction algorithms for an arc of
    circle in the plane. The result is a Geom2d_TrimmedCurve curve.
    A MakeArcOfCircle object provides a framework for:
    -   defining the construction of the arc of circle,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed arc of circle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeArcOfCircle self, gp_Circ2d Circ, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfCircle
        __init__(GCE2d_MakeArcOfCircle self, gp_Circ2d Circ, gp_Pnt2d P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GCE2d_MakeArcOfCircle
        __init__(GCE2d_MakeArcOfCircle self, gp_Circ2d Circ, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfCircle
        __init__(GCE2d_MakeArcOfCircle self, gp_Pnt2d P1, gp_Pnt2d P2, gp_Pnt2d P3) -> GCE2d_MakeArcOfCircle
        __init__(GCE2d_MakeArcOfCircle self, gp_Pnt2d P1, gp_Vec2d V, gp_Pnt2d P2) -> GCE2d_MakeArcOfCircle

        Makes an arc of circle (TrimmedCurve from Geom2d) from
        two points P1,P2 and the tangente to the solution at
        the point P1.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GCE2d.new_GCE2d_MakeArcOfCircle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of circle.
        Exceptions StdFail_NotDone if no arc of circle is constructed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        res = _GCE2d.GCE2d_MakeArcOfCircle_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeArcOfCircle
GCE2d_MakeArcOfCircle_swigregister = _GCE2d.GCE2d_MakeArcOfCircle_swigregister
GCE2d_MakeArcOfCircle_swigregister(GCE2d_MakeArcOfCircle)

class GCE2d_MakeMirror(object):
    """
    This class implements elementary construction algorithms for a
    symmetrical transformation in 2D space about a point
    or axis. The result is a Geom2d_Transformation transformation.
    A MakeMirror object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeMirror self, gp_Pnt2d Point) -> GCE2d_MakeMirror
        __init__(GCE2d_MakeMirror self, gp_Ax2d Axis) -> GCE2d_MakeMirror
        __init__(GCE2d_MakeMirror self, gp_Lin2d Line) -> GCE2d_MakeMirror
        __init__(GCE2d_MakeMirror self, gp_Pnt2d Point, gp_Dir2d Direc) -> GCE2d_MakeMirror

        Make a symetry transformation af axis defined by
        <Point> and <Direc>.

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Direc: OCC.wrapper.gp.gp_Dir2d

        """
        this = _GCE2d.new_GCE2d_MakeMirror(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        res = _GCE2d.GCE2d_MakeMirror_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeMirror
GCE2d_MakeMirror_swigregister = _GCE2d.GCE2d_MakeMirror_swigregister
GCE2d_MakeMirror_swigregister(GCE2d_MakeMirror)

class GCE2d_MakeParabola(GCE2d_Root):
    """
    This class implements the following algorithms used to
    create Parabola from Geom2d.
    * Create an Parabola from two apex  and the center.
    Defines the parabola in the parameterization range  :
    ]-infinite,+infinite[
    The vertex of the parabola is the "Location" point of the
    local coordinate system "XAxis" of the parabola.
    The "XAxis" of the parabola is its axis of symmetry.
    The "Xaxis" is oriented from the vertex of the parabola to the
    Focus of the parabola.
    The equation of the parabola in the local coordinate system is
    Y**2 = (2*P) * X
    P is the distance between the focus and the directrix of the
    parabola called Parameter).
    The focal length F = P/2 is the distance between the vertex
    and the focus of the parabola.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeParabola self, gp_Parab2d Prb) -> GCE2d_MakeParabola
        __init__(GCE2d_MakeParabola self, gp_Ax22d Axis, Standard_Real const Focal) -> GCE2d_MakeParabola
        __init__(GCE2d_MakeParabola self, gp_Ax2d MirrorAxis, Standard_Real const Focal, Standard_Boolean const Sense) -> GCE2d_MakeParabola
        __init__(GCE2d_MakeParabola self, gp_Ax2d D, gp_Pnt2d F, Standard_Boolean const Sense) -> GCE2d_MakeParabola
        __init__(GCE2d_MakeParabola self, gp_Pnt2d S1, gp_Pnt2d O) -> GCE2d_MakeParabola

        Make a parabola with focal point S1 and
        center O
        The branch of the parabola returned will have <S1> as
        focal point
        The implicit orientation of the parabola is:
        -   the same one as the parabola Prb,
        -   the sense defined by the coordinate system Axis or the directrix D,
        -   the trigonometric sense if Sense is not given or is true, or
        -   the opposite sense if Sense is false.
        Warning
        The MakeParabola class does not prevent the
        construction of a parabola with a null focal distance.
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NullFocusLength if Focal is less than 0.0, or
        -   gce_NullAxis if points S1 and O are coincident.

        :type S1: OCC.wrapper.gp.gp_Pnt2d
        :type O: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GCE2d.new_GCE2d_MakeParabola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed parabola.
        Exceptions StdFail_NotDone if no parabola is constructed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Parabola

        """
        res = _GCE2d.GCE2d_MakeParabola_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeParabola
GCE2d_MakeParabola_swigregister = _GCE2d.GCE2d_MakeParabola_swigregister
GCE2d_MakeParabola_swigregister(GCE2d_MakeParabola)

class GCE2d_MakeHyperbola(GCE2d_Root):
    """
    This class implements the following algorithms used to
    create Hyperbola from Geom2d.
    * Create an Hyperbola from two apex  and the center.
    Defines the main branch of an hyperbola.
    The parameterization range is ]-infinite,+infinite[
    It is possible to get the other branch and the two conjugate
    branches of the main branch.

    ^YAxis
    |
    FirstConjugateBranch
    |
    Other            |                Main
    --------------------- C ------------------------------>XAxis
    Branch           |                Branch
    |
    SecondConjugateBranch
    |

    The major radius is the distance between the Location point
    of the hyperbola C and the apex of the main Branch (or the
    Other branch). The major axis is the "XAxis".
    The minor radius is the distance between the Location point
    of the hyperbola C and the apex of the First (or Second)
    Conjugate branch. The minor axis is the "YAxis".
    The major radius can be lower than the minor radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeHyperbola self, gp_Hypr2d H) -> GCE2d_MakeHyperbola
        __init__(GCE2d_MakeHyperbola self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> GCE2d_MakeHyperbola
        __init__(GCE2d_MakeHyperbola self, gp_Ax22d Axis, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> GCE2d_MakeHyperbola
        __init__(GCE2d_MakeHyperbola self, gp_Pnt2d S1, gp_Pnt2d S2, gp_Pnt2d Center) -> GCE2d_MakeHyperbola

        Creates a hyperbol centered on the origin of the coordinate system
        Axis, with major and minor radii MajorRadius and
        MinorRadius, where the major axis is the "X Axis"
        of Axis (Axis is the local coordinate system of the hyperbola).
        The implicit orientation of the ellipse is:
        -   the sense defined by Axis or H,
        -   the sense defined by points Center, S1 and S2,
        -   the trigonometric sense if Sense is not given or is true, or
        -   the opposite sense if Sense is false.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NegativeRadius if MajorRadius or
        MinorRadius is less than 0.0, or
        -   gce_InvertAxis if the major radius defined by
        Center and S1 is less than the minor radius
        defined by Center, S1 and S2.Make an Hyperbola with its center and two apexes.

        :type S1: OCC.wrapper.gp.gp_Pnt2d
        :type S2: OCC.wrapper.gp.gp_Pnt2d
        :type Center: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GCE2d.new_GCE2d_MakeHyperbola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed hyperbola.
        Exceptions: StdFail_NotDone if no hyperbola is constructed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Hyperbola

        """
        res = _GCE2d.GCE2d_MakeHyperbola_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeHyperbola
GCE2d_MakeHyperbola_swigregister = _GCE2d.GCE2d_MakeHyperbola_swigregister
GCE2d_MakeHyperbola_swigregister(GCE2d_MakeHyperbola)

class GCE2d_MakeArcOfEllipse(GCE2d_Root):
    """
    Implements construction algorithms for an arc of
    ellipse in the plane. The result is a Geom2d_TrimmedCurve curve.
    A MakeArcOfEllipse object provides a framework for:
    -   defining the construction of the arc of ellipse,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed arc of ellipse.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeArcOfEllipse self, gp_Elips2d Elips, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfEllipse
        __init__(GCE2d_MakeArcOfEllipse self, gp_Elips2d Elips, gp_Pnt2d P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GCE2d_MakeArcOfEllipse
        __init__(GCE2d_MakeArcOfEllipse self, gp_Elips2d Elips, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfEllipse

        Make an arc of Ellipse (TrimmedCurve from Geom2d) from
        a Ellipse between two points P1 and P2.
        Please, note: The orientation of the arc is:
        -   the trigonometric sense if Sense is not defined or
        is true (default value), or
        -   the opposite sense if Sense is false.
        -   Alpha1, Alpha2 and Alpha are angle values, given in radians.
        -   IsDone always returns true.

        :type Elips: OCC.wrapper.gp.gp_Elips2d
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type Sense: bool

        """
        this = _GCE2d.new_GCE2d_MakeArcOfEllipse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of ellipse.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        res = _GCE2d.GCE2d_MakeArcOfEllipse_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeArcOfEllipse
GCE2d_MakeArcOfEllipse_swigregister = _GCE2d.GCE2d_MakeArcOfEllipse_swigregister
GCE2d_MakeArcOfEllipse_swigregister(GCE2d_MakeArcOfEllipse)

class GCE2d_MakeRotation(object):
    """
    This class implements an elementary construction algorithm for
    a rotation in 2D space. The result is a Geom2d_Transformation transformation.
    A MakeRotation object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeRotation self, gp_Pnt2d Point, Standard_Real const Angle) -> GCE2d_MakeRotation

        Constructs a rotation through angle Angle about the center Point.

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Angle: float

        """
        this = _GCE2d.new_GCE2d_MakeRotation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Transformation

        """
        res = _GCE2d.GCE2d_MakeRotation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeRotation
GCE2d_MakeRotation_swigregister = _GCE2d.GCE2d_MakeRotation_swigregister
GCE2d_MakeRotation_swigregister(GCE2d_MakeRotation)

class GCE2d_MakeArcOfParabola(GCE2d_Root):
    """
    Implements construction algorithms for an arc of
    parabola in the plane. The result is a Geom2d_TrimmedCurve curve.
    A MakeArcOfParabola object provides a framework for:
    -   defining the construction of the arc of parabola,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed arc of parabola.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeArcOfParabola self, gp_Parab2d Parab, Standard_Real const Alpha1, Standard_Real const Alpha2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfParabola
        __init__(GCE2d_MakeArcOfParabola self, gp_Parab2d Parab, gp_Pnt2d P, Standard_Real const Alpha, Standard_Boolean const Sense) -> GCE2d_MakeArcOfParabola
        __init__(GCE2d_MakeArcOfParabola self, gp_Parab2d Parab, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Boolean const Sense) -> GCE2d_MakeArcOfParabola

        Make an arc of Parabola (TrimmedCurve from Geom2d) from
        a Parabola between two points P1 and P2.
        Please, note: the orientation of the arc of parabola is:
        -   the trigonometric sense if Sense is not defined
        or is true (default value), or
        -   the opposite sense if Sense is false.
        - IsDone always returns true.

        :type Parab: OCC.wrapper.gp.gp_Parab2d
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type Sense: bool

        """
        this = _GCE2d.new_GCE2d_MakeArcOfParabola(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed arc of parabola.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        res = _GCE2d.GCE2d_MakeArcOfParabola_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeArcOfParabola
GCE2d_MakeArcOfParabola_swigregister = _GCE2d.GCE2d_MakeArcOfParabola_swigregister
GCE2d_MakeArcOfParabola_swigregister(GCE2d_MakeArcOfParabola)

class GCE2d_MakeCircle(GCE2d_Root):
    """
    This class implements the following algorithms used
    to create Circle from Geom2d.

    * Create a Circle parallel to another and passing
    though a point.
    * Create a Circle parallel to another at the distance
    Dist.
    * Create a Circle passing through 3 points.
    * Create a Circle with its center and the normal of its
    plane and its radius.
    * Create a Circle with its axis and radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeCircle self, gp_Circ2d C) -> GCE2d_MakeCircle
        __init__(GCE2d_MakeCircle self, gp_Ax2d A, Standard_Real const Radius, Standard_Boolean const Sense) -> GCE2d_MakeCircle
        __init__(GCE2d_MakeCircle self, gp_Ax22d A, Standard_Real const Radius) -> GCE2d_MakeCircle
        __init__(GCE2d_MakeCircle self, gp_Circ2d Circ, Standard_Real const Dist) -> GCE2d_MakeCircle
        __init__(GCE2d_MakeCircle self, gp_Circ2d Circ, gp_Pnt2d Point) -> GCE2d_MakeCircle
        __init__(GCE2d_MakeCircle self, gp_Pnt2d P1, gp_Pnt2d P2, gp_Pnt2d P3) -> GCE2d_MakeCircle
        __init__(GCE2d_MakeCircle self, gp_Pnt2d P, Standard_Real const Radius, Standard_Boolean const Sense) -> GCE2d_MakeCircle
        __init__(GCE2d_MakeCircle self, gp_Pnt2d Center, gp_Pnt2d Point, Standard_Boolean const Sense) -> GCE2d_MakeCircle

        Makes a Circle from geom2d <TheCirc> with its center
        <Center> and a point giving the radius.
        If Sense is true the local coordinate system of
        the solution is direct and non direct in the other case.
        Warning
        The MakeCircle class does not prevent the
        construction of a circle with a null radius.
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NegativeRadius if Radius is less than 0.0, or
        -   gce_IntersectionError if points P1, P2 and P3
        are collinear and the three are not coincident.

        :type Center: OCC.wrapper.gp.gp_Pnt2d
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Sense: bool

        """
        this = _GCE2d.new_GCE2d_MakeCircle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed circle.
        Exceptions StdFail_NotDone if no circle is constructed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Circle

        """
        res = _GCE2d.GCE2d_MakeCircle_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeCircle
GCE2d_MakeCircle_swigregister = _GCE2d.GCE2d_MakeCircle_swigregister
GCE2d_MakeCircle_swigregister(GCE2d_MakeCircle)

class GCE2d_MakeSegment(GCE2d_Root):
    """
    Implements construction algorithms for a line
    segment in the plane. The result is a
    Geom2d_TrimmedCurve curve.
    A MakeSegment object provides a framework for:
    -   defining the construction of the line segment,
    -   implementing the construction algorithm, and
    -   consulting the results. In particular, the Value
    function returns the constructed line segment.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GCE2d_MakeSegment self, gp_Pnt2d P1, gp_Pnt2d P2) -> GCE2d_MakeSegment
        __init__(GCE2d_MakeSegment self, gp_Pnt2d P1, gp_Dir2d V, gp_Pnt2d P2) -> GCE2d_MakeSegment
        __init__(GCE2d_MakeSegment self, gp_Lin2d Line, Standard_Real const U1, Standard_Real const U2) -> GCE2d_MakeSegment
        __init__(GCE2d_MakeSegment self, gp_Lin2d Line, gp_Pnt2d Point, Standard_Real const Ulast) -> GCE2d_MakeSegment
        __init__(GCE2d_MakeSegment self, gp_Lin2d Line, gp_Pnt2d P1, gp_Pnt2d P2) -> GCE2d_MakeSegment

        Make a segment of Line from the line <Line>
        between the two points <P1> and <P2>.
        It returns NullObject if <P1> and <P2> are confused.
        Warning
        If the points which limit the segment are coincident
        for given points or for the projection of given points
        on the line which supports the line segment (that is,
        when IsDone returns false), the Status function
        returns gce_ConfusedPoints. This warning only
        concerns the first two constructors.

        :type Line: OCC.wrapper.gp.gp_Lin2d
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GCE2d.new_GCE2d_MakeSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed line segment.
        Exceptions StdFail_NotDone if no line segment is constructed.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_TrimmedCurve

        """
        res = _GCE2d.GCE2d_MakeSegment_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GCE2d.delete_GCE2d_MakeSegment
GCE2d_MakeSegment_swigregister = _GCE2d.GCE2d_MakeSegment_swigregister
GCE2d_MakeSegment_swigregister(GCE2d_MakeSegment)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_DNaming')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_DNaming')
    _DNaming = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_DNaming', [dirname(__file__)])
        except ImportError:
            import _DNaming
            return _DNaming
        try:
            _mod = imp.load_module('_DNaming', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _DNaming = swig_import_helper()
    del swig_import_helper
else:
    import _DNaming
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _DNaming.delete_SwigPyIterator

    def value(self):
        return _DNaming.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _DNaming.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _DNaming.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _DNaming.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _DNaming.SwigPyIterator_equal(self, x)

    def copy(self):
        return _DNaming.SwigPyIterator_copy(self)

    def next(self):
        return _DNaming.SwigPyIterator_next(self)

    def __next__(self):
        return _DNaming.SwigPyIterator___next__(self)

    def previous(self):
        return _DNaming.SwigPyIterator_previous(self)

    def advance(self, n):
        return _DNaming.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _DNaming.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _DNaming.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _DNaming.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _DNaming.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _DNaming.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _DNaming.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _DNaming.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _DNaming.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_DNaming.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _DNaming.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _DNaming.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _DNaming.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _DNaming.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _DNaming.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _DNaming.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _DNaming.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_DNaming.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _DNaming.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _DNaming.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _DNaming.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _DNaming.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _DNaming.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _DNaming.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _DNaming.ptr_to_number(item)
ptr_to_number = _DNaming.ptr_to_number

def HashCode(*args):
    return _DNaming.HashCode(*args)
HashCode = _DNaming.HashCode

def ptr_equal(a, b):
    return _DNaming.ptr_equal(a, b)
ptr_equal = _DNaming.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Draw
else:
    import Draw
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepFilletAPI
else:
    import BRepFilletAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ChFi3d
else:
    import ChFi3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepBuild
else:
    import TopOpeBRepBuild
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepDS
else:
    import TopOpeBRepDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepTool
else:
    import TopOpeBRepTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBlend
else:
    import BRepBlend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ChFiDS
else:
    import ChFiDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppBlend
else:
    import AppBlend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Blend
else:
    import Blend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BlendFunc
else:
    import BlendFunc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTopAdaptor
else:
    import BRepTopAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ChFi2d
else:
    import ChFi2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAlgoAPI
else:
    import BRepAlgoAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPAlgo
else:
    import BOPAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPTools
else:
    import BOPTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPDS
else:
    import BOPDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TFunction
else:
    import TFunction
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TNaming
else:
    import TNaming
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepPrimAPI
else:
    import BRepPrimAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepPrim
else:
    import BRepPrim
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepSweep
else:
    import BRepSweep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Sweep
else:
    import Sweep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDataStd
else:
    import TDataStd
del _swig_python_version_info
class DNaming_RevolutionDriver(TFunction.TFunction_Driver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_RevolutionDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_RevolutionDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_RevolutionDriver self) -> DNaming_RevolutionDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_RevolutionDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_RevolutionDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_RevolutionDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_RevolutionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_RevolutionDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_RevolutionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_RevolutionDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_RevolutionDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_RevolutionDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_RevolutionDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_RevolutionDriver
DNaming_RevolutionDriver_swigregister = _DNaming.DNaming_RevolutionDriver_swigregister
DNaming_RevolutionDriver_swigregister(DNaming_RevolutionDriver)

def DNaming_RevolutionDriver_get_type_name(*args):
    """
    DNaming_RevolutionDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_RevolutionDriver_get_type_name(*args)

def DNaming_RevolutionDriver_get_type_descriptor(*args):
    """
    DNaming_RevolutionDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_RevolutionDriver_get_type_descriptor(*args)

class DNaming_SphereDriver(TFunction.TFunction_Driver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_SphereDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_SphereDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_SphereDriver self) -> DNaming_SphereDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_SphereDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_SphereDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_SphereDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_SphereDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_SphereDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_SphereDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_SphereDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_SphereDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_SphereDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_SphereDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_SphereDriver
DNaming_SphereDriver_swigregister = _DNaming.DNaming_SphereDriver_swigregister
DNaming_SphereDriver_swigregister(DNaming_SphereDriver)

def DNaming_SphereDriver_get_type_name(*args):
    """
    DNaming_SphereDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_SphereDriver_get_type_name(*args)

def DNaming_SphereDriver_get_type_descriptor(*args):
    """
    DNaming_SphereDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_SphereDriver_get_type_descriptor(*args)

class DNaming_BoxDriver(TFunction.TFunction_Driver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_BoxDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_BoxDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_BoxDriver self) -> DNaming_BoxDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_BoxDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_BoxDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_BoxDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_BoxDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_BoxDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_BoxDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_BoxDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_BoxDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_BoxDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_BoxDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_BoxDriver
DNaming_BoxDriver_swigregister = _DNaming.DNaming_BoxDriver_swigregister
DNaming_BoxDriver_swigregister(DNaming_BoxDriver)

def DNaming_BoxDriver_get_type_name(*args):
    """
    DNaming_BoxDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_BoxDriver_get_type_name(*args)

def DNaming_BoxDriver_get_type_descriptor(*args):
    """
    DNaming_BoxDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_BoxDriver_get_type_descriptor(*args)

class Handle_DNaming_RevolutionDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_RevolutionDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_RevolutionDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_RevolutionDriver self, DNaming_RevolutionDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_RevolutionDriver self, Handle_DNaming_RevolutionDriver theHandle) -> Handle_DNaming_RevolutionDriver
        assign(Handle_DNaming_RevolutionDriver self, DNaming_RevolutionDriver thePtr) -> Handle_DNaming_RevolutionDriver
        assign(Handle_DNaming_RevolutionDriver self, Handle_DNaming_RevolutionDriver theHandle) -> Handle_DNaming_RevolutionDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_RevolutionDriver self) -> DNaming_RevolutionDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_RevolutionDriver self) -> DNaming_RevolutionDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_RevolutionDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_RevolutionDriver self) -> DNaming_RevolutionDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_RevolutionDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_RevolutionDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_RevolutionDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_RevolutionDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_RevolutionDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_RevolutionDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_RevolutionDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_RevolutionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_RevolutionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_RevolutionDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_RevolutionDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_RevolutionDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_RevolutionDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_RevolutionDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_RevolutionDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_RevolutionDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_RevolutionDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_RevolutionDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_RevolutionDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_RevolutionDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_RevolutionDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_RevolutionDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_RevolutionDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_RevolutionDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_RevolutionDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_RevolutionDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_RevolutionDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_RevolutionDriver_DecrementRefCounter(self, *args)

Handle_DNaming_RevolutionDriver_swigregister = _DNaming.Handle_DNaming_RevolutionDriver_swigregister
Handle_DNaming_RevolutionDriver_swigregister(Handle_DNaming_RevolutionDriver)

def Handle_DNaming_RevolutionDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_RevolutionDriver_DownCast(thing)
Handle_DNaming_RevolutionDriver_DownCast = _DNaming.Handle_DNaming_RevolutionDriver_DownCast

class DNaming_CylinderDriver(TFunction.TFunction_Driver):
    """Computes Cylinder function"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_CylinderDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_CylinderDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_CylinderDriver self) -> DNaming_CylinderDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_CylinderDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_CylinderDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_CylinderDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_CylinderDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_CylinderDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_CylinderDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_CylinderDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_CylinderDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_CylinderDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_CylinderDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_CylinderDriver
DNaming_CylinderDriver_swigregister = _DNaming.DNaming_CylinderDriver_swigregister
DNaming_CylinderDriver_swigregister(DNaming_CylinderDriver)

def DNaming_CylinderDriver_get_type_name(*args):
    """
    DNaming_CylinderDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_CylinderDriver_get_type_name(*args)

def DNaming_CylinderDriver_get_type_descriptor(*args):
    """
    DNaming_CylinderDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_CylinderDriver_get_type_descriptor(*args)

class NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TCollection_AsciiString,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TCollection_AsciiString,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TCollection_AsciiString,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TCollection_AsciiString,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _DNaming.new_NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TCollection_AsciiString theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TCollection_AsciiString theItem) -> TCollection_AsciiString

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TCollection_AsciiString

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TCollection_AsciiString

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TCollection_AsciiString

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _DNaming.delete_NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_swigregister = _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _DNaming.new_NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _DNaming.delete_NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _DNaming.NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher_IteratorHelper)


try:
	DNaming_DataMapOfShapeOfName = NCollection_DataMap_TopoDS_Shape_TCollection_AsciiString_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class DNaming_PrismDriver(TFunction.TFunction_Driver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_PrismDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_PrismDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_PrismDriver self) -> DNaming_PrismDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_PrismDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_PrismDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_PrismDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_PrismDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_PrismDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_PrismDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_PrismDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_PrismDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_PrismDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_PrismDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_PrismDriver
DNaming_PrismDriver_swigregister = _DNaming.DNaming_PrismDriver_swigregister
DNaming_PrismDriver_swigregister(DNaming_PrismDriver)

def DNaming_PrismDriver_get_type_name(*args):
    """
    DNaming_PrismDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_PrismDriver_get_type_name(*args)

def DNaming_PrismDriver_get_type_descriptor(*args):
    """
    DNaming_PrismDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_PrismDriver_get_type_descriptor(*args)

class DNaming_(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetReal(*args):
        """
        GetReal(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_Real

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :type thePosition: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Real

        """
        return _DNaming.DNaming__GetReal(*args)

    GetReal = staticmethod(GetReal)

    def GetInteger(*args):
        """
        GetInteger(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_Integer

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :type thePosition: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Integer

        """
        return _DNaming.DNaming__GetInteger(*args)

    GetInteger = staticmethod(GetInteger)

    def GetString(*args):
        """
        GetString(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_Name

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :type thePosition: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Name

        """
        return _DNaming.DNaming__GetString(*args)

    GetString = staticmethod(GetString)

    def ComputeAxis(*args):
        """
        ComputeAxis(Handle_TNaming_NamedShape theNS, gp_Ax1 theAx1) -> Standard_Boolean

        :type theNS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
        :type theAx1: OCC.wrapper.gp.gp_Ax1
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming__ComputeAxis(*args)

    ComputeAxis = staticmethod(ComputeAxis)

    def GetFunctionResult(*args):
        """
        GetFunctionResult(Handle_TFunction_Function theFunction) -> Handle_TNaming_NamedShape

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _DNaming.DNaming__GetFunctionResult(*args)

    GetFunctionResult = staticmethod(GetFunctionResult)

    def GetObjectArg(*args):
        """
        GetObjectArg(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_UAttribute

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :type thePosition: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

        """
        return _DNaming.DNaming__GetObjectArg(*args)

    GetObjectArg = staticmethod(GetObjectArg)

    def SetObjectArg(*args):
        """
        SetObjectArg(Handle_TFunction_Function theFunction, Standard_Integer const thePosition, Handle_TDataStd_UAttribute theNewValue)

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :type thePosition: int
        :type theNewValue: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

        """
        return _DNaming.DNaming__SetObjectArg(*args)

    SetObjectArg = staticmethod(SetObjectArg)

    def GetObjectValue(*args):
        """
        GetObjectValue(Handle_TDataStd_UAttribute theObject) -> Handle_TNaming_NamedShape

        :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _DNaming.DNaming__GetObjectValue(*args)

    GetObjectValue = staticmethod(GetObjectValue)

    def GetLastFunction(*args):
        """
        GetLastFunction(Handle_TDataStd_UAttribute theObject) -> Handle_TFunction_Function

        :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

        """
        return _DNaming.DNaming__GetLastFunction(*args)

    GetLastFunction = staticmethod(GetLastFunction)

    def GetFirstFunction(*args):
        """
        GetFirstFunction(Handle_TDataStd_UAttribute theObject) -> Handle_TFunction_Function

        :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

        """
        return _DNaming.DNaming__GetFirstFunction(*args)

    GetFirstFunction = staticmethod(GetFirstFunction)

    def GetPrevFunction(*args):
        """
        GetPrevFunction(Handle_TFunction_Function theFunction) -> Handle_TFunction_Function

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

        """
        return _DNaming.DNaming__GetPrevFunction(*args)

    GetPrevFunction = staticmethod(GetPrevFunction)

    def GetObjectFromFunction(*args):
        """
        GetObjectFromFunction(Handle_TFunction_Function theFunction) -> Handle_TDataStd_UAttribute

        :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

        """
        return _DNaming.DNaming__GetObjectFromFunction(*args)

    GetObjectFromFunction = staticmethod(GetObjectFromFunction)

    def IsAttachment(*args):
        """
        IsAttachment(Handle_TDataStd_UAttribute theObject) -> Standard_Boolean

        :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming__IsAttachment(*args)

    IsAttachment = staticmethod(IsAttachment)

    def GetAttachmentsContext(*args):
        """
        GetAttachmentsContext(Handle_TDataStd_UAttribute theObject) -> Handle_TNaming_NamedShape

        :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
        :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

        """
        return _DNaming.DNaming__GetAttachmentsContext(*args)

    GetAttachmentsContext = staticmethod(GetAttachmentsContext)

    def ComputeSweepDir(*args):
        """
        ComputeSweepDir(TopoDS_Shape theShape, gp_Ax1 theAxis) -> Standard_Boolean

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theAxis: OCC.wrapper.gp.gp_Ax1
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming__ComputeSweepDir(*args)

    ComputeSweepDir = staticmethod(ComputeSweepDir)

    def LoadAndOrientModifiedShapes(*args):
        """
        LoadAndOrientModifiedShapes(BRepBuilderAPI_MakeShape MakeShape, TopoDS_Shape ShapeIn, TopAbs_ShapeEnum const GeneratedFrom, TNaming_Builder Buider, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher SubShapesOfResult)

        :type MakeShape: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_MakeShape
        :type ShapeIn: OCC.wrapper.TopoDS.TopoDS_Shape
        :type GeneratedFrom: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type Buider: OCC.wrapper.TNaming.TNaming_Builder
        :type SubShapesOfResult: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _DNaming.DNaming__LoadAndOrientModifiedShapes(*args)

    LoadAndOrientModifiedShapes = staticmethod(LoadAndOrientModifiedShapes)

    def LoadAndOrientGeneratedShapes(*args):
        """
        LoadAndOrientGeneratedShapes(BRepBuilderAPI_MakeShape MakeShape, TopoDS_Shape ShapeIn, TopAbs_ShapeEnum const GeneratedFrom, TNaming_Builder Buider, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher SubShapesOfResult)

        :type MakeShape: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_MakeShape
        :type ShapeIn: OCC.wrapper.TopoDS.TopoDS_Shape
        :type GeneratedFrom: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type Buider: OCC.wrapper.TNaming.TNaming_Builder
        :type SubShapesOfResult: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _DNaming.DNaming__LoadAndOrientGeneratedShapes(*args)

    LoadAndOrientGeneratedShapes = staticmethod(LoadAndOrientGeneratedShapes)

    def LoadDeletedShapes(*args):
        """
        LoadDeletedShapes(BRepBuilderAPI_MakeShape MakeShape, TopoDS_Shape ShapeIn, TopAbs_ShapeEnum const KindOfDeletedShape, TNaming_Builder Buider)

        :type MakeShape: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_MakeShape
        :type ShapeIn: OCC.wrapper.TopoDS.TopoDS_Shape
        :type KindOfDeletedShape: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type Buider: OCC.wrapper.TNaming.TNaming_Builder

        """
        return _DNaming.DNaming__LoadDeletedShapes(*args)

    LoadDeletedShapes = staticmethod(LoadDeletedShapes)

    def LoadResult(*args):
        """
        LoadResult(TDF_Label theLabel, BRepAlgoAPI_BooleanOperation MS)

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type MS: OCC.wrapper.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation

        """
        return _DNaming.DNaming__LoadResult(*args)

    LoadResult = staticmethod(LoadResult)

    def CurrentShape(*args):
        """
        CurrentShape(Standard_CString const ShapeEntry, Handle_TDF_Data Data) -> TopoDS_Shape

        :type ShapeEntry: OCC.wrapper.Standard.Standard_CString
        :type Data: OCC.wrapper.TDF.Handle_TDF_Data
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _DNaming.DNaming__CurrentShape(*args)

    CurrentShape = staticmethod(CurrentShape)

    def GetShape(*args):
        """
        GetShape(Standard_CString const ShapeEntry, Handle_TDF_Data Data, NCollection_List_TopoDS_Shape Shapes)

        :type ShapeEntry: OCC.wrapper.Standard.Standard_CString
        :type Data: OCC.wrapper.TDF.Handle_TDF_Data
        :type Shapes: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _DNaming.DNaming__GetShape(*args)

    GetShape = staticmethod(GetShape)

    def GetEntry(*args):
        """
        GetEntry(TopoDS_Shape Shape, Handle_TDF_Data Data) -> TCollection_AsciiString

        theStatus = 0  Not  found,
        theStatus = 1  One  shape,
        theStatus = 2  More than one shape.

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Data: OCC.wrapper.TDF.Handle_TDF_Data
        :type theStatus: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _DNaming.DNaming__GetEntry(*args)

    GetEntry = staticmethod(GetEntry)

    def LoadImportedShape(*args):
        """
        LoadImportedShape(TDF_Label theResultLabel, TopoDS_Shape theShape)

        Loads the Shape to DF

        :type theResultLabel: OCC.wrapper.TDF.TDF_Label
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _DNaming.DNaming__LoadImportedShape(*args)

    LoadImportedShape = staticmethod(LoadImportedShape)

    def LoadPrime(*args):
        """
        LoadPrime(TDF_Label theResultLabel, TopoDS_Shape theShape)

        Reloads sub-shapes of the Shape to DF

        :type theResultLabel: OCC.wrapper.TDF.TDF_Label
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _DNaming.DNaming__LoadPrime(*args)

    LoadPrime = staticmethod(LoadPrime)

    def AllCommands(*args):
        """
        AllCommands(Draw_Interpretor DI)

        :type DI: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _DNaming.DNaming__AllCommands(*args)

    AllCommands = staticmethod(AllCommands)

    def BasicCommands(*args):
        """
        BasicCommands(Draw_Interpretor DI)

        commands relatives to NamedShape

        :type DI: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _DNaming.DNaming__BasicCommands(*args)

    BasicCommands = staticmethod(BasicCommands)

    def ToolsCommands(*args):
        """
        ToolsCommands(Draw_Interpretor DI)

        :type DI: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _DNaming.DNaming__ToolsCommands(*args)

    ToolsCommands = staticmethod(ToolsCommands)

    def SelectionCommands(*args):
        """
        SelectionCommands(Draw_Interpretor DI)

        commands relatives to Naming

        :type DI: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _DNaming.DNaming__SelectionCommands(*args)

    SelectionCommands = staticmethod(SelectionCommands)

    def ModelingCommands(*args):
        """
        ModelingCommands(Draw_Interpretor DI)

        commands for  testing Naming

        :type DI: OCC.wrapper.Draw.Draw_Interpretor

        """
        return _DNaming.DNaming__ModelingCommands(*args)

    ModelingCommands = staticmethod(ModelingCommands)

    def __init__(self):
        this = _DNaming.new_DNaming_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _DNaming.delete_DNaming_
DNaming__swigregister = _DNaming.DNaming__swigregister
DNaming__swigregister(DNaming_)

def DNaming__GetReal(*args):
    """
    DNaming__GetReal(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_Real

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :type thePosition: int
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Real

    """
    return _DNaming.DNaming__GetReal(*args)

def DNaming__GetInteger(*args):
    """
    DNaming__GetInteger(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_Integer

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :type thePosition: int
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Integer

    """
    return _DNaming.DNaming__GetInteger(*args)

def DNaming__GetString(*args):
    """
    DNaming__GetString(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_Name

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :type thePosition: int
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Name

    """
    return _DNaming.DNaming__GetString(*args)

def DNaming__ComputeAxis(*args):
    """
    DNaming__ComputeAxis(Handle_TNaming_NamedShape theNS, gp_Ax1 theAx1) -> Standard_Boolean

    :type theNS: OCC.wrapper.TNaming.Handle_TNaming_NamedShape
    :type theAx1: OCC.wrapper.gp.gp_Ax1
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _DNaming.DNaming__ComputeAxis(*args)

def DNaming__GetFunctionResult(*args):
    """
    DNaming__GetFunctionResult(Handle_TFunction_Function theFunction) -> Handle_TNaming_NamedShape

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

    """
    return _DNaming.DNaming__GetFunctionResult(*args)

def DNaming__GetObjectArg(*args):
    """
    DNaming__GetObjectArg(Handle_TFunction_Function theFunction, Standard_Integer const thePosition) -> Handle_TDataStd_UAttribute

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :type thePosition: int
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

    """
    return _DNaming.DNaming__GetObjectArg(*args)

def DNaming__SetObjectArg(*args):
    """
    DNaming__SetObjectArg(Handle_TFunction_Function theFunction, Standard_Integer const thePosition, Handle_TDataStd_UAttribute theNewValue)

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :type thePosition: int
    :type theNewValue: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

    """
    return _DNaming.DNaming__SetObjectArg(*args)

def DNaming__GetObjectValue(*args):
    """
    DNaming__GetObjectValue(Handle_TDataStd_UAttribute theObject) -> Handle_TNaming_NamedShape

    :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
    :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

    """
    return _DNaming.DNaming__GetObjectValue(*args)

def DNaming__GetLastFunction(*args):
    """
    DNaming__GetLastFunction(Handle_TDataStd_UAttribute theObject) -> Handle_TFunction_Function

    :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
    :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

    """
    return _DNaming.DNaming__GetLastFunction(*args)

def DNaming__GetFirstFunction(*args):
    """
    DNaming__GetFirstFunction(Handle_TDataStd_UAttribute theObject) -> Handle_TFunction_Function

    :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
    :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

    """
    return _DNaming.DNaming__GetFirstFunction(*args)

def DNaming__GetPrevFunction(*args):
    """
    DNaming__GetPrevFunction(Handle_TFunction_Function theFunction) -> Handle_TFunction_Function

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

    """
    return _DNaming.DNaming__GetPrevFunction(*args)

def DNaming__GetObjectFromFunction(*args):
    """
    DNaming__GetObjectFromFunction(Handle_TFunction_Function theFunction) -> Handle_TDataStd_UAttribute

    :type theFunction: OCC.wrapper.TFunction.Handle_TFunction_Function
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

    """
    return _DNaming.DNaming__GetObjectFromFunction(*args)

def DNaming__IsAttachment(*args):
    """
    DNaming__IsAttachment(Handle_TDataStd_UAttribute theObject) -> Standard_Boolean

    :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _DNaming.DNaming__IsAttachment(*args)

def DNaming__GetAttachmentsContext(*args):
    """
    DNaming__GetAttachmentsContext(Handle_TDataStd_UAttribute theObject) -> Handle_TNaming_NamedShape

    :type theObject: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute
    :rtype: OCC.wrapper.TNaming.Handle_TNaming_NamedShape

    """
    return _DNaming.DNaming__GetAttachmentsContext(*args)

def DNaming__ComputeSweepDir(*args):
    """
    DNaming__ComputeSweepDir(TopoDS_Shape theShape, gp_Ax1 theAxis) -> Standard_Boolean

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theAxis: OCC.wrapper.gp.gp_Ax1
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _DNaming.DNaming__ComputeSweepDir(*args)

def DNaming__LoadAndOrientModifiedShapes(*args):
    """
    DNaming__LoadAndOrientModifiedShapes(BRepBuilderAPI_MakeShape MakeShape, TopoDS_Shape ShapeIn, TopAbs_ShapeEnum const GeneratedFrom, TNaming_Builder Buider, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher SubShapesOfResult)

    :type MakeShape: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_MakeShape
    :type ShapeIn: OCC.wrapper.TopoDS.TopoDS_Shape
    :type GeneratedFrom: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type Buider: OCC.wrapper.TNaming.TNaming_Builder
    :type SubShapesOfResult: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

    """
    return _DNaming.DNaming__LoadAndOrientModifiedShapes(*args)

def DNaming__LoadAndOrientGeneratedShapes(*args):
    """
    DNaming__LoadAndOrientGeneratedShapes(BRepBuilderAPI_MakeShape MakeShape, TopoDS_Shape ShapeIn, TopAbs_ShapeEnum const GeneratedFrom, TNaming_Builder Buider, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher SubShapesOfResult)

    :type MakeShape: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_MakeShape
    :type ShapeIn: OCC.wrapper.TopoDS.TopoDS_Shape
    :type GeneratedFrom: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type Buider: OCC.wrapper.TNaming.TNaming_Builder
    :type SubShapesOfResult: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

    """
    return _DNaming.DNaming__LoadAndOrientGeneratedShapes(*args)

def DNaming__LoadDeletedShapes(*args):
    """
    DNaming__LoadDeletedShapes(BRepBuilderAPI_MakeShape MakeShape, TopoDS_Shape ShapeIn, TopAbs_ShapeEnum const KindOfDeletedShape, TNaming_Builder Buider)

    :type MakeShape: OCC.wrapper.BRepBuilderAPI.BRepBuilderAPI_MakeShape
    :type ShapeIn: OCC.wrapper.TopoDS.TopoDS_Shape
    :type KindOfDeletedShape: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type Buider: OCC.wrapper.TNaming.TNaming_Builder

    """
    return _DNaming.DNaming__LoadDeletedShapes(*args)

def DNaming__LoadResult(*args):
    """
    DNaming__LoadResult(TDF_Label theLabel, BRepAlgoAPI_BooleanOperation MS)

    :type theLabel: OCC.wrapper.TDF.TDF_Label
    :type MS: OCC.wrapper.BRepAlgoAPI.BRepAlgoAPI_BooleanOperation

    """
    return _DNaming.DNaming__LoadResult(*args)

def DNaming__CurrentShape(*args):
    """
    DNaming__CurrentShape(Standard_CString const ShapeEntry, Handle_TDF_Data Data) -> TopoDS_Shape

    :type ShapeEntry: OCC.wrapper.Standard.Standard_CString
    :type Data: OCC.wrapper.TDF.Handle_TDF_Data
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _DNaming.DNaming__CurrentShape(*args)

def DNaming__GetShape(*args):
    """
    DNaming__GetShape(Standard_CString const ShapeEntry, Handle_TDF_Data Data, NCollection_List_TopoDS_Shape Shapes)

    :type ShapeEntry: OCC.wrapper.Standard.Standard_CString
    :type Data: OCC.wrapper.TDF.Handle_TDF_Data
    :type Shapes: OCC.wrapper.TopTools.TopTools_ListOfShape

    """
    return _DNaming.DNaming__GetShape(*args)

def DNaming__GetEntry(*args):
    """
    DNaming__GetEntry(TopoDS_Shape Shape, Handle_TDF_Data Data) -> TCollection_AsciiString

    theStatus = 0  Not  found,
    theStatus = 1  One  shape,
    theStatus = 2  More than one shape.

    :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Data: OCC.wrapper.TDF.Handle_TDF_Data
    :type theStatus: int
    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _DNaming.DNaming__GetEntry(*args)

def DNaming__LoadImportedShape(*args):
    """
    DNaming__LoadImportedShape(TDF_Label theResultLabel, TopoDS_Shape theShape)

    Loads the Shape to DF

    :type theResultLabel: OCC.wrapper.TDF.TDF_Label
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _DNaming.DNaming__LoadImportedShape(*args)

def DNaming__LoadPrime(*args):
    """
    DNaming__LoadPrime(TDF_Label theResultLabel, TopoDS_Shape theShape)

    Reloads sub-shapes of the Shape to DF

    :type theResultLabel: OCC.wrapper.TDF.TDF_Label
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _DNaming.DNaming__LoadPrime(*args)

def DNaming__AllCommands(*args):
    """
    DNaming__AllCommands(Draw_Interpretor DI)

    :type DI: OCC.wrapper.Draw.Draw_Interpretor

    """
    return _DNaming.DNaming__AllCommands(*args)

def DNaming__BasicCommands(*args):
    """
    DNaming__BasicCommands(Draw_Interpretor DI)

    commands relatives to NamedShape

    :type DI: OCC.wrapper.Draw.Draw_Interpretor

    """
    return _DNaming.DNaming__BasicCommands(*args)

def DNaming__ToolsCommands(*args):
    """
    DNaming__ToolsCommands(Draw_Interpretor DI)

    :type DI: OCC.wrapper.Draw.Draw_Interpretor

    """
    return _DNaming.DNaming__ToolsCommands(*args)

def DNaming__SelectionCommands(*args):
    """
    DNaming__SelectionCommands(Draw_Interpretor DI)

    commands relatives to Naming

    :type DI: OCC.wrapper.Draw.Draw_Interpretor

    """
    return _DNaming.DNaming__SelectionCommands(*args)

def DNaming__ModelingCommands(*args):
    """
    DNaming__ModelingCommands(Draw_Interpretor DI)

    commands for  testing Naming

    :type DI: OCC.wrapper.Draw.Draw_Interpretor

    """
    return _DNaming.DNaming__ModelingCommands(*args)

class DNaming_FilletDriver(TFunction.TFunction_Driver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_FilletDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_FilletDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_FilletDriver self) -> DNaming_FilletDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_FilletDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_FilletDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_FilletDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_FilletDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_FilletDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_FilletDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_FilletDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_FilletDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_FilletDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_FilletDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_FilletDriver
DNaming_FilletDriver_swigregister = _DNaming.DNaming_FilletDriver_swigregister
DNaming_FilletDriver_swigregister(DNaming_FilletDriver)

def DNaming_FilletDriver_get_type_name(*args):
    """
    DNaming_FilletDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_FilletDriver_get_type_name(*args)

def DNaming_FilletDriver_get_type_descriptor(*args):
    """
    DNaming_FilletDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_FilletDriver_get_type_descriptor(*args)

class Handle_DNaming_SphereDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_SphereDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_SphereDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_SphereDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_SphereDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_SphereDriver self, DNaming_SphereDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_SphereDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_SphereDriver self, Handle_DNaming_SphereDriver theHandle) -> Handle_DNaming_SphereDriver
        assign(Handle_DNaming_SphereDriver self, DNaming_SphereDriver thePtr) -> Handle_DNaming_SphereDriver
        assign(Handle_DNaming_SphereDriver self, Handle_DNaming_SphereDriver theHandle) -> Handle_DNaming_SphereDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_SphereDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_SphereDriver self) -> DNaming_SphereDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_SphereDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_SphereDriver self) -> DNaming_SphereDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_SphereDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_SphereDriver self) -> DNaming_SphereDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_SphereDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_SphereDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_SphereDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_SphereDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_SphereDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_SphereDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_SphereDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_SphereDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_SphereDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_SphereDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_SphereDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_SphereDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_SphereDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_SphereDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_SphereDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_SphereDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_SphereDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_SphereDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_SphereDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_SphereDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_SphereDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_SphereDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_SphereDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_SphereDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_SphereDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_SphereDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_SphereDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_SphereDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_SphereDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_SphereDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_SphereDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_SphereDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_SphereDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_SphereDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_SphereDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_SphereDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_SphereDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_SphereDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_SphereDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_SphereDriver_DecrementRefCounter(self, *args)

Handle_DNaming_SphereDriver_swigregister = _DNaming.Handle_DNaming_SphereDriver_swigregister
Handle_DNaming_SphereDriver_swigregister(Handle_DNaming_SphereDriver)

def Handle_DNaming_SphereDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_SphereDriver_DownCast(thing)
Handle_DNaming_SphereDriver_DownCast = _DNaming.Handle_DNaming_SphereDriver_DownCast

class DNaming_Line3DDriver(TFunction.TFunction_Driver):
    """Computes Line 3D function"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_Line3DDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_Line3DDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_Line3DDriver self) -> DNaming_Line3DDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_Line3DDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_Line3DDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_Line3DDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_Line3DDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_Line3DDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_Line3DDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_Line3DDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_Line3DDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_Line3DDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_Line3DDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_Line3DDriver
DNaming_Line3DDriver_swigregister = _DNaming.DNaming_Line3DDriver_swigregister
DNaming_Line3DDriver_swigregister(DNaming_Line3DDriver)

def DNaming_Line3DDriver_get_type_name(*args):
    """
    DNaming_Line3DDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_Line3DDriver_get_type_name(*args)

def DNaming_Line3DDriver_get_type_descriptor(*args):
    """
    DNaming_Line3DDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_Line3DDriver_get_type_descriptor(*args)

class DNaming_TransformationDriver(TFunction.TFunction_Driver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_TransformationDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_TransformationDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_TransformationDriver self) -> DNaming_TransformationDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_TransformationDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_TransformationDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_TransformationDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_TransformationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_TransformationDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_TransformationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_TransformationDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_TransformationDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_TransformationDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_TransformationDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_TransformationDriver
DNaming_TransformationDriver_swigregister = _DNaming.DNaming_TransformationDriver_swigregister
DNaming_TransformationDriver_swigregister(DNaming_TransformationDriver)

def DNaming_TransformationDriver_get_type_name(*args):
    """
    DNaming_TransformationDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_TransformationDriver_get_type_name(*args)

def DNaming_TransformationDriver_get_type_descriptor(*args):
    """
    DNaming_TransformationDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_TransformationDriver_get_type_descriptor(*args)

class Handle_DNaming_FilletDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_FilletDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_FilletDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_FilletDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_FilletDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_FilletDriver self, DNaming_FilletDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_FilletDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_FilletDriver self, Handle_DNaming_FilletDriver theHandle) -> Handle_DNaming_FilletDriver
        assign(Handle_DNaming_FilletDriver self, DNaming_FilletDriver thePtr) -> Handle_DNaming_FilletDriver
        assign(Handle_DNaming_FilletDriver self, Handle_DNaming_FilletDriver theHandle) -> Handle_DNaming_FilletDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_FilletDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_FilletDriver self) -> DNaming_FilletDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_FilletDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_FilletDriver self) -> DNaming_FilletDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_FilletDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_FilletDriver self) -> DNaming_FilletDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_FilletDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_FilletDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_FilletDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_FilletDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_FilletDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_FilletDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_FilletDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_FilletDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_FilletDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_FilletDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_FilletDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_FilletDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_FilletDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_FilletDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_FilletDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_FilletDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_FilletDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_FilletDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_FilletDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_FilletDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_FilletDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_FilletDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_FilletDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_FilletDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_FilletDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_FilletDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_FilletDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_FilletDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_FilletDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_FilletDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_FilletDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_FilletDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_FilletDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_FilletDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_FilletDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_FilletDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_FilletDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_FilletDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_FilletDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_FilletDriver_DecrementRefCounter(self, *args)

Handle_DNaming_FilletDriver_swigregister = _DNaming.Handle_DNaming_FilletDriver_swigregister
Handle_DNaming_FilletDriver_swigregister(Handle_DNaming_FilletDriver)

def Handle_DNaming_FilletDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_FilletDriver_DownCast(thing)
Handle_DNaming_FilletDriver_DownCast = _DNaming.Handle_DNaming_FilletDriver_DownCast

class DNaming_PointDriver(TFunction.TFunction_Driver):
    """Driver for PointXYZ  and  RelativePoint"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_PointDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_PointDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_PointDriver self) -> DNaming_PointDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_PointDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_PointDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_PointDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_PointDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_PointDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_PointDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_PointDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_PointDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_PointDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_PointDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_PointDriver
DNaming_PointDriver_swigregister = _DNaming.DNaming_PointDriver_swigregister
DNaming_PointDriver_swigregister(DNaming_PointDriver)

def DNaming_PointDriver_get_type_name(*args):
    """
    DNaming_PointDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_PointDriver_get_type_name(*args)

def DNaming_PointDriver_get_type_descriptor(*args):
    """
    DNaming_PointDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_PointDriver_get_type_descriptor(*args)

class DNaming_BooleanOperationDriver(TFunction.TFunction_Driver):
    """Driver  for Fuse,  Cut,  Common"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_BooleanOperationDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_BooleanOperationDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_BooleanOperationDriver self) -> DNaming_BooleanOperationDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_BooleanOperationDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_BooleanOperationDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_BooleanOperationDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_BooleanOperationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_BooleanOperationDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_BooleanOperationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_BooleanOperationDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_BooleanOperationDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_BooleanOperationDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_BooleanOperationDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_BooleanOperationDriver
DNaming_BooleanOperationDriver_swigregister = _DNaming.DNaming_BooleanOperationDriver_swigregister
DNaming_BooleanOperationDriver_swigregister(DNaming_BooleanOperationDriver)

def DNaming_BooleanOperationDriver_get_type_name(*args):
    """
    DNaming_BooleanOperationDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_BooleanOperationDriver_get_type_name(*args)

def DNaming_BooleanOperationDriver_get_type_descriptor(*args):
    """
    DNaming_BooleanOperationDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_BooleanOperationDriver_get_type_descriptor(*args)

class DNaming_SelectionDriver(TFunction.TFunction_Driver):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_DNaming_SelectionDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_DNaming_SelectionDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(DNaming_SelectionDriver self) -> DNaming_SelectionDriver

        Constructor
        validation
        ==========


        """
        this = _DNaming.new_DNaming_SelectionDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Validate(self, *args):
        """
        Validate(DNaming_SelectionDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.DNaming_SelectionDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(DNaming_SelectionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.DNaming_SelectionDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(DNaming_SelectionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.DNaming_SelectionDriver_Execute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _DNaming.DNaming_SelectionDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _DNaming.DNaming_SelectionDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.DNaming_SelectionDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _DNaming.delete_DNaming_SelectionDriver
DNaming_SelectionDriver_swigregister = _DNaming.DNaming_SelectionDriver_swigregister
DNaming_SelectionDriver_swigregister(DNaming_SelectionDriver)

def DNaming_SelectionDriver_get_type_name(*args):
    """
    DNaming_SelectionDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _DNaming.DNaming_SelectionDriver_get_type_name(*args)

def DNaming_SelectionDriver_get_type_descriptor(*args):
    """
    DNaming_SelectionDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _DNaming.DNaming_SelectionDriver_get_type_descriptor(*args)

class Handle_DNaming_BoxDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_BoxDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_BoxDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_BoxDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_BoxDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_BoxDriver self, DNaming_BoxDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_BoxDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_BoxDriver self, Handle_DNaming_BoxDriver theHandle) -> Handle_DNaming_BoxDriver
        assign(Handle_DNaming_BoxDriver self, DNaming_BoxDriver thePtr) -> Handle_DNaming_BoxDriver
        assign(Handle_DNaming_BoxDriver self, Handle_DNaming_BoxDriver theHandle) -> Handle_DNaming_BoxDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_BoxDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_BoxDriver self) -> DNaming_BoxDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_BoxDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_BoxDriver self) -> DNaming_BoxDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_BoxDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_BoxDriver self) -> DNaming_BoxDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_BoxDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_BoxDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_BoxDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_BoxDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_BoxDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_BoxDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_BoxDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_BoxDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_BoxDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_BoxDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_BoxDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_BoxDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_BoxDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_BoxDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_BoxDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_BoxDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_BoxDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_BoxDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_BoxDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_BoxDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_BoxDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_BoxDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_BoxDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_BoxDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_BoxDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_BoxDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_BoxDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_BoxDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_BoxDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_BoxDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_BoxDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_BoxDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_BoxDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_BoxDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_BoxDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_BoxDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_BoxDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_BoxDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_BoxDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_BoxDriver_DecrementRefCounter(self, *args)

Handle_DNaming_BoxDriver_swigregister = _DNaming.Handle_DNaming_BoxDriver_swigregister
Handle_DNaming_BoxDriver_swigregister(Handle_DNaming_BoxDriver)

def Handle_DNaming_BoxDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_BoxDriver_DownCast(thing)
Handle_DNaming_BoxDriver_DownCast = _DNaming.Handle_DNaming_BoxDriver_DownCast

class Handle_DNaming_PointDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_PointDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_PointDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_PointDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_PointDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_PointDriver self, DNaming_PointDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_PointDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_PointDriver self, Handle_DNaming_PointDriver theHandle) -> Handle_DNaming_PointDriver
        assign(Handle_DNaming_PointDriver self, DNaming_PointDriver thePtr) -> Handle_DNaming_PointDriver
        assign(Handle_DNaming_PointDriver self, Handle_DNaming_PointDriver theHandle) -> Handle_DNaming_PointDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_PointDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_PointDriver self) -> DNaming_PointDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_PointDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_PointDriver self) -> DNaming_PointDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_PointDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_PointDriver self) -> DNaming_PointDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_PointDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_PointDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_PointDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_PointDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_PointDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_PointDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_PointDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_PointDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_PointDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_PointDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_PointDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_PointDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_PointDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_PointDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_PointDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_PointDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_PointDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_PointDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_PointDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_PointDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_PointDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_PointDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_PointDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_PointDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_PointDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_PointDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_PointDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_PointDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_PointDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_PointDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_PointDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_PointDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_PointDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_PointDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_PointDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_PointDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_PointDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_PointDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_PointDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_PointDriver_DecrementRefCounter(self, *args)

Handle_DNaming_PointDriver_swigregister = _DNaming.Handle_DNaming_PointDriver_swigregister
Handle_DNaming_PointDriver_swigregister(Handle_DNaming_PointDriver)

def Handle_DNaming_PointDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_PointDriver_DownCast(thing)
Handle_DNaming_PointDriver_DownCast = _DNaming.Handle_DNaming_PointDriver_DownCast

class Handle_DNaming_PrismDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_PrismDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_PrismDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_PrismDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_PrismDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_PrismDriver self, DNaming_PrismDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_PrismDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_PrismDriver self, Handle_DNaming_PrismDriver theHandle) -> Handle_DNaming_PrismDriver
        assign(Handle_DNaming_PrismDriver self, DNaming_PrismDriver thePtr) -> Handle_DNaming_PrismDriver
        assign(Handle_DNaming_PrismDriver self, Handle_DNaming_PrismDriver theHandle) -> Handle_DNaming_PrismDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_PrismDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_PrismDriver self) -> DNaming_PrismDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_PrismDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_PrismDriver self) -> DNaming_PrismDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_PrismDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_PrismDriver self) -> DNaming_PrismDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_PrismDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_PrismDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_PrismDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_PrismDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_PrismDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_PrismDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_PrismDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_PrismDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_PrismDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_PrismDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_PrismDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_PrismDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_PrismDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_PrismDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_PrismDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_PrismDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_PrismDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_PrismDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_PrismDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_PrismDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_PrismDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_PrismDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_PrismDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_PrismDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_PrismDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_PrismDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_PrismDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_PrismDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_PrismDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_PrismDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_PrismDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_PrismDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_PrismDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_PrismDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_PrismDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_PrismDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_PrismDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_PrismDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_PrismDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_PrismDriver_DecrementRefCounter(self, *args)

Handle_DNaming_PrismDriver_swigregister = _DNaming.Handle_DNaming_PrismDriver_swigregister
Handle_DNaming_PrismDriver_swigregister(Handle_DNaming_PrismDriver)

def Handle_DNaming_PrismDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_PrismDriver_DownCast(thing)
Handle_DNaming_PrismDriver_DownCast = _DNaming.Handle_DNaming_PrismDriver_DownCast

class Handle_DNaming_BooleanOperationDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_BooleanOperationDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_BooleanOperationDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_BooleanOperationDriver self, DNaming_BooleanOperationDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_BooleanOperationDriver self, Handle_DNaming_BooleanOperationDriver theHandle) -> Handle_DNaming_BooleanOperationDriver
        assign(Handle_DNaming_BooleanOperationDriver self, DNaming_BooleanOperationDriver thePtr) -> Handle_DNaming_BooleanOperationDriver
        assign(Handle_DNaming_BooleanOperationDriver self, Handle_DNaming_BooleanOperationDriver theHandle) -> Handle_DNaming_BooleanOperationDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_BooleanOperationDriver self) -> DNaming_BooleanOperationDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_BooleanOperationDriver self) -> DNaming_BooleanOperationDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_BooleanOperationDriver self) -> DNaming_BooleanOperationDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_BooleanOperationDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_BooleanOperationDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_BooleanOperationDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_BooleanOperationDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_BooleanOperationDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_BooleanOperationDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_BooleanOperationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_BooleanOperationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_BooleanOperationDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_BooleanOperationDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_BooleanOperationDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_BooleanOperationDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_BooleanOperationDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_BooleanOperationDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_BooleanOperationDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_BooleanOperationDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_BooleanOperationDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_BooleanOperationDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_BooleanOperationDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_BooleanOperationDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_BooleanOperationDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_BooleanOperationDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_BooleanOperationDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_BooleanOperationDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_BooleanOperationDriver_DecrementRefCounter(self, *args)

Handle_DNaming_BooleanOperationDriver_swigregister = _DNaming.Handle_DNaming_BooleanOperationDriver_swigregister
Handle_DNaming_BooleanOperationDriver_swigregister(Handle_DNaming_BooleanOperationDriver)

def Handle_DNaming_BooleanOperationDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_BooleanOperationDriver_DownCast(thing)
Handle_DNaming_BooleanOperationDriver_DownCast = _DNaming.Handle_DNaming_BooleanOperationDriver_DownCast

class Handle_DNaming_CylinderDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_CylinderDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_CylinderDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_CylinderDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_CylinderDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_CylinderDriver self, DNaming_CylinderDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_CylinderDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_CylinderDriver self, Handle_DNaming_CylinderDriver theHandle) -> Handle_DNaming_CylinderDriver
        assign(Handle_DNaming_CylinderDriver self, DNaming_CylinderDriver thePtr) -> Handle_DNaming_CylinderDriver
        assign(Handle_DNaming_CylinderDriver self, Handle_DNaming_CylinderDriver theHandle) -> Handle_DNaming_CylinderDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_CylinderDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_CylinderDriver self) -> DNaming_CylinderDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_CylinderDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_CylinderDriver self) -> DNaming_CylinderDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_CylinderDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_CylinderDriver self) -> DNaming_CylinderDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_CylinderDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_CylinderDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_CylinderDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_CylinderDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_CylinderDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_CylinderDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_CylinderDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_CylinderDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_CylinderDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_CylinderDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_CylinderDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_CylinderDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_CylinderDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_CylinderDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_CylinderDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_CylinderDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_CylinderDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_CylinderDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_CylinderDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_CylinderDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_CylinderDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_CylinderDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_CylinderDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_CylinderDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_CylinderDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_CylinderDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_CylinderDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_CylinderDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_CylinderDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_CylinderDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_CylinderDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_CylinderDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_CylinderDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_CylinderDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_CylinderDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_CylinderDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_CylinderDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_CylinderDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_CylinderDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_CylinderDriver_DecrementRefCounter(self, *args)

Handle_DNaming_CylinderDriver_swigregister = _DNaming.Handle_DNaming_CylinderDriver_swigregister
Handle_DNaming_CylinderDriver_swigregister(Handle_DNaming_CylinderDriver)

def Handle_DNaming_CylinderDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_CylinderDriver_DownCast(thing)
Handle_DNaming_CylinderDriver_DownCast = _DNaming.Handle_DNaming_CylinderDriver_DownCast

class Handle_DNaming_SelectionDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_SelectionDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_SelectionDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_SelectionDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_SelectionDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_SelectionDriver self, DNaming_SelectionDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_SelectionDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_SelectionDriver self, Handle_DNaming_SelectionDriver theHandle) -> Handle_DNaming_SelectionDriver
        assign(Handle_DNaming_SelectionDriver self, DNaming_SelectionDriver thePtr) -> Handle_DNaming_SelectionDriver
        assign(Handle_DNaming_SelectionDriver self, Handle_DNaming_SelectionDriver theHandle) -> Handle_DNaming_SelectionDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_SelectionDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_SelectionDriver self) -> DNaming_SelectionDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_SelectionDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_SelectionDriver self) -> DNaming_SelectionDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_SelectionDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_SelectionDriver self) -> DNaming_SelectionDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_SelectionDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_SelectionDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_SelectionDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_SelectionDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_SelectionDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_SelectionDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_SelectionDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_SelectionDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_SelectionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_SelectionDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_SelectionDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_SelectionDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_SelectionDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_SelectionDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_SelectionDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_SelectionDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_SelectionDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_SelectionDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_SelectionDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_SelectionDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_SelectionDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_SelectionDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_SelectionDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_SelectionDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_SelectionDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_SelectionDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_SelectionDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_SelectionDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_SelectionDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_SelectionDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_SelectionDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_SelectionDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_SelectionDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_SelectionDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_SelectionDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_SelectionDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_SelectionDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_SelectionDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_SelectionDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_SelectionDriver_DecrementRefCounter(self, *args)

Handle_DNaming_SelectionDriver_swigregister = _DNaming.Handle_DNaming_SelectionDriver_swigregister
Handle_DNaming_SelectionDriver_swigregister(Handle_DNaming_SelectionDriver)

def Handle_DNaming_SelectionDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_SelectionDriver_DownCast(thing)
Handle_DNaming_SelectionDriver_DownCast = _DNaming.Handle_DNaming_SelectionDriver_DownCast

class Handle_DNaming_TransformationDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_TransformationDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_TransformationDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_TransformationDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_TransformationDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_TransformationDriver self, DNaming_TransformationDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_TransformationDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_TransformationDriver self, Handle_DNaming_TransformationDriver theHandle) -> Handle_DNaming_TransformationDriver
        assign(Handle_DNaming_TransformationDriver self, DNaming_TransformationDriver thePtr) -> Handle_DNaming_TransformationDriver
        assign(Handle_DNaming_TransformationDriver self, Handle_DNaming_TransformationDriver theHandle) -> Handle_DNaming_TransformationDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_TransformationDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_TransformationDriver self) -> DNaming_TransformationDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_TransformationDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_TransformationDriver self) -> DNaming_TransformationDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_TransformationDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_TransformationDriver self) -> DNaming_TransformationDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_TransformationDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_TransformationDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_TransformationDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_TransformationDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_TransformationDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_TransformationDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_TransformationDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_TransformationDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_TransformationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_TransformationDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_TransformationDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_TransformationDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_TransformationDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_TransformationDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_TransformationDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_TransformationDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_TransformationDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_TransformationDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_TransformationDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_TransformationDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_TransformationDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_TransformationDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_TransformationDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_TransformationDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_TransformationDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_TransformationDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_TransformationDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_TransformationDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_TransformationDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_TransformationDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_TransformationDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_TransformationDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_TransformationDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_TransformationDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_TransformationDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_TransformationDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_TransformationDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_TransformationDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_TransformationDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_TransformationDriver_DecrementRefCounter(self, *args)

Handle_DNaming_TransformationDriver_swigregister = _DNaming.Handle_DNaming_TransformationDriver_swigregister
Handle_DNaming_TransformationDriver_swigregister(Handle_DNaming_TransformationDriver)

def Handle_DNaming_TransformationDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_TransformationDriver_DownCast(thing)
Handle_DNaming_TransformationDriver_DownCast = _DNaming.Handle_DNaming_TransformationDriver_DownCast

class Handle_DNaming_Line3DDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_DNaming_Line3DDriver self)

        Nullify the handle


        """
        return _DNaming.Handle_DNaming_Line3DDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_DNaming_Line3DDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _DNaming.Handle_DNaming_Line3DDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_DNaming_Line3DDriver self, DNaming_Line3DDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _DNaming.Handle_DNaming_Line3DDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_DNaming_Line3DDriver self, Handle_DNaming_Line3DDriver theHandle) -> Handle_DNaming_Line3DDriver
        assign(Handle_DNaming_Line3DDriver self, DNaming_Line3DDriver thePtr) -> Handle_DNaming_Line3DDriver
        assign(Handle_DNaming_Line3DDriver self, Handle_DNaming_Line3DDriver theHandle) -> Handle_DNaming_Line3DDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _DNaming.Handle_DNaming_Line3DDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_DNaming_Line3DDriver self) -> DNaming_Line3DDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_Line3DDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_DNaming_Line3DDriver self) -> DNaming_Line3DDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _DNaming.Handle_DNaming_Line3DDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_DNaming_Line3DDriver self) -> DNaming_Line3DDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _DNaming.Handle_DNaming_Line3DDriver___ref__(self, *args)


    def __hash__(self):
        return _DNaming.Handle_DNaming_Line3DDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _DNaming.Handle_DNaming_Line3DDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _DNaming.new_Handle_DNaming_Line3DDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_DNaming.Handle_DNaming_Line3DDriver_DownCast)
    __swig_destroy__ = _DNaming.delete_Handle_DNaming_Line3DDriver

    def Validate(self, *args):
        """
        Validate(Handle_DNaming_Line3DDriver self, Handle_TFunction_Logbook theLog)

        Validates labels of a function in <log>.
        In regeneration mode this method must be called (by the
        solver) even if the function is not executed, to build
        the valid label scope.
        execution of function
        ======================

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _DNaming.Handle_DNaming_Line3DDriver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_DNaming_Line3DDriver self, Handle_TFunction_Logbook theLog) -> Standard_Boolean

        Analyse in <log> if the loaded function must be executed
        (i.e.arguments are modified) or not.
        If the Function label itself is modified, the function must
        be executed.

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_Line3DDriver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_DNaming_Line3DDriver self, Handle_TFunction_Logbook theLog) -> Standard_Integer

        Execute the function and push in <log> the impacted
        labels (see method SetImpacted).

        :type theLog: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_Line3DDriver_Execute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_DNaming_Line3DDriver self) -> char const *

        :rtype: const char *

        """
        return _DNaming.Handle_DNaming_Line3DDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_Line3DDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _DNaming.Handle_DNaming_Line3DDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_DNaming_Line3DDriver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_Line3DDriver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_DNaming_Line3DDriver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _DNaming.Handle_DNaming_Line3DDriver_Label(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_DNaming_Line3DDriver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_Line3DDriver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_DNaming_Line3DDriver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _DNaming.Handle_DNaming_Line3DDriver_Results(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_DNaming_Line3DDriver self)

        Memory deallocator for transient classes


        """
        return _DNaming.Handle_DNaming_Line3DDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_DNaming_Line3DDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_DNaming_Line3DDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_Line3DDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_DNaming_Line3DDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_DNaming_Line3DDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _DNaming.Handle_DNaming_Line3DDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_DNaming_Line3DDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _DNaming.Handle_DNaming_Line3DDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_DNaming_Line3DDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_Line3DDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_DNaming_Line3DDriver self)

        Increments the reference counter of this object


        """
        return _DNaming.Handle_DNaming_Line3DDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_DNaming_Line3DDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _DNaming.Handle_DNaming_Line3DDriver_DecrementRefCounter(self, *args)

Handle_DNaming_Line3DDriver_swigregister = _DNaming.Handle_DNaming_Line3DDriver_swigregister
Handle_DNaming_Line3DDriver_swigregister(Handle_DNaming_Line3DDriver)

def Handle_DNaming_Line3DDriver_DownCast(thing):
    return _DNaming.Handle_DNaming_Line3DDriver_DownCast(thing)
Handle_DNaming_Line3DDriver_DownCast = _DNaming.Handle_DNaming_Line3DDriver_DownCast




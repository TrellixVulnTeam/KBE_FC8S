# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_LProp3d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_LProp3d')
    _LProp3d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_LProp3d', [dirname(__file__)])
        except ImportError:
            import _LProp3d
            return _LProp3d
        try:
            _mod = imp.load_module('_LProp3d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _LProp3d = swig_import_helper()
    del swig_import_helper
else:
    import _LProp3d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _LProp3d.delete_SwigPyIterator

    def value(self):
        return _LProp3d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _LProp3d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _LProp3d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _LProp3d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _LProp3d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _LProp3d.SwigPyIterator_copy(self)

    def next(self):
        return _LProp3d.SwigPyIterator_next(self)

    def __next__(self):
        return _LProp3d.SwigPyIterator___next__(self)

    def previous(self):
        return _LProp3d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _LProp3d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _LProp3d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _LProp3d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _LProp3d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _LProp3d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _LProp3d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _LProp3d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _LProp3d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _LProp3d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_LProp3d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _LProp3d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _LProp3d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LProp3d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _LProp3d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _LProp3d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _LProp3d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _LProp3d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_LProp3d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _LProp3d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _LProp3d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LProp3d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _LProp3d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _LProp3d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _LProp3d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _LProp3d.ptr_to_number(item)
ptr_to_number = _LProp3d.ptr_to_number

def HashCode(*args):
    return _LProp3d.HashCode(*args)
HashCode = _LProp3d.HashCode

def ptr_equal(a, b):
    return _LProp3d.ptr_equal(a, b)
ptr_equal = _LProp3d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
class LProp3d_CLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LProp3d_CLProps self, Handle_Adaptor3d_HCurve C, Standard_Integer const N, Standard_Real const Resolution) -> LProp3d_CLProps
        __init__(LProp3d_CLProps self, Handle_Adaptor3d_HCurve C, Standard_Real const U, Standard_Integer const N, Standard_Real const Resolution) -> LProp3d_CLProps
        __init__(LProp3d_CLProps self, Standard_Integer const N, Standard_Real const Resolution) -> LProp3d_CLProps

        Same as previous constructor but here the parameter is
        set to the value <U> and the curve is set
        with SetCurve.
        the curve can have a empty constructor
        All the computations done will be related to <C> and <U>
        when the functions "set" will be done.

        :type N: int
        :type Resolution: float

        """
        this = _LProp3d.new_LProp3d_CLProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParameter(self, *args):
        """
        SetParameter(LProp3d_CLProps self, Standard_Real const U)

        Initializes the local properties of the curve
        for the parameter value <U>.

        :type U: float

        """
        return _LProp3d.LProp3d_CLProps_SetParameter(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(LProp3d_CLProps self, Handle_Adaptor3d_HCurve C)

        Initializes the local properties of the curve
        for the new curve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _LProp3d.LProp3d_CLProps_SetCurve(self, *args)


    def Value(self, *args):
        """
        Returns the Point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _LProp3d.LProp3d_CLProps_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1(self, *args):
        """
        Returns the first derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_CLProps_D1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D2(self, *args):
        """
        Returns the second derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_CLProps_D2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D3(self, *args):
        """
        Returns the third derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_CLProps_D3(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentDefined(self, *args):
        """
        IsTangentDefined(LProp3d_CLProps self) -> Standard_Boolean

        Returns True if the tangent is defined.
        For example, the tangent is not defined if the
        three first derivatives are all null.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LProp3d.LProp3d_CLProps_IsTangentDefined(self, *args)


    def Tangent(self, *args):
        """
        Tangent(LProp3d_CLProps self, gp_Dir D)

        output  the tangent direction <D>

        :type D: OCC.wrapper.gp.gp_Dir

        """
        return _LProp3d.LProp3d_CLProps_Tangent(self, *args)


    def Curvature(self, *args):
        """
        Curvature(LProp3d_CLProps self) -> Standard_Real

        Returns the curvature.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LProp3d.LProp3d_CLProps_Curvature(self, *args)


    def Normal(self, *args):
        """
        Normal(LProp3d_CLProps self, gp_Dir N)

        Returns the normal direction <N>.

        :type N: OCC.wrapper.gp.gp_Dir

        """
        return _LProp3d.LProp3d_CLProps_Normal(self, *args)


    def CentreOfCurvature(self, *args):
        """
        CentreOfCurvature(LProp3d_CLProps self, gp_Pnt P)

        Returns the centre of curvature <P>.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _LProp3d.LProp3d_CLProps_CentreOfCurvature(self, *args)

    __swig_destroy__ = _LProp3d.delete_LProp3d_CLProps
LProp3d_CLProps_swigregister = _LProp3d.LProp3d_CLProps_swigregister
LProp3d_CLProps_swigregister(LProp3d_CLProps)

class LProp3d_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        Value(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P)

        Computes the point <P> of parameter <U> on the HCurve <C>.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _LProp3d.LProp3d_CurveTool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Computes the point <P> and first derivative <V1> of
        parameter <U> on the HCurve <C>.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _LProp3d.LProp3d_CurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Computes the point <P>, the first derivative <V1> and second
        derivative <V2> of parameter <U> on the HCurve <C>.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _LProp3d.LProp3d_CurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Computes the point <P>, the first derivative <V1>, the
        second derivative <V2> and third derivative <V3> of
        parameter <U> on the HCurve <C>.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _LProp3d.LProp3d_CurveTool_D3(*args)

    D3 = staticmethod(D3)

    def Continuity(*args):
        """
        Continuity(Handle_Adaptor3d_HCurve C) -> Standard_Integer

        returns the order of continuity of the HCurve <C>.
        returns 1 : first derivative only is computable
        returns 2 : first and second derivative only are computable.
        returns 3 : first, second and third are computable.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LProp3d.LProp3d_CurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def FirstParameter(*args):
        """
        FirstParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

        returns the first parameter bound of the HCurve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LProp3d.LProp3d_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

        returns the last parameter bound of the HCurve.
        FirstParameter must be less than LastParamenter.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LProp3d.LProp3d_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def __init__(self):
        this = _LProp3d.new_LProp3d_CurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LProp3d.delete_LProp3d_CurveTool
LProp3d_CurveTool_swigregister = _LProp3d.LProp3d_CurveTool_swigregister
LProp3d_CurveTool_swigregister(LProp3d_CurveTool)

def LProp3d_CurveTool_Value(*args):
    """
    LProp3d_CurveTool_Value(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P)

    Computes the point <P> of parameter <U> on the HCurve <C>.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _LProp3d.LProp3d_CurveTool_Value(*args)

def LProp3d_CurveTool_D1(*args):
    """
    LProp3d_CurveTool_D1(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1)

    Computes the point <P> and first derivative <V1> of
    parameter <U> on the HCurve <C>.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec

    """
    return _LProp3d.LProp3d_CurveTool_D1(*args)

def LProp3d_CurveTool_D2(*args):
    """
    LProp3d_CurveTool_D2(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

    Computes the point <P>, the first derivative <V1> and second
    derivative <V2> of parameter <U> on the HCurve <C>.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec

    """
    return _LProp3d.LProp3d_CurveTool_D2(*args)

def LProp3d_CurveTool_D3(*args):
    """
    LProp3d_CurveTool_D3(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

    Computes the point <P>, the first derivative <V1>, the
    second derivative <V2> and third derivative <V3> of
    parameter <U> on the HCurve <C>.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec
    :type V3: OCC.wrapper.gp.gp_Vec

    """
    return _LProp3d.LProp3d_CurveTool_D3(*args)

def LProp3d_CurveTool_Continuity(*args):
    """
    LProp3d_CurveTool_Continuity(Handle_Adaptor3d_HCurve C) -> Standard_Integer

    returns the order of continuity of the HCurve <C>.
    returns 1 : first derivative only is computable
    returns 2 : first and second derivative only are computable.
    returns 3 : first, second and third are computable.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _LProp3d.LProp3d_CurveTool_Continuity(*args)

def LProp3d_CurveTool_FirstParameter(*args):
    """
    LProp3d_CurveTool_FirstParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

    returns the first parameter bound of the HCurve.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _LProp3d.LProp3d_CurveTool_FirstParameter(*args)

def LProp3d_CurveTool_LastParameter(*args):
    """
    LProp3d_CurveTool_LastParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

    returns the last parameter bound of the HCurve.
    FirstParameter must be less than LastParamenter.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _LProp3d.LProp3d_CurveTool_LastParameter(*args)

class LProp3d_SurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        Value(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P)

        Computes the point <P> of parameter <U> and <V> on the
        HSurface <S>.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _LProp3d.LProp3d_SurfaceTool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

        Computes the point <P> and first derivative <D1*> of
        parameter <U> and <V> on the HSurface <S>.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec

        """
        return _LProp3d.LProp3d_SurfaceTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec DUV)

        Computes the point <P>, the first derivative <D1*> and second
        derivative <D2*> of parameter <U> and <V> on the HSurface <S>.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type D1U: OCC.wrapper.gp.gp_Vec
        :type D1V: OCC.wrapper.gp.gp_Vec
        :type D2U: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type DUV: OCC.wrapper.gp.gp_Vec

        """
        return _LProp3d.LProp3d_SurfaceTool_D2(*args)

    D2 = staticmethod(D2)

    def DN(*args):
        """
        DN(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, Standard_Integer const IU, Standard_Integer const IV) -> gp_Vec

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U: float
        :type V: float
        :type IU: int
        :type IV: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _LProp3d.LProp3d_SurfaceTool_DN(*args)

    DN = staticmethod(DN)

    def Continuity(*args):
        """
        Continuity(Handle_Adaptor3d_HSurface S) -> Standard_Integer

        returns the order of continuity of the HSurface <S>.
        returns 1 : first derivative only is computable
        returns 2 : first and second derivative only are computable.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _LProp3d.LProp3d_SurfaceTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def Bounds(*args):
        """
        Bounds(Handle_Adaptor3d_HSurface S)

        returns the bounds of the HSurface.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _LProp3d.LProp3d_SurfaceTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def __init__(self):
        this = _LProp3d.new_LProp3d_SurfaceTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LProp3d.delete_LProp3d_SurfaceTool
LProp3d_SurfaceTool_swigregister = _LProp3d.LProp3d_SurfaceTool_swigregister
LProp3d_SurfaceTool_swigregister(LProp3d_SurfaceTool)

def LProp3d_SurfaceTool_Value(*args):
    """
    LProp3d_SurfaceTool_Value(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P)

    Computes the point <P> of parameter <U> and <V> on the
    HSurface <S>.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _LProp3d.LProp3d_SurfaceTool_Value(*args)

def LProp3d_SurfaceTool_D1(*args):
    """
    LProp3d_SurfaceTool_D1(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V)

    Computes the point <P> and first derivative <D1*> of
    parameter <U> and <V> on the HSurface <S>.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec

    """
    return _LProp3d.LProp3d_SurfaceTool_D1(*args)

def LProp3d_SurfaceTool_D2(*args):
    """
    LProp3d_SurfaceTool_D2(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec D1U, gp_Vec D1V, gp_Vec D2U, gp_Vec D2V, gp_Vec DUV)

    Computes the point <P>, the first derivative <D1*> and second
    derivative <D2*> of parameter <U> and <V> on the HSurface <S>.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type D1U: OCC.wrapper.gp.gp_Vec
    :type D1V: OCC.wrapper.gp.gp_Vec
    :type D2U: OCC.wrapper.gp.gp_Vec
    :type D2V: OCC.wrapper.gp.gp_Vec
    :type DUV: OCC.wrapper.gp.gp_Vec

    """
    return _LProp3d.LProp3d_SurfaceTool_D2(*args)

def LProp3d_SurfaceTool_DN(*args):
    """
    LProp3d_SurfaceTool_DN(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, Standard_Integer const IU, Standard_Integer const IV) -> gp_Vec

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U: float
    :type V: float
    :type IU: int
    :type IV: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _LProp3d.LProp3d_SurfaceTool_DN(*args)

def LProp3d_SurfaceTool_Continuity(*args):
    """
    LProp3d_SurfaceTool_Continuity(Handle_Adaptor3d_HSurface S) -> Standard_Integer

    returns the order of continuity of the HSurface <S>.
    returns 1 : first derivative only is computable
    returns 2 : first and second derivative only are computable.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _LProp3d.LProp3d_SurfaceTool_Continuity(*args)

def LProp3d_SurfaceTool_Bounds(*args):
    """
    LProp3d_SurfaceTool_Bounds(Handle_Adaptor3d_HSurface S)

    returns the bounds of the HSurface.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U1: float
    :type V1: float
    :type U2: float
    :type V2: float

    """
    return _LProp3d.LProp3d_SurfaceTool_Bounds(*args)

class LProp3d_SLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LProp3d_SLProps self, Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, Standard_Integer const N, Standard_Real const Resolution) -> LProp3d_SLProps
        __init__(LProp3d_SLProps self, Handle_Adaptor3d_HSurface S, Standard_Integer const N, Standard_Real const Resolution) -> LProp3d_SLProps
        __init__(LProp3d_SLProps self, Standard_Integer const N, Standard_Real const Resolution) -> LProp3d_SLProps

        idem as previous constructor but without setting the value
        of parameters <U> and <V> and the surface.
        the surface can have an empty constructor.

        :type N: int
        :type Resolution: float

        """
        this = _LProp3d.new_LProp3d_SLProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetSurface(self, *args):
        """
        SetSurface(LProp3d_SLProps self, Handle_Adaptor3d_HSurface S)

        Initializes the local properties of the surface S
        for the new surface.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _LProp3d.LProp3d_SLProps_SetSurface(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(LProp3d_SLProps self, Standard_Real const U, Standard_Real const V)

        Initializes the local properties of the surface S
        for the new parameter values (<U>, <V>).

        :type U: float
        :type V: float

        """
        return _LProp3d.LProp3d_SLProps_SetParameters(self, *args)


    def Value(self, *args):
        """
        Returns the point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _LProp3d.LProp3d_SLProps_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1U(self, *args):
        """
        Returns the first U derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_SLProps_D1U(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D1V(self, *args):
        """
        Returns the first V derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_SLProps_D1V(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D2U(self, *args):
        """
        Returns the second U derivatives
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_SLProps_D2U(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def D2V(self, *args):
        """
        Returns the second V derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_SLProps_D2V(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DUV(self, *args):
        """
        Returns the second UV cross-derivative.
        The derivative is computed if it has not been yet.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _LProp3d.LProp3d_SLProps_DUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentUDefined(self, *args):
        """
        IsTangentUDefined(LProp3d_SLProps self) -> Standard_Boolean

        returns True if the U tangent is defined.
        For example, the tangent is not defined if the
        two first U derivatives are null.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LProp3d.LProp3d_SLProps_IsTangentUDefined(self, *args)


    def TangentU(self, *args):
        """
        TangentU(LProp3d_SLProps self, gp_Dir D)

        Returns the tangent direction <D> on the iso-V.

        :type D: OCC.wrapper.gp.gp_Dir

        """
        return _LProp3d.LProp3d_SLProps_TangentU(self, *args)


    def IsTangentVDefined(self, *args):
        """
        IsTangentVDefined(LProp3d_SLProps self) -> Standard_Boolean

        returns if the V tangent is defined.
        For example, the tangent is not defined if the
        two first V derivatives are null.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LProp3d.LProp3d_SLProps_IsTangentVDefined(self, *args)


    def TangentV(self, *args):
        """
        TangentV(LProp3d_SLProps self, gp_Dir D)

        Returns the tangent direction <D> on the iso-V.

        :type D: OCC.wrapper.gp.gp_Dir

        """
        return _LProp3d.LProp3d_SLProps_TangentV(self, *args)


    def IsNormalDefined(self, *args):
        """
        IsNormalDefined(LProp3d_SLProps self) -> Standard_Boolean

        Tells if the normal is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LProp3d.LProp3d_SLProps_IsNormalDefined(self, *args)


    def Normal(self, *args):
        """
        Returns the normal direction.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _LProp3d.LProp3d_SLProps_Normal(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCurvatureDefined(self, *args):
        """
        IsCurvatureDefined(LProp3d_SLProps self) -> Standard_Boolean

        returns True if the curvature is defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LProp3d.LProp3d_SLProps_IsCurvatureDefined(self, *args)


    def IsUmbilic(self, *args):
        """
        IsUmbilic(LProp3d_SLProps self) -> Standard_Boolean

        returns True if the point is umbilic (i.e. if the
        curvature is constant).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LProp3d.LProp3d_SLProps_IsUmbilic(self, *args)


    def MaxCurvature(self, *args):
        """
        MaxCurvature(LProp3d_SLProps self) -> Standard_Real

        Returns the maximum curvature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LProp3d.LProp3d_SLProps_MaxCurvature(self, *args)


    def MinCurvature(self, *args):
        """
        MinCurvature(LProp3d_SLProps self) -> Standard_Real

        Returns the minimum curvature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LProp3d.LProp3d_SLProps_MinCurvature(self, *args)


    def CurvatureDirections(self, *args):
        """
        CurvatureDirections(LProp3d_SLProps self, gp_Dir MaxD, gp_Dir MinD)

        Returns the direction of the maximum and minimum curvature
        <MaxD> and <MinD>

        :type MaxD: OCC.wrapper.gp.gp_Dir
        :type MinD: OCC.wrapper.gp.gp_Dir

        """
        return _LProp3d.LProp3d_SLProps_CurvatureDirections(self, *args)


    def MeanCurvature(self, *args):
        """
        MeanCurvature(LProp3d_SLProps self) -> Standard_Real

        Returns the mean curvature.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LProp3d.LProp3d_SLProps_MeanCurvature(self, *args)


    def GaussianCurvature(self, *args):
        """
        GaussianCurvature(LProp3d_SLProps self) -> Standard_Real

        Returns the Gaussian curvature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LProp3d.LProp3d_SLProps_GaussianCurvature(self, *args)

    __swig_destroy__ = _LProp3d.delete_LProp3d_SLProps
LProp3d_SLProps_swigregister = _LProp3d.LProp3d_SLProps_swigregister
LProp3d_SLProps_swigregister(LProp3d_SLProps)




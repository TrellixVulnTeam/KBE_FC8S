# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_XCAFPrs')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_XCAFPrs')
    _XCAFPrs = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_XCAFPrs', [dirname(__file__)])
        except ImportError:
            import _XCAFPrs
            return _XCAFPrs
        try:
            _mod = imp.load_module('_XCAFPrs', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _XCAFPrs = swig_import_helper()
    del swig_import_helper
else:
    import _XCAFPrs
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _XCAFPrs.delete_SwigPyIterator

    def value(self):
        return _XCAFPrs.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _XCAFPrs.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _XCAFPrs.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _XCAFPrs.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _XCAFPrs.SwigPyIterator_equal(self, x)

    def copy(self):
        return _XCAFPrs.SwigPyIterator_copy(self)

    def next(self):
        return _XCAFPrs.SwigPyIterator_next(self)

    def __next__(self):
        return _XCAFPrs.SwigPyIterator___next__(self)

    def previous(self):
        return _XCAFPrs.SwigPyIterator_previous(self)

    def advance(self, n):
        return _XCAFPrs.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _XCAFPrs.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _XCAFPrs.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _XCAFPrs.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _XCAFPrs.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _XCAFPrs.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _XCAFPrs.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _XCAFPrs.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _XCAFPrs.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_XCAFPrs.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _XCAFPrs.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _XCAFPrs.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XCAFPrs.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _XCAFPrs.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _XCAFPrs.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _XCAFPrs.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _XCAFPrs.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_XCAFPrs.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _XCAFPrs.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _XCAFPrs.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XCAFPrs.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _XCAFPrs.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _XCAFPrs.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _XCAFPrs.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _XCAFPrs.ptr_to_number(item)
ptr_to_number = _XCAFPrs.ptr_to_number

def HashCode(*args):
    return _XCAFPrs.HashCode(*args)
HashCode = _XCAFPrs.HashCode

def ptr_equal(a, b):
    return _XCAFPrs.ptr_equal(a, b)
ptr_equal = _XCAFPrs.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TPrsStd
else:
    import TPrsStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDataXtd
else:
    import TDataXtd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TNaming
else:
    import TNaming
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDataStd
else:
    import TDataStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AIS
else:
    import AIS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PrsMgr
else:
    import PrsMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import V3d
else:
    import V3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Prs3d
else:
    import Prs3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import DsgPrs
else:
    import DsgPrs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Select3D
else:
    import Select3D
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectBasics
else:
    import SelectBasics
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectMgr
else:
    import SelectMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StdSelect
else:
    import StdSelect
del _swig_python_version_info
class XCAFPrs_AISObject(AIS.AIS_ColoredShape):
    """Implements AIS_InteractiveObject functionality for shape in DECAF document."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XCAFPrs_AISObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XCAFPrs_AISObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(XCAFPrs_AISObject self, TDF_Label theLabel) -> XCAFPrs_AISObject

        Creates an object to visualise the shape label.

        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        this = _XCAFPrs.new_XCAFPrs_AISObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetLabel(self, *args):
        """
        Returns the label which was visualised by this presentation

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _XCAFPrs.XCAFPrs_AISObject_GetLabel(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLabel(self, *args):
        """
        SetLabel(XCAFPrs_AISObject self, TDF_Label theLabel)

        Assign the label to this presentation
        (but does not mark it outdated with SetToUpdate()).

        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _XCAFPrs.XCAFPrs_AISObject_SetLabel(self, *args)


    def DispatchStyles(self, *args):
        """
        DispatchStyles(XCAFPrs_AISObject self, Standard_Boolean const theToSyncStyles)

        Fetch the Shape from associated Label and fill the map of sub-shapes styles.
        By default, this method is called implicitly within first ::Compute().
        Application might call this method explicitly to manipulate styles afterwards.
        @param theToSyncStyles flag indicating if method ::Compute() should call this method again
        on first compute or re-compute

        :type theToSyncStyles: bool

        """
        return _XCAFPrs.XCAFPrs_AISObject_DispatchStyles(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(XCAFPrs_AISObject self, Graphic3d_MaterialAspect theMaterial)

        Sets the material aspect.
        This method assigns the new default material without overriding XDE styles.
        Re-computation of existing presentation is not required after calling this method.

        :type theMaterial: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _XCAFPrs.XCAFPrs_AISObject_SetMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XCAFPrs.XCAFPrs_AISObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XCAFPrs.XCAFPrs_AISObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XCAFPrs.XCAFPrs_AISObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _XCAFPrs.delete_XCAFPrs_AISObject
XCAFPrs_AISObject_swigregister = _XCAFPrs.XCAFPrs_AISObject_swigregister
XCAFPrs_AISObject_swigregister(XCAFPrs_AISObject)

def XCAFPrs_AISObject_get_type_name(*args):
    """
    XCAFPrs_AISObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XCAFPrs.XCAFPrs_AISObject_get_type_name(*args)

def XCAFPrs_AISObject_get_type_descriptor(*args):
    """
    XCAFPrs_AISObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XCAFPrs.XCAFPrs_AISObject_get_type_descriptor(*args)

class XCAFPrs_Driver(TPrsStd.TPrsStd_Driver):
    """
    Implements a driver for presentation of shapes in DECAF
    document. Its the only purpose is to initialize and return
    XCAFPrs_AISObject object on request
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_XCAFPrs_Driver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_XCAFPrs_Driver(self) 
            return h


    def Update(self, *args):
        """
        Update(XCAFPrs_Driver self, TDF_Label L, Handle_AIS_InteractiveObject ais) -> Standard_Boolean

        :type L: OCC.wrapper.TDF.TDF_Label
        :type ais: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.XCAFPrs_Driver_Update(self, *args)


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        returns GUID of the driver

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _XCAFPrs.XCAFPrs_Driver_GetID(*args)

    GetID = staticmethod(GetID)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _XCAFPrs.XCAFPrs_Driver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _XCAFPrs.XCAFPrs_Driver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XCAFPrs.XCAFPrs_Driver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """
        Implements a driver for presentation of shapes in DECAF
        document. Its the only purpose is to initialize and return
        XCAFPrs_AISObject object on request
        """
        this = _XCAFPrs.new_XCAFPrs_Driver()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _XCAFPrs.delete_XCAFPrs_Driver
XCAFPrs_Driver_swigregister = _XCAFPrs.XCAFPrs_Driver_swigregister
XCAFPrs_Driver_swigregister(XCAFPrs_Driver)

def XCAFPrs_Driver_GetID(*args):
    """
    XCAFPrs_Driver_GetID() -> Standard_GUID

    returns GUID of the driver

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _XCAFPrs.XCAFPrs_Driver_GetID(*args)

def XCAFPrs_Driver_get_type_name(*args):
    """
    XCAFPrs_Driver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _XCAFPrs.XCAFPrs_Driver_get_type_name(*args)

def XCAFPrs_Driver_get_type_descriptor(*args):
    """
    XCAFPrs_Driver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _XCAFPrs.XCAFPrs_Driver_get_type_descriptor(*args)

class XCAFPrs_Style(object):
    """Represents a set of styling settings applicable to a (sub)shape"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(XCAFPrs_Style self) -> XCAFPrs_Style

        Empty constructor - colors are unset, visibility is TRUE.


        """
        this = _XCAFPrs.new_XCAFPrs_Style(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSetColorSurf(self, *args):
        """
        IsSetColorSurf(XCAFPrs_Style self) -> Standard_Boolean

        Return TRUE if surface color has been defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.XCAFPrs_Style_IsSetColorSurf(self, *args)


    def GetColorSurf(self, *args):
        """
        Return surface color.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _XCAFPrs.XCAFPrs_Style_GetColorSurf(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetColorSurfRGBA(self, *args):
        """
        Return surface color.

        :rtype: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        res = _XCAFPrs.XCAFPrs_Style_GetColorSurfRGBA(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColorSurf(self, *args):
        """
        SetColorSurf(XCAFPrs_Style self, Quantity_Color theColor)
        SetColorSurf(XCAFPrs_Style self, Quantity_ColorRGBA theColor)

        Set surface color.

        :type theColor: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _XCAFPrs.XCAFPrs_Style_SetColorSurf(self, *args)


    def UnSetColorSurf(self, *args):
        """
        UnSetColorSurf(XCAFPrs_Style self)

        Manage surface color setting


        """
        return _XCAFPrs.XCAFPrs_Style_UnSetColorSurf(self, *args)


    def IsSetColorCurv(self, *args):
        """
        IsSetColorCurv(XCAFPrs_Style self) -> Standard_Boolean

        Return TRUE if curve color has been defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.XCAFPrs_Style_IsSetColorCurv(self, *args)


    def GetColorCurv(self, *args):
        """
        Return curve color.

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        res = _XCAFPrs.XCAFPrs_Style_GetColorCurv(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColorCurv(self, *args):
        """
        SetColorCurv(XCAFPrs_Style self, Quantity_Color col)

        Set curve color.

        :type col: OCC.wrapper.Quantity.Quantity_Color

        """
        return _XCAFPrs.XCAFPrs_Style_SetColorCurv(self, *args)


    def UnSetColorCurv(self, *args):
        """
        UnSetColorCurv(XCAFPrs_Style self)

        Manage curve color setting


        """
        return _XCAFPrs.XCAFPrs_Style_UnSetColorCurv(self, *args)


    def SetVisibility(self, *args):
        """
        SetVisibility(XCAFPrs_Style self, Standard_Boolean const theVisibility)

        Assign visibility.

        :type theVisibility: bool

        """
        return _XCAFPrs.XCAFPrs_Style_SetVisibility(self, *args)


    def IsVisible(self, *args):
        """
        IsVisible(XCAFPrs_Style self) -> Standard_Boolean

        Manage visibility.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.XCAFPrs_Style_IsVisible(self, *args)


    def __eq__(self, *args):
        """
        __eq__(XCAFPrs_Style self, XCAFPrs_Style theOther) -> Standard_Boolean

        Returns True if styles are the same.

        :type theOther: OCC.wrapper.XCAFPrs.XCAFPrs_Style
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.XCAFPrs_Style___eq__(self, *args)


    def HashCode(*args):
        """
        HashCode(XCAFPrs_Style theStyle, Standard_Integer const theUpper) -> Standard_Integer

        Returns a HasCode value.

        :type theStyle: OCC.wrapper.XCAFPrs.XCAFPrs_Style
        :type theUpper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.XCAFPrs_Style_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(XCAFPrs_Style theOther) -> Standard_Boolean
        IsEqual(XCAFPrs_Style theS1, XCAFPrs_Style theS2) -> Standard_Boolean

        Returns True when the two keys are the same.

        :type theS1: OCC.wrapper.XCAFPrs.XCAFPrs_Style
        :type theS2: OCC.wrapper.XCAFPrs.XCAFPrs_Style
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.XCAFPrs_Style_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)
    __swig_destroy__ = _XCAFPrs.delete_XCAFPrs_Style
XCAFPrs_Style_swigregister = _XCAFPrs.XCAFPrs_Style_swigregister
XCAFPrs_Style_swigregister(XCAFPrs_Style)

def XCAFPrs_Style_HashCode(*args):
    """
    XCAFPrs_Style_HashCode(XCAFPrs_Style theStyle, Standard_Integer const theUpper) -> Standard_Integer

    Returns a HasCode value.

    :type theStyle: OCC.wrapper.XCAFPrs.XCAFPrs_Style
    :type theUpper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _XCAFPrs.XCAFPrs_Style_HashCode(*args)

def XCAFPrs_Style_IsEqual(*args):
    """
    IsEqual(XCAFPrs_Style theOther) -> Standard_Boolean
    XCAFPrs_Style_IsEqual(XCAFPrs_Style theS1, XCAFPrs_Style theS2) -> Standard_Boolean

    Returns True when the two keys are the same.

    :type theS1: OCC.wrapper.XCAFPrs.XCAFPrs_Style
    :type theS2: OCC.wrapper.XCAFPrs.XCAFPrs_Style
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _XCAFPrs.XCAFPrs_Style_IsEqual(*args)

class Handle_XCAFPrs_AISObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XCAFPrs_AISObject self)

        Nullify the handle


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XCAFPrs_AISObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XCAFPrs_AISObject self, XCAFPrs_AISObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XCAFPrs_AISObject self, Handle_XCAFPrs_AISObject theHandle) -> Handle_XCAFPrs_AISObject
        assign(Handle_XCAFPrs_AISObject self, XCAFPrs_AISObject thePtr) -> Handle_XCAFPrs_AISObject
        assign(Handle_XCAFPrs_AISObject self, Handle_XCAFPrs_AISObject theHandle) -> Handle_XCAFPrs_AISObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XCAFPrs_AISObject self) -> XCAFPrs_AISObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XCAFPrs_AISObject self) -> XCAFPrs_AISObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XCAFPrs_AISObject self) -> XCAFPrs_AISObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject___ref__(self, *args)


    def __hash__(self):
        return _XCAFPrs.Handle_XCAFPrs_AISObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XCAFPrs.Handle_XCAFPrs_AISObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XCAFPrs.new_Handle_XCAFPrs_AISObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XCAFPrs.Handle_XCAFPrs_AISObject_DownCast)
    __swig_destroy__ = _XCAFPrs.delete_Handle_XCAFPrs_AISObject

    def GetLabel(self, *args):
        """
        Returns the label which was visualised by this presentation

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_GetLabel(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLabel(self, *args):
        """
        SetLabel(Handle_XCAFPrs_AISObject self, TDF_Label theLabel)

        Assign the label to this presentation
        (but does not mark it outdated with SetToUpdate()).

        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetLabel(self, *args)


    def DispatchStyles(self, *args):
        """
        DispatchStyles(Handle_XCAFPrs_AISObject self, Standard_Boolean const theToSyncStyles)

        Fetch the Shape from associated Label and fill the map of sub-shapes styles.
        By default, this method is called implicitly within first ::Compute().
        Application might call this method explicitly to manipulate styles afterwards.
        @param theToSyncStyles flag indicating if method ::Compute() should call this method again
        on first compute or re-compute

        :type theToSyncStyles: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_DispatchStyles(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_XCAFPrs_AISObject self, Graphic3d_MaterialAspect theMaterial)

        Sets the material aspect.
        This method assigns the new default material without overriding XDE styles.
        Re-computation of existing presentation is not required after calling this method.

        :type theMaterial: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XCAFPrs_AISObject self) -> char const *

        :rtype: const char *

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CustomAspects(self, *args):
        """
        CustomAspects(Handle_XCAFPrs_AISObject self, TopoDS_Shape theShape) -> Handle_AIS_ColoredDrawer

        Customize properties of specified sub-shape.
        The shape will be stored in the map but ignored, if it is not sub-shape of main Shape!
        This method can be used to mark sub-shapes with customizable properties.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.AIS.Handle_AIS_ColoredDrawer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_CustomAspects(self, *args)


    def ClearCustomAspects(self, *args):
        """
        ClearCustomAspects(Handle_XCAFPrs_AISObject self)

        Reset the map of custom sub-shape aspects.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ClearCustomAspects(self, *args)


    def UnsetCustomAspects(self, *args):
        """
        UnsetCustomAspects(Handle_XCAFPrs_AISObject self, TopoDS_Shape theShape, Standard_Boolean const theToUnregister)

        Reset custom properties of specified sub-shape.
        @param theToUnregister unregister or not sub-shape from the map

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theToUnregister: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetCustomAspects(self, *args)


    def SetCustomColor(self, *args):
        """
        SetCustomColor(Handle_XCAFPrs_AISObject self, TopoDS_Shape theShape, Quantity_Color theColor)

        Customize color of specified sub-shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetCustomColor(self, *args)


    def SetCustomWidth(self, *args):
        """
        SetCustomWidth(Handle_XCAFPrs_AISObject self, TopoDS_Shape theShape, Standard_Real const theLineWidth)

        Customize line width of specified sub-shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theLineWidth: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetCustomWidth(self, *args)


    def CustomAspectsMap(self, *args):
        """
        Return the map of custom aspects.

        :rtype: OCC.wrapper.AIS.AIS_DataMapOfShapeDrawer

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_CustomAspectsMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCustomAspectsMap(self, *args):
        """
        ChangeCustomAspectsMap(Handle_XCAFPrs_AISObject self) -> NCollection_DataMap_TopoDS_Shape_Handle_AIS_ColoredDrawer_TopTools_ShapeMapHasher

        Return the map of custom aspects.

        :rtype: OCC.wrapper.AIS.AIS_DataMapOfShapeDrawer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ChangeCustomAspectsMap(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_XCAFPrs_AISObject self, Quantity_Color theColor)

        Setup color of entire shape.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_XCAFPrs_AISObject self, Standard_Real const theLineWidth)

        Setup line width of entire shape.

        :type theLineWidth: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetWidth(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_XCAFPrs_AISObject self, Standard_Real const theValue)

        Sets transparency value.

        :type theValue: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetTransparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_XCAFPrs_AISObject self)

        Removes the setting for transparency in the reconstructed compound shape.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetTransparency(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_XCAFPrs_AISObject self) -> Standard_Integer

        Returns index 0. This value refers to SHAPE from TopAbs_ShapeEnum

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Signature(self, *args)


    def Type(self, *args):
        """
        Type(Handle_XCAFPrs_AISObject self) -> AIS_KindOfInteractive

        Returns Object as the type of Interactive Object.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Type(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the Interactive Object accepts shape decomposition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_AcceptShapeDecomposition(self, *args)


    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_XCAFPrs_AISObject self, Standard_Integer const theMode) -> Standard_Boolean

        Return true if specified display mode is supported.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_AcceptDisplayMode(self, *args)


    def Shape(self, *args):
        """
        Returns this shape object.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape(self, *args):
        """
        SetShape(Handle_XCAFPrs_AISObject self, TopoDS_Shape theShape)

        Constructs an instance of the shape object theShape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetShape(self, *args)


    def Set(self, *args):
        """
        Set(Handle_XCAFPrs_AISObject self, TopoDS_Shape theShape)

        Alias for ::SetShape().

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Set(self, *args)


    def SetOwnDeviationCoefficient(self, *args):
        """
        SetOwnDeviationCoefficient(Handle_XCAFPrs_AISObject self) -> Standard_Boolean
        SetOwnDeviationCoefficient(Handle_XCAFPrs_AISObject self, Standard_Real const aCoefficient)

        Sets a local value for deviation coefficient for this specific shape.

        :type aCoefficient: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetOwnDeviationCoefficient(self, *args)


    def SetOwnHLRDeviationCoefficient(self, *args):
        """
        SetOwnHLRDeviationCoefficient(Handle_XCAFPrs_AISObject self) -> Standard_Boolean
        SetOwnHLRDeviationCoefficient(Handle_XCAFPrs_AISObject self, Standard_Real const aCoefficient)

        sets myOwnHLRDeviationCoefficient field in Prs3d_Drawer &
        recomputes presentation

        :type aCoefficient: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetOwnHLRDeviationCoefficient(self, *args)


    def SetOwnDeviationAngle(self, *args):
        """
        SetOwnDeviationAngle(Handle_XCAFPrs_AISObject self) -> Standard_Boolean
        SetOwnDeviationAngle(Handle_XCAFPrs_AISObject self, Standard_Real const anAngle)

        sets myOwnDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetOwnDeviationAngle(self, *args)


    def SetOwnHLRDeviationAngle(self, *args):
        """
        SetOwnHLRDeviationAngle(Handle_XCAFPrs_AISObject self) -> Standard_Boolean
        SetOwnHLRDeviationAngle(Handle_XCAFPrs_AISObject self, Standard_Real const anAngle)

        sets myOwnHLRDeviationAngle field in Prs3d_Drawer & recomputes presentation

        :type anAngle: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetOwnHLRDeviationAngle(self, *args)


    def SetAngleAndDeviation(self, *args):
        """
        SetAngleAndDeviation(Handle_XCAFPrs_AISObject self, Standard_Real const anAngle)

        this compute a new angle and Deviation from the value anAngle
        and set the values stored in myDrawer with these that become local to the shape

        :type anAngle: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetAngleAndDeviation(self, *args)


    def UserAngle(self, *args):
        """
        UserAngle(Handle_XCAFPrs_AISObject self) -> Standard_Real

        gives back the angle initial value put by the User.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UserAngle(self, *args)


    def SetHLRAngleAndDeviation(self, *args):
        """
        SetHLRAngleAndDeviation(Handle_XCAFPrs_AISObject self, Standard_Real const anAngle)

        this compute a new Angle and Deviation from the value anAngle for HLR
        and set the values stored in myDrawer for with these that become local to the shape

        :type anAngle: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetHLRAngleAndDeviation(self, *args)


    def OwnDeviationCoefficient(self, *args):
        """
        OwnDeviationCoefficient(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true and the values of the deviation
        coefficient aCoefficient and the previous deviation
        coefficient aPreviousCoefficient. If these values are
        not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_OwnDeviationCoefficient(self, *args)


    def OwnHLRDeviationCoefficient(self, *args):
        """
        OwnHLRDeviationCoefficient(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns   true and the values of the HLR deviation
        coefficient aCoefficient and the previous HLR
        deviation coefficient aPreviousCoefficient. If these
        values are not already set, false is returned.

        :type aCoefficient: float
        :type aPreviousCoefficient: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_OwnHLRDeviationCoefficient(self, *args)


    def OwnDeviationAngle(self, *args):
        """
        OwnDeviationAngle(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true and the values of the deviation angle
        anAngle and the previous deviation angle aPreviousAngle.
        If these values are not already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_OwnDeviationAngle(self, *args)


    def OwnHLRDeviationAngle(self, *args):
        """
        OwnHLRDeviationAngle(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true and the values   of the HLR deviation
        angle anAngle and of the previous HLR deviation
        angle aPreviousAngle. If these values are not
        already set, false is returned.

        :type anAngle: float
        :type aPreviousAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_OwnHLRDeviationAngle(self, *args)


    def SetTypeOfHLR(self, *args):
        """
        SetTypeOfHLR(Handle_XCAFPrs_AISObject self, Prs3d_TypeOfHLR const theTypeOfHLR)

        Sets the type of HLR algorithm used by the shape

        :type theTypeOfHLR: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetTypeOfHLR(self, *args)


    def TypeOfHLR(self, *args):
        """
        TypeOfHLR(Handle_XCAFPrs_AISObject self) -> Prs3d_TypeOfHLR

        Gets the type of HLR algorithm

        :rtype: OCC.wrapper.Prs3d.Prs3d_TypeOfHLR

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_TypeOfHLR(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_XCAFPrs_AISObject self)

        Removes settings for color in the reconstructed compound shape.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetColor(self, *args)


    def UnsetWidth(self, *args):
        """
        UnsetWidth(Handle_XCAFPrs_AISObject self)

        Removes the setting for line width in the reconstructed compound shape.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetWidth(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_XCAFPrs_AISObject self)

        Removes settings for material in the reconstructed compound shape.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetMaterial(self, *args)


    def BoundingBox(self, *args):
        """
        Constructs a bounding box with which to reconstruct
        compound topological shapes for presentation.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Color(self, *args):
        """
        Color(Handle_XCAFPrs_AISObject self, Quantity_Color aColor)

        Returns the Color attributes of the shape accordingly to
        the current facing model;

        :type aColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Color(self, *args)


    def Material(self, *args):
        """
        Material(Handle_XCAFPrs_AISObject self) -> Graphic3d_NameOfMaterial

        Returns the NameOfMaterial attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Material(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_XCAFPrs_AISObject self) -> Standard_Real

        Returns the transparency attributes of the shape accordingly to
        the current facing model;

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Transparency(self, *args)


    def SelectionType(self, *args):
        """
        SelectionType(Handle_XCAFPrs_AISObject self, Standard_Integer const theSelMode) -> TopAbs_ShapeEnum

        Return shape type for specified selection mode.

        :type theSelMode: int
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SelectionType(self, *args)


    def SelectionMode(self, *args):
        """
        SelectionMode(Handle_XCAFPrs_AISObject self, TopAbs_ShapeEnum const theShapeType) -> Standard_Integer

        Return selection mode for specified shape type.

        :type theShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SelectionMode(self, *args)


    def TextureRepeatUV(self, *args):
        """
        Return texture repeat UV values; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_TextureRepeatUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureRepeatUV(self, *args):
        """
        SetTextureRepeatUV(Handle_XCAFPrs_AISObject self, gp_Pnt2d theRepeatUV)

        Sets the number of occurrences of the texture on each face. The texture itself is parameterized in (0,1) by (0,1).
        Each face of the shape to be textured is parameterized in UV space (Umin,Umax) by (Vmin,Vmax).

        :type theRepeatUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetTextureRepeatUV(self, *args)


    def TextureOriginUV(self, *args):
        """
        Return texture origin UV position; (0, 0) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_TextureOriginUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureOriginUV(self, *args):
        """
        SetTextureOriginUV(Handle_XCAFPrs_AISObject self, gp_Pnt2d theOriginUV)

        Use this method to change the origin of the texture.
        The texel (0,0) will be mapped to the surface (myUVOrigin.X(), myUVOrigin.Y()).

        :type theOriginUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetTextureOriginUV(self, *args)


    def TextureScaleUV(self, *args):
        """
        Return scale factor for UV coordinates; (1, 1) by default.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_TextureScaleUV(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureScaleUV(self, *args):
        """
        SetTextureScaleUV(Handle_XCAFPrs_AISObject self, gp_Pnt2d theScaleUV)

        Use this method to scale the texture (percent of the face).
        You can specify a scale factor for both U and V.
        Example: if you set ScaleU and ScaleV to 0.5 and you enable texture repeat,
        the texture will appear twice on the face in each direction.

        :type theScaleUV: OCC.wrapper.gp.gp_Pnt2d

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetTextureScaleUV(self, *args)


    def computeHlrPresentation(self, *args):
        """
        computeHlrPresentation(Handle_XCAFPrs_AISObject self, Handle_Prs3d_Projector theProjector, Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

        Compute HLR presentation for specified shape.

        :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector
        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_computeHlrPresentation(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_XCAFPrs_AISObject self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_XCAFPrs_AISObject self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_CurrentFacingModel(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_XCAFPrs_AISObject self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_XCAFPrs_AISObject self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_XCAFPrs_AISObject self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_XCAFPrs_AISObject self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_XCAFPrs_AISObject self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_XCAFPrs_AISObject self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_XCAFPrs_AISObject self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_XCAFPrs_AISObject self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_XCAFPrs_AISObject self)

        Removes display mode settings from the interactive object.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_XCAFPrs_AISObject self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_XCAFPrs_AISObject self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_XCAFPrs_AISObject self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_XCAFPrs_AISObject self)

        Unsets highlight display mode.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasColor(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_XCAFPrs_AISObject self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasMaterial(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IsTransparent(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_XCAFPrs_AISObject self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_XCAFPrs_AISObject self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_XCAFPrs_AISObject self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_XCAFPrs_AISObject self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_XCAFPrs_AISObject self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_PolygonOffsets(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_XCAFPrs_AISObject self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_XCAFPrs_AISObject self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_XCAFPrs_AISObject self)
        RecomputePrimitives(Handle_XCAFPrs_AISObject self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_XCAFPrs_AISObject self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_XCAFPrs_AISObject self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_XCAFPrs_AISObject self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_XCAFPrs_AISObject self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_XCAFPrs_AISObject self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_XCAFPrs_AISObject self)

        resets local transformation to identity.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_XCAFPrs_AISObject self)

        Recomputes the location of the selection aSelection.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_XCAFPrs_AISObject self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UpdateTransformations(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_XCAFPrs_AISObject self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Seq)

        Method which draws selected owners ( for fast presentation draw )

        :type PM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type Seq: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HilightSelected(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_XCAFPrs_AISObject self)

        Method which clear all selected owners belonging
        to this selectable object ( for fast presentation draw )


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ClearSelected(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_XCAFPrs_AISObject self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ClearDynamicHighlight(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_XCAFPrs_AISObject self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Handle_SelectMgr_EntityOwner theOwner)

        Method which hilight an owner belonging to
        this selectable object  ( for fast presentation draw )

        :type thePM: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HilightOwnerWithColor(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_XCAFPrs_AISObject self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_XCAFPrs_AISObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_XCAFPrs_AISObject self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_XCAFPrs_AISObject self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_XCAFPrs_AISObject self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_XCAFPrs_AISObject self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_XCAFPrs_AISObject self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_XCAFPrs_AISObject self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_XCAFPrs_AISObject self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_XCAFPrs_AISObject self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_XCAFPrs_AISObject self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_XCAFPrs_AISObject self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_XCAFPrs_AISObject self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_XCAFPrs_AISObject self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_XCAFPrs_AISObject self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_XCAFPrs_AISObject self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_XCAFPrs_AISObject self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_XCAFPrs_AISObject self, Standard_Integer const aMode)
        SetToUpdate(Handle_XCAFPrs_AISObject self)

        flags all the Presentations to be Updated.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_XCAFPrs_AISObject self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_XCAFPrs_AISObject self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_XCAFPrs_AISObject self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_XCAFPrs_AISObject self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_XCAFPrs_AISObject self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_XCAFPrs_AISObject self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_XCAFPrs_AISObject self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_XCAFPrs_AISObject self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_XCAFPrs_AISObject self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_XCAFPrs_AISObject self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_XCAFPrs_AISObject self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_XCAFPrs_AISObject self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_XCAFPrs_AISObject self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_XCAFPrs_AISObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_XCAFPrs_AISObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _XCAFPrs.Handle_XCAFPrs_AISObject_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_XCAFPrs_AISObject self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_XCAFPrs_AISObject self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_XCAFPrs_AISObject self)

        Memory deallocator for transient classes


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XCAFPrs_AISObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XCAFPrs_AISObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XCAFPrs_AISObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XCAFPrs_AISObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XCAFPrs_AISObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XCAFPrs_AISObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XCAFPrs_AISObject self)

        Increments the reference counter of this object


        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XCAFPrs_AISObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_AISObject_DecrementRefCounter(self, *args)

Handle_XCAFPrs_AISObject_swigregister = _XCAFPrs.Handle_XCAFPrs_AISObject_swigregister
Handle_XCAFPrs_AISObject_swigregister(Handle_XCAFPrs_AISObject)

def Handle_XCAFPrs_AISObject_DownCast(thing):
    return _XCAFPrs.Handle_XCAFPrs_AISObject_DownCast(thing)
Handle_XCAFPrs_AISObject_DownCast = _XCAFPrs.Handle_XCAFPrs_AISObject_DownCast

class Handle_XCAFPrs_Driver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_XCAFPrs_Driver self)

        Nullify the handle


        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_XCAFPrs_Driver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_XCAFPrs_Driver self, XCAFPrs_Driver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_XCAFPrs_Driver self, Handle_XCAFPrs_Driver theHandle) -> Handle_XCAFPrs_Driver
        assign(Handle_XCAFPrs_Driver self, XCAFPrs_Driver thePtr) -> Handle_XCAFPrs_Driver
        assign(Handle_XCAFPrs_Driver self, Handle_XCAFPrs_Driver theHandle) -> Handle_XCAFPrs_Driver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_XCAFPrs_Driver self) -> XCAFPrs_Driver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_XCAFPrs_Driver self) -> XCAFPrs_Driver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_XCAFPrs_Driver self) -> XCAFPrs_Driver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver___ref__(self, *args)


    def __hash__(self):
        return _XCAFPrs.Handle_XCAFPrs_Driver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _XCAFPrs.Handle_XCAFPrs_Driver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _XCAFPrs.new_Handle_XCAFPrs_Driver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_XCAFPrs.Handle_XCAFPrs_Driver_DownCast)
    __swig_destroy__ = _XCAFPrs.delete_Handle_XCAFPrs_Driver

    def Update(self, *args):
        """
        Update(Handle_XCAFPrs_Driver self, TDF_Label L, Handle_AIS_InteractiveObject ais) -> Standard_Boolean

        :type L: OCC.wrapper.TDF.TDF_Label
        :type ais: OCC.wrapper.AIS.Handle_AIS_InteractiveObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_Update(self, *args)


    def GetID(self, *args):
        """
        GetID(Handle_XCAFPrs_Driver self) -> Standard_GUID

        returns GUID of the driver

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_GetID(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_XCAFPrs_Driver self) -> char const *

        :rtype: const char *

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XCAFPrs.Handle_XCAFPrs_Driver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _XCAFPrs.Handle_XCAFPrs_Driver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_XCAFPrs_Driver self)

        Memory deallocator for transient classes


        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_XCAFPrs_Driver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_XCAFPrs_Driver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_XCAFPrs_Driver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_XCAFPrs_Driver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_XCAFPrs_Driver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_XCAFPrs_Driver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_XCAFPrs_Driver self)

        Increments the reference counter of this object


        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_XCAFPrs_Driver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.Handle_XCAFPrs_Driver_DecrementRefCounter(self, *args)

Handle_XCAFPrs_Driver_swigregister = _XCAFPrs.Handle_XCAFPrs_Driver_swigregister
Handle_XCAFPrs_Driver_swigregister(Handle_XCAFPrs_Driver)

def Handle_XCAFPrs_Driver_DownCast(thing):
    return _XCAFPrs.Handle_XCAFPrs_Driver_DownCast(thing)
Handle_XCAFPrs_Driver_DownCast = _XCAFPrs.Handle_XCAFPrs_Driver_DownCast

class NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,opencascade::handle< Standard_Transient >,XCAFPrs_Style >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,opencascade::handle< Standard_Transient >,XCAFPrs_Style >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,opencascade::handle< Standard_Transient >,XCAFPrs_Style >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,opencascade::handle< Standard_Transient >,XCAFPrs_Style >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _XCAFPrs.new_NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style theOther) -> NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style theOther) -> NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, XCAFPrs_Style theKey, Handle_Standard_Transient theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, XCAFPrs_Style theKey, Handle_Standard_Transient theItem) -> Handle_Standard_Transient

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, XCAFPrs_Style theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, XCAFPrs_Style theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, XCAFPrs_Style theKey) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, XCAFPrs_Style theKey) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, XCAFPrs_Style theKey) -> Handle_Standard_Transient

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_Size(self, *args)


    def __iter__(self):
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style___iter__(self)
    __swig_destroy__ = _XCAFPrs.delete_NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style
NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_swigregister = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_swigregister
NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_swigregister(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style)

class NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _XCAFPrs.new_NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XCAFPrs.delete_NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper

    def __next__(self):
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper___next__(self)
NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper_swigregister = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper_swigregister
NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper_swigregister(NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style_IteratorHelper)


try:
	XCAFPrs_DataMapOfStyleTransient = NCollection_DataMap_XCAFPrs_Style_Handle_Standard_Transient_XCAFPrs_Style
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,XCAFPrs_Style,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,XCAFPrs_Style,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,XCAFPrs_Style,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,XCAFPrs_Style,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _XCAFPrs.new_NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, XCAFPrs_Style theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, XCAFPrs_Style theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> XCAFPrs_Style

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> XCAFPrs_Style

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> XCAFPrs_Style

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> XCAFPrs_Style

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _XCAFPrs.delete_NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_swigregister = _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _XCAFPrs.new_NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XCAFPrs.delete_NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _XCAFPrs.NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher_IteratorHelper)


try:
	XCAFPrs_IndexedDataMapOfShapeStyle = NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class XCAFPrs_(object):
    """
    Presentation (visualiation, selection etc.) tools for
    DECAF documents
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CollectStyleSettings(*args):
        """
        CollectStyleSettings(TDF_Label L, TopLoc_Location loc, NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher settings, Quantity_ColorRGBA theLayerColor)

        Collect styles defined for shape on label L
        and its components and subshapes and fills a map of
        shape - style correspondence
        The location <loc> is for internal use, it
        should be Null location for external call

        :type L: OCC.wrapper.TDF.TDF_Label
        :type loc: OCC.wrapper.TopLoc.TopLoc_Location
        :type settings: OCC.wrapper.XCAFPrs.XCAFPrs_IndexedDataMapOfShapeStyle
        :type theLayerColor: OCC.wrapper.Quantity.Quantity_ColorRGBA

        """
        return _XCAFPrs.XCAFPrs__CollectStyleSettings(*args)

    CollectStyleSettings = staticmethod(CollectStyleSettings)

    def SetViewNameMode(*args):
        """
        SetViewNameMode(Standard_Boolean const viewNameMode)

        Set ViewNameMode for indicate display names or not.

        :type viewNameMode: bool

        """
        return _XCAFPrs.XCAFPrs__SetViewNameMode(*args)

    SetViewNameMode = staticmethod(SetViewNameMode)

    def GetViewNameMode(*args):
        """
        GetViewNameMode() -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.XCAFPrs__GetViewNameMode(*args)

    GetViewNameMode = staticmethod(GetViewNameMode)

    def __init__(self):
        """
        Presentation (visualiation, selection etc.) tools for
        DECAF documents
        """
        this = _XCAFPrs.new_XCAFPrs_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XCAFPrs.delete_XCAFPrs_
XCAFPrs__swigregister = _XCAFPrs.XCAFPrs__swigregister
XCAFPrs__swigregister(XCAFPrs_)

def XCAFPrs__CollectStyleSettings(*args):
    """
    XCAFPrs__CollectStyleSettings(TDF_Label L, TopLoc_Location loc, NCollection_IndexedDataMap_TopoDS_Shape_XCAFPrs_Style_TopTools_ShapeMapHasher settings, Quantity_ColorRGBA theLayerColor)

    Collect styles defined for shape on label L
    and its components and subshapes and fills a map of
    shape - style correspondence
    The location <loc> is for internal use, it
    should be Null location for external call

    :type L: OCC.wrapper.TDF.TDF_Label
    :type loc: OCC.wrapper.TopLoc.TopLoc_Location
    :type settings: OCC.wrapper.XCAFPrs.XCAFPrs_IndexedDataMapOfShapeStyle
    :type theLayerColor: OCC.wrapper.Quantity.Quantity_ColorRGBA

    """
    return _XCAFPrs.XCAFPrs__CollectStyleSettings(*args)

def XCAFPrs__SetViewNameMode(*args):
    """
    XCAFPrs__SetViewNameMode(Standard_Boolean const viewNameMode)

    Set ViewNameMode for indicate display names or not.

    :type viewNameMode: bool

    """
    return _XCAFPrs.XCAFPrs__SetViewNameMode(*args)

def XCAFPrs__GetViewNameMode(*args):
    """
    XCAFPrs__GetViewNameMode() -> Standard_Boolean

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _XCAFPrs.XCAFPrs__GetViewNameMode(*args)

class NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,TopoDS_Shape,XCAFPrs_Style >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,TopoDS_Shape,XCAFPrs_Style >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,TopoDS_Shape,XCAFPrs_Style >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self) -> NCollection_DataMap< XCAFPrs_Style,TopoDS_Shape,XCAFPrs_Style >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _XCAFPrs.new_NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style theOther) -> NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style theOther) -> NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, XCAFPrs_Style theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, XCAFPrs_Style theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, XCAFPrs_Style theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, XCAFPrs_Style theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, XCAFPrs_Style theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, XCAFPrs_Style theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, XCAFPrs_Style theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_Size(self, *args)


    def __iter__(self):
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style___iter__(self)
    __swig_destroy__ = _XCAFPrs.delete_NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style
NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_swigregister = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_swigregister
NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_swigregister(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style)

class NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _XCAFPrs.new_NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _XCAFPrs.delete_NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper

    def __next__(self):
        return _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper___next__(self)
NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper_swigregister = _XCAFPrs.NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper_swigregister
NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper_swigregister(NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style_IteratorHelper)


try:
	XCAFPrs_DataMapOfStyleShape = NCollection_DataMap_XCAFPrs_Style_TopoDS_Shape_XCAFPrs_Style
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntCurveSurface')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntCurveSurface')
    _IntCurveSurface = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntCurveSurface', [dirname(__file__)])
        except ImportError:
            import _IntCurveSurface
            return _IntCurveSurface
        try:
            _mod = imp.load_module('_IntCurveSurface', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntCurveSurface = swig_import_helper()
    del swig_import_helper
else:
    import _IntCurveSurface
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntCurveSurface.delete_SwigPyIterator

    def value(self):
        return _IntCurveSurface.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntCurveSurface.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntCurveSurface.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntCurveSurface.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntCurveSurface.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntCurveSurface.SwigPyIterator_copy(self)

    def next(self):
        return _IntCurveSurface.SwigPyIterator_next(self)

    def __next__(self):
        return _IntCurveSurface.SwigPyIterator___next__(self)

    def previous(self):
        return _IntCurveSurface.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntCurveSurface.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntCurveSurface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntCurveSurface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntCurveSurface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntCurveSurface.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntCurveSurface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntCurveSurface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntCurveSurface.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntCurveSurface.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntCurveSurface.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntCurveSurface.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntCurveSurface.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurveSurface.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntCurveSurface.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntCurveSurface.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntCurveSurface.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntCurveSurface.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntCurveSurface.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntCurveSurface.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntCurveSurface.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurveSurface.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntCurveSurface.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntCurveSurface.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntCurveSurface.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntCurveSurface.ptr_to_number(item)
ptr_to_number = _IntCurveSurface.ptr_to_number

def HashCode(*args):
    return _IntCurveSurface.HashCode(*args)
HashCode = _IntCurveSurface.HashCode

def ptr_equal(a, b):
    return _IntCurveSurface.ptr_equal(a, b)
ptr_equal = _IntCurveSurface.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
IntCurveSurface_Tangent = _IntCurveSurface.IntCurveSurface_Tangent
IntCurveSurface_In = _IntCurveSurface.IntCurveSurface_In
IntCurveSurface_Out = _IntCurveSurface.IntCurveSurface_Out
class IntCurveSurface_IntersectionSegment(object):
    """
    A IntersectionSegment describes a segment of curve
    (w1,w2) where distance(C(w),Surface) is less than a
    given tolerances.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_IntersectionSegment self) -> IntCurveSurface_IntersectionSegment
        __init__(IntCurveSurface_IntersectionSegment self, IntCurveSurface_IntersectionPoint P1, IntCurveSurface_IntersectionPoint P2) -> IntCurveSurface_IntersectionSegment

        :type P1: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint
        :type P2: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint

        """
        this = _IntCurveSurface.new_IntCurveSurface_IntersectionSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValues(self, *args):
        """
        SetValues(IntCurveSurface_IntersectionSegment self, IntCurveSurface_IntersectionPoint P1, IntCurveSurface_IntersectionPoint P2)

        :type P1: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint
        :type P2: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_SetValues(self, *args)


    def Values(self, *args):
        """
        Values(IntCurveSurface_IntersectionSegment self, IntCurveSurface_IntersectionPoint P1, IntCurveSurface_IntersectionPoint P2)

        :type P1: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint
        :type P2: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_Values(self, *args)


    def FirstPoint(self, *args):
        """
        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint

        """
        res = _IntCurveSurface.IntCurveSurface_IntersectionSegment_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SecondPoint(self, *args):
        """
        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint

        """
        res = _IntCurveSurface.IntCurveSurface_IntersectionSegment_SecondPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """Dump(IntCurveSurface_IntersectionSegment self)"""
        return _IntCurveSurface.IntCurveSurface_IntersectionSegment_Dump(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_IntersectionSegment
IntCurveSurface_IntersectionSegment_swigregister = _IntCurveSurface.IntCurveSurface_IntersectionSegment_swigregister
IntCurveSurface_IntersectionSegment_swigregister(IntCurveSurface_IntersectionSegment)

class IntCurveSurface_IntersectionPoint(object):
    """
    Definition of an interserction point between a
    curve and a surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_IntersectionPoint self) -> IntCurveSurface_IntersectionPoint
        __init__(IntCurveSurface_IntersectionPoint self, gp_Pnt P, Standard_Real const USurf, Standard_Real const VSurf, Standard_Real const UCurv, IntCurveSurface_TransitionOnCurve const TrCurv) -> IntCurveSurface_IntersectionPoint

        Create an IntersectionPoint.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type USurf: float
        :type VSurf: float
        :type UCurv: float
        :type TrCurv: OCC.wrapper.IntCurveSurface.IntCurveSurface_TransitionOnCurve

        """
        this = _IntCurveSurface.new_IntCurveSurface_IntersectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValues(self, *args):
        """
        SetValues(IntCurveSurface_IntersectionPoint self, gp_Pnt P, Standard_Real const USurf, Standard_Real const VSurf, Standard_Real const UCurv, IntCurveSurface_TransitionOnCurve const TrCurv)

        Set the fields of the current IntersectionPoint.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type USurf: float
        :type VSurf: float
        :type UCurv: float
        :type TrCurv: OCC.wrapper.IntCurveSurface.IntCurveSurface_TransitionOnCurve

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_SetValues(self, *args)


    def Values(self, *args):
        """
        Values(IntCurveSurface_IntersectionPoint self, gp_Pnt P)

        Get the fields of the current IntersectionPoint.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type USurf: float
        :type VSurf: float
        :type UCurv: float
        :type TrCurv: OCC.wrapper.IntCurveSurface.IntCurveSurface_TransitionOnCurve

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_Values(self, *args)


    def Pnt(self, *args):
        """
        returns the geometric point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntCurveSurface.IntCurveSurface_IntersectionPoint_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def U(self, *args):
        """
        U(IntCurveSurface_IntersectionPoint self) -> Standard_Real

        returns the U parameter on the surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_U(self, *args)


    def V(self, *args):
        """
        V(IntCurveSurface_IntersectionPoint self) -> Standard_Real

        returns the V parameter on the surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_V(self, *args)


    def W(self, *args):
        """
        W(IntCurveSurface_IntersectionPoint self) -> Standard_Real

        returns the parameter on the curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_W(self, *args)


    def Transition(self, *args):
        """
        Transition(IntCurveSurface_IntersectionPoint self) -> IntCurveSurface_TransitionOnCurve

        returns the Transition of the point.

        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_TransitionOnCurve

        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_Transition(self, *args)


    def Dump(self, *args):
        """
        Dump(IntCurveSurface_IntersectionPoint self)

        Dump all the fields.


        """
        return _IntCurveSurface.IntCurveSurface_IntersectionPoint_Dump(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_IntersectionPoint
IntCurveSurface_IntersectionPoint_swigregister = _IntCurveSurface.IntCurveSurface_IntersectionPoint_swigregister
IntCurveSurface_IntersectionPoint_swigregister(IntCurveSurface_IntersectionPoint)

class IntCurveSurface_Intersection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(IntCurveSurface_Intersection self) -> Standard_Boolean

        returns the <done> field.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_Intersection_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntCurveSurface_Intersection self) -> Standard_Integer

        returns the number of IntersectionPoint
        if IsDone returns True.
        else NotDone is raised.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_Intersection_NbPoints(self, *args)


    def Point(self, *args):
        """
        returns the IntersectionPoint of range <Index>
        raises NotDone if the computation has failed or if
        the computation has not been done
        raises OutOfRange if Index is not in the range <1..NbPoints>

        :type Index: int
        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionPoint

        """
        res = _IntCurveSurface.IntCurveSurface_Intersection_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSegments(self, *args):
        """
        NbSegments(IntCurveSurface_Intersection self) -> Standard_Integer

        returns the number of IntersectionSegment
        if IsDone returns True.
        else NotDone is raised.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_Intersection_NbSegments(self, *args)


    def Segment(self, *args):
        """
        returns the IntersectionSegment of range <Index>
        raises NotDone if the computation has failed or if
        the computation has not been done
        raises OutOfRange if Index is not in the range <1..NbSegment>

        :type Index: int
        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_IntersectionSegment

        """
        res = _IntCurveSurface.IntCurveSurface_Intersection_Segment(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsParallel(self, *args):
        """
        IsParallel(IntCurveSurface_Intersection self) -> Standard_Boolean

        Returns true if curve is parallel or belongs surface
        This case is recognized only for some pairs 
        of analytical curves and surfaces (plane - line, ...)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_Intersection_IsParallel(self, *args)


    def Dump(self, *args):
        """
        Dump(IntCurveSurface_Intersection self)

        Dump all the fields.


        """
        return _IntCurveSurface.IntCurveSurface_Intersection_Dump(self, *args)

IntCurveSurface_Intersection_swigregister = _IntCurveSurface.IntCurveSurface_Intersection_swigregister
IntCurveSurface_Intersection_swigregister(IntCurveSurface_Intersection)

class NCollection_Sequence_IntCurveSurface_IntersectionPoint(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> NCollection_Sequence< IntCurveSurface_IntersectionPoint >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> NCollection_Sequence< IntCurveSurface_IntersectionPoint >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> NCollection_Sequence< IntCurveSurface_IntersectionPoint >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> NCollection_Sequence< IntCurveSurface_IntersectionPoint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntCurveSurface.new_NCollection_Sequence_IntCurveSurface_IntersectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntCurveSurface_IntersectionPoint self)

        Reverse sequence


        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, NCollection_Sequence_IntCurveSurface_IntersectionPoint theOther) -> NCollection_Sequence_IntCurveSurface_IntersectionPoint

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, NCollection_Sequence_IntCurveSurface_IntersectionPoint theOther) -> NCollection_Sequence_IntCurveSurface_IntersectionPoint

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, NCollection_Sequence< IntCurveSurface_IntersectionPoint >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, IntCurveSurface_IntersectionPoint theItem)
        Append(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, NCollection_Sequence_IntCurveSurface_IntersectionPoint theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, IntCurveSurface_IntersectionPoint theItem)
        Prepend(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, NCollection_Sequence_IntCurveSurface_IntersectionPoint theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex, IntCurveSurface_IntersectionPoint theItem)
        InsertBefore(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntCurveSurface_IntersectionPoint theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, NCollection_Sequence< IntCurveSurface_IntersectionPoint >::Iterator & thePosition, IntCurveSurface_IntersectionPoint theItem)
        InsertAfter(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntCurveSurface_IntersectionPoint theSeq)
        InsertAfter(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex, IntCurveSurface_IntersectionPoint theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntCurveSurface_IntersectionPoint theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> IntCurveSurface_IntersectionPoint

        First item access

        :rtype: TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntCurveSurface_IntersectionPoint self) -> IntCurveSurface_IntersectionPoint

        Last item access

        :rtype: TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex) -> IntCurveSurface_IntersectionPoint

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntCurveSurface_IntersectionPoint self, Standard_Integer const theIndex, IntCurveSurface_IntersectionPoint theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_SetValue(self, *args)


    def __iter__(self):
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint___iter__(self)
    __swig_destroy__ = _IntCurveSurface.delete_NCollection_Sequence_IntCurveSurface_IntersectionPoint
NCollection_Sequence_IntCurveSurface_IntersectionPoint_swigregister = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_swigregister
NCollection_Sequence_IntCurveSurface_IntersectionPoint_swigregister(NCollection_Sequence_IntCurveSurface_IntersectionPoint)

def NCollection_Sequence_IntCurveSurface_IntersectionPoint_delNode(*args):
    """
    NCollection_Sequence_IntCurveSurface_IntersectionPoint_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_delNode(*args)

class NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntCurveSurface.new_NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurveSurface.delete_NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper

    def __next__(self):
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper___next__(self)
NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper_swigregister = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper_swigregister
NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper_swigregister(NCollection_Sequence_IntCurveSurface_IntersectionPoint_IteratorHelper)


try:
	IntCurveSurface_SequenceOfPnt = NCollection_Sequence_IntCurveSurface_IntersectionPoint
except NameError:
	pass # does not exist, probably ignored

class IntCurveSurface_TheHCurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Handle_Adaptor3d_HCurve C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Handle_Adaptor3d_HCurve C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(myclass) >= <S>

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Handle_Adaptor3d_HCurve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args):
        """
        IsClosed(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Handle_Adaptor3d_HCurve C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(Handle_Adaptor3d_HCurve C, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Handle_Adaptor3d_HCurve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(Handle_Adaptor3d_HCurve C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Handle_Adaptor3d_HCurve C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(Handle_Adaptor3d_HCurve C) -> gp_Lin

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Handle_Adaptor3d_HCurve C) -> gp_Circ

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Handle_Adaptor3d_HCurve C) -> gp_Elips

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Handle_Adaptor3d_HCurve C) -> gp_Hypr

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Handle_Adaptor3d_HCurve C) -> gp_Parab

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BezierCurve

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BSplineCurve

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def NbSamples(*args):
        """
        NbSamples(Handle_Adaptor3d_HCurve C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def SamplePars(*args):
        """
        SamplePars(Handle_Adaptor3d_HCurve C, Standard_Real const U0, Standard_Real const U1, Standard_Real const Defl, Standard_Integer const NbMin, Handle_TColStd_HArray1OfReal Pars)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type U0: float
        :type U1: float
        :type Defl: float
        :type NbMin: int
        :type Pars: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _IntCurveSurface.IntCurveSurface_TheHCurveTool_SamplePars(*args)

    SamplePars = staticmethod(SamplePars)

    def __init__(self):
        this = _IntCurveSurface.new_IntCurveSurface_TheHCurveTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheHCurveTool
IntCurveSurface_TheHCurveTool_swigregister = _IntCurveSurface.IntCurveSurface_TheHCurveTool_swigregister
IntCurveSurface_TheHCurveTool_swigregister(IntCurveSurface_TheHCurveTool)

def IntCurveSurface_TheHCurveTool_FirstParameter(*args):
    """
    IntCurveSurface_TheHCurveTool_FirstParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_FirstParameter(*args)

def IntCurveSurface_TheHCurveTool_LastParameter(*args):
    """
    IntCurveSurface_TheHCurveTool_LastParameter(Handle_Adaptor3d_HCurve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_LastParameter(*args)

def IntCurveSurface_TheHCurveTool_Continuity(*args):
    """
    IntCurveSurface_TheHCurveTool_Continuity(Handle_Adaptor3d_HCurve C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Continuity(*args)

def IntCurveSurface_TheHCurveTool_NbIntervals(*args):
    """
    IntCurveSurface_TheHCurveTool_NbIntervals(Handle_Adaptor3d_HCurve C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(myclass) >= <S>

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbIntervals(*args)

def IntCurveSurface_TheHCurveTool_Intervals(*args):
    """
    IntCurveSurface_TheHCurveTool_Intervals(Handle_Adaptor3d_HCurve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Intervals(*args)

def IntCurveSurface_TheHCurveTool_IsClosed(*args):
    """
    IntCurveSurface_TheHCurveTool_IsClosed(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsClosed(*args)

def IntCurveSurface_TheHCurveTool_IsPeriodic(*args):
    """
    IntCurveSurface_TheHCurveTool_IsPeriodic(Handle_Adaptor3d_HCurve C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_IsPeriodic(*args)

def IntCurveSurface_TheHCurveTool_Period(*args):
    """
    IntCurveSurface_TheHCurveTool_Period(Handle_Adaptor3d_HCurve C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Period(*args)

def IntCurveSurface_TheHCurveTool_Value(*args):
    """
    IntCurveSurface_TheHCurveTool_Value(Handle_Adaptor3d_HCurve C, Standard_Real const U) -> gp_Pnt

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Value(*args)

def IntCurveSurface_TheHCurveTool_D0(*args):
    """
    IntCurveSurface_TheHCurveTool_D0(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D0(*args)

def IntCurveSurface_TheHCurveTool_D1(*args):
    """
    IntCurveSurface_TheHCurveTool_D1(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V)

    Computes the point of parameter U on the curve with its
    first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V: OCC.wrapper.gp.gp_Vec

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D1(*args)

def IntCurveSurface_TheHCurveTool_D2(*args):
    """
    IntCurveSurface_TheHCurveTool_D2(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D2(*args)

def IntCurveSurface_TheHCurveTool_D3(*args):
    """
    IntCurveSurface_TheHCurveTool_D3(Handle_Adaptor3d_HCurve C, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec
    :type V2: OCC.wrapper.gp.gp_Vec
    :type V3: OCC.wrapper.gp.gp_Vec

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_D3(*args)

def IntCurveSurface_TheHCurveTool_DN(*args):
    """
    IntCurveSurface_TheHCurveTool_DN(Handle_Adaptor3d_HCurve C, Standard_Real const U, Standard_Integer const N) -> gp_Vec

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_DN(*args)

def IntCurveSurface_TheHCurveTool_Resolution(*args):
    """
    IntCurveSurface_TheHCurveTool_Resolution(Handle_Adaptor3d_HCurve C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Resolution(*args)

def IntCurveSurface_TheHCurveTool_GetType(*args):
    """
    IntCurveSurface_TheHCurveTool_GetType(Handle_Adaptor3d_HCurve C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_GetType(*args)

def IntCurveSurface_TheHCurveTool_Line(*args):
    """
    IntCurveSurface_TheHCurveTool_Line(Handle_Adaptor3d_HCurve C) -> gp_Lin

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Line(*args)

def IntCurveSurface_TheHCurveTool_Circle(*args):
    """
    IntCurveSurface_TheHCurveTool_Circle(Handle_Adaptor3d_HCurve C) -> gp_Circ

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Circle(*args)

def IntCurveSurface_TheHCurveTool_Ellipse(*args):
    """
    IntCurveSurface_TheHCurveTool_Ellipse(Handle_Adaptor3d_HCurve C) -> gp_Elips

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Elips

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Ellipse(*args)

def IntCurveSurface_TheHCurveTool_Hyperbola(*args):
    """
    IntCurveSurface_TheHCurveTool_Hyperbola(Handle_Adaptor3d_HCurve C) -> gp_Hypr

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Hypr

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Hyperbola(*args)

def IntCurveSurface_TheHCurveTool_Parabola(*args):
    """
    IntCurveSurface_TheHCurveTool_Parabola(Handle_Adaptor3d_HCurve C) -> gp_Parab

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.gp.gp_Parab

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Parabola(*args)

def IntCurveSurface_TheHCurveTool_Bezier(*args):
    """
    IntCurveSurface_TheHCurveTool_Bezier(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BezierCurve

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_Bezier(*args)

def IntCurveSurface_TheHCurveTool_BSpline(*args):
    """
    IntCurveSurface_TheHCurveTool_BSpline(Handle_Adaptor3d_HCurve C) -> Handle_Geom_BSplineCurve

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_BSpline(*args)

def IntCurveSurface_TheHCurveTool_NbSamples(*args):
    """
    IntCurveSurface_TheHCurveTool_NbSamples(Handle_Adaptor3d_HCurve C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_NbSamples(*args)

def IntCurveSurface_TheHCurveTool_SamplePars(*args):
    """
    IntCurveSurface_TheHCurveTool_SamplePars(Handle_Adaptor3d_HCurve C, Standard_Real const U0, Standard_Real const U1, Standard_Real const Defl, Standard_Integer const NbMin, Handle_TColStd_HArray1OfReal Pars)

    :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
    :type U0: float
    :type U1: float
    :type Defl: float
    :type NbMin: int
    :type Pars: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

    """
    return _IntCurveSurface.IntCurveSurface_TheHCurveTool_SamplePars(*args)

class NCollection_Sequence_IntCurveSurface_IntersectionSegment(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> NCollection_Sequence< IntCurveSurface_IntersectionSegment >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> NCollection_Sequence< IntCurveSurface_IntersectionSegment >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> NCollection_Sequence< IntCurveSurface_IntersectionSegment >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> NCollection_Sequence< IntCurveSurface_IntersectionSegment >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntCurveSurface.new_NCollection_Sequence_IntCurveSurface_IntersectionSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntCurveSurface_IntersectionSegment self)

        Reverse sequence


        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, NCollection_Sequence_IntCurveSurface_IntersectionSegment theOther) -> NCollection_Sequence_IntCurveSurface_IntersectionSegment

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, NCollection_Sequence_IntCurveSurface_IntersectionSegment theOther) -> NCollection_Sequence_IntCurveSurface_IntersectionSegment

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, NCollection_Sequence< IntCurveSurface_IntersectionSegment >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, IntCurveSurface_IntersectionSegment theItem)
        Append(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, NCollection_Sequence_IntCurveSurface_IntersectionSegment theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, IntCurveSurface_IntersectionSegment theItem)
        Prepend(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, NCollection_Sequence_IntCurveSurface_IntersectionSegment theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex, IntCurveSurface_IntersectionSegment theItem)
        InsertBefore(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex, NCollection_Sequence_IntCurveSurface_IntersectionSegment theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, NCollection_Sequence< IntCurveSurface_IntersectionSegment >::Iterator & thePosition, IntCurveSurface_IntersectionSegment theItem)
        InsertAfter(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex, NCollection_Sequence_IntCurveSurface_IntersectionSegment theSeq)
        InsertAfter(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex, IntCurveSurface_IntersectionSegment theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex, NCollection_Sequence_IntCurveSurface_IntersectionSegment theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> IntCurveSurface_IntersectionSegment

        First item access

        :rtype: TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntCurveSurface_IntersectionSegment self) -> IntCurveSurface_IntersectionSegment

        Last item access

        :rtype: TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex) -> IntCurveSurface_IntersectionSegment

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntCurveSurface_IntersectionSegment self, Standard_Integer const theIndex, IntCurveSurface_IntersectionSegment theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_SetValue(self, *args)


    def __iter__(self):
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment___iter__(self)
    __swig_destroy__ = _IntCurveSurface.delete_NCollection_Sequence_IntCurveSurface_IntersectionSegment
NCollection_Sequence_IntCurveSurface_IntersectionSegment_swigregister = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_swigregister
NCollection_Sequence_IntCurveSurface_IntersectionSegment_swigregister(NCollection_Sequence_IntCurveSurface_IntersectionSegment)

def NCollection_Sequence_IntCurveSurface_IntersectionSegment_delNode(*args):
    """
    NCollection_Sequence_IntCurveSurface_IntersectionSegment_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_delNode(*args)

class NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntCurveSurface.new_NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurveSurface.delete_NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper

    def __next__(self):
        return _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper___next__(self)
NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper_swigregister = _IntCurveSurface.NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper_swigregister
NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper_swigregister(NCollection_Sequence_IntCurveSurface_IntersectionSegment_IteratorHelper)


try:
	IntCurveSurface_SequenceOfSeg = NCollection_Sequence_IntCurveSurface_IntersectionSegment
except NameError:
	pass # does not exist, probably ignored

class IntCurveSurface_ThePolyhedronOfHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_ThePolyhedronOfHInter self, Handle_Adaptor3d_HSurface Surface, Standard_Integer const nbdU, Standard_Integer const nbdV, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2) -> IntCurveSurface_ThePolyhedronOfHInter
        __init__(IntCurveSurface_ThePolyhedronOfHInter self, Handle_Adaptor3d_HSurface Surface, NCollection_Array1_Standard_Real Upars, NCollection_Array1_Standard_Real Vpars) -> IntCurveSurface_ThePolyhedronOfHInter

        :type Surface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Upars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Vpars: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _IntCurveSurface.new_IntCurveSurface_ThePolyhedronOfHInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """Destroy(IntCurveSurface_ThePolyhedronOfHInter self)"""
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Destroy(self, *args)


    def DeflectionOnTriangle(self, *args):
        """
        DeflectionOnTriangle(IntCurveSurface_ThePolyhedronOfHInter self, Handle_Adaptor3d_HSurface Surface, Standard_Integer const Index) -> Standard_Real

        :type Surface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_DeflectionOnTriangle(self, *args)


    def Size(self, *args):
        """
        Size(IntCurveSurface_ThePolyhedronOfHInter self)

        get the size of the discretization.

        :type nbdu: int
        :type nbdv: int

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Size(self, *args)


    def NbTriangles(self, *args):
        """
        NbTriangles(IntCurveSurface_ThePolyhedronOfHInter self) -> Standard_Integer

        Give the number of triangles in this double array of

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_NbTriangles(self, *args)


    def Triangle(self, *args):
        """
        Triangle(IntCurveSurface_ThePolyhedronOfHInter self, Standard_Integer const Index)

        Give the 3 points of the triangle of addresse Index in
        the double array of triangles.

        :type Index: int
        :type P1: int
        :type P2: int
        :type P3: int

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Triangle(self, *args)


    def TriConnex(self, *args):
        """
        TriConnex(IntCurveSurface_ThePolyhedronOfHInter self, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

        Give the addresse Tricon of the triangle connexe to the
        triangle of address Triang by the edge Pivot Pedge and
        the third point of this connexe triangle. When we are
        on a free edge TriCon==0 but the function return the
        value of the triangle in the other side of Pivot on
        the free edge. Used to turn around a vertex.

        :type Triang: int
        :type Pivot: int
        :type Pedge: int
        :type TriCon: int
        :type OtherP: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_TriConnex(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntCurveSurface_ThePolyhedronOfHInter self) -> Standard_Integer

        Give the number of point in the double array of
        triangles ((nbdu+1)*(nbdv+1)).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_NbPoints(self, *args)


    def Point(self, *args):
        """
        Give the point of index i in the MaTriangle.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bounding(self, *args):
        """
        Give the bounding box of the MaTriangle.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Bounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillBounding(self, *args):
        """
        FillBounding(IntCurveSurface_ThePolyhedronOfHInter self)

        Compute the array of boxes. The box <n> corresponding
        to the triangle <n>.


        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_FillBounding(self, *args)


    def ComponentsBounding(self, *args):
        """
        Give the array of boxes. The box <n> corresponding
        to the triangle <n>.

        :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

        """
        res = _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_ComponentsBounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(IntCurveSurface_ThePolyhedronOfHInter self, Standard_Real const flec)
        DeflectionOverEstimation(IntCurveSurface_ThePolyhedronOfHInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_DeflectionOverEstimation(self, *args)


    def PlaneEquation(self, *args):
        """
        PlaneEquation(IntCurveSurface_ThePolyhedronOfHInter self, Standard_Integer const Triang, gp_XYZ NormalVector)

        Give the plane equation of the triangle of addresse Triang.

        :type Triang: int
        :type NormalVector: OCC.wrapper.gp.gp_XYZ
        :type PolarDistance: float

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_PlaneEquation(self, *args)


    def Contain(self, *args):
        """
        Contain(IntCurveSurface_ThePolyhedronOfHInter self, Standard_Integer const Triang, gp_Pnt ThePnt) -> Standard_Boolean

        Give the plane equation of the triangle of addresse Triang.

        :type Triang: int
        :type ThePnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Contain(self, *args)


    def Parameters(self, *args):
        """
        Parameters(IntCurveSurface_ThePolyhedronOfHInter self, Standard_Integer const Index)

        :type Index: int
        :type U: float
        :type V: float

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Parameters(self, *args)


    def IsOnBound(self, *args):
        """
        IsOnBound(IntCurveSurface_ThePolyhedronOfHInter self, Standard_Integer const Index1, Standard_Integer const Index2) -> Standard_Boolean

        This method returns true if the edge based on points with
        indices Index1 and Index2 represents a boundary edge. It is
        necessary to take into account the boundary deflection for
        this edge.

        :type Index1: int
        :type Index2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_IsOnBound(self, *args)


    def GetBorderDeflection(self, *args):
        """
        GetBorderDeflection(IntCurveSurface_ThePolyhedronOfHInter self) -> Standard_Real

        This method returns a border deflection.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_GetBorderDeflection(self, *args)


    def Dump(self, *args):
        """Dump(IntCurveSurface_ThePolyhedronOfHInter self)"""
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_Dump(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_ThePolyhedronOfHInter
IntCurveSurface_ThePolyhedronOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter_swigregister
IntCurveSurface_ThePolyhedronOfHInter_swigregister(IntCurveSurface_ThePolyhedronOfHInter)

class IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter self, IntSurf_Quadric Q, Handle_Adaptor3d_HCurve C) -> IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter

        Create the function.

        :type Q: OCC.wrapper.IntSurf.IntSurf_Quadric
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _IntCurveSurface.new_IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the value of the signed  distance between
        the  implicit surface and  the point  at parameter
        Param on the parametrised curve.
        Value always returns True.

        :type Param: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the derivative of the previous function at
        parameter Param.
        Derivative always returns True.

        :type Param: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter self, Standard_Real const Param) -> Standard_Boolean

        Computes the value and the derivative of the function.
        returns True.

        :type Param: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_Values(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter
IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_swigregister
IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter_swigregister(IntCurveSurface_TheQuadCurvFuncOfTheQuadCurvExactHInter)

class IntCurveSurface_TheInterferenceOfHInter(Intf.Intf_Interference):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_TheInterferenceOfHInter self) -> IntCurveSurface_TheInterferenceOfHInter
        __init__(IntCurveSurface_TheInterferenceOfHInter self, IntCurveSurface_ThePolygonOfHInter thePolyg, IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> IntCurveSurface_TheInterferenceOfHInter
        __init__(IntCurveSurface_TheInterferenceOfHInter self, gp_Lin theLin, IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> IntCurveSurface_TheInterferenceOfHInter
        __init__(IntCurveSurface_TheInterferenceOfHInter self, NCollection_Array1_gp_Lin theLins, IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> IntCurveSurface_TheInterferenceOfHInter
        __init__(IntCurveSurface_TheInterferenceOfHInter self, IntCurveSurface_ThePolygonOfHInter thePolyg, IntCurveSurface_ThePolyhedronOfHInter thePolyh, Bnd_BoundSortBox theBoundSB) -> IntCurveSurface_TheInterferenceOfHInter
        __init__(IntCurveSurface_TheInterferenceOfHInter self, gp_Lin theLin, IntCurveSurface_ThePolyhedronOfHInter thePolyh, Bnd_BoundSortBox theBoundSB) -> IntCurveSurface_TheInterferenceOfHInter
        __init__(IntCurveSurface_TheInterferenceOfHInter self, NCollection_Array1_gp_Lin theLins, IntCurveSurface_ThePolyhedronOfHInter thePolyh, Bnd_BoundSortBox theBoundSB) -> IntCurveSurface_TheInterferenceOfHInter

        Constructs   and   computes  an  interference   between the
        Straight Lines and the Polyhedron.

        :type theLins: OCC.wrapper.Intf.Intf_Array1OfLin
        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :type theBoundSB: OCC.wrapper.Bnd.Bnd_BoundSortBox

        """
        this = _IntCurveSurface.new_IntCurveSurface_TheInterferenceOfHInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntCurveSurface_TheInterferenceOfHInter self, IntCurveSurface_ThePolygonOfHInter thePolyg, IntCurveSurface_ThePolyhedronOfHInter thePolyh)
        Perform(IntCurveSurface_TheInterferenceOfHInter self, gp_Lin theLin, IntCurveSurface_ThePolyhedronOfHInter thePolyh)
        Perform(IntCurveSurface_TheInterferenceOfHInter self, NCollection_Array1_gp_Lin theLins, IntCurveSurface_ThePolyhedronOfHInter thePolyh)
        Perform(IntCurveSurface_TheInterferenceOfHInter self, IntCurveSurface_ThePolygonOfHInter thePolyg, IntCurveSurface_ThePolyhedronOfHInter thePolyh, Bnd_BoundSortBox theBoundSB)
        Perform(IntCurveSurface_TheInterferenceOfHInter self, gp_Lin theLin, IntCurveSurface_ThePolyhedronOfHInter thePolyh, Bnd_BoundSortBox theBoundSB)
        Perform(IntCurveSurface_TheInterferenceOfHInter self, NCollection_Array1_gp_Lin theLins, IntCurveSurface_ThePolyhedronOfHInter thePolyh, Bnd_BoundSortBox theBoundSB)

        Computes an interference  between the  Straight Lines  and
        the Polyhedron.

        :type theLins: OCC.wrapper.Intf.Intf_Array1OfLin
        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :type theBoundSB: OCC.wrapper.Bnd.Bnd_BoundSortBox

        """
        return _IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_Perform(self, *args)


    def Interference(self, *args):
        """
        Interference(IntCurveSurface_TheInterferenceOfHInter self, IntCurveSurface_ThePolygonOfHInter thePolyg, IntCurveSurface_ThePolyhedronOfHInter thePolyh, Bnd_BoundSortBox theBoundSB)
        Interference(IntCurveSurface_TheInterferenceOfHInter self, IntCurveSurface_ThePolygonOfHInter thePolyg, IntCurveSurface_ThePolyhedronOfHInter thePolyh)

        Compares the boundings between the segment of <thePolyg> and
        the facets of <thePolyh>.

        :type thePolyg: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter

        """
        return _IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_Interference(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheInterferenceOfHInter
IntCurveSurface_TheInterferenceOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheInterferenceOfHInter_swigregister
IntCurveSurface_TheInterferenceOfHInter_swigregister(IntCurveSurface_TheInterferenceOfHInter)

class IntCurveSurface_TheQuadCurvExactHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_TheQuadCurvExactHInter self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C) -> IntCurveSurface_TheQuadCurvExactHInter

        Provides the signed distance function : Q(w)
        and its first derivative dQ(w)/dw

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _IntCurveSurface.new_IntCurveSurface_TheQuadCurvExactHInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(IntCurveSurface_TheQuadCurvExactHInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_IsDone(self, *args)


    def NbRoots(self, *args):
        """
        NbRoots(IntCurveSurface_TheQuadCurvExactHInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_NbRoots(self, *args)


    def Root(self, *args):
        """
        Root(IntCurveSurface_TheQuadCurvExactHInter self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_Root(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(IntCurveSurface_TheQuadCurvExactHInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(IntCurveSurface_TheQuadCurvExactHInter self, Standard_Integer const Index)

        U1 and U2 are the parameters of
        a segment on the curve.

        :type Index: int
        :type U1: float
        :type U2: float

        """
        return _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_Intervals(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheQuadCurvExactHInter
IntCurveSurface_TheQuadCurvExactHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheQuadCurvExactHInter_swigregister
IntCurveSurface_TheQuadCurvExactHInter_swigregister(IntCurveSurface_TheQuadCurvExactHInter)

class IntCurveSurface_TheCSFunctionOfHInter(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_TheCSFunctionOfHInter self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C) -> IntCurveSurface_TheCSFunctionOfHInter

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _IntCurveSurface.new_IntCurveSurface_TheCSFunctionOfHInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(IntCurveSurface_TheCSFunctionOfHInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(IntCurveSurface_TheCSFunctionOfHInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(IntCurveSurface_TheCSFunctionOfHInter self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(IntCurveSurface_TheCSFunctionOfHInter self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(IntCurveSurface_TheCSFunctionOfHInter self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Values(self, *args)


    def Point(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Root(self, *args):
        """
        Root(IntCurveSurface_TheCSFunctionOfHInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_Root(self, *args)


    def AuxillarSurface(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_AuxillarSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AuxillarCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_AuxillarCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheCSFunctionOfHInter
IntCurveSurface_TheCSFunctionOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter_swigregister
IntCurveSurface_TheCSFunctionOfHInter_swigregister(IntCurveSurface_TheCSFunctionOfHInter)

class IntCurveSurface_HInter(IntCurveSurface_Intersection):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_HInter self) -> IntCurveSurface_HInter

        Empty Constructor


        """
        this = _IntCurveSurface.new_IntCurveSurface_HInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntCurveSurface_HInter self, Handle_Adaptor3d_HCurve Curve, Handle_Adaptor3d_HSurface Surface)
        Perform(IntCurveSurface_HInter self, Handle_Adaptor3d_HCurve Curve, IntCurveSurface_ThePolygonOfHInter Polygon, Handle_Adaptor3d_HSurface Surface)
        Perform(IntCurveSurface_HInter self, Handle_Adaptor3d_HCurve Curve, IntCurveSurface_ThePolygonOfHInter ThePolygon, Handle_Adaptor3d_HSurface Surface, IntCurveSurface_ThePolyhedronOfHInter Polyhedron)
        Perform(IntCurveSurface_HInter self, Handle_Adaptor3d_HCurve Curve, IntCurveSurface_ThePolygonOfHInter ThePolygon, Handle_Adaptor3d_HSurface Surface, IntCurveSurface_ThePolyhedronOfHInter Polyhedron, Bnd_BoundSortBox BndBSB)
        Perform(IntCurveSurface_HInter self, Handle_Adaptor3d_HCurve Curve, Handle_Adaptor3d_HSurface Surface, IntCurveSurface_ThePolyhedronOfHInter Polyhedron)

        Compute the Intersection  between the curve  and
        the surface. The Surface is already  sampled and
        its polyhedron : <Polyhedron> is given.

        :type Curve: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Surface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Polyhedron: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter

        """
        return _IntCurveSurface.IntCurveSurface_HInter_Perform(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_HInter
IntCurveSurface_HInter_swigregister = _IntCurveSurface.IntCurveSurface_HInter_swigregister
IntCurveSurface_HInter_swigregister(IntCurveSurface_HInter)

class IntCurveSurface_ThePolygonToolOfHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args):
        """
        Bounding(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Bnd_Box

        Give the bounding box of the polygon.

        :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def DeflectionOverEstimation(*args):
        """
        DeflectionOverEstimation(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Standard_Real

        :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def Closed(*args):
        """
        Closed(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Standard_Boolean

        :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Closed(*args)

    Closed = staticmethod(Closed)

    def NbSegments(*args):
        """
        NbSegments(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Standard_Integer

        :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    def BeginOfSeg(*args):
        """
        BeginOfSeg(IntCurveSurface_ThePolygonOfHInter thePolygon, Standard_Integer const Index) -> gp_Pnt

        Give the point of range Index in the Polygon.

        :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_BeginOfSeg(*args)

    BeginOfSeg = staticmethod(BeginOfSeg)

    def EndOfSeg(*args):
        """
        EndOfSeg(IntCurveSurface_ThePolygonOfHInter thePolygon, Standard_Integer const Index) -> gp_Pnt

        Give the point of range Index in the Polygon.

        :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_EndOfSeg(*args)

    EndOfSeg = staticmethod(EndOfSeg)

    def Dump(*args):
        """
        Dump(IntCurveSurface_ThePolygonOfHInter thePolygon)

        :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Dump(*args)

    Dump = staticmethod(Dump)

    def __init__(self):
        this = _IntCurveSurface.new_IntCurveSurface_ThePolygonToolOfHInter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_ThePolygonToolOfHInter
IntCurveSurface_ThePolygonToolOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_swigregister
IntCurveSurface_ThePolygonToolOfHInter_swigregister(IntCurveSurface_ThePolygonToolOfHInter)

def IntCurveSurface_ThePolygonToolOfHInter_Bounding(*args):
    """
    IntCurveSurface_ThePolygonToolOfHInter_Bounding(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Bnd_Box

    Give the bounding box of the polygon.

    :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
    :rtype: OCC.wrapper.Bnd.Bnd_Box

    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Bounding(*args)

def IntCurveSurface_ThePolygonToolOfHInter_DeflectionOverEstimation(*args):
    """
    IntCurveSurface_ThePolygonToolOfHInter_DeflectionOverEstimation(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Standard_Real

    :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_DeflectionOverEstimation(*args)

def IntCurveSurface_ThePolygonToolOfHInter_Closed(*args):
    """
    IntCurveSurface_ThePolygonToolOfHInter_Closed(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Standard_Boolean

    :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Closed(*args)

def IntCurveSurface_ThePolygonToolOfHInter_NbSegments(*args):
    """
    IntCurveSurface_ThePolygonToolOfHInter_NbSegments(IntCurveSurface_ThePolygonOfHInter thePolygon) -> Standard_Integer

    :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_NbSegments(*args)

def IntCurveSurface_ThePolygonToolOfHInter_BeginOfSeg(*args):
    """
    IntCurveSurface_ThePolygonToolOfHInter_BeginOfSeg(IntCurveSurface_ThePolygonOfHInter thePolygon, Standard_Integer const Index) -> gp_Pnt

    Give the point of range Index in the Polygon.

    :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
    :type Index: int
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_BeginOfSeg(*args)

def IntCurveSurface_ThePolygonToolOfHInter_EndOfSeg(*args):
    """
    IntCurveSurface_ThePolygonToolOfHInter_EndOfSeg(IntCurveSurface_ThePolygonOfHInter thePolygon, Standard_Integer const Index) -> gp_Pnt

    Give the point of range Index in the Polygon.

    :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter
    :type Index: int
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_EndOfSeg(*args)

def IntCurveSurface_ThePolygonToolOfHInter_Dump(*args):
    """
    IntCurveSurface_ThePolygonToolOfHInter_Dump(IntCurveSurface_ThePolygonOfHInter thePolygon)

    :type thePolygon: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolygonOfHInter

    """
    return _IntCurveSurface.IntCurveSurface_ThePolygonToolOfHInter_Dump(*args)

class IntCurveSurface_ThePolyhedronToolOfHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Bounding(*args):
        """
        Bounding(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Bnd_Box

        Give the bounding box of the PolyhedronTool.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Bounding(*args)

    Bounding = staticmethod(Bounding)

    def ComponentsBounding(*args):
        """
        ComponentsBounding(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Handle_Bnd_HArray1OfBox

        Give the array of boxes. The box <n> corresponding
        to the triangle <n>.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_ComponentsBounding(*args)

    ComponentsBounding = staticmethod(ComponentsBounding)

    def DeflectionOverEstimation(*args):
        """
        DeflectionOverEstimation(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Standard_Real

        Give the tolerance of the polygon.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_DeflectionOverEstimation(*args)

    DeflectionOverEstimation = staticmethod(DeflectionOverEstimation)

    def NbTriangles(*args):
        """
        NbTriangles(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Standard_Integer

        Give the number of triangles in this polyedral surface.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_NbTriangles(*args)

    NbTriangles = staticmethod(NbTriangles)

    def Triangle(*args):
        """
        Triangle(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Index)

        Give the indices  of  the 3 points of  the triangle of
        address Index in the PolyhedronTool.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :type Index: int
        :type P1: int
        :type P2: int
        :type P3: int

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Triangle(*args)

    Triangle = staticmethod(Triangle)

    def Point(*args):
        """
        Point(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Index) -> gp_Pnt

        Give the point of index i in the polyedral surface.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Point(*args)

    Point = staticmethod(Point)

    def TriConnex(*args):
        """
        TriConnex(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

        Give the  addresse Tricon of   the triangle connexe to
        the triangle of address Triang by the edge Pivot Pedge
        and the third point of this  connexe triangle. When we
        are on  a free edge TriCon==0  but the function return
        the value of  the triangle in the  other side of Pivot
        on the free edge.  Used to turn around a vertex.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :type Triang: int
        :type Pivot: int
        :type Pedge: int
        :type TriCon: int
        :type OtherP: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_TriConnex(*args)

    TriConnex = staticmethod(TriConnex)

    def IsOnBound(*args):
        """
        IsOnBound(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Index1, Standard_Integer const Index2) -> Standard_Boolean

        This method returns true if the edge based on points with
        indices Index1 and Index2 represents a boundary edge. It is
        necessary to take into account the boundary deflection for
        this edge.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :type Index1: int
        :type Index2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_IsOnBound(*args)

    IsOnBound = staticmethod(IsOnBound)

    def GetBorderDeflection(*args):
        """
        GetBorderDeflection(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Standard_Real

        This method returns a border deflection of the polyhedron.

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_GetBorderDeflection(*args)

    GetBorderDeflection = staticmethod(GetBorderDeflection)

    def Dump(*args):
        """
        Dump(IntCurveSurface_ThePolyhedronOfHInter thePolyh)

        :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter

        """
        return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Dump(*args)

    Dump = staticmethod(Dump)

    def __init__(self):
        this = _IntCurveSurface.new_IntCurveSurface_ThePolyhedronToolOfHInter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_ThePolyhedronToolOfHInter
IntCurveSurface_ThePolyhedronToolOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_swigregister
IntCurveSurface_ThePolyhedronToolOfHInter_swigregister(IntCurveSurface_ThePolyhedronToolOfHInter)

def IntCurveSurface_ThePolyhedronToolOfHInter_Bounding(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_Bounding(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Bnd_Box

    Give the bounding box of the PolyhedronTool.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :rtype: OCC.wrapper.Bnd.Bnd_Box

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Bounding(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_ComponentsBounding(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_ComponentsBounding(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Handle_Bnd_HArray1OfBox

    Give the array of boxes. The box <n> corresponding
    to the triangle <n>.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :rtype: OCC.wrapper.Bnd.Handle_Bnd_HArray1OfBox

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_ComponentsBounding(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_DeflectionOverEstimation(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_DeflectionOverEstimation(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Standard_Real

    Give the tolerance of the polygon.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_DeflectionOverEstimation(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_NbTriangles(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_NbTriangles(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Standard_Integer

    Give the number of triangles in this polyedral surface.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_NbTriangles(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_Triangle(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_Triangle(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Index)

    Give the indices  of  the 3 points of  the triangle of
    address Index in the PolyhedronTool.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :type Index: int
    :type P1: int
    :type P2: int
    :type P3: int

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Triangle(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_Point(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_Point(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Index) -> gp_Pnt

    Give the point of index i in the polyedral surface.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :type Index: int
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Point(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_TriConnex(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_TriConnex(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Triang, Standard_Integer const Pivot, Standard_Integer const Pedge) -> Standard_Integer

    Give the  addresse Tricon of   the triangle connexe to
    the triangle of address Triang by the edge Pivot Pedge
    and the third point of this  connexe triangle. When we
    are on  a free edge TriCon==0  but the function return
    the value of  the triangle in the  other side of Pivot
    on the free edge.  Used to turn around a vertex.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :type Triang: int
    :type Pivot: int
    :type Pedge: int
    :type TriCon: int
    :type OtherP: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_TriConnex(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_IsOnBound(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_IsOnBound(IntCurveSurface_ThePolyhedronOfHInter thePolyh, Standard_Integer const Index1, Standard_Integer const Index2) -> Standard_Boolean

    This method returns true if the edge based on points with
    indices Index1 and Index2 represents a boundary edge. It is
    necessary to take into account the boundary deflection for
    this edge.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :type Index1: int
    :type Index2: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_IsOnBound(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_GetBorderDeflection(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_GetBorderDeflection(IntCurveSurface_ThePolyhedronOfHInter thePolyh) -> Standard_Real

    This method returns a border deflection of the polyhedron.

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_GetBorderDeflection(*args)

def IntCurveSurface_ThePolyhedronToolOfHInter_Dump(*args):
    """
    IntCurveSurface_ThePolyhedronToolOfHInter_Dump(IntCurveSurface_ThePolyhedronOfHInter thePolyh)

    :type thePolyh: OCC.wrapper.IntCurveSurface.IntCurveSurface_ThePolyhedronOfHInter

    """
    return _IntCurveSurface.IntCurveSurface_ThePolyhedronToolOfHInter_Dump(*args)

class IntCurveSurface_TheExactHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_TheExactHInter self, Standard_Real const U, Standard_Real const V, Standard_Real const W, IntCurveSurface_TheCSFunctionOfHInter F, Standard_Real const TolTangency, Standard_Real const MarginCoef=0.0) -> IntCurveSurface_TheExactHInter
        __init__(IntCurveSurface_TheExactHInter self, IntCurveSurface_TheCSFunctionOfHInter F, Standard_Real const TolTangency) -> IntCurveSurface_TheExactHInter

        initialize the parameters to compute the solution

        :type F: OCC.wrapper.IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter
        :type TolTangency: float

        """
        this = _IntCurveSurface.new_IntCurveSurface_TheExactHInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntCurveSurface_TheExactHInter self, Standard_Real const U, Standard_Real const V, Standard_Real const W, math_FunctionSetRoot Rsnld, Standard_Real const u0, Standard_Real const v0, Standard_Real const u1, Standard_Real const v1, Standard_Real const w0, Standard_Real const w1)

        compute the solution
        it's possible to write to optimize:
        IntImp_IntCS inter(S1,C1,Toltangency)
        math_FunctionSetRoot rsnld(Inter.function())
        while ...{
        u=...
        v=...
        w=...
        inter.Perform(u,v,w,rsnld)
        }
        or
        IntImp_IntCS inter(Toltangency)
        inter.SetSurface(S);
        math_FunctionSetRoot rsnld(Inter.function())
        while ...{
        C=...
        inter.SetCurve(C);
        u=...
        v=...
        w=...
        inter.Perform(u,v,w,rsnld)
        }

        :type U: float
        :type V: float
        :type W: float
        :type Rsnld: OCC.wrapper.math.math_FunctionSetRoot
        :type u0: float
        :type v0: float
        :type u1: float
        :type v1: float
        :type w0: float
        :type w1: float

        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntCurveSurface_TheExactHInter self) -> Standard_Boolean

        Returns TRUE if the creation completed without failure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntCurveSurface_TheExactHInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_IsEmpty(self, *args)


    def Point(self, *args):
        """
        returns the intersection point
        The exception NotDone is raised if IsDone is false.
        The exception DomainError is raised if IsEmpty is true.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntCurveSurface.IntCurveSurface_TheExactHInter_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnCurve(self, *args):
        """
        ParameterOnCurve(IntCurveSurface_TheExactHInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_ParameterOnCurve(self, *args)


    def ParameterOnSurface(self, *args):
        """
        ParameterOnSurface(IntCurveSurface_TheExactHInter self)

        :type U: float
        :type V: float

        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_ParameterOnSurface(self, *args)


    def Function(self, *args):
        """
        Function(IntCurveSurface_TheExactHInter self) -> IntCurveSurface_TheCSFunctionOfHInter

        return the math function which
        is used to compute the intersection

        :rtype: OCC.wrapper.IntCurveSurface.IntCurveSurface_TheCSFunctionOfHInter

        """
        return _IntCurveSurface.IntCurveSurface_TheExactHInter_Function(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_TheExactHInter
IntCurveSurface_TheExactHInter_swigregister = _IntCurveSurface.IntCurveSurface_TheExactHInter_swigregister
IntCurveSurface_TheExactHInter_swigregister(IntCurveSurface_TheExactHInter)

class IntCurveSurface_ThePolygonOfHInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntCurveSurface_ThePolygonOfHInter self, Handle_Adaptor3d_HCurve Curve, Standard_Integer const NbPnt) -> IntCurveSurface_ThePolygonOfHInter
        __init__(IntCurveSurface_ThePolygonOfHInter self, Handle_Adaptor3d_HCurve Curve, Standard_Real const U1, Standard_Real const U2, Standard_Integer const NbPnt) -> IntCurveSurface_ThePolygonOfHInter
        __init__(IntCurveSurface_ThePolygonOfHInter self, Handle_Adaptor3d_HCurve Curve, NCollection_Array1_Standard_Real Upars) -> IntCurveSurface_ThePolygonOfHInter

        :type Curve: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Upars: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _IntCurveSurface.new_IntCurveSurface_ThePolygonOfHInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bounding(self, *args):
        """
        Give the bounding box of the polygon.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Bounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(IntCurveSurface_ThePolygonOfHInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_DeflectionOverEstimation(self, *args)


    def SetDeflectionOverEstimation(self, *args):
        """
        SetDeflectionOverEstimation(IntCurveSurface_ThePolygonOfHInter self, Standard_Real const x)

        :type x: float

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_SetDeflectionOverEstimation(self, *args)


    def Closed(self, *args):
        """
        Closed(IntCurveSurface_ThePolygonOfHInter self, Standard_Boolean const clos)
        Closed(IntCurveSurface_ThePolygonOfHInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Closed(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(IntCurveSurface_ThePolygonOfHInter self) -> Standard_Integer

        Give the number of Segments in the polyline.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_NbSegments(self, *args)


    def BeginOfSeg(self, *args):
        """
        Give the point of range Index in the Polygon.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_BeginOfSeg(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndOfSeg(self, *args):
        """
        Give the point of range Index in the Polygon.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_EndOfSeg(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InfParameter(self, *args):
        """
        InfParameter(IntCurveSurface_ThePolygonOfHInter self) -> Standard_Real

        Returns the parameter (On the curve)
        of the first point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_InfParameter(self, *args)


    def SupParameter(self, *args):
        """
        SupParameter(IntCurveSurface_ThePolygonOfHInter self) -> Standard_Real

        Returns the parameter (On the curve)
        of the last point of the Polygon

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_SupParameter(self, *args)


    def ApproxParamOnCurve(self, *args):
        """
        ApproxParamOnCurve(IntCurveSurface_ThePolygonOfHInter self, Standard_Integer const Index, Standard_Real const ParamOnLine) -> Standard_Real

        Give an approximation of the parameter on the curve
        according to the discretization of the Curve.

        :type Index: int
        :type ParamOnLine: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_ApproxParamOnCurve(self, *args)


    def Dump(self, *args):
        """Dump(IntCurveSurface_ThePolygonOfHInter self)"""
        return _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_Dump(self, *args)

    __swig_destroy__ = _IntCurveSurface.delete_IntCurveSurface_ThePolygonOfHInter
IntCurveSurface_ThePolygonOfHInter_swigregister = _IntCurveSurface.IntCurveSurface_ThePolygonOfHInter_swigregister
IntCurveSurface_ThePolygonOfHInter_swigregister(IntCurveSurface_ThePolygonOfHInter)




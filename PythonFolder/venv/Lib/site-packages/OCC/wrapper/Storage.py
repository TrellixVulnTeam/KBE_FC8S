# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Storage')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Storage')
    _Storage = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Storage', [dirname(__file__)])
        except ImportError:
            import _Storage
            return _Storage
        try:
            _mod = imp.load_module('_Storage', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Storage = swig_import_helper()
    del swig_import_helper
else:
    import _Storage
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Storage.delete_SwigPyIterator

    def value(self):
        return _Storage.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Storage.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Storage.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Storage.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Storage.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Storage.SwigPyIterator_copy(self)

    def next(self):
        return _Storage.SwigPyIterator_next(self)

    def __next__(self):
        return _Storage.SwigPyIterator___next__(self)

    def previous(self):
        return _Storage.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Storage.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Storage.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Storage.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Storage.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Storage.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Storage.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Storage.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Storage.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Storage.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Storage.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Storage.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Storage.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Storage.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Storage.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Storage.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Storage.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Storage.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Storage.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Storage.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Storage.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Storage.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Storage.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Storage.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Storage.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Storage.ptr_to_number(item)
ptr_to_number = _Storage.ptr_to_number

def HashCode(*args):
    return _Storage.HashCode(*args)
HashCode = _Storage.HashCode

def ptr_equal(a, b):
    return _Storage.ptr_equal(a, b)
ptr_equal = _Storage.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
Storage_VSNone = _Storage.Storage_VSNone
Storage_VSRead = _Storage.Storage_VSRead
Storage_VSWrite = _Storage.Storage_VSWrite
Storage_VSReadWrite = _Storage.Storage_VSReadWrite
Storage_VSOk = _Storage.Storage_VSOk
Storage_VSOpenError = _Storage.Storage_VSOpenError
Storage_VSModeError = _Storage.Storage_VSModeError
Storage_VSCloseError = _Storage.Storage_VSCloseError
Storage_VSAlreadyOpen = _Storage.Storage_VSAlreadyOpen
Storage_VSNotOpen = _Storage.Storage_VSNotOpen
Storage_VSSectionNotFound = _Storage.Storage_VSSectionNotFound
Storage_VSWriteError = _Storage.Storage_VSWriteError
Storage_VSFormatError = _Storage.Storage_VSFormatError
Storage_VSUnknownType = _Storage.Storage_VSUnknownType
Storage_VSTypeMismatch = _Storage.Storage_VSTypeMismatch
Storage_VSInternalError = _Storage.Storage_VSInternalError
Storage_VSExtCharParityError = _Storage.Storage_VSExtCharParityError
Storage_VSWrongFileDriver = _Storage.Storage_VSWrongFileDriver
Storage_AddSolve = _Storage.Storage_AddSolve
Storage_WriteSolve = _Storage.Storage_WriteSolve
Storage_ReadSolve = _Storage.Storage_ReadSolve
class Storage_CallBack(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_CallBack
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_CallBack(self) 
            return h


    def New(self, *args):
        """
        New(Storage_CallBack self) -> Handle_Standard_Persistent

        :rtype: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Storage_CallBack_New(self, *args)


    def Add(self, *args):
        """
        Add(Storage_CallBack self, Handle_Standard_Persistent aPers, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Storage_CallBack_Add(self, *args)


    def Write(self, *args):
        """
        Write(Storage_CallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Storage_CallBack_Write(self, *args)


    def Read(self, *args):
        """
        Read(Storage_CallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Storage_CallBack_Read(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_CallBack_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_CallBack_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_CallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_CallBack
Storage_CallBack_swigregister = _Storage.Storage_CallBack_swigregister
Storage_CallBack_swigregister(Storage_CallBack)

def Storage_CallBack_get_type_name(*args):
    """
    Storage_CallBack_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_CallBack_get_type_name(*args)

def Storage_CallBack_get_type_descriptor(*args):
    """
    Storage_CallBack_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_CallBack_get_type_descriptor(*args)

class Storage_StreamReadError(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_StreamReadError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_StreamReadError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_StreamReadError self) -> Storage_StreamReadError
        __init__(Storage_StreamReadError self, Standard_CString const theMessage) -> Storage_StreamReadError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Storage.new_Storage_StreamReadError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamReadError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamReadError

        """
        return _Storage.Storage_StreamReadError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_StreamReadError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_StreamReadError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_StreamReadError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_StreamReadError
Storage_StreamReadError_swigregister = _Storage.Storage_StreamReadError_swigregister
Storage_StreamReadError_swigregister(Storage_StreamReadError)

def Storage_StreamReadError_NewInstance(*args):
    """
    Storage_StreamReadError_NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamReadError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Storage.Handle_Storage_StreamReadError

    """
    return _Storage.Storage_StreamReadError_NewInstance(*args)

def Storage_StreamReadError_get_type_name(*args):
    """
    Storage_StreamReadError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_StreamReadError_get_type_name(*args)

def Storage_StreamReadError_get_type_descriptor(*args):
    """
    Storage_StreamReadError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_StreamReadError_get_type_descriptor(*args)

class Storage_StreamFormatError(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_StreamFormatError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_StreamFormatError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_StreamFormatError self) -> Storage_StreamFormatError
        __init__(Storage_StreamFormatError self, Standard_CString const theMessage) -> Storage_StreamFormatError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Storage.new_Storage_StreamFormatError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamFormatError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamFormatError

        """
        return _Storage.Storage_StreamFormatError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_StreamFormatError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_StreamFormatError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_StreamFormatError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_StreamFormatError
Storage_StreamFormatError_swigregister = _Storage.Storage_StreamFormatError_swigregister
Storage_StreamFormatError_swigregister(Storage_StreamFormatError)

def Storage_StreamFormatError_NewInstance(*args):
    """
    Storage_StreamFormatError_NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamFormatError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Storage.Handle_Storage_StreamFormatError

    """
    return _Storage.Storage_StreamFormatError_NewInstance(*args)

def Storage_StreamFormatError_get_type_name(*args):
    """
    Storage_StreamFormatError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_StreamFormatError_get_type_name(*args)

def Storage_StreamFormatError_get_type_descriptor(*args):
    """
    Storage_StreamFormatError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_StreamFormatError_get_type_descriptor(*args)

class Storage_InternalData(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_InternalData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_InternalData(self) 
            return h


    def ReadArray(self, *args):
        """
        ReadArray(Storage_InternalData self) -> Handle_Storage_HPArray

        :rtype: OCC.wrapper.Storage.Handle_Storage_HPArray

        """
        return _Storage.Storage_InternalData_ReadArray(self, *args)


    def __init__(self, *args):
        """__init__(Storage_InternalData self) -> Storage_InternalData"""
        this = _Storage.new_Storage_InternalData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """Clear(Storage_InternalData self)"""
        return _Storage.Storage_InternalData_Clear(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_InternalData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_InternalData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_InternalData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_InternalData
Storage_InternalData_swigregister = _Storage.Storage_InternalData_swigregister
Storage_InternalData_swigregister(Storage_InternalData)

def Storage_InternalData_get_type_name(*args):
    """
    Storage_InternalData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_InternalData_get_type_name(*args)

def Storage_InternalData_get_type_descriptor(*args):
    """
    Storage_InternalData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_InternalData_get_type_descriptor(*args)

class Storage_HArrayOfCallBack(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_HArrayOfCallBack
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_HArrayOfCallBack(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_HArrayOfCallBack self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Storage_HArrayOfCallBack
        __init__(Storage_HArrayOfCallBack self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_Storage_CallBack theValue) -> Storage_HArrayOfCallBack
        __init__(Storage_HArrayOfCallBack self, NCollection_Array1_Handle_Storage_CallBack theOther) -> Storage_HArrayOfCallBack

        :type theOther: OCC.wrapper.Storage.Storage_ArrayOfCallBack

        """
        this = _Storage.new_Storage_HArrayOfCallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_ArrayOfCallBack

        """
        res = _Storage.Storage_HArrayOfCallBack_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Storage_HArrayOfCallBack self) -> NCollection_Array1_Handle_Storage_CallBack

        :rtype: OCC.wrapper.Storage.Storage_ArrayOfCallBack

        """
        return _Storage.Storage_HArrayOfCallBack_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_HArrayOfCallBack_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_HArrayOfCallBack_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_HArrayOfCallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_HArrayOfCallBack
Storage_HArrayOfCallBack_swigregister = _Storage.Storage_HArrayOfCallBack_swigregister
Storage_HArrayOfCallBack_swigregister(Storage_HArrayOfCallBack)

def Storage_HArrayOfCallBack_get_type_name(*args):
    """
    Storage_HArrayOfCallBack_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_HArrayOfCallBack_get_type_name(*args)

def Storage_HArrayOfCallBack_get_type_descriptor(*args):
    """
    Storage_HArrayOfCallBack_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_HArrayOfCallBack_get_type_descriptor(*args)

class Storage_StreamWriteError(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_StreamWriteError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_StreamWriteError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_StreamWriteError self) -> Storage_StreamWriteError
        __init__(Storage_StreamWriteError self, Standard_CString const theMessage) -> Storage_StreamWriteError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Storage.new_Storage_StreamWriteError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamWriteError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamWriteError

        """
        return _Storage.Storage_StreamWriteError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_StreamWriteError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_StreamWriteError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_StreamWriteError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_StreamWriteError
Storage_StreamWriteError_swigregister = _Storage.Storage_StreamWriteError_swigregister
Storage_StreamWriteError_swigregister(Storage_StreamWriteError)

def Storage_StreamWriteError_NewInstance(*args):
    """
    Storage_StreamWriteError_NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamWriteError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Storage.Handle_Storage_StreamWriteError

    """
    return _Storage.Storage_StreamWriteError_NewInstance(*args)

def Storage_StreamWriteError_get_type_name(*args):
    """
    Storage_StreamWriteError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_StreamWriteError_get_type_name(*args)

def Storage_StreamWriteError_get_type_descriptor(*args):
    """
    Storage_StreamWriteError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_StreamWriteError_get_type_descriptor(*args)

class Storage_RootData(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_RootData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_RootData(self) 
            return h


    def __init__(self, *args):
        """__init__(Storage_RootData self) -> Storage_RootData"""
        this = _Storage.new_Storage_RootData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Read(self, *args):
        """
        Read(Storage_RootData self, Storage_BaseDriver theDriver) -> Standard_Boolean

        :type theDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_RootData_Read(self, *args)


    def NumberOfRoots(self, *args):
        """
        NumberOfRoots(Storage_RootData self) -> Standard_Integer

        returns the number of roots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_RootData_NumberOfRoots(self, *args)


    def AddRoot(self, *args):
        """
        AddRoot(Storage_RootData self, Handle_Storage_Root aRoot)

        add a root to <me>. If a root with same name is present, it
        will be replaced by <aRoot>.

        :type aRoot: OCC.wrapper.Storage.Handle_Storage_Root

        """
        return _Storage.Storage_RootData_AddRoot(self, *args)


    def Roots(self, *args):
        """
        Roots(Storage_RootData self) -> Handle_Storage_HSeqOfRoot

        :rtype: OCC.wrapper.Storage.Handle_Storage_HSeqOfRoot

        """
        return _Storage.Storage_RootData_Roots(self, *args)


    def Find(self, *args):
        """
        Find(Storage_RootData self, TCollection_AsciiString aName) -> Handle_Storage_Root

        find a root with name <aName>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Storage.Handle_Storage_Root

        """
        return _Storage.Storage_RootData_Find(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(Storage_RootData self, TCollection_AsciiString aName) -> Standard_Boolean

        returns Standard_True if <me> contains a root named <aName>

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_RootData_IsRoot(self, *args)


    def RemoveRoot(self, *args):
        """
        RemoveRoot(Storage_RootData self, TCollection_AsciiString aName)

        remove the root named <aName>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_RootData_RemoveRoot(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Storage_RootData self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_RootData_ErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Storage_RootData self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_RootData_ErrorStatusExtension(self, *args)


    def ClearErrorStatus(self, *args):
        """ClearErrorStatus(Storage_RootData self)"""
        return _Storage.Storage_RootData_ClearErrorStatus(self, *args)


    def UpdateRoot(self, *args):
        """
        UpdateRoot(Storage_RootData self, TCollection_AsciiString aName, Handle_Standard_Persistent aPers)

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Storage_RootData_UpdateRoot(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_RootData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_RootData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_RootData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_RootData
Storage_RootData_swigregister = _Storage.Storage_RootData_swigregister
Storage_RootData_swigregister(Storage_RootData)

def Storage_RootData_get_type_name(*args):
    """
    Storage_RootData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_RootData_get_type_name(*args)

def Storage_RootData_get_type_descriptor(*args):
    """
    Storage_RootData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_RootData_get_type_descriptor(*args)

class Storage_Schema(Standard.Standard_Transient):
    """
    Root class for basic storage/retrieval algorithms.
    A Storage_Schema object processes:
    -   writing of a set of persistent data into a
    container (store mechanism),
    -   reading of a container to extract all the
    contained persistent data (retrieve mechanism).
    A Storage_Schema object is based on the data
    schema for the persistent data of the application, i.e.:
    -   the list of all persistent objects which may be
    known by the application,
    -   the organization of their data; a data schema
    knows how to browse each persistent object it contains.
    During the store or retrieve operation, only
    persistent objects known from the data schema
    can be processed; they are then stored or
    retrieved according to their description in the schema.
    A data schema is specific to the object classes to
    be read or written. Tools dedicated to the
    environment in use allow a description of the
    application persistent data structure.
    Storage_Schema algorithms are called basic
    because they do not support external references
    between containers.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_Schema
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_Schema(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_Schema self) -> Storage_Schema

        Builds a storage/retrieval algorithm based on a
        given data schema.
        Example
        For example, if ShapeSchema is the class
        inheriting from Storage_Schema and containing
        the description of your application data schema,
        you create a storage/retrieval algorithm as follows:
        Handle(ShapeSchema) s = new
        ShapeSchema;
        -------- --
        USER API -- --------------------------------------------------------------
        -------- --


        """
        this = _Storage.new_Storage_Schema(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetVersion(self, *args):
        """
        SetVersion(Storage_Schema self, TCollection_AsciiString aVersion)

        returns version of the schema

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Schema_SetVersion(self, *args)


    def Version(self, *args):
        """
        Version(Storage_Schema self) -> TCollection_AsciiString

        returns the version of the schema

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Schema_Version(self, *args)


    def SetName(self, *args):
        """
        SetName(Storage_Schema self, TCollection_AsciiString aSchemaName)

        set the schema's name

        :type aSchemaName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Schema_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Storage_Schema self) -> TCollection_AsciiString

        returns the schema's name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Schema_Name(self, *args)


    def Write(self, *args):
        """
        Write(Storage_Schema self, Storage_BaseDriver s, Handle_Storage_Data aData)

        Writes the data aggregated in aData into the
        container defined by the driver s. The storage
        operation is performed according to the data
        schema with which this algorithm is working.
        Note: aData may aggregate several root objects
        to be stored together.

        :type s: OCC.wrapper.Storage.Storage_BaseDriver
        :type aData: OCC.wrapper.Storage.Handle_Storage_Data

        """
        return _Storage.Storage_Schema_Write(self, *args)


    def ICreationDate(*args):
        """
        ICreationDate() -> TCollection_AsciiString

        return a current date string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Schema_ICreationDate(*args)

    ICreationDate = staticmethod(ICreationDate)

    def CheckTypeMigration(*args):
        """
        CheckTypeMigration(TCollection_AsciiString theTypeName, TCollection_AsciiString theNewName) -> Standard_Boolean

        returns True if theType migration is identified
        the callback support provides a way to read a file
        with a incomplete schema.
        ex. : A file contains 3 types a,b and c.
        The  application's  schema  contains  only 2
        type a and b. If you try to read the file in
        the application, you  will  have an error.To
        bypass this  problem  you  can  give to your
        application's schema  a  callback  used when
        the schema dosent  know  how  to handle this
        type.

        :type theTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theNewName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_Schema_CheckTypeMigration(*args)

    CheckTypeMigration = staticmethod(CheckTypeMigration)

    def AddReadUnknownTypeCallBack(self, *args):
        """
        AddReadUnknownTypeCallBack(Storage_Schema self, TCollection_AsciiString aTypeName, Handle_Storage_CallBack aCallBack)

        add two functions to the callback list

        :type aTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aCallBack: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Storage_Schema_AddReadUnknownTypeCallBack(self, *args)


    def RemoveReadUnknownTypeCallBack(self, *args):
        """
        RemoveReadUnknownTypeCallBack(Storage_Schema self, TCollection_AsciiString aTypeName)

        remove a callback for a type

        :type aTypeName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Schema_RemoveReadUnknownTypeCallBack(self, *args)


    def InstalledCallBackList(self, *args):
        """
        InstalledCallBackList(Storage_Schema self) -> Handle_TColStd_HSequenceOfAsciiString

        returns  a  list  of   type  name  with  installed
        callback.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Storage.Storage_Schema_InstalledCallBackList(self, *args)


    def ClearCallBackList(self, *args):
        """
        ClearCallBackList(Storage_Schema self)

        clear all callback from schema instance.


        """
        return _Storage.Storage_Schema_ClearCallBackList(self, *args)


    def UseDefaultCallBack(self, *args):
        """
        UseDefaultCallBack(Storage_Schema self)

        install  a  callback  for  all  unknown  type. the
        objects with unknown types  will be skipped. (look
        SkipObject method in BaseDriver)


        """
        return _Storage.Storage_Schema_UseDefaultCallBack(self, *args)


    def DontUseDefaultCallBack(self, *args):
        """
        DontUseDefaultCallBack(Storage_Schema self)

        tells schema to uninstall the default callback.


        """
        return _Storage.Storage_Schema_DontUseDefaultCallBack(self, *args)


    def IsUsingDefaultCallBack(self, *args):
        """
        IsUsingDefaultCallBack(Storage_Schema self) -> Standard_Boolean

        ask if the schema is using the default callback.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_Schema_IsUsingDefaultCallBack(self, *args)


    def SetDefaultCallBack(self, *args):
        """
        SetDefaultCallBack(Storage_Schema self, Handle_Storage_CallBack f)

        overload the  default  function  for build.(use to
        set an  error  message  or  skip  an  object while
        reading an unknown type).

        :type f: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Storage_Schema_SetDefaultCallBack(self, *args)


    def ResetDefaultCallBack(self, *args):
        """
        ResetDefaultCallBack(Storage_Schema self)

        reset  the  default  function  defined  by Storage
        package.


        """
        return _Storage.Storage_Schema_ResetDefaultCallBack(self, *args)


    def DefaultCallBack(self, *args):
        """
        DefaultCallBack(Storage_Schema self) -> Handle_Storage_CallBack

        returns   the   read   function   used   when  the
        UseDefaultCallBack() is set.

        :rtype: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Storage_Schema_DefaultCallBack(self, *args)


    def WritePersistentObjectHeader(self, *args):
        """
        WritePersistentObjectHeader(Storage_Schema self, Handle_Standard_Persistent sp, Storage_BaseDriver s)

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type s: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_Schema_WritePersistentObjectHeader(self, *args)


    def WritePersistentReference(self, *args):
        """
        WritePersistentReference(Storage_Schema self, Handle_Standard_Persistent sp, Storage_BaseDriver s)

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type s: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_Schema_WritePersistentReference(self, *args)


    def AddPersistent(self, *args):
        """
        AddPersistent(Storage_Schema self, Handle_Standard_Persistent sp, Standard_CString const tName) -> Standard_Boolean

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type tName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_Schema_AddPersistent(self, *args)


    def PersistentToAdd(self, *args):
        """
        PersistentToAdd(Storage_Schema self, Handle_Standard_Persistent sp) -> Standard_Boolean

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_Schema_PersistentToAdd(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_Schema_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_Schema_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_Schema_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_Schema
Storage_Schema_swigregister = _Storage.Storage_Schema_swigregister
Storage_Schema_swigregister(Storage_Schema)

def Storage_Schema_ICreationDate(*args):
    """
    Storage_Schema_ICreationDate() -> TCollection_AsciiString

    return a current date string

    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _Storage.Storage_Schema_ICreationDate(*args)

def Storage_Schema_CheckTypeMigration(*args):
    """
    Storage_Schema_CheckTypeMigration(TCollection_AsciiString theTypeName, TCollection_AsciiString theNewName) -> Standard_Boolean

    returns True if theType migration is identified
    the callback support provides a way to read a file
    with a incomplete schema.
    ex. : A file contains 3 types a,b and c.
    The  application's  schema  contains  only 2
    type a and b. If you try to read the file in
    the application, you  will  have an error.To
    bypass this  problem  you  can  give to your
    application's schema  a  callback  used when
    the schema dosent  know  how  to handle this
    type.

    :type theTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
    :type theNewName: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Storage.Storage_Schema_CheckTypeMigration(*args)

def Storage_Schema_get_type_name(*args):
    """
    Storage_Schema_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_Schema_get_type_name(*args)

def Storage_Schema_get_type_descriptor(*args):
    """
    Storage_Schema_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_Schema_get_type_descriptor(*args)

class Storage_StreamTypeMismatchError(Storage_StreamReadError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_StreamTypeMismatchError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_StreamTypeMismatchError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_StreamTypeMismatchError self) -> Storage_StreamTypeMismatchError
        __init__(Storage_StreamTypeMismatchError self, Standard_CString const theMessage) -> Storage_StreamTypeMismatchError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Storage.new_Storage_StreamTypeMismatchError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamTypeMismatchError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamTypeMismatchError

        """
        return _Storage.Storage_StreamTypeMismatchError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_StreamTypeMismatchError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_StreamTypeMismatchError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_StreamTypeMismatchError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_StreamTypeMismatchError
Storage_StreamTypeMismatchError_swigregister = _Storage.Storage_StreamTypeMismatchError_swigregister
Storage_StreamTypeMismatchError_swigregister(Storage_StreamTypeMismatchError)

def Storage_StreamTypeMismatchError_NewInstance(*args):
    """
    Storage_StreamTypeMismatchError_NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamTypeMismatchError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Storage.Handle_Storage_StreamTypeMismatchError

    """
    return _Storage.Storage_StreamTypeMismatchError_NewInstance(*args)

def Storage_StreamTypeMismatchError_get_type_name(*args):
    """
    Storage_StreamTypeMismatchError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_StreamTypeMismatchError_get_type_name(*args)

def Storage_StreamTypeMismatchError_get_type_descriptor(*args):
    """
    Storage_StreamTypeMismatchError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_StreamTypeMismatchError_get_type_descriptor(*args)

class Storage_HArrayOfSchema(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_HArrayOfSchema
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_HArrayOfSchema(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_HArrayOfSchema self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Storage_HArrayOfSchema
        __init__(Storage_HArrayOfSchema self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_Storage_Schema theValue) -> Storage_HArrayOfSchema
        __init__(Storage_HArrayOfSchema self, NCollection_Array1_Handle_Storage_Schema theOther) -> Storage_HArrayOfSchema

        :type theOther: OCC.wrapper.Storage.Storage_ArrayOfSchema

        """
        this = _Storage.new_Storage_HArrayOfSchema(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_ArrayOfSchema

        """
        res = _Storage.Storage_HArrayOfSchema_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Storage_HArrayOfSchema self) -> NCollection_Array1_Handle_Storage_Schema

        :rtype: OCC.wrapper.Storage.Storage_ArrayOfSchema

        """
        return _Storage.Storage_HArrayOfSchema_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_HArrayOfSchema_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_HArrayOfSchema_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_HArrayOfSchema_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_HArrayOfSchema
Storage_HArrayOfSchema_swigregister = _Storage.Storage_HArrayOfSchema_swigregister
Storage_HArrayOfSchema_swigregister(Storage_HArrayOfSchema)

def Storage_HArrayOfSchema_get_type_name(*args):
    """
    Storage_HArrayOfSchema_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_HArrayOfSchema_get_type_name(*args)

def Storage_HArrayOfSchema_get_type_descriptor(*args):
    """
    Storage_HArrayOfSchema_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_HArrayOfSchema_get_type_descriptor(*args)

class Storage_Root(Standard.Standard_Transient):
    """
    A root object extracted from a Storage_Data object.
    A Storage_Root encapsulates a persistent
    object which is a root of a Storage_Data object.
    It contains additional information: the name and
    the data type of the persistent object.
    When retrieving a Storage_Data object from a
    container (for example, a file) you access its
    roots with the function Roots which returns a
    sequence of root objects. The provided functions
    allow you to request information about each root of the sequence.
    You do not create explicit roots: when inserting
    data in a Storage_Data object, you just provide
    the persistent object and optionally its name to the function AddRoot.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_Root
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_Root(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_Root self) -> Storage_Root
        __init__(Storage_Root self, TCollection_AsciiString theName, Handle_Standard_Persistent theObject) -> Storage_Root
        __init__(Storage_Root self, TCollection_AsciiString theName, Standard_Integer const theRef, TCollection_AsciiString theType) -> Storage_Root

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theRef: int
        :type theType: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _Storage.new_Storage_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetName(self, *args):
        """
        SetName(Storage_Root self, TCollection_AsciiString theName)

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Root_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Storage_Root self) -> TCollection_AsciiString

        Returns the name of this root object.
        The name may have been given explicitly when
        the root was inserted into the Storage_Data
        object. If not, the name is a reference number
        which was assigned automatically by the driver
        when writing the set of data into the container.
        When naming the roots, it is easier to retrieve
        objects by significant references rather than by
        references without any semantic values.
        Warning
        The returned string will be empty if you call this
        function before having named this root object,
        either explicitly, or when writing the set of data
        into the container.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Root_Name(self, *args)


    def SetObject(self, *args):
        """
        SetObject(Storage_Root self, Handle_Standard_Persistent anObject)

        :type anObject: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Storage_Root_SetObject(self, *args)


    def Object(self, *args):
        """
        Object(Storage_Root self) -> Handle_Standard_Persistent

        Returns the persistent object encapsulated by this root.

        :rtype: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Storage_Root_Object(self, *args)


    def Type(self, *args):
        """
        Type(Storage_Root self) -> TCollection_AsciiString

        Returns the name of this root type.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Root_Type(self, *args)


    def SetReference(self, *args):
        """
        SetReference(Storage_Root self, Standard_Integer const aRef)

        :type aRef: int

        """
        return _Storage.Storage_Root_SetReference(self, *args)


    def Reference(self, *args):
        """
        Reference(Storage_Root self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_Root_Reference(self, *args)


    def SetType(self, *args):
        """
        SetType(Storage_Root self, TCollection_AsciiString aType)

        :type aType: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Root_SetType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_Root_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_Root_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_Root_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_Root
Storage_Root_swigregister = _Storage.Storage_Root_swigregister
Storage_Root_swigregister(Storage_Root)

def Storage_Root_get_type_name(*args):
    """
    Storage_Root_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_Root_get_type_name(*args)

def Storage_Root_get_type_descriptor(*args):
    """
    Storage_Root_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_Root_get_type_descriptor(*args)

class Storage_HPArray(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_HPArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_HPArray(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_HPArray self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Storage_HPArray
        __init__(Storage_HPArray self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_Standard_Persistent theValue) -> Storage_HPArray
        __init__(Storage_HPArray self, NCollection_Array1_Handle_Standard_Persistent theOther) -> Storage_HPArray

        :type theOther: OCC.wrapper.Storage.Storage_PArray

        """
        this = _Storage.new_Storage_HPArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_PArray

        """
        res = _Storage.Storage_HPArray_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Storage_HPArray self) -> NCollection_Array1_Handle_Standard_Persistent

        :rtype: OCC.wrapper.Storage.Storage_PArray

        """
        return _Storage.Storage_HPArray_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_HPArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_HPArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_HPArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_HPArray
Storage_HPArray_swigregister = _Storage.Storage_HPArray_swigregister
Storage_HPArray_swigregister(Storage_HPArray)

def Storage_HPArray_get_type_name(*args):
    """
    Storage_HPArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_HPArray_get_type_name(*args)

def Storage_HPArray_get_type_descriptor(*args):
    """
    Storage_HPArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_HPArray_get_type_descriptor(*args)

class Storage_Data(Standard.Standard_Transient):
    """
    A picture memorizing the data stored in a
    container (for example, in a file).
    A Storage_Data object represents either:
    -   persistent data to be written into a container,
    or
    -   persistent data which are read from a container.
    A Storage_Data object is used in both the
    storage and retrieval operations:
    -   Storage mechanism: create an empty
    Storage_Data object, then add successively
    persistent objects (roots) to be stored using
    the function AddRoot. When the set of data is
    complete, write it to a container using the
    function Write in your Storage_Schema
    storage/retrieval algorithm.
    -   Retrieval mechanism: a Storage_Data
    object is returned by the Read function from
    your Storage_Schema storage/retrieval
    algorithm. Use the functions NumberOfRoots
    and Roots to find the roots which were stored
    in the read container.
    The roots of a Storage_Data object may share
    references on objects. The shared internal
    references of a Storage_Data object are
    maintained by the storage/retrieval mechanism.
    Note: References shared by objects which are
    contained in two distinct Storage_Data objects
    are not maintained by the storage/retrieval
    mechanism: external references are not
    supported by Storage_Schema algorithm
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_Data
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_Data(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_Data self) -> Storage_Data

        Creates an empty set of data.
        You explicitly create a Storage_Data object
        when preparing the set of objects to be stored
        together in a container (for example, in a file).
        Then use the function AddRoot to add
        persistent objects to the set of data.
        A Storage_Data object is also returned by the
        Read function of a Storage_Schema
        storage/retrieval algorithm. Use the functions
        NumberOfRoots and Roots to find the roots
        which were stored in the read container.


        """
        this = _Storage.new_Storage_Data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ErrorStatus(self, *args):
        """
        ErrorStatus(Storage_Data self) -> Storage_Error

        Returns Storage_VSOk if
        -   the last storage operation performed with the
        function Read, or
        -   the last retrieval operation performed with the function Write
        by a Storage_Schema algorithm, on this set of data was successful.
        If the storage or retrieval operation was not
        performed, the returned error status indicates the
        reason why the operation failed. The algorithm
        stops its analysis at the first detected error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_Data_ErrorStatus(self, *args)


    def ClearErrorStatus(self, *args):
        """
        ClearErrorStatus(Storage_Data self)

        Clears the error status positioned either by:
        -   the last storage operation performed with the
        Read function, or
        -   the last retrieval operation performed with the Write function
        by a Storage_Schema algorithm, on this set of data.
        This error status may be read by the function ErrorStatus.


        """
        return _Storage.Storage_Data_ClearErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Storage_Data self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_ErrorStatusExtension(self, *args)


    def CreationDate(self, *args):
        """
        CreationDate(Storage_Data self) -> TCollection_AsciiString

        return the creation date

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_CreationDate(self, *args)


    def StorageVersion(self, *args):
        """
        StorageVersion(Storage_Data self) -> TCollection_AsciiString

        return the Storage package version

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_StorageVersion(self, *args)


    def SchemaVersion(self, *args):
        """
        SchemaVersion(Storage_Data self) -> TCollection_AsciiString

        get the version of the schema

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_SchemaVersion(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(Storage_Data self) -> TCollection_AsciiString

        get the schema's name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_SchemaName(self, *args)


    def SetApplicationVersion(self, *args):
        """
        SetApplicationVersion(Storage_Data self, TCollection_AsciiString aVersion)

        set the version of the application

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_SetApplicationVersion(self, *args)


    def ApplicationVersion(self, *args):
        """
        ApplicationVersion(Storage_Data self) -> TCollection_AsciiString

        get the version of the application

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_ApplicationVersion(self, *args)


    def SetApplicationName(self, *args):
        """
        SetApplicationName(Storage_Data self, TCollection_ExtendedString aName)

        set the name of the application

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_Data_SetApplicationName(self, *args)


    def ApplicationName(self, *args):
        """
        ApplicationName(Storage_Data self) -> TCollection_ExtendedString

        get the name of the application

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_Data_ApplicationName(self, *args)


    def SetDataType(self, *args):
        """
        SetDataType(Storage_Data self, TCollection_ExtendedString aType)

        set the data type

        :type aType: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_Data_SetDataType(self, *args)


    def DataType(self, *args):
        """
        DataType(Storage_Data self) -> TCollection_ExtendedString

        returns data type

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_Data_DataType(self, *args)


    def AddToUserInfo(self, *args):
        """
        AddToUserInfo(Storage_Data self, TCollection_AsciiString anInfo)

        add <theUserInfo> to the user informations

        :type anInfo: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_AddToUserInfo(self, *args)


    def UserInfo(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        res = _Storage.Storage_Data_UserInfo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddToComments(self, *args):
        """
        AddToComments(Storage_Data self, TCollection_ExtendedString aComment)

        add <theUserInfo> to the user informations

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_Data_AddToComments(self, *args)


    def Comments(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _Storage.Storage_Data_Comments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NumberOfObjects(self, *args):
        """
        NumberOfObjects(Storage_Data self) -> Standard_Integer

        the the number of persistent objects
        Return:
        the number of persistent objects readed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_Data_NumberOfObjects(self, *args)


    def NumberOfRoots(self, *args):
        """
        NumberOfRoots(Storage_Data self) -> Standard_Integer

        Returns the number of root objects in this set of data.
        -   When preparing a storage operation, the
        result is the number of roots inserted into this
        set of data with the function AddRoot.
        -   When retrieving an object, the result is the
        number of roots stored in the read container.
        Use the Roots function to get these roots in a sequence.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_Data_NumberOfRoots(self, *args)


    def AddRoot(self, *args):
        """
        AddRoot(Storage_Data self, Handle_Standard_Persistent anObject)
        AddRoot(Storage_Data self, TCollection_AsciiString aName, Handle_Standard_Persistent anObject)

        Adds the root anObject to this set of data.
        The name of the root is aName if given; if not, it
        will be a reference number assigned by the driver
        when writing the set of data into the container.
        When naming the roots, it is easier to retrieve
        objects by significant references rather than by
        references without any semantic values.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type anObject: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Storage_Data_AddRoot(self, *args)


    def RemoveRoot(self, *args):
        """
        RemoveRoot(Storage_Data self, TCollection_AsciiString aName)

        Removes from this set of data the root object named aName.
        Warning
        Nothing is done if there is no root object whose
        name is aName in this set of data.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_Data_RemoveRoot(self, *args)


    def Roots(self, *args):
        """
        Roots(Storage_Data self) -> Handle_Storage_HSeqOfRoot

        Returns the roots of this set of data in a sequence.
        -   When preparing a storage operation, the
        sequence contains the roots inserted into this
        set of data with the function AddRoot.
        -   When retrieving an object, the sequence
        contains the roots stored in the container read.
        -   An empty sequence is returned if there is no root in this set of data.

        :rtype: OCC.wrapper.Storage.Handle_Storage_HSeqOfRoot

        """
        return _Storage.Storage_Data_Roots(self, *args)


    def Find(self, *args):
        """
        Find(Storage_Data self, TCollection_AsciiString aName) -> Handle_Storage_Root

        Gives the root object whose name is aName in
        this set of data. The returned object is a
        Storage_Root object, from which the object it
        encapsulates may be extracted.
        Warning
        A null handle is returned if there is no root object
        whose name is aName in this set of data.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Storage.Handle_Storage_Root

        """
        return _Storage.Storage_Data_Find(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(Storage_Data self, TCollection_AsciiString aName) -> Standard_Boolean

        returns Standard_True if <me> contains a root named <aName>

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_Data_IsRoot(self, *args)


    def NumberOfTypes(self, *args):
        """
        NumberOfTypes(Storage_Data self) -> Standard_Integer

        Returns the number of types of objects used in this set of data.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_Data_NumberOfTypes(self, *args)


    def IsType(self, *args):
        """
        IsType(Storage_Data self, TCollection_AsciiString aName) -> Standard_Boolean

        Returns true if this set of data contains an object of type aName.
        Persistent objects from this set of data must
        have types which are recognized by the
        Storage_Schema algorithm used to store or retrieve them.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_Data_IsType(self, *args)


    def Types(self, *args):
        """
        Types(Storage_Data self) -> Handle_TColStd_HSequenceOfAsciiString

        Gives the list of types of objects used in this set of data in a sequence.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Storage.Storage_Data_Types(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_Data_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_Data_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_Data_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HeaderData(self, *args):
        """
        HeaderData(Storage_Data self) -> Handle_Storage_HeaderData

        :rtype: OCC.wrapper.Storage.Handle_Storage_HeaderData

        """
        return _Storage.Storage_Data_HeaderData(self, *args)


    def RootData(self, *args):
        """
        RootData(Storage_Data self) -> Handle_Storage_RootData

        :rtype: OCC.wrapper.Storage.Handle_Storage_RootData

        """
        return _Storage.Storage_Data_RootData(self, *args)


    def TypeData(self, *args):
        """
        TypeData(Storage_Data self) -> Handle_Storage_TypeData

        :rtype: OCC.wrapper.Storage.Handle_Storage_TypeData

        """
        return _Storage.Storage_Data_TypeData(self, *args)


    def InternalData(self, *args):
        """
        InternalData(Storage_Data self) -> Handle_Storage_InternalData

        :rtype: OCC.wrapper.Storage.Handle_Storage_InternalData

        """
        return _Storage.Storage_Data_InternalData(self, *args)


    def Clear(self, *args):
        """Clear(Storage_Data self)"""
        return _Storage.Storage_Data_Clear(self, *args)

    __swig_destroy__ = _Storage.delete_Storage_Data
Storage_Data_swigregister = _Storage.Storage_Data_swigregister
Storage_Data_swigregister(Storage_Data)

def Storage_Data_get_type_name(*args):
    """
    Storage_Data_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_Data_get_type_name(*args)

def Storage_Data_get_type_descriptor(*args):
    """
    Storage_Data_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_Data_get_type_descriptor(*args)

class Storage_DefaultCallBack(Storage_CallBack):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_DefaultCallBack
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_DefaultCallBack(self) 
            return h


    def __init__(self, *args):
        """__init__(Storage_DefaultCallBack self) -> Storage_DefaultCallBack"""
        this = _Storage.new_Storage_DefaultCallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def New(self, *args):
        """
        New(Storage_DefaultCallBack self) -> Handle_Standard_Persistent

        :rtype: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Storage_DefaultCallBack_New(self, *args)


    def Add(self, *args):
        """
        Add(Storage_DefaultCallBack self, Handle_Standard_Persistent aPers, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Storage_DefaultCallBack_Add(self, *args)


    def Write(self, *args):
        """
        Write(Storage_DefaultCallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Storage_DefaultCallBack_Write(self, *args)


    def Read(self, *args):
        """
        Read(Storage_DefaultCallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Storage_DefaultCallBack_Read(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_DefaultCallBack_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_DefaultCallBack_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_DefaultCallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_DefaultCallBack
Storage_DefaultCallBack_swigregister = _Storage.Storage_DefaultCallBack_swigregister
Storage_DefaultCallBack_swigregister(Storage_DefaultCallBack)

def Storage_DefaultCallBack_get_type_name(*args):
    """
    Storage_DefaultCallBack_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_DefaultCallBack_get_type_name(*args)

def Storage_DefaultCallBack_get_type_descriptor(*args):
    """
    Storage_DefaultCallBack_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_DefaultCallBack_get_type_descriptor(*args)

class Handle_Storage_StreamTypeMismatchError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_StreamTypeMismatchError self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_StreamTypeMismatchError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_StreamTypeMismatchError self, Storage_StreamTypeMismatchError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_StreamTypeMismatchError self, Handle_Storage_StreamTypeMismatchError theHandle) -> Handle_Storage_StreamTypeMismatchError
        assign(Handle_Storage_StreamTypeMismatchError self, Storage_StreamTypeMismatchError thePtr) -> Handle_Storage_StreamTypeMismatchError
        assign(Handle_Storage_StreamTypeMismatchError self, Handle_Storage_StreamTypeMismatchError theHandle) -> Handle_Storage_StreamTypeMismatchError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_StreamTypeMismatchError self) -> Storage_StreamTypeMismatchError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_StreamTypeMismatchError self) -> Storage_StreamTypeMismatchError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_StreamTypeMismatchError self) -> Storage_StreamTypeMismatchError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_StreamTypeMismatchError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_StreamTypeMismatchError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_StreamTypeMismatchError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_StreamTypeMismatchError_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_StreamTypeMismatchError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Storage_StreamTypeMismatchError self, Standard_CString const theMessage) -> Handle_Storage_StreamTypeMismatchError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamTypeMismatchError

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_StreamTypeMismatchError self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamTypeMismatchError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamTypeMismatchError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Storage_StreamTypeMismatchError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Storage_StreamTypeMismatchError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Storage_StreamTypeMismatchError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Storage_StreamTypeMismatchError self)
        Reraise(Handle_Storage_StreamTypeMismatchError self, Standard_CString const aMessage)
        Reraise(Handle_Storage_StreamTypeMismatchError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Storage_StreamTypeMismatchError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Storage_StreamTypeMismatchError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_StreamTypeMismatchError self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_StreamTypeMismatchError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_StreamTypeMismatchError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_StreamTypeMismatchError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_StreamTypeMismatchError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_StreamTypeMismatchError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_StreamTypeMismatchError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_StreamTypeMismatchError self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_StreamTypeMismatchError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamTypeMismatchError_DecrementRefCounter(self, *args)

Handle_Storage_StreamTypeMismatchError_swigregister = _Storage.Handle_Storage_StreamTypeMismatchError_swigregister
Handle_Storage_StreamTypeMismatchError_swigregister(Handle_Storage_StreamTypeMismatchError)

def Handle_Storage_StreamTypeMismatchError_DownCast(thing):
    return _Storage.Handle_Storage_StreamTypeMismatchError_DownCast(thing)
Handle_Storage_StreamTypeMismatchError_DownCast = _Storage.Handle_Storage_StreamTypeMismatchError_DownCast

class Storage_TypeData(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_TypeData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_TypeData(self) 
            return h


    def __init__(self, *args):
        """__init__(Storage_TypeData self) -> Storage_TypeData"""
        this = _Storage.new_Storage_TypeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Read(self, *args):
        """
        Read(Storage_TypeData self, Storage_BaseDriver theDriver) -> Standard_Boolean

        :type theDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_TypeData_Read(self, *args)


    def NumberOfTypes(self, *args):
        """
        NumberOfTypes(Storage_TypeData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_TypeData_NumberOfTypes(self, *args)


    def AddType(self, *args):
        """
        AddType(Storage_TypeData self, TCollection_AsciiString aName, Standard_Integer const aTypeNum)

        add a type to the list

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aTypeNum: int

        """
        return _Storage.Storage_TypeData_AddType(self, *args)


    def Type(self, *args):
        """
        Type(Storage_TypeData self, Standard_Integer const aTypeNum) -> TCollection_AsciiString
        Type(Storage_TypeData self, TCollection_AsciiString aTypeName) -> Standard_Integer

        returns the name of the type with number <aTypeNum>

        :type aTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_TypeData_Type(self, *args)


    def IsType(self, *args):
        """
        IsType(Storage_TypeData self, TCollection_AsciiString aName) -> Standard_Boolean

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_TypeData_IsType(self, *args)


    def Types(self, *args):
        """
        Types(Storage_TypeData self) -> Handle_TColStd_HSequenceOfAsciiString

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Storage.Storage_TypeData_Types(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Storage_TypeData self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_TypeData_ErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Storage_TypeData self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_TypeData_ErrorStatusExtension(self, *args)


    def ClearErrorStatus(self, *args):
        """ClearErrorStatus(Storage_TypeData self)"""
        return _Storage.Storage_TypeData_ClearErrorStatus(self, *args)


    def Clear(self, *args):
        """Clear(Storage_TypeData self)"""
        return _Storage.Storage_TypeData_Clear(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_TypeData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_TypeData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_TypeData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_TypeData
Storage_TypeData_swigregister = _Storage.Storage_TypeData_swigregister
Storage_TypeData_swigregister(Storage_TypeData)

def Storage_TypeData_get_type_name(*args):
    """
    Storage_TypeData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_TypeData_get_type_name(*args)

def Storage_TypeData_get_type_descriptor(*args):
    """
    Storage_TypeData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_TypeData_get_type_descriptor(*args)

class Handle_Storage_StreamFormatError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_StreamFormatError self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_StreamFormatError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_StreamFormatError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_StreamFormatError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_StreamFormatError self, Storage_StreamFormatError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_StreamFormatError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_StreamFormatError self, Handle_Storage_StreamFormatError theHandle) -> Handle_Storage_StreamFormatError
        assign(Handle_Storage_StreamFormatError self, Storage_StreamFormatError thePtr) -> Handle_Storage_StreamFormatError
        assign(Handle_Storage_StreamFormatError self, Handle_Storage_StreamFormatError theHandle) -> Handle_Storage_StreamFormatError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_StreamFormatError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_StreamFormatError self) -> Storage_StreamFormatError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamFormatError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_StreamFormatError self) -> Storage_StreamFormatError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamFormatError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_StreamFormatError self) -> Storage_StreamFormatError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_StreamFormatError___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_StreamFormatError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_StreamFormatError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_StreamFormatError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_StreamFormatError_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_StreamFormatError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Storage_StreamFormatError self, Standard_CString const theMessage) -> Handle_Storage_StreamFormatError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamFormatError

        """
        return _Storage.Handle_Storage_StreamFormatError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_StreamFormatError self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_StreamFormatError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamFormatError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamFormatError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Storage_StreamFormatError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Storage.Handle_Storage_StreamFormatError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Storage_StreamFormatError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamFormatError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Storage_StreamFormatError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamFormatError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Storage_StreamFormatError self)
        Reraise(Handle_Storage_StreamFormatError self, Standard_CString const aMessage)
        Reraise(Handle_Storage_StreamFormatError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Storage.Handle_Storage_StreamFormatError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Storage_StreamFormatError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Storage.Handle_Storage_StreamFormatError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Storage_StreamFormatError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Storage.Handle_Storage_StreamFormatError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_StreamFormatError self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_StreamFormatError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_StreamFormatError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_StreamFormatError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamFormatError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_StreamFormatError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_StreamFormatError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamFormatError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_StreamFormatError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_StreamFormatError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_StreamFormatError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamFormatError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_StreamFormatError self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_StreamFormatError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_StreamFormatError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamFormatError_DecrementRefCounter(self, *args)

Handle_Storage_StreamFormatError_swigregister = _Storage.Handle_Storage_StreamFormatError_swigregister
Handle_Storage_StreamFormatError_swigregister(Handle_Storage_StreamFormatError)

def Handle_Storage_StreamFormatError_DownCast(thing):
    return _Storage.Handle_Storage_StreamFormatError_DownCast(thing)
Handle_Storage_StreamFormatError_DownCast = _Storage.Handle_Storage_StreamFormatError_DownCast

class Storage_Bucket(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Storage_Bucket self) -> Storage_Bucket
        __init__(Storage_Bucket self, Standard_Integer const theSpaceSize) -> Storage_Bucket

        :type theSpaceSize: int

        """
        this = _Storage.new_Storage_Bucket(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Storage_Bucket_swigregister = _Storage.Storage_Bucket_swigregister
Storage_Bucket_swigregister(Storage_Bucket)

class Storage_BaseDriver(object):
    """
    Root class for drivers. A driver assigns a physical container
    to data to be stored or retrieved, for instance a file.
    The FSD package provides two derived concrete classes :
    -   FSD_File is a general driver which defines a
    file as the container of data.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Open(self, *args):
        """
        Open(Storage_BaseDriver self, TCollection_AsciiString aName, Storage_OpenMode const aMode) -> Storage_Error

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aMode: OCC.wrapper.Storage.Storage_OpenMode
        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_Open(self, *args)


    def Name(self, *args):
        """
        Name(Storage_BaseDriver self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_BaseDriver_Name(self, *args)


    def OpenMode(self, *args):
        """
        OpenMode(Storage_BaseDriver self) -> Storage_OpenMode

        :rtype: OCC.wrapper.Storage.Storage_OpenMode

        """
        return _Storage.Storage_BaseDriver_OpenMode(self, *args)


    def ReadMagicNumber(*args):
        """
        ReadMagicNumber(Standard_IStream & theIStream) -> TCollection_AsciiString

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_BaseDriver_ReadMagicNumber(*args)

    ReadMagicNumber = staticmethod(ReadMagicNumber)

    def IsEnd(self, *args):
        """
        IsEnd(Storage_BaseDriver self) -> Standard_Boolean

        returns True if we are at end of the stream

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_BaseDriver_IsEnd(self, *args)


    def Tell(self, *args):
        """
        Tell(Storage_BaseDriver self) -> Storage_Position

        return position in the file. Return -1 upon error.

        :rtype: OCC.wrapper.Storage.Storage_Position

        """
        return _Storage.Storage_BaseDriver_Tell(self, *args)


    def BeginWriteInfoSection(self, *args):
        """
        BeginWriteInfoSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginWriteInfoSection(self, *args)


    def WriteInfo(self, *args):
        """
        WriteInfo(Storage_BaseDriver self, Standard_Integer const nbObj, TCollection_AsciiString dbVersion, TCollection_AsciiString date, TCollection_AsciiString schemaName, TCollection_AsciiString schemaVersion, TCollection_ExtendedString appName, TCollection_AsciiString appVersion, TCollection_ExtendedString objectType, NCollection_Sequence_TCollection_AsciiString userInfo)

        :type nbObj: int
        :type dbVersion: OCC.wrapper.TCollection.TCollection_AsciiString
        :type date: OCC.wrapper.TCollection.TCollection_AsciiString
        :type schemaName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type schemaVersion: OCC.wrapper.TCollection.TCollection_AsciiString
        :type appName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type appVersion: OCC.wrapper.TCollection.TCollection_AsciiString
        :type objectType: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type userInfo: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _Storage.Storage_BaseDriver_WriteInfo(self, *args)


    def EndWriteInfoSection(self, *args):
        """
        EndWriteInfoSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndWriteInfoSection(self, *args)


    def BeginReadInfoSection(self, *args):
        """
        BeginReadInfoSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginReadInfoSection(self, *args)


    def ReadInfo(self, *args):
        """
        ReadInfo(Storage_BaseDriver self, TCollection_AsciiString dbVersion, TCollection_AsciiString date, TCollection_AsciiString schemaName, TCollection_AsciiString schemaVersion, TCollection_ExtendedString appName, TCollection_AsciiString appVersion, TCollection_ExtendedString objectType, NCollection_Sequence_TCollection_AsciiString userInfo)

        :type nbObj: int
        :type dbVersion: OCC.wrapper.TCollection.TCollection_AsciiString
        :type date: OCC.wrapper.TCollection.TCollection_AsciiString
        :type schemaName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type schemaVersion: OCC.wrapper.TCollection.TCollection_AsciiString
        :type appName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type appVersion: OCC.wrapper.TCollection.TCollection_AsciiString
        :type objectType: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type userInfo: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _Storage.Storage_BaseDriver_ReadInfo(self, *args)


    def ReadCompleteInfo(self, *args):
        """
        ReadCompleteInfo(Storage_BaseDriver self, Standard_IStream & theIStream, Handle_Storage_Data theData)

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :type theData: OCC.wrapper.Storage.Handle_Storage_Data

        """
        return _Storage.Storage_BaseDriver_ReadCompleteInfo(self, *args)


    def EndReadInfoSection(self, *args):
        """
        EndReadInfoSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndReadInfoSection(self, *args)


    def BeginWriteCommentSection(self, *args):
        """
        BeginWriteCommentSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginWriteCommentSection(self, *args)


    def WriteComment(self, *args):
        """
        WriteComment(Storage_BaseDriver self, NCollection_Sequence_TCollection_ExtendedString userComments)

        :type userComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _Storage.Storage_BaseDriver_WriteComment(self, *args)


    def EndWriteCommentSection(self, *args):
        """
        EndWriteCommentSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndWriteCommentSection(self, *args)


    def BeginReadCommentSection(self, *args):
        """
        BeginReadCommentSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginReadCommentSection(self, *args)


    def ReadComment(self, *args):
        """
        ReadComment(Storage_BaseDriver self, NCollection_Sequence_TCollection_ExtendedString userComments)

        :type userComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _Storage.Storage_BaseDriver_ReadComment(self, *args)


    def EndReadCommentSection(self, *args):
        """
        EndReadCommentSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndReadCommentSection(self, *args)


    def BeginWriteTypeSection(self, *args):
        """
        BeginWriteTypeSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginWriteTypeSection(self, *args)


    def SetTypeSectionSize(self, *args):
        """
        SetTypeSectionSize(Storage_BaseDriver self, Standard_Integer const aSize)

        :type aSize: int

        """
        return _Storage.Storage_BaseDriver_SetTypeSectionSize(self, *args)


    def WriteTypeInformations(self, *args):
        """
        WriteTypeInformations(Storage_BaseDriver self, Standard_Integer const typeNum, TCollection_AsciiString typeName)

        :type typeNum: int
        :type typeName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_BaseDriver_WriteTypeInformations(self, *args)


    def EndWriteTypeSection(self, *args):
        """
        EndWriteTypeSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndWriteTypeSection(self, *args)


    def BeginReadTypeSection(self, *args):
        """
        BeginReadTypeSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginReadTypeSection(self, *args)


    def TypeSectionSize(self, *args):
        """
        TypeSectionSize(Storage_BaseDriver self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_BaseDriver_TypeSectionSize(self, *args)


    def ReadTypeInformations(self, *args):
        """
        ReadTypeInformations(Storage_BaseDriver self, TCollection_AsciiString typeName)

        :type typeNum: int
        :type typeName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_BaseDriver_ReadTypeInformations(self, *args)


    def EndReadTypeSection(self, *args):
        """
        EndReadTypeSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndReadTypeSection(self, *args)


    def BeginWriteRootSection(self, *args):
        """
        BeginWriteRootSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginWriteRootSection(self, *args)


    def SetRootSectionSize(self, *args):
        """
        SetRootSectionSize(Storage_BaseDriver self, Standard_Integer const aSize)

        :type aSize: int

        """
        return _Storage.Storage_BaseDriver_SetRootSectionSize(self, *args)


    def WriteRoot(self, *args):
        """
        WriteRoot(Storage_BaseDriver self, TCollection_AsciiString rootName, Standard_Integer const aRef, TCollection_AsciiString aType)

        :type rootName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aRef: int
        :type aType: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_BaseDriver_WriteRoot(self, *args)


    def EndWriteRootSection(self, *args):
        """
        EndWriteRootSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndWriteRootSection(self, *args)


    def BeginReadRootSection(self, *args):
        """
        BeginReadRootSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginReadRootSection(self, *args)


    def RootSectionSize(self, *args):
        """
        RootSectionSize(Storage_BaseDriver self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_BaseDriver_RootSectionSize(self, *args)


    def ReadRoot(self, *args):
        """
        ReadRoot(Storage_BaseDriver self, TCollection_AsciiString rootName, TCollection_AsciiString aType)

        :type rootName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aRef: int
        :type aType: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_BaseDriver_ReadRoot(self, *args)


    def EndReadRootSection(self, *args):
        """
        EndReadRootSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndReadRootSection(self, *args)


    def BeginWriteRefSection(self, *args):
        """
        BeginWriteRefSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginWriteRefSection(self, *args)


    def SetRefSectionSize(self, *args):
        """
        SetRefSectionSize(Storage_BaseDriver self, Standard_Integer const aSize)

        :type aSize: int

        """
        return _Storage.Storage_BaseDriver_SetRefSectionSize(self, *args)


    def WriteReferenceType(self, *args):
        """
        WriteReferenceType(Storage_BaseDriver self, Standard_Integer const reference, Standard_Integer const typeNum)

        :type reference: int
        :type typeNum: int

        """
        return _Storage.Storage_BaseDriver_WriteReferenceType(self, *args)


    def EndWriteRefSection(self, *args):
        """
        EndWriteRefSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndWriteRefSection(self, *args)


    def BeginReadRefSection(self, *args):
        """
        BeginReadRefSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginReadRefSection(self, *args)


    def RefSectionSize(self, *args):
        """
        RefSectionSize(Storage_BaseDriver self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_BaseDriver_RefSectionSize(self, *args)


    def ReadReferenceType(self, *args):
        """
        ReadReferenceType(Storage_BaseDriver self)

        :type reference: int
        :type typeNum: int

        """
        return _Storage.Storage_BaseDriver_ReadReferenceType(self, *args)


    def EndReadRefSection(self, *args):
        """
        EndReadRefSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndReadRefSection(self, *args)


    def BeginWriteDataSection(self, *args):
        """
        BeginWriteDataSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginWriteDataSection(self, *args)


    def WritePersistentObjectHeader(self, *args):
        """
        WritePersistentObjectHeader(Storage_BaseDriver self, Standard_Integer const aRef, Standard_Integer const aType)

        :type aRef: int
        :type aType: int

        """
        return _Storage.Storage_BaseDriver_WritePersistentObjectHeader(self, *args)


    def BeginWritePersistentObjectData(self, *args):
        """BeginWritePersistentObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_BeginWritePersistentObjectData(self, *args)


    def BeginWriteObjectData(self, *args):
        """BeginWriteObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_BeginWriteObjectData(self, *args)


    def EndWriteObjectData(self, *args):
        """EndWriteObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_EndWriteObjectData(self, *args)


    def EndWritePersistentObjectData(self, *args):
        """EndWritePersistentObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_EndWritePersistentObjectData(self, *args)


    def EndWriteDataSection(self, *args):
        """
        EndWriteDataSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndWriteDataSection(self, *args)


    def BeginReadDataSection(self, *args):
        """
        BeginReadDataSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_BeginReadDataSection(self, *args)


    def ReadPersistentObjectHeader(self, *args):
        """
        ReadPersistentObjectHeader(Storage_BaseDriver self)

        :type aRef: int
        :type aType: int

        """
        return _Storage.Storage_BaseDriver_ReadPersistentObjectHeader(self, *args)


    def BeginReadPersistentObjectData(self, *args):
        """BeginReadPersistentObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_BeginReadPersistentObjectData(self, *args)


    def BeginReadObjectData(self, *args):
        """BeginReadObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_BeginReadObjectData(self, *args)


    def EndReadObjectData(self, *args):
        """EndReadObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_EndReadObjectData(self, *args)


    def EndReadPersistentObjectData(self, *args):
        """EndReadPersistentObjectData(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_EndReadPersistentObjectData(self, *args)


    def EndReadDataSection(self, *args):
        """
        EndReadDataSection(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_EndReadDataSection(self, *args)


    def SkipObject(self, *args):
        """SkipObject(Storage_BaseDriver self)"""
        return _Storage.Storage_BaseDriver_SkipObject(self, *args)


    def PutReference(self, *args):
        """
        PutReference(Storage_BaseDriver self, Standard_Integer const aValue) -> Storage_BaseDriver

        :type aValue: int
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_PutReference(self, *args)


    def PutCharacter(self, *args):
        """
        PutCharacter(Storage_BaseDriver self, Standard_Character const aValue) -> Storage_BaseDriver

        :type aValue: OCC.wrapper.Standard.Standard_Character
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_PutCharacter(self, *args)


    def PutExtCharacter(self, *args):
        """
        PutExtCharacter(Storage_BaseDriver self, Standard_ExtCharacter const aValue) -> Storage_BaseDriver

        :type aValue: OCC.wrapper.Standard.Standard_ExtCharacter
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_PutExtCharacter(self, *args)


    def PutInteger(self, *args):
        """
        PutInteger(Storage_BaseDriver self, Standard_Integer const aValue) -> Storage_BaseDriver

        :type aValue: int
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_PutInteger(self, *args)


    def PutBoolean(self, *args):
        """
        PutBoolean(Storage_BaseDriver self, Standard_Boolean const aValue) -> Storage_BaseDriver

        :type aValue: bool
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_PutBoolean(self, *args)


    def PutReal(self, *args):
        """
        PutReal(Storage_BaseDriver self, Standard_Real const aValue) -> Storage_BaseDriver

        :type aValue: float
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_PutReal(self, *args)


    def PutShortReal(self, *args):
        """
        PutShortReal(Storage_BaseDriver self, Standard_ShortReal const aValue) -> Storage_BaseDriver

        :type aValue: float
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_PutShortReal(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Storage_BaseDriver self, Standard_Character const aValue) -> Storage_BaseDriver
        __lshift__(Storage_BaseDriver self, Standard_ExtCharacter const aValue) -> Storage_BaseDriver
        __lshift__(Storage_BaseDriver self, Standard_Integer const aValue) -> Storage_BaseDriver
        __lshift__(Storage_BaseDriver self, Standard_Boolean const aValue) -> Storage_BaseDriver
        __lshift__(Storage_BaseDriver self, Standard_Real const aValue) -> Storage_BaseDriver
        __lshift__(Storage_BaseDriver self, Standard_ShortReal const aValue) -> Storage_BaseDriver

        :type aValue: float
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver___lshift__(self, *args)


    def GetReference(self, *args):
        """
        GetReference(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: int
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_GetReference(self, *args)


    def GetCharacter(self, *args):
        """
        GetCharacter(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: OCC.wrapper.Standard.Standard_Character
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_GetCharacter(self, *args)


    def GetExtCharacter(self, *args):
        """
        GetExtCharacter(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: OCC.wrapper.Standard.Standard_ExtCharacter
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_GetExtCharacter(self, *args)


    def GetInteger(self, *args):
        """
        GetInteger(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: int
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_GetInteger(self, *args)


    def GetBoolean(self, *args):
        """
        GetBoolean(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: bool
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_GetBoolean(self, *args)


    def GetReal(self, *args):
        """
        GetReal(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: float
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_GetReal(self, *args)


    def GetShortReal(self, *args):
        """
        GetShortReal(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: float
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver_GetShortReal(self, *args)


    def __rshift__(self, *args):
        """
        __rshift__(Storage_BaseDriver self) -> Storage_BaseDriver
        __rshift__(Storage_BaseDriver self) -> Storage_BaseDriver
        __rshift__(Storage_BaseDriver self) -> Storage_BaseDriver
        __rshift__(Storage_BaseDriver self) -> Storage_BaseDriver
        __rshift__(Storage_BaseDriver self) -> Storage_BaseDriver
        __rshift__(Storage_BaseDriver self) -> Storage_BaseDriver

        :type aValue: float
        :rtype: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Storage_BaseDriver___rshift__(self, *args)


    def Close(self, *args):
        """
        Close(Storage_BaseDriver self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_BaseDriver_Close(self, *args)

    __swig_destroy__ = _Storage.delete_Storage_BaseDriver
Storage_BaseDriver_swigregister = _Storage.Storage_BaseDriver_swigregister
Storage_BaseDriver_swigregister(Storage_BaseDriver)

def Storage_BaseDriver_ReadMagicNumber(*args):
    """
    Storage_BaseDriver_ReadMagicNumber(Standard_IStream & theIStream) -> TCollection_AsciiString

    :type theIStream: OCC.wrapper.Standard.Standard_IStream
    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _Storage.Storage_BaseDriver_ReadMagicNumber(*args)

class Handle_Storage_Root(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_Root self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_Root_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_Root self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_Root_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_Root self, Storage_Root thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_Root_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_Root self, Handle_Storage_Root theHandle) -> Handle_Storage_Root
        assign(Handle_Storage_Root self, Storage_Root thePtr) -> Handle_Storage_Root
        assign(Handle_Storage_Root self, Handle_Storage_Root theHandle) -> Handle_Storage_Root

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_Root_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_Root self) -> Storage_Root

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_Root_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_Root self) -> Storage_Root

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_Root___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_Root self) -> Storage_Root

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_Root___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_Root___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_Root___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_Root_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_Root

    def SetName(self, *args):
        """
        SetName(Handle_Storage_Root self, TCollection_AsciiString theName)

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Root_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_Storage_Root self) -> TCollection_AsciiString

        Returns the name of this root object.
        The name may have been given explicitly when
        the root was inserted into the Storage_Data
        object. If not, the name is a reference number
        which was assigned automatically by the driver
        when writing the set of data into the container.
        When naming the roots, it is easier to retrieve
        objects by significant references rather than by
        references without any semantic values.
        Warning
        The returned string will be empty if you call this
        function before having named this root object,
        either explicitly, or when writing the set of data
        into the container.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Root_Name(self, *args)


    def SetObject(self, *args):
        """
        SetObject(Handle_Storage_Root self, Handle_Standard_Persistent anObject)

        :type anObject: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Handle_Storage_Root_SetObject(self, *args)


    def Object(self, *args):
        """
        Object(Handle_Storage_Root self) -> Handle_Standard_Persistent

        Returns the persistent object encapsulated by this root.

        :rtype: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Handle_Storage_Root_Object(self, *args)


    def Type(self, *args):
        """
        Type(Handle_Storage_Root self) -> TCollection_AsciiString

        Returns the name of this root type.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Root_Type(self, *args)


    def SetReference(self, *args):
        """
        SetReference(Handle_Storage_Root self, Standard_Integer const aRef)

        :type aRef: int

        """
        return _Storage.Handle_Storage_Root_SetReference(self, *args)


    def Reference(self, *args):
        """
        Reference(Handle_Storage_Root self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Root_Reference(self, *args)


    def SetType(self, *args):
        """
        SetType(Handle_Storage_Root self, TCollection_AsciiString aType)

        :type aType: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Root_SetType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_Root self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_Root_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_Root_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_Root_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_Root self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_Root_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_Root self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_Root self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Root_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_Root self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_Root self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Root_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_Root self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_Root_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_Root self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Root_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_Root self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_Root_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_Root self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Root_DecrementRefCounter(self, *args)

Handle_Storage_Root_swigregister = _Storage.Handle_Storage_Root_swigregister
Handle_Storage_Root_swigregister(Handle_Storage_Root)

def Handle_Storage_Root_DownCast(thing):
    return _Storage.Handle_Storage_Root_DownCast(thing)
Handle_Storage_Root_DownCast = _Storage.Handle_Storage_Root_DownCast

class Handle_Storage_InternalData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_InternalData self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_InternalData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_InternalData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_InternalData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_InternalData self, Storage_InternalData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_InternalData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_InternalData self, Handle_Storage_InternalData theHandle) -> Handle_Storage_InternalData
        assign(Handle_Storage_InternalData self, Storage_InternalData thePtr) -> Handle_Storage_InternalData
        assign(Handle_Storage_InternalData self, Handle_Storage_InternalData theHandle) -> Handle_Storage_InternalData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_InternalData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_InternalData self) -> Storage_InternalData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_InternalData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_InternalData self) -> Storage_InternalData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_InternalData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_InternalData self) -> Storage_InternalData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_InternalData___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_InternalData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_InternalData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_InternalData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_InternalData_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_InternalData

    def ReadArray(self, *args):
        """
        ReadArray(Handle_Storage_InternalData self) -> Handle_Storage_HPArray

        :rtype: OCC.wrapper.Storage.Handle_Storage_HPArray

        """
        return _Storage.Handle_Storage_InternalData_ReadArray(self, *args)


    def Clear(self, *args):
        """Clear(Handle_Storage_InternalData self)"""
        return _Storage.Handle_Storage_InternalData_Clear(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_InternalData self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_InternalData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_InternalData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_InternalData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_InternalData self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_InternalData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_InternalData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_InternalData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_InternalData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_InternalData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_InternalData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_InternalData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_InternalData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_InternalData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_InternalData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_InternalData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_InternalData self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_InternalData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_InternalData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_InternalData_DecrementRefCounter(self, *args)

Handle_Storage_InternalData_swigregister = _Storage.Handle_Storage_InternalData_swigregister
Handle_Storage_InternalData_swigregister(Handle_Storage_InternalData)

def Handle_Storage_InternalData_DownCast(thing):
    return _Storage.Handle_Storage_InternalData_DownCast(thing)
Handle_Storage_InternalData_DownCast = _Storage.Handle_Storage_InternalData_DownCast

class Handle_Storage_StreamWriteError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_StreamWriteError self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_StreamWriteError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_StreamWriteError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_StreamWriteError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_StreamWriteError self, Storage_StreamWriteError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_StreamWriteError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_StreamWriteError self, Handle_Storage_StreamWriteError theHandle) -> Handle_Storage_StreamWriteError
        assign(Handle_Storage_StreamWriteError self, Storage_StreamWriteError thePtr) -> Handle_Storage_StreamWriteError
        assign(Handle_Storage_StreamWriteError self, Handle_Storage_StreamWriteError theHandle) -> Handle_Storage_StreamWriteError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_StreamWriteError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_StreamWriteError self) -> Storage_StreamWriteError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamWriteError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_StreamWriteError self) -> Storage_StreamWriteError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamWriteError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_StreamWriteError self) -> Storage_StreamWriteError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_StreamWriteError___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_StreamWriteError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_StreamWriteError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_StreamWriteError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_StreamWriteError_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_StreamWriteError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Storage_StreamWriteError self, Standard_CString const theMessage) -> Handle_Storage_StreamWriteError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamWriteError

        """
        return _Storage.Handle_Storage_StreamWriteError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_StreamWriteError self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_StreamWriteError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamWriteError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamWriteError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Storage_StreamWriteError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Storage.Handle_Storage_StreamWriteError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Storage_StreamWriteError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamWriteError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Storage_StreamWriteError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamWriteError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Storage_StreamWriteError self)
        Reraise(Handle_Storage_StreamWriteError self, Standard_CString const aMessage)
        Reraise(Handle_Storage_StreamWriteError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Storage.Handle_Storage_StreamWriteError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Storage_StreamWriteError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Storage.Handle_Storage_StreamWriteError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Storage_StreamWriteError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Storage.Handle_Storage_StreamWriteError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_StreamWriteError self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_StreamWriteError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_StreamWriteError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_StreamWriteError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamWriteError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_StreamWriteError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_StreamWriteError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamWriteError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_StreamWriteError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_StreamWriteError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_StreamWriteError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamWriteError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_StreamWriteError self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_StreamWriteError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_StreamWriteError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamWriteError_DecrementRefCounter(self, *args)

Handle_Storage_StreamWriteError_swigregister = _Storage.Handle_Storage_StreamWriteError_swigregister
Handle_Storage_StreamWriteError_swigregister(Handle_Storage_StreamWriteError)

def Handle_Storage_StreamWriteError_DownCast(thing):
    return _Storage.Handle_Storage_StreamWriteError_DownCast(thing)
Handle_Storage_StreamWriteError_DownCast = _Storage.Handle_Storage_StreamWriteError_DownCast

class Handle_Storage_DefaultCallBack(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_DefaultCallBack self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_DefaultCallBack_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_DefaultCallBack self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_DefaultCallBack_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_DefaultCallBack self, Storage_DefaultCallBack thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_DefaultCallBack_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_DefaultCallBack self, Handle_Storage_DefaultCallBack theHandle) -> Handle_Storage_DefaultCallBack
        assign(Handle_Storage_DefaultCallBack self, Storage_DefaultCallBack thePtr) -> Handle_Storage_DefaultCallBack
        assign(Handle_Storage_DefaultCallBack self, Handle_Storage_DefaultCallBack theHandle) -> Handle_Storage_DefaultCallBack

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_DefaultCallBack_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_DefaultCallBack self) -> Storage_DefaultCallBack

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_DefaultCallBack_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_DefaultCallBack self) -> Storage_DefaultCallBack

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_DefaultCallBack___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_DefaultCallBack self) -> Storage_DefaultCallBack

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_DefaultCallBack___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_DefaultCallBack___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_DefaultCallBack___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_DefaultCallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_DefaultCallBack_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_DefaultCallBack

    def New(self, *args):
        """
        New(Handle_Storage_DefaultCallBack self) -> Handle_Standard_Persistent

        :rtype: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Handle_Storage_DefaultCallBack_New(self, *args)


    def Add(self, *args):
        """
        Add(Handle_Storage_DefaultCallBack self, Handle_Standard_Persistent aPers, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Handle_Storage_DefaultCallBack_Add(self, *args)


    def Write(self, *args):
        """
        Write(Handle_Storage_DefaultCallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Handle_Storage_DefaultCallBack_Write(self, *args)


    def Read(self, *args):
        """
        Read(Handle_Storage_DefaultCallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Handle_Storage_DefaultCallBack_Read(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_DefaultCallBack self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_DefaultCallBack_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_DefaultCallBack_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_DefaultCallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_DefaultCallBack self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_DefaultCallBack_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_DefaultCallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_DefaultCallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_DefaultCallBack_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_DefaultCallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_DefaultCallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_DefaultCallBack_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_DefaultCallBack self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_DefaultCallBack_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_DefaultCallBack self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_DefaultCallBack_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_DefaultCallBack self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_DefaultCallBack_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_DefaultCallBack self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_DefaultCallBack_DecrementRefCounter(self, *args)

Handle_Storage_DefaultCallBack_swigregister = _Storage.Handle_Storage_DefaultCallBack_swigregister
Handle_Storage_DefaultCallBack_swigregister(Handle_Storage_DefaultCallBack)

def Handle_Storage_DefaultCallBack_DownCast(thing):
    return _Storage.Handle_Storage_DefaultCallBack_DownCast(thing)
Handle_Storage_DefaultCallBack_DownCast = _Storage.Handle_Storage_DefaultCallBack_DownCast

class Storage_HSeqOfRoot(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_HSeqOfRoot
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_HSeqOfRoot(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_HSeqOfRoot self) -> Storage_HSeqOfRoot
        __init__(Storage_HSeqOfRoot self, NCollection_Sequence_Handle_Storage_Root theOther) -> Storage_HSeqOfRoot

        :type theOther: OCC.wrapper.Storage.Storage_SeqOfRoot

        """
        this = _Storage.new_Storage_HSeqOfRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_SeqOfRoot

        """
        res = _Storage.Storage_HSeqOfRoot_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Storage_HSeqOfRoot self, Handle_Storage_Root theItem)
        Append(Storage_HSeqOfRoot self, NCollection_Sequence_Handle_Storage_Root theSequence)

        :type theSequence: OCC.wrapper.Storage.Storage_SeqOfRoot

        """
        return _Storage.Storage_HSeqOfRoot_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Storage_HSeqOfRoot self) -> NCollection_Sequence_Handle_Storage_Root

        :rtype: OCC.wrapper.Storage.Storage_SeqOfRoot

        """
        return _Storage.Storage_HSeqOfRoot_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_HSeqOfRoot_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_HSeqOfRoot_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_HSeqOfRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_HSeqOfRoot
Storage_HSeqOfRoot_swigregister = _Storage.Storage_HSeqOfRoot_swigregister
Storage_HSeqOfRoot_swigregister(Storage_HSeqOfRoot)

def Storage_HSeqOfRoot_get_type_name(*args):
    """
    Storage_HSeqOfRoot_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_HSeqOfRoot_get_type_name(*args)

def Storage_HSeqOfRoot_get_type_descriptor(*args):
    """
    Storage_HSeqOfRoot_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_HSeqOfRoot_get_type_descriptor(*args)

class Handle_Storage_Data(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_Data self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_Data_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_Data self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_Data_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_Data self, Storage_Data thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_Data_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_Data self, Handle_Storage_Data theHandle) -> Handle_Storage_Data
        assign(Handle_Storage_Data self, Storage_Data thePtr) -> Handle_Storage_Data
        assign(Handle_Storage_Data self, Handle_Storage_Data theHandle) -> Handle_Storage_Data

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_Data_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_Data self) -> Storage_Data

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_Data_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_Data self) -> Storage_Data

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_Data___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_Data self) -> Storage_Data

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_Data___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_Data___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_Data___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_Data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_Data_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_Data

    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_Storage_Data self) -> Storage_Error

        Returns Storage_VSOk if
        -   the last storage operation performed with the
        function Read, or
        -   the last retrieval operation performed with the function Write
        by a Storage_Schema algorithm, on this set of data was successful.
        If the storage or retrieval operation was not
        performed, the returned error status indicates the
        reason why the operation failed. The algorithm
        stops its analysis at the first detected error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Handle_Storage_Data_ErrorStatus(self, *args)


    def ClearErrorStatus(self, *args):
        """
        ClearErrorStatus(Handle_Storage_Data self)

        Clears the error status positioned either by:
        -   the last storage operation performed with the
        Read function, or
        -   the last retrieval operation performed with the Write function
        by a Storage_Schema algorithm, on this set of data.
        This error status may be read by the function ErrorStatus.


        """
        return _Storage.Handle_Storage_Data_ClearErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Handle_Storage_Data self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_ErrorStatusExtension(self, *args)


    def CreationDate(self, *args):
        """
        CreationDate(Handle_Storage_Data self) -> TCollection_AsciiString

        return the creation date

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_CreationDate(self, *args)


    def StorageVersion(self, *args):
        """
        StorageVersion(Handle_Storage_Data self) -> TCollection_AsciiString

        return the Storage package version

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_StorageVersion(self, *args)


    def SchemaVersion(self, *args):
        """
        SchemaVersion(Handle_Storage_Data self) -> TCollection_AsciiString

        get the version of the schema

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_SchemaVersion(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(Handle_Storage_Data self) -> TCollection_AsciiString

        get the schema's name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_SchemaName(self, *args)


    def SetApplicationVersion(self, *args):
        """
        SetApplicationVersion(Handle_Storage_Data self, TCollection_AsciiString aVersion)

        set the version of the application

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_SetApplicationVersion(self, *args)


    def ApplicationVersion(self, *args):
        """
        ApplicationVersion(Handle_Storage_Data self) -> TCollection_AsciiString

        get the version of the application

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_ApplicationVersion(self, *args)


    def SetApplicationName(self, *args):
        """
        SetApplicationName(Handle_Storage_Data self, TCollection_ExtendedString aName)

        set the name of the application

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_Data_SetApplicationName(self, *args)


    def ApplicationName(self, *args):
        """
        ApplicationName(Handle_Storage_Data self) -> TCollection_ExtendedString

        get the name of the application

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_Data_ApplicationName(self, *args)


    def SetDataType(self, *args):
        """
        SetDataType(Handle_Storage_Data self, TCollection_ExtendedString aType)

        set the data type

        :type aType: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_Data_SetDataType(self, *args)


    def DataType(self, *args):
        """
        DataType(Handle_Storage_Data self) -> TCollection_ExtendedString

        returns data type

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_Data_DataType(self, *args)


    def AddToUserInfo(self, *args):
        """
        AddToUserInfo(Handle_Storage_Data self, TCollection_AsciiString anInfo)

        add <theUserInfo> to the user informations

        :type anInfo: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_AddToUserInfo(self, *args)


    def UserInfo(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        res = _Storage.Handle_Storage_Data_UserInfo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddToComments(self, *args):
        """
        AddToComments(Handle_Storage_Data self, TCollection_ExtendedString aComment)

        add <theUserInfo> to the user informations

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_Data_AddToComments(self, *args)


    def Comments(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _Storage.Handle_Storage_Data_Comments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NumberOfObjects(self, *args):
        """
        NumberOfObjects(Handle_Storage_Data self) -> Standard_Integer

        the the number of persistent objects
        Return:
        the number of persistent objects readed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Data_NumberOfObjects(self, *args)


    def NumberOfRoots(self, *args):
        """
        NumberOfRoots(Handle_Storage_Data self) -> Standard_Integer

        Returns the number of root objects in this set of data.
        -   When preparing a storage operation, the
        result is the number of roots inserted into this
        set of data with the function AddRoot.
        -   When retrieving an object, the result is the
        number of roots stored in the read container.
        Use the Roots function to get these roots in a sequence.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Data_NumberOfRoots(self, *args)


    def AddRoot(self, *args):
        """
        AddRoot(Handle_Storage_Data self, Handle_Standard_Persistent anObject)
        AddRoot(Handle_Storage_Data self, TCollection_AsciiString aName, Handle_Standard_Persistent anObject)

        Adds the root anObject to this set of data.
        The name of the root is aName if given; if not, it
        will be a reference number assigned by the driver
        when writing the set of data into the container.
        When naming the roots, it is easier to retrieve
        objects by significant references rather than by
        references without any semantic values.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type anObject: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Handle_Storage_Data_AddRoot(self, *args)


    def RemoveRoot(self, *args):
        """
        RemoveRoot(Handle_Storage_Data self, TCollection_AsciiString aName)

        Removes from this set of data the root object named aName.
        Warning
        Nothing is done if there is no root object whose
        name is aName in this set of data.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Data_RemoveRoot(self, *args)


    def Roots(self, *args):
        """
        Roots(Handle_Storage_Data self) -> Handle_Storage_HSeqOfRoot

        Returns the roots of this set of data in a sequence.
        -   When preparing a storage operation, the
        sequence contains the roots inserted into this
        set of data with the function AddRoot.
        -   When retrieving an object, the sequence
        contains the roots stored in the container read.
        -   An empty sequence is returned if there is no root in this set of data.

        :rtype: OCC.wrapper.Storage.Handle_Storage_HSeqOfRoot

        """
        return _Storage.Handle_Storage_Data_Roots(self, *args)


    def Find(self, *args):
        """
        Find(Handle_Storage_Data self, TCollection_AsciiString aName) -> Handle_Storage_Root

        Gives the root object whose name is aName in
        this set of data. The returned object is a
        Storage_Root object, from which the object it
        encapsulates may be extracted.
        Warning
        A null handle is returned if there is no root object
        whose name is aName in this set of data.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Storage.Handle_Storage_Root

        """
        return _Storage.Handle_Storage_Data_Find(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(Handle_Storage_Data self, TCollection_AsciiString aName) -> Standard_Boolean

        returns Standard_True if <me> contains a root named <aName>

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Data_IsRoot(self, *args)


    def NumberOfTypes(self, *args):
        """
        NumberOfTypes(Handle_Storage_Data self) -> Standard_Integer

        Returns the number of types of objects used in this set of data.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Data_NumberOfTypes(self, *args)


    def IsType(self, *args):
        """
        IsType(Handle_Storage_Data self, TCollection_AsciiString aName) -> Standard_Boolean

        Returns true if this set of data contains an object of type aName.
        Persistent objects from this set of data must
        have types which are recognized by the
        Storage_Schema algorithm used to store or retrieve them.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Data_IsType(self, *args)


    def Types(self, *args):
        """
        Types(Handle_Storage_Data self) -> Handle_TColStd_HSequenceOfAsciiString

        Gives the list of types of objects used in this set of data in a sequence.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Storage.Handle_Storage_Data_Types(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_Data self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_Data_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_Data_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_Data_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HeaderData(self, *args):
        """
        HeaderData(Handle_Storage_Data self) -> Handle_Storage_HeaderData

        :rtype: OCC.wrapper.Storage.Handle_Storage_HeaderData

        """
        return _Storage.Handle_Storage_Data_HeaderData(self, *args)


    def RootData(self, *args):
        """
        RootData(Handle_Storage_Data self) -> Handle_Storage_RootData

        :rtype: OCC.wrapper.Storage.Handle_Storage_RootData

        """
        return _Storage.Handle_Storage_Data_RootData(self, *args)


    def TypeData(self, *args):
        """
        TypeData(Handle_Storage_Data self) -> Handle_Storage_TypeData

        :rtype: OCC.wrapper.Storage.Handle_Storage_TypeData

        """
        return _Storage.Handle_Storage_Data_TypeData(self, *args)


    def InternalData(self, *args):
        """
        InternalData(Handle_Storage_Data self) -> Handle_Storage_InternalData

        :rtype: OCC.wrapper.Storage.Handle_Storage_InternalData

        """
        return _Storage.Handle_Storage_Data_InternalData(self, *args)


    def Clear(self, *args):
        """Clear(Handle_Storage_Data self)"""
        return _Storage.Handle_Storage_Data_Clear(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_Data self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_Data_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_Data self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_Data self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Data_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_Data self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_Data self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Data_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_Data self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_Data_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_Data self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Data_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_Data self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_Data_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_Data self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Data_DecrementRefCounter(self, *args)

Handle_Storage_Data_swigregister = _Storage.Handle_Storage_Data_swigregister
Handle_Storage_Data_swigregister(Handle_Storage_Data)

def Handle_Storage_Data_DownCast(thing):
    return _Storage.Handle_Storage_Data_DownCast(thing)
Handle_Storage_Data_DownCast = _Storage.Handle_Storage_Data_DownCast

class Handle_Storage_TypeData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_TypeData self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_TypeData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_TypeData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_TypeData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_TypeData self, Storage_TypeData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_TypeData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_TypeData self, Handle_Storage_TypeData theHandle) -> Handle_Storage_TypeData
        assign(Handle_Storage_TypeData self, Storage_TypeData thePtr) -> Handle_Storage_TypeData
        assign(Handle_Storage_TypeData self, Handle_Storage_TypeData theHandle) -> Handle_Storage_TypeData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_TypeData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_TypeData self) -> Storage_TypeData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_TypeData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_TypeData self) -> Storage_TypeData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_TypeData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_TypeData self) -> Storage_TypeData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_TypeData___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_TypeData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_TypeData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_TypeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_TypeData_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_TypeData

    def Read(self, *args):
        """
        Read(Handle_Storage_TypeData self, Storage_BaseDriver theDriver) -> Standard_Boolean

        :type theDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_TypeData_Read(self, *args)


    def NumberOfTypes(self, *args):
        """
        NumberOfTypes(Handle_Storage_TypeData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_TypeData_NumberOfTypes(self, *args)


    def AddType(self, *args):
        """
        AddType(Handle_Storage_TypeData self, TCollection_AsciiString aName, Standard_Integer const aTypeNum)

        add a type to the list

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aTypeNum: int

        """
        return _Storage.Handle_Storage_TypeData_AddType(self, *args)


    def Type(self, *args):
        """
        Type(Handle_Storage_TypeData self, Standard_Integer const aTypeNum) -> TCollection_AsciiString
        Type(Handle_Storage_TypeData self, TCollection_AsciiString aTypeName) -> Standard_Integer

        returns the name of the type with number <aTypeNum>

        :type aTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_TypeData_Type(self, *args)


    def IsType(self, *args):
        """
        IsType(Handle_Storage_TypeData self, TCollection_AsciiString aName) -> Standard_Boolean

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_TypeData_IsType(self, *args)


    def Types(self, *args):
        """
        Types(Handle_Storage_TypeData self) -> Handle_TColStd_HSequenceOfAsciiString

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Storage.Handle_Storage_TypeData_Types(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_Storage_TypeData self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Handle_Storage_TypeData_ErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Handle_Storage_TypeData self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_TypeData_ErrorStatusExtension(self, *args)


    def ClearErrorStatus(self, *args):
        """ClearErrorStatus(Handle_Storage_TypeData self)"""
        return _Storage.Handle_Storage_TypeData_ClearErrorStatus(self, *args)


    def Clear(self, *args):
        """Clear(Handle_Storage_TypeData self)"""
        return _Storage.Handle_Storage_TypeData_Clear(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_TypeData self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_TypeData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_TypeData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_TypeData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_TypeData self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_TypeData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_TypeData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_TypeData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_TypeData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_TypeData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_TypeData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_TypeData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_TypeData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_TypeData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_TypeData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_TypeData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_TypeData self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_TypeData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_TypeData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_TypeData_DecrementRefCounter(self, *args)

Handle_Storage_TypeData_swigregister = _Storage.Handle_Storage_TypeData_swigregister
Handle_Storage_TypeData_swigregister(Handle_Storage_TypeData)

def Handle_Storage_TypeData_DownCast(thing):
    return _Storage.Handle_Storage_TypeData_DownCast(thing)
Handle_Storage_TypeData_DownCast = _Storage.Handle_Storage_TypeData_DownCast

class Handle_Storage_HArrayOfSchema(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_HArrayOfSchema self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_HArrayOfSchema_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_HArrayOfSchema self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_HArrayOfSchema_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_HArrayOfSchema self, Storage_HArrayOfSchema thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_HArrayOfSchema_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_HArrayOfSchema self, Handle_Storage_HArrayOfSchema theHandle) -> Handle_Storage_HArrayOfSchema
        assign(Handle_Storage_HArrayOfSchema self, Storage_HArrayOfSchema thePtr) -> Handle_Storage_HArrayOfSchema
        assign(Handle_Storage_HArrayOfSchema self, Handle_Storage_HArrayOfSchema theHandle) -> Handle_Storage_HArrayOfSchema

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_HArrayOfSchema_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_HArrayOfSchema self) -> Storage_HArrayOfSchema

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_HArrayOfSchema_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_HArrayOfSchema self) -> Storage_HArrayOfSchema

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_HArrayOfSchema___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_HArrayOfSchema self) -> Storage_HArrayOfSchema

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_HArrayOfSchema___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_HArrayOfSchema___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_HArrayOfSchema___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_HArrayOfSchema(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_HArrayOfSchema_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_HArrayOfSchema

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_ArrayOfSchema

        """
        res = _Storage.Handle_Storage_HArrayOfSchema_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Storage_HArrayOfSchema self) -> NCollection_Array1_Handle_Storage_Schema

        :rtype: OCC.wrapper.Storage.Storage_ArrayOfSchema

        """
        return _Storage.Handle_Storage_HArrayOfSchema_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_HArrayOfSchema self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_HArrayOfSchema_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HArrayOfSchema_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HArrayOfSchema_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_HArrayOfSchema self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_HArrayOfSchema_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_HArrayOfSchema self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_HArrayOfSchema self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HArrayOfSchema_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_HArrayOfSchema self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_HArrayOfSchema self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HArrayOfSchema_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_HArrayOfSchema self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_HArrayOfSchema_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_HArrayOfSchema self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HArrayOfSchema_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_HArrayOfSchema self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_HArrayOfSchema_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_HArrayOfSchema self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HArrayOfSchema_DecrementRefCounter(self, *args)

Handle_Storage_HArrayOfSchema_swigregister = _Storage.Handle_Storage_HArrayOfSchema_swigregister
Handle_Storage_HArrayOfSchema_swigregister(Handle_Storage_HArrayOfSchema)

def Handle_Storage_HArrayOfSchema_DownCast(thing):
    return _Storage.Handle_Storage_HArrayOfSchema_DownCast(thing)
Handle_Storage_HArrayOfSchema_DownCast = _Storage.Handle_Storage_HArrayOfSchema_DownCast

class Handle_Standard_Persistent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Standard_Persistent self)

        Nullify the handle


        """
        return _Storage.Handle_Standard_Persistent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Standard_Persistent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Standard_Persistent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Standard_Persistent self, Standard_Persistent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Standard_Persistent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Standard_Persistent self, Handle_Standard_Persistent theHandle) -> Handle_Standard_Persistent
        assign(Handle_Standard_Persistent self, Standard_Persistent thePtr) -> Handle_Standard_Persistent
        assign(Handle_Standard_Persistent self, Handle_Standard_Persistent theHandle) -> Handle_Standard_Persistent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Standard_Persistent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Standard_Persistent self) -> Standard_Persistent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Standard_Persistent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Standard_Persistent self) -> Standard_Persistent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Standard_Persistent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Standard_Persistent self) -> Standard_Persistent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Standard_Persistent___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Standard_Persistent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Standard_Persistent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Standard_Persistent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Standard_Persistent_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Standard_Persistent

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Standard_Persistent self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Standard_Persistent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Standard_Persistent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Standard_Persistent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TypeNum(self, *args):
        """
        TypeNum(Handle_Standard_Persistent self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Standard_Persistent_TypeNum(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Standard_Persistent self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Standard_Persistent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Standard_Persistent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Standard_Persistent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Standard_Persistent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Standard_Persistent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Standard_Persistent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Standard_Persistent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Standard_Persistent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Standard_Persistent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Standard_Persistent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Standard_Persistent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Standard_Persistent self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Standard_Persistent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Standard_Persistent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Standard_Persistent_DecrementRefCounter(self, *args)

Handle_Standard_Persistent_swigregister = _Storage.Handle_Standard_Persistent_swigregister
Handle_Standard_Persistent_swigregister(Handle_Standard_Persistent)

def Handle_Standard_Persistent_DownCast(thing):
    return _Storage.Handle_Standard_Persistent_DownCast(thing)
Handle_Standard_Persistent_DownCast = _Storage.Handle_Standard_Persistent_DownCast

class Handle_Storage_HArrayOfCallBack(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_HArrayOfCallBack self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_HArrayOfCallBack_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_HArrayOfCallBack self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_HArrayOfCallBack self, Storage_HArrayOfCallBack thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_HArrayOfCallBack self, Handle_Storage_HArrayOfCallBack theHandle) -> Handle_Storage_HArrayOfCallBack
        assign(Handle_Storage_HArrayOfCallBack self, Storage_HArrayOfCallBack thePtr) -> Handle_Storage_HArrayOfCallBack
        assign(Handle_Storage_HArrayOfCallBack self, Handle_Storage_HArrayOfCallBack theHandle) -> Handle_Storage_HArrayOfCallBack

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_HArrayOfCallBack self) -> Storage_HArrayOfCallBack

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_HArrayOfCallBack self) -> Storage_HArrayOfCallBack

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_HArrayOfCallBack___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_HArrayOfCallBack self) -> Storage_HArrayOfCallBack

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_HArrayOfCallBack___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_HArrayOfCallBack___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_HArrayOfCallBack___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_HArrayOfCallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_HArrayOfCallBack_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_HArrayOfCallBack

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_ArrayOfCallBack

        """
        res = _Storage.Handle_Storage_HArrayOfCallBack_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Storage_HArrayOfCallBack self) -> NCollection_Array1_Handle_Storage_CallBack

        :rtype: OCC.wrapper.Storage.Storage_ArrayOfCallBack

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_HArrayOfCallBack self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HArrayOfCallBack_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HArrayOfCallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_HArrayOfCallBack self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_HArrayOfCallBack_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_HArrayOfCallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_HArrayOfCallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_HArrayOfCallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_HArrayOfCallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_HArrayOfCallBack self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_HArrayOfCallBack self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_HArrayOfCallBack self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_HArrayOfCallBack_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_HArrayOfCallBack self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HArrayOfCallBack_DecrementRefCounter(self, *args)

Handle_Storage_HArrayOfCallBack_swigregister = _Storage.Handle_Storage_HArrayOfCallBack_swigregister
Handle_Storage_HArrayOfCallBack_swigregister(Handle_Storage_HArrayOfCallBack)

def Handle_Storage_HArrayOfCallBack_DownCast(thing):
    return _Storage.Handle_Storage_HArrayOfCallBack_DownCast(thing)
Handle_Storage_HArrayOfCallBack_DownCast = _Storage.Handle_Storage_HArrayOfCallBack_DownCast

class Handle_Storage_Schema(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_Schema self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_Schema_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_Schema self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_Schema_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_Schema self, Storage_Schema thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_Schema_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_Schema self, Handle_Storage_Schema theHandle) -> Handle_Storage_Schema
        assign(Handle_Storage_Schema self, Storage_Schema thePtr) -> Handle_Storage_Schema
        assign(Handle_Storage_Schema self, Handle_Storage_Schema theHandle) -> Handle_Storage_Schema

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_Schema_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_Schema self) -> Storage_Schema

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_Schema_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_Schema self) -> Storage_Schema

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_Schema___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_Schema self) -> Storage_Schema

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_Schema___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_Schema___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_Schema___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_Schema(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_Schema_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_Schema

    def SetVersion(self, *args):
        """
        SetVersion(Handle_Storage_Schema self, TCollection_AsciiString aVersion)

        returns version of the schema

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Schema_SetVersion(self, *args)


    def Version(self, *args):
        """
        Version(Handle_Storage_Schema self) -> TCollection_AsciiString

        returns the version of the schema

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Schema_Version(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_Storage_Schema self, TCollection_AsciiString aSchemaName)

        set the schema's name

        :type aSchemaName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Schema_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_Storage_Schema self) -> TCollection_AsciiString

        returns the schema's name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Schema_Name(self, *args)


    def Write(self, *args):
        """
        Write(Handle_Storage_Schema self, Storage_BaseDriver s, Handle_Storage_Data aData)

        Writes the data aggregated in aData into the
        container defined by the driver s. The storage
        operation is performed according to the data
        schema with which this algorithm is working.
        Note: aData may aggregate several root objects
        to be stored together.

        :type s: OCC.wrapper.Storage.Storage_BaseDriver
        :type aData: OCC.wrapper.Storage.Handle_Storage_Data

        """
        return _Storage.Handle_Storage_Schema_Write(self, *args)


    def ICreationDate(self, *args):
        """
        ICreationDate(Handle_Storage_Schema self) -> TCollection_AsciiString

        return a current date string

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Schema_ICreationDate(self, *args)


    def CheckTypeMigration(self, *args):
        """
        CheckTypeMigration(Handle_Storage_Schema self, TCollection_AsciiString theTypeName, TCollection_AsciiString theNewName) -> Standard_Boolean

        returns True if theType migration is identified
        the callback support provides a way to read a file
        with a incomplete schema.
        ex. : A file contains 3 types a,b and c.
        The  application's  schema  contains  only 2
        type a and b. If you try to read the file in
        the application, you  will  have an error.To
        bypass this  problem  you  can  give to your
        application's schema  a  callback  used when
        the schema dosent  know  how  to handle this
        type.

        :type theTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theNewName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Schema_CheckTypeMigration(self, *args)


    def AddReadUnknownTypeCallBack(self, *args):
        """
        AddReadUnknownTypeCallBack(Handle_Storage_Schema self, TCollection_AsciiString aTypeName, Handle_Storage_CallBack aCallBack)

        add two functions to the callback list

        :type aTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aCallBack: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Handle_Storage_Schema_AddReadUnknownTypeCallBack(self, *args)


    def RemoveReadUnknownTypeCallBack(self, *args):
        """
        RemoveReadUnknownTypeCallBack(Handle_Storage_Schema self, TCollection_AsciiString aTypeName)

        remove a callback for a type

        :type aTypeName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_Schema_RemoveReadUnknownTypeCallBack(self, *args)


    def InstalledCallBackList(self, *args):
        """
        InstalledCallBackList(Handle_Storage_Schema self) -> Handle_TColStd_HSequenceOfAsciiString

        returns  a  list  of   type  name  with  installed
        callback.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _Storage.Handle_Storage_Schema_InstalledCallBackList(self, *args)


    def ClearCallBackList(self, *args):
        """
        ClearCallBackList(Handle_Storage_Schema self)

        clear all callback from schema instance.


        """
        return _Storage.Handle_Storage_Schema_ClearCallBackList(self, *args)


    def UseDefaultCallBack(self, *args):
        """
        UseDefaultCallBack(Handle_Storage_Schema self)

        install  a  callback  for  all  unknown  type. the
        objects with unknown types  will be skipped. (look
        SkipObject method in BaseDriver)


        """
        return _Storage.Handle_Storage_Schema_UseDefaultCallBack(self, *args)


    def DontUseDefaultCallBack(self, *args):
        """
        DontUseDefaultCallBack(Handle_Storage_Schema self)

        tells schema to uninstall the default callback.


        """
        return _Storage.Handle_Storage_Schema_DontUseDefaultCallBack(self, *args)


    def IsUsingDefaultCallBack(self, *args):
        """
        IsUsingDefaultCallBack(Handle_Storage_Schema self) -> Standard_Boolean

        ask if the schema is using the default callback.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Schema_IsUsingDefaultCallBack(self, *args)


    def SetDefaultCallBack(self, *args):
        """
        SetDefaultCallBack(Handle_Storage_Schema self, Handle_Storage_CallBack f)

        overload the  default  function  for build.(use to
        set an  error  message  or  skip  an  object while
        reading an unknown type).

        :type f: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Handle_Storage_Schema_SetDefaultCallBack(self, *args)


    def ResetDefaultCallBack(self, *args):
        """
        ResetDefaultCallBack(Handle_Storage_Schema self)

        reset  the  default  function  defined  by Storage
        package.


        """
        return _Storage.Handle_Storage_Schema_ResetDefaultCallBack(self, *args)


    def DefaultCallBack(self, *args):
        """
        DefaultCallBack(Handle_Storage_Schema self) -> Handle_Storage_CallBack

        returns   the   read   function   used   when  the
        UseDefaultCallBack() is set.

        :rtype: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Handle_Storage_Schema_DefaultCallBack(self, *args)


    def WritePersistentObjectHeader(self, *args):
        """
        WritePersistentObjectHeader(Handle_Storage_Schema self, Handle_Standard_Persistent sp, Storage_BaseDriver s)

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type s: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Handle_Storage_Schema_WritePersistentObjectHeader(self, *args)


    def WritePersistentReference(self, *args):
        """
        WritePersistentReference(Handle_Storage_Schema self, Handle_Standard_Persistent sp, Storage_BaseDriver s)

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type s: OCC.wrapper.Storage.Storage_BaseDriver

        """
        return _Storage.Handle_Storage_Schema_WritePersistentReference(self, *args)


    def AddPersistent(self, *args):
        """
        AddPersistent(Handle_Storage_Schema self, Handle_Standard_Persistent sp, Standard_CString const tName) -> Standard_Boolean

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type tName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Schema_AddPersistent(self, *args)


    def PersistentToAdd(self, *args):
        """
        PersistentToAdd(Handle_Storage_Schema self, Handle_Standard_Persistent sp) -> Standard_Boolean

        :type sp: OCC.wrapper.Storage.Handle_Standard_Persistent
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Schema_PersistentToAdd(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_Schema self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_Schema_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_Schema_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_Schema_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_Schema self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_Schema_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_Schema self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_Schema self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Schema_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_Schema self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_Schema self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_Schema_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_Schema self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_Schema_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_Schema self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Schema_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_Schema self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_Schema_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_Schema self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_Schema_DecrementRefCounter(self, *args)

Handle_Storage_Schema_swigregister = _Storage.Handle_Storage_Schema_swigregister
Handle_Storage_Schema_swigregister(Handle_Storage_Schema)

def Handle_Storage_Schema_DownCast(thing):
    return _Storage.Handle_Storage_Schema_DownCast(thing)
Handle_Storage_Schema_DownCast = _Storage.Handle_Storage_Schema_DownCast

class NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_Root >,TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_Root >,TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_Root >,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_Root >,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _Storage.new_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, TCollection_AsciiString theKey, Handle_Storage_Root theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, TCollection_AsciiString theKey, Handle_Storage_Root theItem) -> Handle_Storage_Root

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Storage_Root

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Storage_Root

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Storage_Root

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_Size(self, *args)


    def __iter__(self):
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _Storage.delete_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_swigregister = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_swigregister
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_swigregister(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString)

class NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Storage.new_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Storage.delete_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper_swigregister = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString_IteratorHelper)


try:
	Storage_MapOfPers = NCollection_DataMap_TCollection_AsciiString_Handle_Storage_Root_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class Storage_HeaderData(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_HeaderData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_HeaderData(self) 
            return h


    def __init__(self, *args):
        """__init__(Storage_HeaderData self) -> Storage_HeaderData"""
        this = _Storage.new_Storage_HeaderData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Read(self, *args):
        """
        Read(Storage_HeaderData self, Storage_BaseDriver theDriver) -> Standard_Boolean

        :type theDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_HeaderData_Read(self, *args)


    def CreationDate(self, *args):
        """
        CreationDate(Storage_HeaderData self) -> TCollection_AsciiString

        return the creation date

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_CreationDate(self, *args)


    def StorageVersion(self, *args):
        """
        StorageVersion(Storage_HeaderData self) -> TCollection_AsciiString

        return the Storage package version

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_StorageVersion(self, *args)


    def SchemaVersion(self, *args):
        """
        SchemaVersion(Storage_HeaderData self) -> TCollection_AsciiString

        get the version of the schema

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_SchemaVersion(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(Storage_HeaderData self) -> TCollection_AsciiString

        get the schema's name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_SchemaName(self, *args)


    def SetApplicationVersion(self, *args):
        """
        SetApplicationVersion(Storage_HeaderData self, TCollection_AsciiString aVersion)

        set the version of the application

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_SetApplicationVersion(self, *args)


    def ApplicationVersion(self, *args):
        """
        ApplicationVersion(Storage_HeaderData self) -> TCollection_AsciiString

        get the version of the application

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_ApplicationVersion(self, *args)


    def SetApplicationName(self, *args):
        """
        SetApplicationName(Storage_HeaderData self, TCollection_ExtendedString aName)

        set the name of the application

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_HeaderData_SetApplicationName(self, *args)


    def ApplicationName(self, *args):
        """
        ApplicationName(Storage_HeaderData self) -> TCollection_ExtendedString

        get the name of the application

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_HeaderData_ApplicationName(self, *args)


    def SetDataType(self, *args):
        """
        SetDataType(Storage_HeaderData self, TCollection_ExtendedString aType)

        set the data type

        :type aType: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_HeaderData_SetDataType(self, *args)


    def DataType(self, *args):
        """
        DataType(Storage_HeaderData self) -> TCollection_ExtendedString

        returns data type

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_HeaderData_DataType(self, *args)


    def AddToUserInfo(self, *args):
        """
        AddToUserInfo(Storage_HeaderData self, TCollection_AsciiString theUserInfo)

        add <theUserInfo> to the user informations

        :type theUserInfo: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_AddToUserInfo(self, *args)


    def UserInfo(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        res = _Storage.Storage_HeaderData_UserInfo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddToComments(self, *args):
        """
        AddToComments(Storage_HeaderData self, TCollection_ExtendedString aComment)

        add <theUserInfo> to the user informations

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Storage_HeaderData_AddToComments(self, *args)


    def Comments(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _Storage.Storage_HeaderData_Comments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NumberOfObjects(self, *args):
        """
        NumberOfObjects(Storage_HeaderData self) -> Standard_Integer

        the the number of persistent objects
        Return:
        the number of persistent objects readed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_HeaderData_NumberOfObjects(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Storage_HeaderData self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Storage_HeaderData_ErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Storage_HeaderData self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_ErrorStatusExtension(self, *args)


    def ClearErrorStatus(self, *args):
        """ClearErrorStatus(Storage_HeaderData self)"""
        return _Storage.Storage_HeaderData_ClearErrorStatus(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_HeaderData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_HeaderData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_HeaderData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetNumberOfObjects(self, *args):
        """
        SetNumberOfObjects(Storage_HeaderData self, Standard_Integer const anObjectNumber)

        :type anObjectNumber: int

        """
        return _Storage.Storage_HeaderData_SetNumberOfObjects(self, *args)


    def SetStorageVersion(self, *args):
        """
        SetStorageVersion(Storage_HeaderData self, TCollection_AsciiString aVersion)

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_SetStorageVersion(self, *args)


    def SetCreationDate(self, *args):
        """
        SetCreationDate(Storage_HeaderData self, TCollection_AsciiString aDate)

        :type aDate: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_SetCreationDate(self, *args)


    def SetSchemaVersion(self, *args):
        """
        SetSchemaVersion(Storage_HeaderData self, TCollection_AsciiString aVersion)

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_SetSchemaVersion(self, *args)


    def SetSchemaName(self, *args):
        """
        SetSchemaName(Storage_HeaderData self, TCollection_AsciiString aName)

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_HeaderData_SetSchemaName(self, *args)

    __swig_destroy__ = _Storage.delete_Storage_HeaderData
Storage_HeaderData_swigregister = _Storage.Storage_HeaderData_swigregister
Storage_HeaderData_swigregister(Storage_HeaderData)

def Storage_HeaderData_get_type_name(*args):
    """
    Storage_HeaderData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_HeaderData_get_type_name(*args)

def Storage_HeaderData_get_type_descriptor(*args):
    """
    Storage_HeaderData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_HeaderData_get_type_descriptor(*args)

class Storage_StreamUnknownTypeError(Storage_StreamReadError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_StreamUnknownTypeError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_StreamUnknownTypeError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_StreamUnknownTypeError self) -> Storage_StreamUnknownTypeError
        __init__(Storage_StreamUnknownTypeError self, Standard_CString const theMessage) -> Storage_StreamUnknownTypeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Storage.new_Storage_StreamUnknownTypeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamUnknownTypeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamUnknownTypeError

        """
        return _Storage.Storage_StreamUnknownTypeError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_StreamUnknownTypeError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_StreamUnknownTypeError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_StreamUnknownTypeError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_StreamUnknownTypeError
Storage_StreamUnknownTypeError_swigregister = _Storage.Storage_StreamUnknownTypeError_swigregister
Storage_StreamUnknownTypeError_swigregister(Storage_StreamUnknownTypeError)

def Storage_StreamUnknownTypeError_NewInstance(*args):
    """
    Storage_StreamUnknownTypeError_NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamUnknownTypeError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Storage.Handle_Storage_StreamUnknownTypeError

    """
    return _Storage.Storage_StreamUnknownTypeError_NewInstance(*args)

def Storage_StreamUnknownTypeError_get_type_name(*args):
    """
    Storage_StreamUnknownTypeError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_StreamUnknownTypeError_get_type_name(*args)

def Storage_StreamUnknownTypeError_get_type_descriptor(*args):
    """
    Storage_StreamUnknownTypeError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_StreamUnknownTypeError_get_type_descriptor(*args)

class NCollection_Sequence_Handle_Storage_Root(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Storage_Root self) -> NCollection_Sequence< opencascade::handle< Storage_Root > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Storage_Root self) -> NCollection_Sequence< opencascade::handle< Storage_Root > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Storage_Root self) -> NCollection_Sequence< opencascade::handle< Storage_Root > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Storage_Root self) -> NCollection_Sequence< opencascade::handle< Storage_Root > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Storage.new_NCollection_Sequence_Handle_Storage_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Storage_Root self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Storage_Root self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Storage_Root self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Storage_Root self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Storage_Root self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Storage_Root self)

        Reverse sequence


        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Storage_Root self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Storage_Root self, NCollection_Sequence_Handle_Storage_Root theOther) -> NCollection_Sequence_Handle_Storage_Root

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Storage_Root self, NCollection_Sequence_Handle_Storage_Root theOther) -> NCollection_Sequence_Handle_Storage_Root

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Storage_Root self, NCollection_Sequence< opencascade::handle< Storage_Root > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Storage_Root self, Handle_Storage_Root theItem)
        Append(NCollection_Sequence_Handle_Storage_Root self, NCollection_Sequence_Handle_Storage_Root theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Storage_Root self, Handle_Storage_Root theItem)
        Prepend(NCollection_Sequence_Handle_Storage_Root self, NCollection_Sequence_Handle_Storage_Root theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex, Handle_Storage_Root theItem)
        InsertBefore(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Storage_Root theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Storage_Root self, NCollection_Sequence< opencascade::handle< Storage_Root > >::Iterator & thePosition, Handle_Storage_Root theItem)
        InsertAfter(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Storage_Root theSeq)
        InsertAfter(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex, Handle_Storage_Root theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Storage_Root theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Sequence_Handle_Storage_Root_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Storage_Root self) -> Handle_Storage_Root

        First item access

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Sequence_Handle_Storage_Root_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Storage_Root self) -> Handle_Storage_Root

        Last item access

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Sequence_Handle_Storage_Root_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex) -> Handle_Storage_Root

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Sequence_Handle_Storage_Root___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Storage_Root self, Standard_Integer const theIndex, Handle_Storage_Root theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Storage.NCollection_Sequence_Handle_Storage_Root_SetValue(self, *args)


    def __iter__(self):
        return _Storage.NCollection_Sequence_Handle_Storage_Root___iter__(self)
    __swig_destroy__ = _Storage.delete_NCollection_Sequence_Handle_Storage_Root
NCollection_Sequence_Handle_Storage_Root_swigregister = _Storage.NCollection_Sequence_Handle_Storage_Root_swigregister
NCollection_Sequence_Handle_Storage_Root_swigregister(NCollection_Sequence_Handle_Storage_Root)

def NCollection_Sequence_Handle_Storage_Root_delNode(*args):
    """
    NCollection_Sequence_Handle_Storage_Root_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Storage.NCollection_Sequence_Handle_Storage_Root_delNode(*args)

class NCollection_Sequence_Handle_Storage_Root_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Storage.new_NCollection_Sequence_Handle_Storage_Root_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Storage.delete_NCollection_Sequence_Handle_Storage_Root_IteratorHelper

    def __next__(self):
        return _Storage.NCollection_Sequence_Handle_Storage_Root_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Storage_Root_IteratorHelper_swigregister = _Storage.NCollection_Sequence_Handle_Storage_Root_IteratorHelper_swigregister
NCollection_Sequence_Handle_Storage_Root_IteratorHelper_swigregister(NCollection_Sequence_Handle_Storage_Root_IteratorHelper)


try:
	Storage_SeqOfRoot = NCollection_Sequence_Handle_Storage_Root
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Handle_Standard_Persistent(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Standard_Persistent self) -> NCollection_Array1< opencascade::handle< Standard_Persistent > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Standard_Persistent self) -> NCollection_Array1< opencascade::handle< Standard_Persistent > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Standard_Persistent self) -> NCollection_Array1< opencascade::handle< Standard_Persistent > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Standard_Persistent self) -> NCollection_Array1< opencascade::handle< Standard_Persistent > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Storage.new_NCollection_Array1_Handle_Standard_Persistent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Standard_Persistent self, Handle_Standard_Persistent theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Standard_Persistent self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Standard_Persistent self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Standard_Persistent self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Standard_Persistent self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Standard_Persistent self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Standard_Persistent self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Standard_Persistent self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Standard_Persistent self, NCollection_Array1_Handle_Standard_Persistent theOther) -> NCollection_Array1_Handle_Standard_Persistent

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Standard_Persistent self, NCollection_Array1_Handle_Standard_Persistent theOther) -> NCollection_Array1_Handle_Standard_Persistent

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Standard_Persistent self, NCollection_Array1_Handle_Standard_Persistent theOther) -> NCollection_Array1_Handle_Standard_Persistent
        assign(NCollection_Array1_Handle_Standard_Persistent self, NCollection_Array1_Handle_Standard_Persistent theOther) -> NCollection_Array1_Handle_Standard_Persistent

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Standard_Persistent_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Standard_Persistent self) -> Handle_Standard_Persistent

        @return first element

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Standard_Persistent_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Standard_Persistent self) -> Handle_Standard_Persistent

        @return last element

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Standard_Persistent_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Standard_Persistent self, Standard_Integer const theIndex) -> Handle_Standard_Persistent

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Standard_Persistent___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Standard_Persistent_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Standard_Persistent self, Standard_Integer const theIndex, Handle_Standard_Persistent theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Standard_Persistent self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Storage.NCollection_Array1_Handle_Standard_Persistent_Resize(self, *args)

    __swig_destroy__ = _Storage.delete_NCollection_Array1_Handle_Standard_Persistent
NCollection_Array1_Handle_Standard_Persistent_swigregister = _Storage.NCollection_Array1_Handle_Standard_Persistent_swigregister
NCollection_Array1_Handle_Standard_Persistent_swigregister(NCollection_Array1_Handle_Standard_Persistent)


try:
	Storage_PArray = NCollection_Array1_Handle_Standard_Persistent
except NameError:
	pass # does not exist, probably ignored

class Storage_TypedCallBack(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_TypedCallBack
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_TypedCallBack(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_TypedCallBack self) -> Storage_TypedCallBack
        __init__(Storage_TypedCallBack self, TCollection_AsciiString aTypeName, Handle_Storage_CallBack aCallBack) -> Storage_TypedCallBack

        :type aTypeName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aCallBack: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        this = _Storage.new_Storage_TypedCallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetType(self, *args):
        """
        SetType(Storage_TypedCallBack self, TCollection_AsciiString aType)

        :type aType: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_TypedCallBack_SetType(self, *args)


    def Type(self, *args):
        """
        Type(Storage_TypedCallBack self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage_TypedCallBack_Type(self, *args)


    def SetCallBack(self, *args):
        """
        SetCallBack(Storage_TypedCallBack self, Handle_Storage_CallBack aCallBack)

        :type aCallBack: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Storage_TypedCallBack_SetCallBack(self, *args)


    def CallBack(self, *args):
        """
        CallBack(Storage_TypedCallBack self) -> Handle_Storage_CallBack

        :rtype: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Storage_TypedCallBack_CallBack(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(Storage_TypedCallBack self, Standard_Integer const anIndex)

        :type anIndex: int

        """
        return _Storage.Storage_TypedCallBack_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(Storage_TypedCallBack self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_TypedCallBack_Index(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_TypedCallBack_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_TypedCallBack_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_TypedCallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_TypedCallBack
Storage_TypedCallBack_swigregister = _Storage.Storage_TypedCallBack_swigregister
Storage_TypedCallBack_swigregister(Storage_TypedCallBack)

def Storage_TypedCallBack_get_type_name(*args):
    """
    Storage_TypedCallBack_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_TypedCallBack_get_type_name(*args)

def Storage_TypedCallBack_get_type_descriptor(*args):
    """
    Storage_TypedCallBack_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_TypedCallBack_get_type_descriptor(*args)

class Handle_Storage_RootData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_RootData self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_RootData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_RootData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_RootData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_RootData self, Storage_RootData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_RootData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_RootData self, Handle_Storage_RootData theHandle) -> Handle_Storage_RootData
        assign(Handle_Storage_RootData self, Storage_RootData thePtr) -> Handle_Storage_RootData
        assign(Handle_Storage_RootData self, Handle_Storage_RootData theHandle) -> Handle_Storage_RootData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_RootData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_RootData self) -> Storage_RootData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_RootData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_RootData self) -> Storage_RootData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_RootData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_RootData self) -> Storage_RootData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_RootData___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_RootData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_RootData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_RootData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_RootData_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_RootData

    def Read(self, *args):
        """
        Read(Handle_Storage_RootData self, Storage_BaseDriver theDriver) -> Standard_Boolean

        :type theDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_RootData_Read(self, *args)


    def NumberOfRoots(self, *args):
        """
        NumberOfRoots(Handle_Storage_RootData self) -> Standard_Integer

        returns the number of roots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_RootData_NumberOfRoots(self, *args)


    def AddRoot(self, *args):
        """
        AddRoot(Handle_Storage_RootData self, Handle_Storage_Root aRoot)

        add a root to <me>. If a root with same name is present, it
        will be replaced by <aRoot>.

        :type aRoot: OCC.wrapper.Storage.Handle_Storage_Root

        """
        return _Storage.Handle_Storage_RootData_AddRoot(self, *args)


    def Roots(self, *args):
        """
        Roots(Handle_Storage_RootData self) -> Handle_Storage_HSeqOfRoot

        :rtype: OCC.wrapper.Storage.Handle_Storage_HSeqOfRoot

        """
        return _Storage.Handle_Storage_RootData_Roots(self, *args)


    def Find(self, *args):
        """
        Find(Handle_Storage_RootData self, TCollection_AsciiString aName) -> Handle_Storage_Root

        find a root with name <aName>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Storage.Handle_Storage_Root

        """
        return _Storage.Handle_Storage_RootData_Find(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(Handle_Storage_RootData self, TCollection_AsciiString aName) -> Standard_Boolean

        returns Standard_True if <me> contains a root named <aName>

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_RootData_IsRoot(self, *args)


    def RemoveRoot(self, *args):
        """
        RemoveRoot(Handle_Storage_RootData self, TCollection_AsciiString aName)

        remove the root named <aName>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_RootData_RemoveRoot(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_Storage_RootData self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Handle_Storage_RootData_ErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Handle_Storage_RootData self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_RootData_ErrorStatusExtension(self, *args)


    def ClearErrorStatus(self, *args):
        """ClearErrorStatus(Handle_Storage_RootData self)"""
        return _Storage.Handle_Storage_RootData_ClearErrorStatus(self, *args)


    def UpdateRoot(self, *args):
        """
        UpdateRoot(Handle_Storage_RootData self, TCollection_AsciiString aName, Handle_Standard_Persistent aPers)

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Handle_Storage_RootData_UpdateRoot(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_RootData self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_RootData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_RootData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_RootData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_RootData self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_RootData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_RootData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_RootData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_RootData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_RootData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_RootData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_RootData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_RootData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_RootData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_RootData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_RootData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_RootData self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_RootData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_RootData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_RootData_DecrementRefCounter(self, *args)

Handle_Storage_RootData_swigregister = _Storage.Handle_Storage_RootData_swigregister
Handle_Storage_RootData_swigregister(Handle_Storage_RootData)

def Handle_Storage_RootData_DownCast(thing):
    return _Storage.Handle_Storage_RootData_DownCast(thing)
Handle_Storage_RootData_DownCast = _Storage.Handle_Storage_RootData_DownCast

class NCollection_Array1_Handle_Storage_CallBack(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Storage_CallBack self) -> NCollection_Array1< opencascade::handle< Storage_CallBack > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Storage_CallBack self) -> NCollection_Array1< opencascade::handle< Storage_CallBack > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Storage_CallBack self) -> NCollection_Array1< opencascade::handle< Storage_CallBack > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Storage_CallBack self) -> NCollection_Array1< opencascade::handle< Storage_CallBack > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Storage.new_NCollection_Array1_Handle_Storage_CallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Storage_CallBack self, Handle_Storage_CallBack theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Storage_CallBack self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Storage_CallBack self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Storage_CallBack self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Storage_CallBack self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Storage_CallBack self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Storage_CallBack self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Storage_CallBack self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Storage_CallBack self, NCollection_Array1_Handle_Storage_CallBack theOther) -> NCollection_Array1_Handle_Storage_CallBack

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Storage_CallBack self, NCollection_Array1_Handle_Storage_CallBack theOther) -> NCollection_Array1_Handle_Storage_CallBack

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Storage_CallBack self, NCollection_Array1_Handle_Storage_CallBack theOther) -> NCollection_Array1_Handle_Storage_CallBack
        assign(NCollection_Array1_Handle_Storage_CallBack self, NCollection_Array1_Handle_Storage_CallBack theOther) -> NCollection_Array1_Handle_Storage_CallBack

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_CallBack_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Storage_CallBack self) -> Handle_Storage_CallBack

        @return first element

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_CallBack_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Storage_CallBack self) -> Handle_Storage_CallBack

        @return last element

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_CallBack_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Storage_CallBack self, Standard_Integer const theIndex) -> Handle_Storage_CallBack

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_CallBack___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_CallBack_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Storage_CallBack self, Standard_Integer const theIndex, Handle_Storage_CallBack theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Storage_CallBack self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Storage.NCollection_Array1_Handle_Storage_CallBack_Resize(self, *args)

    __swig_destroy__ = _Storage.delete_NCollection_Array1_Handle_Storage_CallBack
NCollection_Array1_Handle_Storage_CallBack_swigregister = _Storage.NCollection_Array1_Handle_Storage_CallBack_swigregister
NCollection_Array1_Handle_Storage_CallBack_swigregister(NCollection_Array1_Handle_Storage_CallBack)


try:
	Storage_ArrayOfCallBack = NCollection_Array1_Handle_Storage_CallBack
except NameError:
	pass # does not exist, probably ignored

class Handle_Storage_CallBack(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_CallBack self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_CallBack_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_CallBack self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_CallBack_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_CallBack self, Storage_CallBack thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_CallBack_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_CallBack self, Handle_Storage_CallBack theHandle) -> Handle_Storage_CallBack
        assign(Handle_Storage_CallBack self, Storage_CallBack thePtr) -> Handle_Storage_CallBack
        assign(Handle_Storage_CallBack self, Handle_Storage_CallBack theHandle) -> Handle_Storage_CallBack

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_CallBack_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_CallBack self) -> Storage_CallBack

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_CallBack_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_CallBack self) -> Storage_CallBack

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_CallBack___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_CallBack self) -> Storage_CallBack

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_CallBack___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_CallBack___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_CallBack___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_CallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_CallBack_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_CallBack

    def New(self, *args):
        """
        New(Handle_Storage_CallBack self) -> Handle_Standard_Persistent

        :rtype: OCC.wrapper.Storage.Handle_Standard_Persistent

        """
        return _Storage.Handle_Storage_CallBack_New(self, *args)


    def Add(self, *args):
        """
        Add(Handle_Storage_CallBack self, Handle_Standard_Persistent aPers, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Handle_Storage_CallBack_Add(self, *args)


    def Write(self, *args):
        """
        Write(Handle_Storage_CallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Handle_Storage_CallBack_Write(self, *args)


    def Read(self, *args):
        """
        Read(Handle_Storage_CallBack self, Handle_Standard_Persistent aPers, Storage_BaseDriver aDriver, Handle_Storage_Schema aSchema)

        :type aPers: OCC.wrapper.Storage.Handle_Standard_Persistent
        :type aDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :type aSchema: OCC.wrapper.Storage.Handle_Storage_Schema

        """
        return _Storage.Handle_Storage_CallBack_Read(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_CallBack self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_CallBack_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_CallBack_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_CallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_CallBack self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_CallBack_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_CallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_CallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_CallBack_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_CallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_CallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_CallBack_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_CallBack self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_CallBack_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_CallBack self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_CallBack_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_CallBack self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_CallBack_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_CallBack self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_CallBack_DecrementRefCounter(self, *args)

Handle_Storage_CallBack_swigregister = _Storage.Handle_Storage_CallBack_swigregister
Handle_Storage_CallBack_swigregister(Handle_Storage_CallBack)

def Handle_Storage_CallBack_DownCast(thing):
    return _Storage.Handle_Storage_CallBack_DownCast(thing)
Handle_Storage_CallBack_DownCast = _Storage.Handle_Storage_CallBack_DownCast

class Storage_StreamModeError(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_StreamModeError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_StreamModeError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_StreamModeError self) -> Storage_StreamModeError
        __init__(Storage_StreamModeError self, Standard_CString const theMessage) -> Storage_StreamModeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Storage.new_Storage_StreamModeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamModeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamModeError

        """
        return _Storage.Storage_StreamModeError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_StreamModeError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_StreamModeError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_StreamModeError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_StreamModeError
Storage_StreamModeError_swigregister = _Storage.Storage_StreamModeError_swigregister
Storage_StreamModeError_swigregister(Storage_StreamModeError)

def Storage_StreamModeError_NewInstance(*args):
    """
    Storage_StreamModeError_NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamModeError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Storage.Handle_Storage_StreamModeError

    """
    return _Storage.Storage_StreamModeError_NewInstance(*args)

def Storage_StreamModeError_get_type_name(*args):
    """
    Storage_StreamModeError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_StreamModeError_get_type_name(*args)

def Storage_StreamModeError_get_type_descriptor(*args):
    """
    Storage_StreamModeError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_StreamModeError_get_type_descriptor(*args)

class Handle_Storage_StreamUnknownTypeError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_StreamUnknownTypeError self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_StreamUnknownTypeError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_StreamUnknownTypeError self, Storage_StreamUnknownTypeError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_StreamUnknownTypeError self, Handle_Storage_StreamUnknownTypeError theHandle) -> Handle_Storage_StreamUnknownTypeError
        assign(Handle_Storage_StreamUnknownTypeError self, Storage_StreamUnknownTypeError thePtr) -> Handle_Storage_StreamUnknownTypeError
        assign(Handle_Storage_StreamUnknownTypeError self, Handle_Storage_StreamUnknownTypeError theHandle) -> Handle_Storage_StreamUnknownTypeError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_StreamUnknownTypeError self) -> Storage_StreamUnknownTypeError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_StreamUnknownTypeError self) -> Storage_StreamUnknownTypeError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_StreamUnknownTypeError self) -> Storage_StreamUnknownTypeError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_StreamUnknownTypeError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_StreamUnknownTypeError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_StreamUnknownTypeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_StreamUnknownTypeError_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_StreamUnknownTypeError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Storage_StreamUnknownTypeError self, Standard_CString const theMessage) -> Handle_Storage_StreamUnknownTypeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamUnknownTypeError

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_StreamUnknownTypeError self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamUnknownTypeError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamUnknownTypeError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Storage_StreamUnknownTypeError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Storage_StreamUnknownTypeError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Storage_StreamUnknownTypeError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Storage_StreamUnknownTypeError self)
        Reraise(Handle_Storage_StreamUnknownTypeError self, Standard_CString const aMessage)
        Reraise(Handle_Storage_StreamUnknownTypeError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Storage_StreamUnknownTypeError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Storage_StreamUnknownTypeError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_StreamUnknownTypeError self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_StreamUnknownTypeError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_StreamUnknownTypeError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_StreamUnknownTypeError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_StreamUnknownTypeError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_StreamUnknownTypeError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_StreamUnknownTypeError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_StreamUnknownTypeError self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_StreamUnknownTypeError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamUnknownTypeError_DecrementRefCounter(self, *args)

Handle_Storage_StreamUnknownTypeError_swigregister = _Storage.Handle_Storage_StreamUnknownTypeError_swigregister
Handle_Storage_StreamUnknownTypeError_swigregister(Handle_Storage_StreamUnknownTypeError)

def Handle_Storage_StreamUnknownTypeError_DownCast(thing):
    return _Storage.Handle_Storage_StreamUnknownTypeError_DownCast(thing)
Handle_Storage_StreamUnknownTypeError_DownCast = _Storage.Handle_Storage_StreamUnknownTypeError_DownCast

class Storage_StreamExtCharParityError(Storage_StreamReadError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Storage_StreamExtCharParityError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Storage_StreamExtCharParityError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Storage_StreamExtCharParityError self) -> Storage_StreamExtCharParityError
        __init__(Storage_StreamExtCharParityError self, Standard_CString const theMessage) -> Storage_StreamExtCharParityError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Storage.new_Storage_StreamExtCharParityError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamExtCharParityError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamExtCharParityError

        """
        return _Storage.Storage_StreamExtCharParityError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Storage.Storage_StreamExtCharParityError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Storage.Storage_StreamExtCharParityError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Storage_StreamExtCharParityError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Storage.delete_Storage_StreamExtCharParityError
Storage_StreamExtCharParityError_swigregister = _Storage.Storage_StreamExtCharParityError_swigregister
Storage_StreamExtCharParityError_swigregister(Storage_StreamExtCharParityError)

def Storage_StreamExtCharParityError_NewInstance(*args):
    """
    Storage_StreamExtCharParityError_NewInstance(Standard_CString const theMessage) -> Handle_Storage_StreamExtCharParityError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Storage.Handle_Storage_StreamExtCharParityError

    """
    return _Storage.Storage_StreamExtCharParityError_NewInstance(*args)

def Storage_StreamExtCharParityError_get_type_name(*args):
    """
    Storage_StreamExtCharParityError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Storage.Storage_StreamExtCharParityError_get_type_name(*args)

def Storage_StreamExtCharParityError_get_type_descriptor(*args):
    """
    Storage_StreamExtCharParityError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Storage.Storage_StreamExtCharParityError_get_type_descriptor(*args)

class Handle_Storage_HeaderData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_HeaderData self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_HeaderData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_HeaderData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_HeaderData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_HeaderData self, Storage_HeaderData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_HeaderData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_HeaderData self, Handle_Storage_HeaderData theHandle) -> Handle_Storage_HeaderData
        assign(Handle_Storage_HeaderData self, Storage_HeaderData thePtr) -> Handle_Storage_HeaderData
        assign(Handle_Storage_HeaderData self, Handle_Storage_HeaderData theHandle) -> Handle_Storage_HeaderData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_HeaderData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_HeaderData self) -> Storage_HeaderData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_HeaderData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_HeaderData self) -> Storage_HeaderData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_HeaderData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_HeaderData self) -> Storage_HeaderData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_HeaderData___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_HeaderData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_HeaderData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_HeaderData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_HeaderData_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_HeaderData

    def Read(self, *args):
        """
        Read(Handle_Storage_HeaderData self, Storage_BaseDriver theDriver) -> Standard_Boolean

        :type theDriver: OCC.wrapper.Storage.Storage_BaseDriver
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HeaderData_Read(self, *args)


    def CreationDate(self, *args):
        """
        CreationDate(Handle_Storage_HeaderData self) -> TCollection_AsciiString

        return the creation date

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_CreationDate(self, *args)


    def StorageVersion(self, *args):
        """
        StorageVersion(Handle_Storage_HeaderData self) -> TCollection_AsciiString

        return the Storage package version

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_StorageVersion(self, *args)


    def SchemaVersion(self, *args):
        """
        SchemaVersion(Handle_Storage_HeaderData self) -> TCollection_AsciiString

        get the version of the schema

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_SchemaVersion(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(Handle_Storage_HeaderData self) -> TCollection_AsciiString

        get the schema's name

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_SchemaName(self, *args)


    def SetApplicationVersion(self, *args):
        """
        SetApplicationVersion(Handle_Storage_HeaderData self, TCollection_AsciiString aVersion)

        set the version of the application

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_SetApplicationVersion(self, *args)


    def ApplicationVersion(self, *args):
        """
        ApplicationVersion(Handle_Storage_HeaderData self) -> TCollection_AsciiString

        get the version of the application

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_ApplicationVersion(self, *args)


    def SetApplicationName(self, *args):
        """
        SetApplicationName(Handle_Storage_HeaderData self, TCollection_ExtendedString aName)

        set the name of the application

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_HeaderData_SetApplicationName(self, *args)


    def ApplicationName(self, *args):
        """
        ApplicationName(Handle_Storage_HeaderData self) -> TCollection_ExtendedString

        get the name of the application

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_HeaderData_ApplicationName(self, *args)


    def SetDataType(self, *args):
        """
        SetDataType(Handle_Storage_HeaderData self, TCollection_ExtendedString aType)

        set the data type

        :type aType: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_HeaderData_SetDataType(self, *args)


    def DataType(self, *args):
        """
        DataType(Handle_Storage_HeaderData self) -> TCollection_ExtendedString

        returns data type

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_HeaderData_DataType(self, *args)


    def AddToUserInfo(self, *args):
        """
        AddToUserInfo(Handle_Storage_HeaderData self, TCollection_AsciiString theUserInfo)

        add <theUserInfo> to the user informations

        :type theUserInfo: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_AddToUserInfo(self, *args)


    def UserInfo(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        res = _Storage.Handle_Storage_HeaderData_UserInfo(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddToComments(self, *args):
        """
        AddToComments(Handle_Storage_HeaderData self, TCollection_ExtendedString aComment)

        add <theUserInfo> to the user informations

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _Storage.Handle_Storage_HeaderData_AddToComments(self, *args)


    def Comments(self, *args):
        """
        return the user informations

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _Storage.Handle_Storage_HeaderData_Comments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NumberOfObjects(self, *args):
        """
        NumberOfObjects(Handle_Storage_HeaderData self) -> Standard_Integer

        the the number of persistent objects
        Return:
        the number of persistent objects readed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HeaderData_NumberOfObjects(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_Storage_HeaderData self) -> Storage_Error

        :rtype: OCC.wrapper.Storage.Storage_Error

        """
        return _Storage.Handle_Storage_HeaderData_ErrorStatus(self, *args)


    def ErrorStatusExtension(self, *args):
        """
        ErrorStatusExtension(Handle_Storage_HeaderData self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_ErrorStatusExtension(self, *args)


    def ClearErrorStatus(self, *args):
        """ClearErrorStatus(Handle_Storage_HeaderData self)"""
        return _Storage.Handle_Storage_HeaderData_ClearErrorStatus(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_HeaderData self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_HeaderData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HeaderData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HeaderData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetNumberOfObjects(self, *args):
        """
        SetNumberOfObjects(Handle_Storage_HeaderData self, Standard_Integer const anObjectNumber)

        :type anObjectNumber: int

        """
        return _Storage.Handle_Storage_HeaderData_SetNumberOfObjects(self, *args)


    def SetStorageVersion(self, *args):
        """
        SetStorageVersion(Handle_Storage_HeaderData self, TCollection_AsciiString aVersion)

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_SetStorageVersion(self, *args)


    def SetCreationDate(self, *args):
        """
        SetCreationDate(Handle_Storage_HeaderData self, TCollection_AsciiString aDate)

        :type aDate: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_SetCreationDate(self, *args)


    def SetSchemaVersion(self, *args):
        """
        SetSchemaVersion(Handle_Storage_HeaderData self, TCollection_AsciiString aVersion)

        :type aVersion: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_SetSchemaVersion(self, *args)


    def SetSchemaName(self, *args):
        """
        SetSchemaName(Handle_Storage_HeaderData self, TCollection_AsciiString aName)

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_HeaderData_SetSchemaName(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_HeaderData self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_HeaderData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_HeaderData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_HeaderData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HeaderData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_HeaderData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_HeaderData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HeaderData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_HeaderData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_HeaderData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_HeaderData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HeaderData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_HeaderData self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_HeaderData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_HeaderData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HeaderData_DecrementRefCounter(self, *args)

Handle_Storage_HeaderData_swigregister = _Storage.Handle_Storage_HeaderData_swigregister
Handle_Storage_HeaderData_swigregister(Handle_Storage_HeaderData)

def Handle_Storage_HeaderData_DownCast(thing):
    return _Storage.Handle_Storage_HeaderData_DownCast(thing)
Handle_Storage_HeaderData_DownCast = _Storage.Handle_Storage_HeaderData_DownCast

class Handle_Storage_StreamModeError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_StreamModeError self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_StreamModeError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_StreamModeError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_StreamModeError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_StreamModeError self, Storage_StreamModeError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_StreamModeError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_StreamModeError self, Handle_Storage_StreamModeError theHandle) -> Handle_Storage_StreamModeError
        assign(Handle_Storage_StreamModeError self, Storage_StreamModeError thePtr) -> Handle_Storage_StreamModeError
        assign(Handle_Storage_StreamModeError self, Handle_Storage_StreamModeError theHandle) -> Handle_Storage_StreamModeError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_StreamModeError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_StreamModeError self) -> Storage_StreamModeError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamModeError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_StreamModeError self) -> Storage_StreamModeError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamModeError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_StreamModeError self) -> Storage_StreamModeError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_StreamModeError___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_StreamModeError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_StreamModeError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_StreamModeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_StreamModeError_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_StreamModeError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Storage_StreamModeError self, Standard_CString const theMessage) -> Handle_Storage_StreamModeError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamModeError

        """
        return _Storage.Handle_Storage_StreamModeError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_StreamModeError self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_StreamModeError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamModeError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamModeError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Storage_StreamModeError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Storage.Handle_Storage_StreamModeError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Storage_StreamModeError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamModeError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Storage_StreamModeError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamModeError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Storage_StreamModeError self)
        Reraise(Handle_Storage_StreamModeError self, Standard_CString const aMessage)
        Reraise(Handle_Storage_StreamModeError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Storage.Handle_Storage_StreamModeError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Storage_StreamModeError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Storage.Handle_Storage_StreamModeError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Storage_StreamModeError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Storage.Handle_Storage_StreamModeError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_StreamModeError self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_StreamModeError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_StreamModeError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_StreamModeError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamModeError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_StreamModeError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_StreamModeError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamModeError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_StreamModeError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_StreamModeError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_StreamModeError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamModeError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_StreamModeError self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_StreamModeError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_StreamModeError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamModeError_DecrementRefCounter(self, *args)

Handle_Storage_StreamModeError_swigregister = _Storage.Handle_Storage_StreamModeError_swigregister
Handle_Storage_StreamModeError_swigregister(Handle_Storage_StreamModeError)

def Handle_Storage_StreamModeError_DownCast(thing):
    return _Storage.Handle_Storage_StreamModeError_DownCast(thing)
Handle_Storage_StreamModeError_DownCast = _Storage.Handle_Storage_StreamModeError_DownCast

class NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_TypedCallBack >,TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_TypedCallBack >,TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_TypedCallBack >,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Storage_TypedCallBack >,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _Storage.new_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, TCollection_AsciiString theKey, Handle_Storage_TypedCallBack theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, TCollection_AsciiString theKey, Handle_Storage_TypedCallBack theItem) -> Handle_Storage_TypedCallBack

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Storage_TypedCallBack

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Storage_TypedCallBack

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Storage_TypedCallBack

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_Size(self, *args)


    def __iter__(self):
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _Storage.delete_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_swigregister = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_swigregister
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_swigregister(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString)

class NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Storage.new_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Storage.delete_NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper_swigregister = _Storage.NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString_IteratorHelper)


try:
	Storage_MapOfCallBack = NCollection_DataMap_TCollection_AsciiString_Handle_Storage_TypedCallBack_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Handle_Storage_Schema(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Storage_Schema self) -> NCollection_Array1< opencascade::handle< Storage_Schema > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Storage_Schema self) -> NCollection_Array1< opencascade::handle< Storage_Schema > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Storage_Schema self) -> NCollection_Array1< opencascade::handle< Storage_Schema > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Storage_Schema self) -> NCollection_Array1< opencascade::handle< Storage_Schema > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Storage.new_NCollection_Array1_Handle_Storage_Schema(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Storage_Schema self, Handle_Storage_Schema theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Storage_Schema self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Storage_Schema self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Storage_Schema self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Storage_Schema self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Storage_Schema self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Storage_Schema self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Storage_Schema self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Storage_Schema self, NCollection_Array1_Handle_Storage_Schema theOther) -> NCollection_Array1_Handle_Storage_Schema

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Storage_Schema self, NCollection_Array1_Handle_Storage_Schema theOther) -> NCollection_Array1_Handle_Storage_Schema

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Storage_Schema self, NCollection_Array1_Handle_Storage_Schema theOther) -> NCollection_Array1_Handle_Storage_Schema
        assign(NCollection_Array1_Handle_Storage_Schema self, NCollection_Array1_Handle_Storage_Schema theOther) -> NCollection_Array1_Handle_Storage_Schema

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_Schema_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Storage_Schema self) -> Handle_Storage_Schema

        @return first element

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_Schema_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Storage_Schema self) -> Handle_Storage_Schema

        @return last element

        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_Schema_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Storage_Schema self, Standard_Integer const theIndex) -> Handle_Storage_Schema

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_Schema___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_Array1_Handle_Storage_Schema_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Storage_Schema self, Standard_Integer const theIndex, Handle_Storage_Schema theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Storage_Schema self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Storage.NCollection_Array1_Handle_Storage_Schema_Resize(self, *args)

    __swig_destroy__ = _Storage.delete_NCollection_Array1_Handle_Storage_Schema
NCollection_Array1_Handle_Storage_Schema_swigregister = _Storage.NCollection_Array1_Handle_Storage_Schema_swigregister
NCollection_Array1_Handle_Storage_Schema_swigregister(NCollection_Array1_Handle_Storage_Schema)


try:
	Storage_ArrayOfSchema = NCollection_Array1_Handle_Storage_Schema
except NameError:
	pass # does not exist, probably ignored

class Handle_Storage_StreamExtCharParityError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_StreamExtCharParityError self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_StreamExtCharParityError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_StreamExtCharParityError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_StreamExtCharParityError self, Storage_StreamExtCharParityError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_StreamExtCharParityError self, Handle_Storage_StreamExtCharParityError theHandle) -> Handle_Storage_StreamExtCharParityError
        assign(Handle_Storage_StreamExtCharParityError self, Storage_StreamExtCharParityError thePtr) -> Handle_Storage_StreamExtCharParityError
        assign(Handle_Storage_StreamExtCharParityError self, Handle_Storage_StreamExtCharParityError theHandle) -> Handle_Storage_StreamExtCharParityError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_StreamExtCharParityError self) -> Storage_StreamExtCharParityError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_StreamExtCharParityError self) -> Storage_StreamExtCharParityError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamExtCharParityError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_StreamExtCharParityError self) -> Storage_StreamExtCharParityError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_StreamExtCharParityError___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_StreamExtCharParityError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_StreamExtCharParityError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_StreamExtCharParityError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_StreamExtCharParityError_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_StreamExtCharParityError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Storage_StreamExtCharParityError self, Standard_CString const theMessage) -> Handle_Storage_StreamExtCharParityError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamExtCharParityError

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_StreamExtCharParityError self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamExtCharParityError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamExtCharParityError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Storage_StreamExtCharParityError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Storage_StreamExtCharParityError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Storage_StreamExtCharParityError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Storage_StreamExtCharParityError self)
        Reraise(Handle_Storage_StreamExtCharParityError self, Standard_CString const aMessage)
        Reraise(Handle_Storage_StreamExtCharParityError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Storage_StreamExtCharParityError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Storage.Handle_Storage_StreamExtCharParityError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Storage_StreamExtCharParityError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_StreamExtCharParityError self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_StreamExtCharParityError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_StreamExtCharParityError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_StreamExtCharParityError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_StreamExtCharParityError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_StreamExtCharParityError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_StreamExtCharParityError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_StreamExtCharParityError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_StreamExtCharParityError self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_StreamExtCharParityError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_StreamExtCharParityError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamExtCharParityError_DecrementRefCounter(self, *args)

Handle_Storage_StreamExtCharParityError_swigregister = _Storage.Handle_Storage_StreamExtCharParityError_swigregister
Handle_Storage_StreamExtCharParityError_swigregister(Handle_Storage_StreamExtCharParityError)

def Handle_Storage_StreamExtCharParityError_DownCast(thing):
    return _Storage.Handle_Storage_StreamExtCharParityError_DownCast(thing)
Handle_Storage_StreamExtCharParityError_DownCast = _Storage.Handle_Storage_StreamExtCharParityError_DownCast

class Storage_(object):
    """
    Storage package is used to write and read persistent objects.
    These objects are read and written by a retrieval or storage
    algorithm (Storage_Schema object) in a container (disk, memory,
    network ...). Drivers (FSD_File objects) assign a physical
    container for data to be stored or retrieved.
    The standard procedure for an application in
    reading a container is the following:
    -   open the driver in reading mode,
    -   call the Read function from the schema,
    setting the driver as a parameter. This   function returns
    an instance of the   Storage_Data class which contains the   data being read,
    -   close the driver.
    The standard procedure for an application in writing a container is the following:
    -   open the driver in writing mode,
    -   create an instance of the Storage_Data   class, then
    add the persistent data to write   with the function AddRoot,
    -   call the function Write from the schema,
    setting the driver and the Storage_Data   instance as parameters,
    -      close the driver.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Version(*args):
        """
        Version() -> TCollection_AsciiString

        returns the version of Storage's read/write routines

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Storage__Version(*args)

    Version = staticmethod(Version)

    def __init__(self):
        """
        Storage package is used to write and read persistent objects.
        These objects are read and written by a retrieval or storage
        algorithm (Storage_Schema object) in a container (disk, memory,
        network ...). Drivers (FSD_File objects) assign a physical
        container for data to be stored or retrieved.
        The standard procedure for an application in
        reading a container is the following:
        -   open the driver in reading mode,
        -   call the Read function from the schema,
        setting the driver as a parameter. This   function returns
        an instance of the   Storage_Data class which contains the   data being read,
        -   close the driver.
        The standard procedure for an application in writing a container is the following:
        -   open the driver in writing mode,
        -   create an instance of the Storage_Data   class, then
        add the persistent data to write   with the function AddRoot,
        -   call the function Write from the schema,
        setting the driver and the Storage_Data   instance as parameters,
        -      close the driver.
        """
        this = _Storage.new_Storage_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Storage.delete_Storage_
Storage__swigregister = _Storage.Storage__swigregister
Storage__swigregister(Storage_)

def Storage__Version(*args):
    """
    Storage__Version() -> TCollection_AsciiString

    returns the version of Storage's read/write routines

    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _Storage.Storage__Version(*args)

class Handle_Storage_HSeqOfRoot(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_HSeqOfRoot self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_HSeqOfRoot_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_HSeqOfRoot self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_HSeqOfRoot_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_HSeqOfRoot self, Storage_HSeqOfRoot thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_HSeqOfRoot_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_HSeqOfRoot self, Handle_Storage_HSeqOfRoot theHandle) -> Handle_Storage_HSeqOfRoot
        assign(Handle_Storage_HSeqOfRoot self, Storage_HSeqOfRoot thePtr) -> Handle_Storage_HSeqOfRoot
        assign(Handle_Storage_HSeqOfRoot self, Handle_Storage_HSeqOfRoot theHandle) -> Handle_Storage_HSeqOfRoot

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_HSeqOfRoot_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_HSeqOfRoot self) -> Storage_HSeqOfRoot

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_HSeqOfRoot_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_HSeqOfRoot self) -> Storage_HSeqOfRoot

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_HSeqOfRoot___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_HSeqOfRoot self) -> Storage_HSeqOfRoot

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_HSeqOfRoot___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_HSeqOfRoot___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_HSeqOfRoot___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_HSeqOfRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_HSeqOfRoot_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_HSeqOfRoot

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_SeqOfRoot

        """
        res = _Storage.Handle_Storage_HSeqOfRoot_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Storage_HSeqOfRoot self, Handle_Storage_Root theItem)
        Append(Handle_Storage_HSeqOfRoot self, NCollection_Sequence_Handle_Storage_Root theSequence)

        :type theSequence: OCC.wrapper.Storage.Storage_SeqOfRoot

        """
        return _Storage.Handle_Storage_HSeqOfRoot_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Storage_HSeqOfRoot self) -> NCollection_Sequence_Handle_Storage_Root

        :rtype: OCC.wrapper.Storage.Storage_SeqOfRoot

        """
        return _Storage.Handle_Storage_HSeqOfRoot_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_HSeqOfRoot self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_HSeqOfRoot_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HSeqOfRoot_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HSeqOfRoot_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_HSeqOfRoot self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_HSeqOfRoot_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_HSeqOfRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_HSeqOfRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HSeqOfRoot_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_HSeqOfRoot self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_HSeqOfRoot self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HSeqOfRoot_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_HSeqOfRoot self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_HSeqOfRoot_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_HSeqOfRoot self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HSeqOfRoot_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_HSeqOfRoot self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_HSeqOfRoot_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_HSeqOfRoot self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HSeqOfRoot_DecrementRefCounter(self, *args)

Handle_Storage_HSeqOfRoot_swigregister = _Storage.Handle_Storage_HSeqOfRoot_swigregister
Handle_Storage_HSeqOfRoot_swigregister(Handle_Storage_HSeqOfRoot)

def Handle_Storage_HSeqOfRoot_DownCast(thing):
    return _Storage.Handle_Storage_HSeqOfRoot_DownCast(thing)
Handle_Storage_HSeqOfRoot_DownCast = _Storage.Handle_Storage_HSeqOfRoot_DownCast

class NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _Storage.new_NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString theOther) -> NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString theOther) -> NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey1, int const & theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theKey1, int const & theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self)

        RemoveLast


        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Integer const theIndex) -> int &

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> int &

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Size(self, *args)


    def __iter__(self):
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _Storage.delete_NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString
NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_swigregister = _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_swigregister
NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_swigregister(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString)

class NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Storage.new_NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Storage.delete_NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper_swigregister = _Storage.NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper)


try:
	Storage_PType = NCollection_IndexedDataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class Storage_BucketIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Value(self, *args):
        """
        Value(Storage_BucketIterator self) -> Standard_Persistent

        :rtype: OCC.wrapper.Standard.Standard_Persistent

        """
        return _Storage.Storage_BucketIterator_Value(self, *args)


    def More(self, *args):
        """
        More(Storage_BucketIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Storage_BucketIterator_More(self, *args)

    __swig_destroy__ = _Storage.delete_Storage_BucketIterator
Storage_BucketIterator_swigregister = _Storage.Storage_BucketIterator_swigregister
Storage_BucketIterator_swigregister(Storage_BucketIterator)

class Handle_Storage_HPArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_HPArray self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_HPArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_HPArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_HPArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_HPArray self, Storage_HPArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_HPArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_HPArray self, Handle_Storage_HPArray theHandle) -> Handle_Storage_HPArray
        assign(Handle_Storage_HPArray self, Storage_HPArray thePtr) -> Handle_Storage_HPArray
        assign(Handle_Storage_HPArray self, Handle_Storage_HPArray theHandle) -> Handle_Storage_HPArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_HPArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_HPArray self) -> Storage_HPArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_HPArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_HPArray self) -> Storage_HPArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_HPArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_HPArray self) -> Storage_HPArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_HPArray___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_HPArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_HPArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_HPArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_HPArray_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_HPArray

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Storage.Storage_PArray

        """
        res = _Storage.Handle_Storage_HPArray_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Storage_HPArray self) -> NCollection_Array1_Handle_Standard_Persistent

        :rtype: OCC.wrapper.Storage.Storage_PArray

        """
        return _Storage.Handle_Storage_HPArray_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_HPArray self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_HPArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HPArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_HPArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_HPArray self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_HPArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_HPArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_HPArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HPArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_HPArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_HPArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_HPArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_HPArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_HPArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_HPArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HPArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_HPArray self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_HPArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_HPArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_HPArray_DecrementRefCounter(self, *args)

Handle_Storage_HPArray_swigregister = _Storage.Handle_Storage_HPArray_swigregister
Handle_Storage_HPArray_swigregister(Handle_Storage_HPArray)

def Handle_Storage_HPArray_DownCast(thing):
    return _Storage.Handle_Storage_HPArray_DownCast(thing)
Handle_Storage_HPArray_DownCast = _Storage.Handle_Storage_HPArray_DownCast

class Storage_BucketOfPersistent(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Length(self, *args):
        """
        Length(Storage_BucketOfPersistent self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Storage_BucketOfPersistent_Length(self, *args)

Storage_BucketOfPersistent_swigregister = _Storage.Storage_BucketOfPersistent_swigregister
Storage_BucketOfPersistent_swigregister(Storage_BucketOfPersistent)

class Handle_Storage_StreamReadError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_StreamReadError self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_StreamReadError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_StreamReadError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_StreamReadError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_StreamReadError self, Storage_StreamReadError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_StreamReadError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_StreamReadError self, Handle_Storage_StreamReadError theHandle) -> Handle_Storage_StreamReadError
        assign(Handle_Storage_StreamReadError self, Storage_StreamReadError thePtr) -> Handle_Storage_StreamReadError
        assign(Handle_Storage_StreamReadError self, Handle_Storage_StreamReadError theHandle) -> Handle_Storage_StreamReadError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_StreamReadError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_StreamReadError self) -> Storage_StreamReadError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamReadError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_StreamReadError self) -> Storage_StreamReadError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_StreamReadError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_StreamReadError self) -> Storage_StreamReadError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_StreamReadError___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_StreamReadError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_StreamReadError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_StreamReadError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_StreamReadError_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_StreamReadError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Storage_StreamReadError self, Standard_CString const theMessage) -> Handle_Storage_StreamReadError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Storage.Handle_Storage_StreamReadError

        """
        return _Storage.Handle_Storage_StreamReadError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_StreamReadError self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_StreamReadError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamReadError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_StreamReadError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Storage_StreamReadError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Storage.Handle_Storage_StreamReadError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Storage_StreamReadError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamReadError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Storage_StreamReadError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Storage.Handle_Storage_StreamReadError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Storage_StreamReadError self)
        Reraise(Handle_Storage_StreamReadError self, Standard_CString const aMessage)
        Reraise(Handle_Storage_StreamReadError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Storage.Handle_Storage_StreamReadError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Storage_StreamReadError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Storage.Handle_Storage_StreamReadError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Storage_StreamReadError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Storage.Handle_Storage_StreamReadError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Storage_StreamReadError self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_StreamReadError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_StreamReadError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_StreamReadError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamReadError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_StreamReadError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_StreamReadError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_StreamReadError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_StreamReadError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_StreamReadError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_StreamReadError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamReadError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_StreamReadError self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_StreamReadError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_StreamReadError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_StreamReadError_DecrementRefCounter(self, *args)

Handle_Storage_StreamReadError_swigregister = _Storage.Handle_Storage_StreamReadError_swigregister
Handle_Storage_StreamReadError_swigregister(Handle_Storage_StreamReadError)

def Handle_Storage_StreamReadError_DownCast(thing):
    return _Storage.Handle_Storage_StreamReadError_DownCast(thing)
Handle_Storage_StreamReadError_DownCast = _Storage.Handle_Storage_StreamReadError_DownCast

class Handle_Storage_TypedCallBack(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Storage_TypedCallBack self)

        Nullify the handle


        """
        return _Storage.Handle_Storage_TypedCallBack_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Storage_TypedCallBack self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Storage.Handle_Storage_TypedCallBack_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Storage_TypedCallBack self, Storage_TypedCallBack thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Storage.Handle_Storage_TypedCallBack_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Storage_TypedCallBack self, Handle_Storage_TypedCallBack theHandle) -> Handle_Storage_TypedCallBack
        assign(Handle_Storage_TypedCallBack self, Storage_TypedCallBack thePtr) -> Handle_Storage_TypedCallBack
        assign(Handle_Storage_TypedCallBack self, Handle_Storage_TypedCallBack theHandle) -> Handle_Storage_TypedCallBack

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Storage.Handle_Storage_TypedCallBack_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Storage_TypedCallBack self) -> Storage_TypedCallBack

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Storage.Handle_Storage_TypedCallBack_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Storage_TypedCallBack self) -> Storage_TypedCallBack

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Storage.Handle_Storage_TypedCallBack___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Storage_TypedCallBack self) -> Storage_TypedCallBack

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Storage.Handle_Storage_TypedCallBack___ref__(self, *args)


    def __hash__(self):
        return _Storage.Handle_Storage_TypedCallBack___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Storage.Handle_Storage_TypedCallBack___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Storage.new_Handle_Storage_TypedCallBack(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Storage.Handle_Storage_TypedCallBack_DownCast)
    __swig_destroy__ = _Storage.delete_Handle_Storage_TypedCallBack

    def SetType(self, *args):
        """
        SetType(Handle_Storage_TypedCallBack self, TCollection_AsciiString aType)

        :type aType: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_TypedCallBack_SetType(self, *args)


    def Type(self, *args):
        """
        Type(Handle_Storage_TypedCallBack self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Storage.Handle_Storage_TypedCallBack_Type(self, *args)


    def SetCallBack(self, *args):
        """
        SetCallBack(Handle_Storage_TypedCallBack self, Handle_Storage_CallBack aCallBack)

        :type aCallBack: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Handle_Storage_TypedCallBack_SetCallBack(self, *args)


    def CallBack(self, *args):
        """
        CallBack(Handle_Storage_TypedCallBack self) -> Handle_Storage_CallBack

        :rtype: OCC.wrapper.Storage.Handle_Storage_CallBack

        """
        return _Storage.Handle_Storage_TypedCallBack_CallBack(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(Handle_Storage_TypedCallBack self, Standard_Integer const anIndex)

        :type anIndex: int

        """
        return _Storage.Handle_Storage_TypedCallBack_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(Handle_Storage_TypedCallBack self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_TypedCallBack_Index(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Storage_TypedCallBack self) -> char const *

        :rtype: const char *

        """
        return _Storage.Handle_Storage_TypedCallBack_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_TypedCallBack_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Storage.Handle_Storage_TypedCallBack_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Storage_TypedCallBack self)

        Memory deallocator for transient classes


        """
        return _Storage.Handle_Storage_TypedCallBack_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Storage_TypedCallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Storage_TypedCallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_TypedCallBack_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Storage_TypedCallBack self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Storage_TypedCallBack self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Storage.Handle_Storage_TypedCallBack_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Storage_TypedCallBack self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Storage.Handle_Storage_TypedCallBack_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Storage_TypedCallBack self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_TypedCallBack_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Storage_TypedCallBack self)

        Increments the reference counter of this object


        """
        return _Storage.Handle_Storage_TypedCallBack_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Storage_TypedCallBack self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Storage.Handle_Storage_TypedCallBack_DecrementRefCounter(self, *args)

Handle_Storage_TypedCallBack_swigregister = _Storage.Handle_Storage_TypedCallBack_swigregister
Handle_Storage_TypedCallBack_swigregister(Handle_Storage_TypedCallBack)

def Handle_Storage_TypedCallBack_DownCast(thing):
    return _Storage.Handle_Storage_TypedCallBack_DownCast(thing)
Handle_Storage_TypedCallBack_DownCast = _Storage.Handle_Storage_TypedCallBack_DownCast




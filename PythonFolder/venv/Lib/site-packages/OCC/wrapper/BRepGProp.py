# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepGProp')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepGProp')
    _BRepGProp = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepGProp', [dirname(__file__)])
        except ImportError:
            import _BRepGProp
            return _BRepGProp
        try:
            _mod = imp.load_module('_BRepGProp', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepGProp = swig_import_helper()
    del swig_import_helper
else:
    import _BRepGProp
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepGProp.delete_SwigPyIterator

    def value(self):
        return _BRepGProp.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepGProp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepGProp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepGProp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepGProp.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepGProp.SwigPyIterator_copy(self)

    def next(self):
        return _BRepGProp.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepGProp.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepGProp.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepGProp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepGProp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepGProp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepGProp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepGProp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepGProp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepGProp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepGProp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepGProp.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepGProp.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepGProp.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepGProp.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepGProp.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepGProp.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepGProp.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepGProp.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepGProp.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepGProp.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepGProp.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepGProp.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepGProp.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepGProp.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepGProp.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepGProp.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepGProp.ptr_to_number(item)
ptr_to_number = _BRepGProp.ptr_to_number

def HashCode(*args):
    return _BRepGProp.HashCode(*args)
HashCode = _BRepGProp.HashCode

def ptr_equal(a, b):
    return _BRepGProp.ptr_equal(a, b)
ptr_equal = _BRepGProp.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GProp
else:
    import GProp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
class BRepGProp_Cinert(GProp.GProp_GProps):
    """
    Computes the  global properties of bounded curves
    in 3D space. The curve must have at least a continuity C1.
    It can be a curve as defined in the template CurveTool from
    package GProp. This template gives the minimum of methods
    required to evaluate the global properties of a curve 3D with
    the algorithmes of GProp.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_Cinert self) -> BRepGProp_Cinert
        __init__(BRepGProp_Cinert self, BRepAdaptor_Curve C, gp_Pnt CLocation) -> BRepGProp_Cinert

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type CLocation: OCC.wrapper.gp.gp_Pnt

        """
        this = _BRepGProp.new_BRepGProp_Cinert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(BRepGProp_Cinert self, gp_Pnt CLocation)

        :type CLocation: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepGProp.BRepGProp_Cinert_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepGProp_Cinert self, BRepAdaptor_Curve C)

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve

        """
        return _BRepGProp.BRepGProp_Cinert_Perform(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Cinert
BRepGProp_Cinert_swigregister = _BRepGProp.BRepGProp_Cinert_swigregister
BRepGProp_Cinert_swigregister(BRepGProp_Cinert)

class BRepGProp_Face(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_Face self, Standard_Boolean const IsUseSpan) -> BRepGProp_Face
        __init__(BRepGProp_Face self, TopoDS_Face F, Standard_Boolean const IsUseSpan) -> BRepGProp_Face

        Constructor. Initializes the object with the face and the
        flag IsUseSpan that says if it is necessary to define
        spans on a face. This option has an effect only for
        BSpline faces. Spans are returned by the methods GetUKnots
        and GetTKnots.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type IsUseSpan: bool

        """
        this = _BRepGProp.new_BRepGProp_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def VIntegrationOrder(self, *args):
        """
        VIntegrationOrder(BRepGProp_Face self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_VIntegrationOrder(self, *args)


    def NaturalRestriction(self, *args):
        """
        NaturalRestriction(BRepGProp_Face self) -> Standard_Boolean

        Returns Standard_True if the face is not trimmed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepGProp.BRepGProp_Face_NaturalRestriction(self, *args)


    def GetFace(self, *args):
        """
        Returns the TopoDS face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepGProp.BRepGProp_Face_GetFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value2d(self, *args):
        """
        Value2d(BRepGProp_Face self, Standard_Real const U) -> gp_Pnt2d

        Returns the value of the boundary curve of the face.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepGProp.BRepGProp_Face_Value2d(self, *args)


    def SIntOrder(self, *args):
        """
        SIntOrder(BRepGProp_Face self, Standard_Real const Eps) -> Standard_Integer

        :type Eps: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_SIntOrder(self, *args)


    def SVIntSubs(self, *args):
        """
        SVIntSubs(BRepGProp_Face self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_SVIntSubs(self, *args)


    def SUIntSubs(self, *args):
        """
        SUIntSubs(BRepGProp_Face self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_SUIntSubs(self, *args)


    def UKnots(self, *args):
        """
        UKnots(BRepGProp_Face self, NCollection_Array1_Standard_Real Knots)

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepGProp.BRepGProp_Face_UKnots(self, *args)


    def VKnots(self, *args):
        """
        VKnots(BRepGProp_Face self, NCollection_Array1_Standard_Real Knots)

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepGProp.BRepGProp_Face_VKnots(self, *args)


    def LIntOrder(self, *args):
        """
        LIntOrder(BRepGProp_Face self, Standard_Real const Eps) -> Standard_Integer

        :type Eps: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_LIntOrder(self, *args)


    def LIntSubs(self, *args):
        """
        LIntSubs(BRepGProp_Face self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_LIntSubs(self, *args)


    def LKnots(self, *args):
        """
        LKnots(BRepGProp_Face self, NCollection_Array1_Standard_Real Knots)

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BRepGProp.BRepGProp_Face_LKnots(self, *args)


    def UIntegrationOrder(self, *args):
        """
        UIntegrationOrder(BRepGProp_Face self) -> Standard_Integer

        Returns the number of points required to do the
        integration in the U parametric direction with
        a good accuracy.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_UIntegrationOrder(self, *args)


    def Bounds(self, *args):
        """
        Bounds(BRepGProp_Face self)

        Returns the parametric bounds of the Face.

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _BRepGProp.BRepGProp_Face_Bounds(self, *args)


    def Normal(self, *args):
        """
        Normal(BRepGProp_Face self, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec VNor)

        Computes the point of parameter U, V on the Face <S> and
        the normal to the face at this point.

        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type VNor: OCC.wrapper.gp.gp_Vec

        """
        return _BRepGProp.BRepGProp_Face_Normal(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(BRepGProp_Face self) -> Standard_Real

        Returns the parametric value of the start point of
        the current arc of curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_Face_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(BRepGProp_Face self) -> Standard_Real

        Returns the parametric value of the end point of
        the current arc of curve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_Face_LastParameter(self, *args)


    def IntegrationOrder(self, *args):
        """
        IntegrationOrder(BRepGProp_Face self) -> Standard_Integer

        Returns the number of points required to do the
        integration along the parameter of curve.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_Face_IntegrationOrder(self, *args)


    def D12d(self, *args):
        """
        D12d(BRepGProp_Face self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1)

        Returns the point of parameter U and the first derivative
        at this point of a boundary curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d

        """
        return _BRepGProp.BRepGProp_Face_D12d(self, *args)


    def Load(self, *args):
        """
        Load(BRepGProp_Face self, TopoDS_Face F)
        Load(BRepGProp_Face self, TopoDS_Edge E)
        Load(BRepGProp_Face self, Standard_Boolean const IsFirstParam, GeomAbs_IsoType const theIsoType)

        Loading the boundary arc. This arc is either a top, bottom,
        left or right bound of a UV rectangle in which the
        parameters of surface are defined.
        If IsFirstParam is equal to Standard_True, the face is
        initialized by either left of bottom bound. Otherwise it is
        initialized by the top or right one.
        If theIsoType is equal to GeomAbs_IsoU, the face is
        initialized with either left or right bound. Otherwise -
        with either top or bottom one.

        :type IsFirstParam: bool
        :type theIsoType: OCC.wrapper.GeomAbs.GeomAbs_IsoType

        """
        return _BRepGProp.BRepGProp_Face_Load(self, *args)


    def GetUKnots(self, *args):
        """
        GetUKnots(BRepGProp_Face self, Standard_Real const theUMin, Standard_Real const theUMax, Handle_TColStd_HArray1OfReal theUKnots)

        Returns an array of U knots of the face. The first and last
        elements of the array will be theUMin and theUMax. The
        middle elements will be the U Knots of the face greater
        then theUMin and lower then theUMax in increasing order.
        If the face is not a BSpline, the array initialized with
        theUMin and theUMax only.

        :type theUMin: float
        :type theUMax: float
        :type theUKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _BRepGProp.BRepGProp_Face_GetUKnots(self, *args)


    def GetTKnots(self, *args):
        """
        GetTKnots(BRepGProp_Face self, Standard_Real const theTMin, Standard_Real const theTMax, Handle_TColStd_HArray1OfReal theTKnots)

        Returns an array of combination of T knots of the arc and
        V knots of the face. The first and last elements of the
        array will be theTMin and theTMax. The middle elements will
        be the Knots of the arc and the values of parameters of
        arc on which the value points have V coordinates close to V
        knots of face. All the parameter will be greater then
        theTMin and lower then theTMax in increasing order.
        If the face is not a BSpline, the array initialized with
        theTMin and theTMax only.

        :type theTMin: float
        :type theTMax: float
        :type theTKnots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _BRepGProp.BRepGProp_Face_GetTKnots(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Face
BRepGProp_Face_swigregister = _BRepGProp.BRepGProp_Face_swigregister
BRepGProp_Face_swigregister(BRepGProp_Face)

class BRepGProp_Sinert(GProp.GProp_GProps):
    """
    Computes the global properties of a face in 3D space.
    The face 's requirements to evaluate the global properties
    are defined in the template FaceTool from package GProp.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_Sinert self) -> BRepGProp_Sinert
        __init__(BRepGProp_Sinert self, BRepGProp_Face S, gp_Pnt SLocation) -> BRepGProp_Sinert
        __init__(BRepGProp_Sinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt SLocation) -> BRepGProp_Sinert
        __init__(BRepGProp_Sinert self, BRepGProp_Face S, gp_Pnt SLocation, Standard_Real const Eps) -> BRepGProp_Sinert
        __init__(BRepGProp_Sinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt SLocation, Standard_Real const Eps) -> BRepGProp_Sinert

        :type S: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type D: OCC.wrapper.BRepGProp.BRepGProp_Domain
        :type SLocation: OCC.wrapper.gp.gp_Pnt
        :type Eps: float

        """
        this = _BRepGProp.new_BRepGProp_Sinert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(BRepGProp_Sinert self, gp_Pnt SLocation)

        :type SLocation: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepGProp.BRepGProp_Sinert_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepGProp_Sinert self, BRepGProp_Face S)
        Perform(BRepGProp_Sinert self, BRepGProp_Face S, BRepGProp_Domain D)
        Perform(BRepGProp_Sinert self, BRepGProp_Face S, Standard_Real const Eps) -> Standard_Real
        Perform(BRepGProp_Sinert self, BRepGProp_Face S, BRepGProp_Domain D, Standard_Real const Eps) -> Standard_Real

        :type S: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type D: OCC.wrapper.BRepGProp.BRepGProp_Domain
        :type Eps: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_Sinert_Perform(self, *args)


    def GetEpsilon(self, *args):
        """
        GetEpsilon(BRepGProp_Sinert self) -> Standard_Real

        If previously used method contained Eps parameter
        get actual relative error of the computation, else return  1.0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_Sinert_GetEpsilon(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Sinert
BRepGProp_Sinert_swigregister = _BRepGProp.BRepGProp_Sinert_swigregister
BRepGProp_Sinert_swigregister(BRepGProp_Sinert)

class BRepGProp_UFunction(math.math_Function):
    """
    This class represents the integrand function for
    computation of an inner integral. The returned value
    depends on the value type and the flag IsByPoint.

    The type of returned value is the one of the following
    values:
    -  GProp_Mass - volume computation.
    -  GProp_CenterMassX, GProp_CenterMassY,
    GProp_CenterMassZ - X, Y and Z coordinates of center
    of mass computation.
    -  GProp_InertiaXX, GProp_InertiaYY, GProp_InertiaZZ,
    GProp_InertiaXY, GProp_InertiaXZ, GProp_InertiaYZ
    - moments of inertia computation.

    If the flag IsByPoint is set to Standard_True, the value is
    returned for the region of space that is delimited by a
    surface and a point. Otherwise all computations are
    performed for the region of space delimited by a surface
    and a plane.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_UFunction self, BRepGProp_Face theSurface, gp_Pnt theVertex, Standard_Boolean const IsByPoint, Standard_Address const theCoeffs) -> BRepGProp_UFunction

        Constructor. Initializes the function with the face, the
        location point, the flag IsByPoint and the coefficients
        theCoeff that have different meaning depending on the value
        of IsByPoint.
        If IsByPoint is equal to Standard_True, the number of the
        coefficients is equal to 3 and they represent X, Y and Z
        coordinates (theCoeff[0], theCoeff[1] and theCoeff[2]
        correspondingly) of the shift, if the inertia is computed
        with respect to the point different then the location.
        If IsByPoint is equal to Standard_False, the number of the
        coefficients is 4 and they represent the combination of
        plane parameters and shift values.

        :type theSurface: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type theVertex: OCC.wrapper.gp.gp_Pnt
        :type IsByPoint: bool
        :type theCoeffs: OCC.wrapper.Standard.Standard_Address

        """
        this = _BRepGProp.new_BRepGProp_UFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValueType(self, *args):
        """
        SetValueType(BRepGProp_UFunction self, GProp_ValueType const theType)

        Setting the type of the value to be returned.

        :type theType: OCC.wrapper.GProp.GProp_ValueType

        """
        return _BRepGProp.BRepGProp_UFunction_SetValueType(self, *args)


    def SetVParam(self, *args):
        """
        SetVParam(BRepGProp_UFunction self, Standard_Real const theVParam)

        Setting the V parameter that is constant during the
        integral computation.

        :type theVParam: float

        """
        return _BRepGProp.BRepGProp_UFunction_SetVParam(self, *args)


    def Value(self, *args):
        """
        Value(BRepGProp_UFunction self, Standard_Real const X) -> Standard_Boolean

        Returns a value of the function.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepGProp.BRepGProp_UFunction_Value(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_UFunction
BRepGProp_UFunction_swigregister = _BRepGProp.BRepGProp_UFunction_swigregister
BRepGProp_UFunction_swigregister(BRepGProp_UFunction)

class BRepGProp_Gauss(object):
    """
    Class performs computing of the global inertia properties
    of geometric object in 3D space by adaptive and non-adaptive
    2D Gauss integration algorithms.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Vinert = _BRepGProp.BRepGProp_Gauss_Vinert
    Sinert = _BRepGProp.BRepGProp_Gauss_Sinert

    def __init__(self, *args):
        """
        __init__(BRepGProp_Gauss self, BRepGProp_Gauss::BRepGProp_GaussType const theType) -> BRepGProp_Gauss

        Constructor

        :type theType: OCC.wrapper.BRepGProp.BRepGProp_GaussType

        """
        this = _BRepGProp.new_BRepGProp_Gauss(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Compute(self, *args):
        """
        Compute(BRepGProp_Gauss self, BRepGProp_Face theSurface, gp_Pnt theLocation, Standard_Real const * theCoeff, Standard_Boolean const theIsByPoint, gp_Pnt theOutGravityCenter, gp_Mat theOutInertia)
        Compute(BRepGProp_Gauss self, BRepGProp_Face theSurface, gp_Pnt theLocation, gp_Pnt theOutGravityCenter, gp_Mat theOutInertia)
        Compute(BRepGProp_Gauss self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pnt theLocation, Standard_Real const * theCoeff, Standard_Boolean const theIsByPoint, gp_Pnt theOutGravityCenter, gp_Mat theOutInertia)
        Compute(BRepGProp_Gauss self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pnt theLocation, gp_Pnt theOutGravityCenter, gp_Mat theOutInertia)
        Compute(BRepGProp_Gauss self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pnt theLocation, Standard_Real const theEps, Standard_Real const * theCoeff, Standard_Boolean const theByPoint, gp_Pnt theOutGravityCenter, gp_Mat theOutInertia) -> Standard_Real
        Compute(BRepGProp_Gauss self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pnt theLocation, Standard_Real const theEps, gp_Pnt theOutGravityCenter, gp_Mat theOutInertia) -> Standard_Real

        Computes the global properties of the face. Adaptive 2D Gauss integration is used.
        If Epsilon more than 0.001 then algorithm performs non-adaptive integration.
        @param theSurface - bounding surface of the region;
        @param theDomain - surface boundings;
        @param theLocation - surface location;
        @param theEps - maximal relative error of computed mass (square) for face;
        @param theOutMass[out] - mass (volume) of region;
        @param theOutGravityCenter[out] - garvity center of region;
        @param theOutInertia[out] - matrix of inertia;
        @return value of error which is calculated as
        Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values
        for two successive steps of adaptive integration.

        :type theSurface: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type theDomain: OCC.wrapper.BRepGProp.BRepGProp_Domain
        :type theLocation: OCC.wrapper.gp.gp_Pnt
        :type theEps: float
        :type theOutMass: float
        :type theOutGravityCenter: OCC.wrapper.gp.gp_Pnt
        :type theOutInertia: OCC.wrapper.gp.gp_Mat
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_Gauss_Compute(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Gauss
BRepGProp_Gauss_swigregister = _BRepGProp.BRepGProp_Gauss_swigregister
BRepGProp_Gauss_swigregister(BRepGProp_Gauss)

class BRepGProp_TFunction(math.math_Function):
    """
    This class represents the integrand function for the outer
    integral computation. The returned value represents the
    integral of UFunction. It depends on the value type and the
    flag IsByPoint.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_TFunction self, BRepGProp_Face theSurface, gp_Pnt theVertex, Standard_Boolean const IsByPoint, Standard_Address const theCoeffs, Standard_Real const theUMin, Standard_Real const theTolerance) -> BRepGProp_TFunction

        Constructor. Initializes the function with the face, the
        location point, the flag IsByPoint, the coefficients
        theCoeff that have different meaning depending on the value
        of IsByPoint. The last two parameters are theUMin - the
        lower bound of the inner integral. This value is fixed for
        any integral. And the value of tolerance of inner integral
        computation.
        If IsByPoint is equal to Standard_True, the number of the
        coefficients is equal to 3 and they represent X, Y and Z
        coordinates (theCoeff[0], theCoeff[1] and theCoeff[2]
        correspondingly) of the shift if the inertia is computed
        with respect to the point different then the location.
        If IsByPoint is equal to Standard_False, the number of the
        coefficients is 4 and they represent the compbination of
        plane parameters and shift values.

        :type theSurface: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type theVertex: OCC.wrapper.gp.gp_Pnt
        :type IsByPoint: bool
        :type theCoeffs: OCC.wrapper.Standard.Standard_Address
        :type theUMin: float
        :type theTolerance: float

        """
        this = _BRepGProp.new_BRepGProp_TFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """Init(BRepGProp_TFunction self)"""
        return _BRepGProp.BRepGProp_TFunction_Init(self, *args)


    def SetNbKronrodPoints(self, *args):
        """
        SetNbKronrodPoints(BRepGProp_TFunction self, Standard_Integer const theNbPoints)

        Setting the expected number of Kronrod points for the outer
        integral computation. This number is required for
        computation of a value of tolerance for inner integral
        computation. After GetStateNumber method call, this number
        is recomputed by the same law as in
        math_KronrodSingleIntegration, i.e. next number of points
        is equal to the current number plus a square root of the
        current number. If the law in math_KronrodSingleIntegration
        is changed, the modification algo should be modified
        accordingly.

        :type theNbPoints: int

        """
        return _BRepGProp.BRepGProp_TFunction_SetNbKronrodPoints(self, *args)


    def SetValueType(self, *args):
        """
        SetValueType(BRepGProp_TFunction self, GProp_ValueType const aType)

        Setting the type of the value to be returned. This
        parameter is directly passed to the UFunction.

        :type aType: OCC.wrapper.GProp.GProp_ValueType

        """
        return _BRepGProp.BRepGProp_TFunction_SetValueType(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepGProp_TFunction self, Standard_Real const aTol)

        Setting the tolerance  for  inner integration

        :type aTol: float

        """
        return _BRepGProp.BRepGProp_TFunction_SetTolerance(self, *args)


    def ErrorReached(self, *args):
        """
        ErrorReached(BRepGProp_TFunction self) -> Standard_Real

        Returns the relative reached error of all values computation since
        the last call of GetStateNumber method.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_TFunction_ErrorReached(self, *args)


    def AbsolutError(self, *args):
        """
        AbsolutError(BRepGProp_TFunction self) -> Standard_Real

        Returns the absolut reached error of all values computation since
        the last call of GetStateNumber method.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_TFunction_AbsolutError(self, *args)


    def Value(self, *args):
        """
        Value(BRepGProp_TFunction self, Standard_Real const X) -> Standard_Boolean

        Returns a value of the function. The value represents an
        integral of UFunction. It is computed with the predefined
        tolerance using the adaptive Gauss-Kronrod method.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepGProp.BRepGProp_TFunction_Value(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(BRepGProp_TFunction self) -> Standard_Integer

        Redefined  method. Remembers the error reached during
        computation of integral values since the object creation
        or the last call of GetStateNumber. It is invoked in each
        algorithm from the package math. Particularly in the
        algorithm math_KronrodSingleIntegration that is used to
        compute the integral of TFunction.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_TFunction_GetStateNumber(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_TFunction
BRepGProp_TFunction_swigregister = _BRepGProp.BRepGProp_TFunction_swigregister
BRepGProp_TFunction_swigregister(BRepGProp_TFunction)

class BRepGProp_EdgeTool(object):
    """
    Provides  the required  methods    to instantiate
    CGProps from GProp with a Curve from BRepAdaptor.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(BRepAdaptor_Curve C) -> Standard_Real

        Returns the parametric value of the start point of
        the curve.  The curve is oriented from the start point
        to the end point.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_EdgeTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(BRepAdaptor_Curve C) -> Standard_Real

        Returns the parametric value of the end point of
        the curve.  The curve is oriented from the start point
        to the end point.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_EdgeTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def IntegrationOrder(*args):
        """
        IntegrationOrder(BRepAdaptor_Curve C) -> Standard_Integer

        Returns the number of Gauss points required to do
        the integration with a good accuracy using the
        Gauss method.  For a polynomial curve of degree n
        the maxima of accuracy is obtained with an order
        of integration equal to 2*n-1.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_EdgeTool_IntegrationOrder(*args)

    IntegrationOrder = staticmethod(IntegrationOrder)

    def Value(*args):
        """
        Value(BRepAdaptor_Curve C, Standard_Real const U) -> gp_Pnt

        Returns the point of parameter U on the loaded curve.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepGProp.BRepGProp_EdgeTool_Value(*args)

    Value = staticmethod(Value)

    def D1(*args):
        """
        D1(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1)

        Returns the point of parameter U and the first derivative
        at this point.

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _BRepGProp.BRepGProp_EdgeTool_D1(*args)

    D1 = staticmethod(D1)

    def NbIntervals(*args):
        """
        NbIntervals(BRepAdaptor_Curve C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepGProp.BRepGProp_EdgeTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(BRepAdaptor_Curve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepGProp.BRepGProp_EdgeTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def __init__(self):
        """
        Provides  the required  methods    to instantiate
        CGProps from GProp with a Curve from BRepAdaptor.
        """
        this = _BRepGProp.new_BRepGProp_EdgeTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepGProp.delete_BRepGProp_EdgeTool
BRepGProp_EdgeTool_swigregister = _BRepGProp.BRepGProp_EdgeTool_swigregister
BRepGProp_EdgeTool_swigregister(BRepGProp_EdgeTool)

def BRepGProp_EdgeTool_FirstParameter(*args):
    """
    BRepGProp_EdgeTool_FirstParameter(BRepAdaptor_Curve C) -> Standard_Real

    Returns the parametric value of the start point of
    the curve.  The curve is oriented from the start point
    to the end point.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepGProp.BRepGProp_EdgeTool_FirstParameter(*args)

def BRepGProp_EdgeTool_LastParameter(*args):
    """
    BRepGProp_EdgeTool_LastParameter(BRepAdaptor_Curve C) -> Standard_Real

    Returns the parametric value of the end point of
    the curve.  The curve is oriented from the start point
    to the end point.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepGProp.BRepGProp_EdgeTool_LastParameter(*args)

def BRepGProp_EdgeTool_IntegrationOrder(*args):
    """
    BRepGProp_EdgeTool_IntegrationOrder(BRepAdaptor_Curve C) -> Standard_Integer

    Returns the number of Gauss points required to do
    the integration with a good accuracy using the
    Gauss method.  For a polynomial curve of degree n
    the maxima of accuracy is obtained with an order
    of integration equal to 2*n-1.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepGProp.BRepGProp_EdgeTool_IntegrationOrder(*args)

def BRepGProp_EdgeTool_Value(*args):
    """
    BRepGProp_EdgeTool_Value(BRepAdaptor_Curve C, Standard_Real const U) -> gp_Pnt

    Returns the point of parameter U on the loaded curve.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _BRepGProp.BRepGProp_EdgeTool_Value(*args)

def BRepGProp_EdgeTool_D1(*args):
    """
    BRepGProp_EdgeTool_D1(BRepAdaptor_Curve C, Standard_Real const U, gp_Pnt P, gp_Vec V1)

    Returns the point of parameter U and the first derivative
    at this point.

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type V1: OCC.wrapper.gp.gp_Vec

    """
    return _BRepGProp.BRepGProp_EdgeTool_D1(*args)

def BRepGProp_EdgeTool_NbIntervals(*args):
    """
    BRepGProp_EdgeTool_NbIntervals(BRepAdaptor_Curve C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(me) >= <S>

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _BRepGProp.BRepGProp_EdgeTool_NbIntervals(*args)

def BRepGProp_EdgeTool_Intervals(*args):
    """
    BRepGProp_EdgeTool_Intervals(BRepAdaptor_Curve C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _BRepGProp.BRepGProp_EdgeTool_Intervals(*args)

class BRepGProp_Domain(object):
    """
    Arc iterator. Returns only Forward and Reversed edges from
    the face in an undigested order.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_Domain self) -> BRepGProp_Domain
        __init__(BRepGProp_Domain self, TopoDS_Face F) -> BRepGProp_Domain

        Constructor. Initializes the domain with the face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _BRepGProp.new_BRepGProp_Domain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(BRepGProp_Domain self) -> Standard_Boolean

        Returns True if there is another arc of curve in the list.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepGProp.BRepGProp_Domain_More(self, *args)


    def Init(self, *args):
        """
        Init(BRepGProp_Domain self, TopoDS_Face F)
        Init(BRepGProp_Domain self)

        Initializes the exploration with the face already set.


        """
        return _BRepGProp.BRepGProp_Domain_Init(self, *args)


    def Value(self, *args):
        """
        Value(BRepGProp_Domain self) -> TopoDS_Edge

        Returns the current edge.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepGProp.BRepGProp_Domain_Value(self, *args)


    def Next(self, *args):
        """
        Next(BRepGProp_Domain self)

        Sets the index of the arc iterator to the next arc of
        curve.


        """
        return _BRepGProp.BRepGProp_Domain_Next(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Domain
BRepGProp_Domain_swigregister = _BRepGProp.BRepGProp_Domain_swigregister
BRepGProp_Domain_swigregister(BRepGProp_Domain)

class BRepGProp_Vinert(GProp.GProp_GProps):
    """
    Computes the global properties of a geometric solid
    (3D closed region of space) delimited with :
    . a surface
    . a point and a surface
    . a plane and a surface

    The surface can be :
    . a surface limited with its parametric values U-V,
    . a surface limited in U-V space with its curves of restriction,

    The surface 's requirements to evaluate the global properties
    are defined in the template SurfaceTool from package GProp.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_Vinert self) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pnt VLocation) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pnt VLocation, Standard_Real const Eps) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pnt O, gp_Pnt VLocation) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pnt O, gp_Pnt VLocation, Standard_Real const Eps) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pln Pl, gp_Pnt VLocation) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pln Pl, gp_Pnt VLocation, Standard_Real const Eps) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt VLocation) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt VLocation, Standard_Real const Eps) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt O, gp_Pnt VLocation) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt O, gp_Pnt VLocation, Standard_Real const Eps) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pln Pl, gp_Pnt VLocation) -> BRepGProp_Vinert
        __init__(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pln Pl, gp_Pnt VLocation, Standard_Real const Eps) -> BRepGProp_Vinert

        Computes the global properties of the region of 3D space
        delimited with the surface <S> and the plane Pln.
        Adaptive 2D Gauss integration is used.
        Parameter Eps sets maximal relative error of computed mass (volume) for face.
        Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values
        for two successive steps of adaptive integration.
        WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.

        :type S: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type D: OCC.wrapper.BRepGProp.BRepGProp_Domain
        :type Pl: OCC.wrapper.gp.gp_Pln
        :type VLocation: OCC.wrapper.gp.gp_Pnt
        :type Eps: float

        """
        this = _BRepGProp.new_BRepGProp_Vinert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(BRepGProp_Vinert self, gp_Pnt VLocation)

        :type VLocation: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepGProp.BRepGProp_Vinert_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepGProp_Vinert self, BRepGProp_Face S)
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, Standard_Real const Eps) -> Standard_Real
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pnt O)
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pnt O, Standard_Real const Eps) -> Standard_Real
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pln Pl)
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, gp_Pln Pl, Standard_Real const Eps) -> Standard_Real
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D)
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, Standard_Real const Eps) -> Standard_Real
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt O)
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pnt O, Standard_Real const Eps) -> Standard_Real
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pln Pl)
        Perform(BRepGProp_Vinert self, BRepGProp_Face S, BRepGProp_Domain D, gp_Pln Pl, Standard_Real const Eps) -> Standard_Real

        :type S: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type D: OCC.wrapper.BRepGProp.BRepGProp_Domain
        :type Pl: OCC.wrapper.gp.gp_Pln
        :type Eps: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_Vinert_Perform(self, *args)


    def GetEpsilon(self, *args):
        """
        GetEpsilon(BRepGProp_Vinert self) -> Standard_Real

        If previously used methods containe Eps parameter
        gets actual relative error of the computation, else returns  1.0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_Vinert_GetEpsilon(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_Vinert
BRepGProp_Vinert_swigregister = _BRepGProp.BRepGProp_Vinert_swigregister
BRepGProp_Vinert_swigregister(BRepGProp_Vinert)

class BRepGProp_(object):
    """
    Provides global functions to compute a shape's global
    properties for lines, surfaces or volumes, and bring
    them together with the global properties already
    computed for a geometric system.
    The global properties computed for a system are :
    - its mass,
    - its center of mass,
    - its matrix of inertia,
    - its moment about an axis,
    - its radius of gyration about an axis,
    - and its principal properties of inertia such as
    principal axis, principal moments, principal radius of gyration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def LinearProperties(*args):
        """
        LinearProperties(TopoDS_Shape S, GProp_GProps LProps, Standard_Boolean const SkipShared)

        Computes the linear global properties of the shape S,
        i.e. the global properties induced by each edge of the
        shape S, and brings them together with the global
        properties still retained by the framework LProps. If
        the current system of LProps was empty, its global
        properties become equal to the linear global
        properties of S.
        For this computation no linear density is attached to
        the edges. So, for example, the added mass
        corresponds to the sum of the lengths of the edges of
        S. The density of the composed systems, i.e. that of
        each component of the current system of LProps, and
        that of S which is considered to be equal to 1, must be coherent.
        Note that this coherence cannot be checked. You are
        advised to use a separate framework for each
        density, and then to bring these frameworks together
        into a global one.
        The point relative to which the inertia of the system is
        computed is the reference point of the framework LProps.
        Note: if your programming ensures that the framework
        LProps retains only linear global properties (brought
        together for example, by the function
        LinearProperties) for objects the density of which is
        equal to 1 (or is not defined), the function Mass will
        return the total length of edges of the system analysed by LProps.
        Warning
        No check is performed to verify that the shape S
        retains truly linear properties. If S is simply a vertex, it
        is not considered to present any additional global properties.
        SkipShared is special flag, which allows to take in calculation shared topological entities or not
        For ex., if SkipShared = True, edges, shared by two or more faces, are taken into calculation only once.
        If we have cube with sizes 1, 1, 1, its linear properties = 12 for SkipEdges = true and 24 for SkipEdges = false.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LProps: OCC.wrapper.GProp.GProp_GProps
        :type SkipShared: bool

        """
        return _BRepGProp.BRepGProp__LinearProperties(*args)

    LinearProperties = staticmethod(LinearProperties)

    def SurfaceProperties(*args):
        """
        SurfaceProperties(TopoDS_Shape S, GProp_GProps SProps, Standard_Boolean const SkipShared)
        SurfaceProperties(TopoDS_Shape S, GProp_GProps SProps, Standard_Real const Eps, Standard_Boolean const SkipShared) -> Standard_Real

        Updates <SProps> with the shape <S>, that contains its pricipal properties.
        The surface properties of all the faces in <S> are computed.
        Adaptive 2D Gauss integration is used.
        Parameter Eps sets maximal relative error of computed mass (area) for each face.
        Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values
        for two successive steps of adaptive integration.
        Method returns estimation of relative error reached for whole shape.
        WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
        SkipShared is special flag, which allows to take in calculation shared topological entities or not
        For ex., if SkipShared = True, faces, shared by two or more shells, are taken into calculation only once.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SProps: OCC.wrapper.GProp.GProp_GProps
        :type Eps: float
        :type SkipShared: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp__SurfaceProperties(*args)

    SurfaceProperties = staticmethod(SurfaceProperties)

    def VolumeProperties(*args):
        """
        VolumeProperties(TopoDS_Shape S, GProp_GProps VProps, Standard_Boolean const OnlyClosed, Standard_Boolean const SkipShared)
        VolumeProperties(TopoDS_Shape S, GProp_GProps VProps, Standard_Real const Eps, Standard_Boolean const OnlyClosed, Standard_Boolean const SkipShared) -> Standard_Real

        Updates <VProps> with the shape <S>, that contains its pricipal properties.
        The volume properties of all the FORWARD and REVERSED faces in <S> are computed.
        If OnlyClosed is True then computed faces must belong to closed Shells.
        Adaptive 2D Gauss integration is used.
        Parameter Eps sets maximal relative error of computed mass (volume) for each face.
        Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values
        for two successive steps of adaptive integration.
        Method returns estimation of relative error reached for whole shape.
        WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
        SkipShared is special flag, which allows to take in calculation shared topological entities or not
        For ex., if SkipShared = True, the volumes formed by the equal (the same TShape, location and orientation) faces are taken into calculation only once.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type VProps: OCC.wrapper.GProp.GProp_GProps
        :type Eps: float
        :type OnlyClosed: bool
        :type SkipShared: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp__VolumeProperties(*args)

    VolumeProperties = staticmethod(VolumeProperties)

    def VolumePropertiesGK(*args):
        """
        VolumePropertiesGK(TopoDS_Shape S, GProp_GProps VProps, Standard_Real const Eps=0.001, Standard_Boolean const OnlyClosed, Standard_Boolean const IsUseSpan, Standard_Boolean const CGFlag, Standard_Boolean const IFlag, Standard_Boolean const SkipShared) -> Standard_Real
        VolumePropertiesGK(TopoDS_Shape S, GProp_GProps VProps, gp_Pln thePln, Standard_Real const Eps=0.001, Standard_Boolean const OnlyClosed, Standard_Boolean const IsUseSpan, Standard_Boolean const CGFlag, Standard_Boolean const IFlag, Standard_Boolean const SkipShared) -> Standard_Real

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type VProps: OCC.wrapper.GProp.GProp_GProps
        :type thePln: OCC.wrapper.gp.gp_Pln
        :type Eps: float
        :type OnlyClosed: bool
        :type IsUseSpan: bool
        :type CGFlag: bool
        :type IFlag: bool
        :type SkipShared: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp__VolumePropertiesGK(*args)

    VolumePropertiesGK = staticmethod(VolumePropertiesGK)

    def __init__(self):
        """
        Provides global functions to compute a shape's global
        properties for lines, surfaces or volumes, and bring
        them together with the global properties already
        computed for a geometric system.
        The global properties computed for a system are :
        - its mass,
        - its center of mass,
        - its matrix of inertia,
        - its moment about an axis,
        - its radius of gyration about an axis,
        - and its principal properties of inertia such as
        principal axis, principal moments, principal radius of gyration.
        """
        this = _BRepGProp.new_BRepGProp_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepGProp.delete_BRepGProp_
BRepGProp__swigregister = _BRepGProp.BRepGProp__swigregister
BRepGProp__swigregister(BRepGProp_)

def BRepGProp__LinearProperties(*args):
    """
    BRepGProp__LinearProperties(TopoDS_Shape S, GProp_GProps LProps, Standard_Boolean const SkipShared)

    Computes the linear global properties of the shape S,
    i.e. the global properties induced by each edge of the
    shape S, and brings them together with the global
    properties still retained by the framework LProps. If
    the current system of LProps was empty, its global
    properties become equal to the linear global
    properties of S.
    For this computation no linear density is attached to
    the edges. So, for example, the added mass
    corresponds to the sum of the lengths of the edges of
    S. The density of the composed systems, i.e. that of
    each component of the current system of LProps, and
    that of S which is considered to be equal to 1, must be coherent.
    Note that this coherence cannot be checked. You are
    advised to use a separate framework for each
    density, and then to bring these frameworks together
    into a global one.
    The point relative to which the inertia of the system is
    computed is the reference point of the framework LProps.
    Note: if your programming ensures that the framework
    LProps retains only linear global properties (brought
    together for example, by the function
    LinearProperties) for objects the density of which is
    equal to 1 (or is not defined), the function Mass will
    return the total length of edges of the system analysed by LProps.
    Warning
    No check is performed to verify that the shape S
    retains truly linear properties. If S is simply a vertex, it
    is not considered to present any additional global properties.
    SkipShared is special flag, which allows to take in calculation shared topological entities or not
    For ex., if SkipShared = True, edges, shared by two or more faces, are taken into calculation only once.
    If we have cube with sizes 1, 1, 1, its linear properties = 12 for SkipEdges = true and 24 for SkipEdges = false.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type LProps: OCC.wrapper.GProp.GProp_GProps
    :type SkipShared: bool

    """
    return _BRepGProp.BRepGProp__LinearProperties(*args)

def BRepGProp__SurfaceProperties(*args):
    """
    SurfaceProperties(TopoDS_Shape S, GProp_GProps SProps, Standard_Boolean const SkipShared)
    BRepGProp__SurfaceProperties(TopoDS_Shape S, GProp_GProps SProps, Standard_Real const Eps, Standard_Boolean const SkipShared) -> Standard_Real

    Updates <SProps> with the shape <S>, that contains its pricipal properties.
    The surface properties of all the faces in <S> are computed.
    Adaptive 2D Gauss integration is used.
    Parameter Eps sets maximal relative error of computed mass (area) for each face.
    Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values
    for two successive steps of adaptive integration.
    Method returns estimation of relative error reached for whole shape.
    WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
    SkipShared is special flag, which allows to take in calculation shared topological entities or not
    For ex., if SkipShared = True, faces, shared by two or more shells, are taken into calculation only once.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type SProps: OCC.wrapper.GProp.GProp_GProps
    :type Eps: float
    :type SkipShared: bool
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepGProp.BRepGProp__SurfaceProperties(*args)

def BRepGProp__VolumeProperties(*args):
    """
    VolumeProperties(TopoDS_Shape S, GProp_GProps VProps, Standard_Boolean const OnlyClosed, Standard_Boolean const SkipShared)
    BRepGProp__VolumeProperties(TopoDS_Shape S, GProp_GProps VProps, Standard_Real const Eps, Standard_Boolean const OnlyClosed, Standard_Boolean const SkipShared) -> Standard_Real

    Updates <VProps> with the shape <S>, that contains its pricipal properties.
    The volume properties of all the FORWARD and REVERSED faces in <S> are computed.
    If OnlyClosed is True then computed faces must belong to closed Shells.
    Adaptive 2D Gauss integration is used.
    Parameter Eps sets maximal relative error of computed mass (volume) for each face.
    Error is calculated as Abs((M(i+1)-M(i))/M(i+1)), M(i+1) and M(i) are values
    for two successive steps of adaptive integration.
    Method returns estimation of relative error reached for whole shape.
    WARNING: if Eps > 0.001 algorithm performs non-adaptive integration.
    SkipShared is special flag, which allows to take in calculation shared topological entities or not
    For ex., if SkipShared = True, the volumes formed by the equal (the same TShape, location and orientation) faces are taken into calculation only once.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type VProps: OCC.wrapper.GProp.GProp_GProps
    :type Eps: float
    :type OnlyClosed: bool
    :type SkipShared: bool
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepGProp.BRepGProp__VolumeProperties(*args)

def BRepGProp__VolumePropertiesGK(*args):
    """
    VolumePropertiesGK(TopoDS_Shape S, GProp_GProps VProps, Standard_Real const Eps=0.001, Standard_Boolean const OnlyClosed, Standard_Boolean const IsUseSpan, Standard_Boolean const CGFlag, Standard_Boolean const IFlag, Standard_Boolean const SkipShared) -> Standard_Real
    BRepGProp__VolumePropertiesGK(TopoDS_Shape S, GProp_GProps VProps, gp_Pln thePln, Standard_Real const Eps=0.001, Standard_Boolean const OnlyClosed, Standard_Boolean const IsUseSpan, Standard_Boolean const CGFlag, Standard_Boolean const IFlag, Standard_Boolean const SkipShared) -> Standard_Real

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type VProps: OCC.wrapper.GProp.GProp_GProps
    :type thePln: OCC.wrapper.gp.gp_Pln
    :type Eps: float
    :type OnlyClosed: bool
    :type IsUseSpan: bool
    :type CGFlag: bool
    :type IFlag: bool
    :type SkipShared: bool
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepGProp.BRepGProp__VolumePropertiesGK(*args)

class BRepGProp_VinertGK(GProp.GProp_GProps):
    """
    Computes the global properties of a geometric solid
    (3D closed region of space) delimited with :
    -  a point and a surface
    -  a plane and a surface

    The surface can be :
    -  a surface limited with its parametric values U-V,
    (naturally restricted)
    -  a surface limited in U-V space with its boundary
    curves.

    The surface's requirements to evaluate the global
    properties are defined in the template FaceTool class from
    the package GProp.

    The adaptive 2D algorithm of Gauss-Kronrod integration of
    double integral is used.

    The inner integral is computed along U parameter of
    surface. The integrand function is encapsulated in the
    support class UFunction that is defined below.

    The outer integral is computed along T parameter of a
    bounding curve. The integrand function is encapsulated in
    the support class TFunction that is defined below.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepGProp_VinertGK self) -> BRepGProp_VinertGK
        __init__(BRepGProp_VinertGK self, BRepGProp_Face theSurface, gp_Pnt theLocation, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> BRepGProp_VinertGK
        __init__(BRepGProp_VinertGK self, BRepGProp_Face theSurface, gp_Pnt thePoint, gp_Pnt theLocation, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> BRepGProp_VinertGK
        __init__(BRepGProp_VinertGK self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pnt theLocation, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> BRepGProp_VinertGK
        __init__(BRepGProp_VinertGK self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pnt thePoint, gp_Pnt theLocation, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> BRepGProp_VinertGK
        __init__(BRepGProp_VinertGK self, BRepGProp_Face theSurface, gp_Pln thePlane, gp_Pnt theLocation, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> BRepGProp_VinertGK
        __init__(BRepGProp_VinertGK self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pln thePlane, gp_Pnt theLocation, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> BRepGProp_VinertGK

        Constructor. Computes the global properties of a region of
        3D space delimited with the surface bounded by the domain
        and the plane.

        :type theSurface: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type theDomain: OCC.wrapper.BRepGProp.BRepGProp_Domain
        :type thePlane: OCC.wrapper.gp.gp_Pln
        :type theLocation: OCC.wrapper.gp.gp_Pnt
        :type theTolerance: float
        :type theCGFlag: bool
        :type theIFlag: bool

        """
        this = _BRepGProp.new_BRepGProp_VinertGK(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(BRepGProp_VinertGK self, gp_Pnt theLocation)

        Sets the vertex that delimit 3D closed region of space.

        :type theLocation: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepGProp.BRepGProp_VinertGK_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepGProp_VinertGK self, BRepGProp_Face theSurface, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> Standard_Real
        Perform(BRepGProp_VinertGK self, BRepGProp_Face theSurface, gp_Pnt thePoint, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> Standard_Real
        Perform(BRepGProp_VinertGK self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> Standard_Real
        Perform(BRepGProp_VinertGK self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pnt thePoint, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> Standard_Real
        Perform(BRepGProp_VinertGK self, BRepGProp_Face theSurface, gp_Pln thePlane, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> Standard_Real
        Perform(BRepGProp_VinertGK self, BRepGProp_Face theSurface, BRepGProp_Domain theDomain, gp_Pln thePlane, Standard_Real const theTolerance=0.001, Standard_Boolean const theCGFlag, Standard_Boolean const theIFlag) -> Standard_Real

        Computes the global properties of a region of 3D space
        delimited with the surface bounded by the domain and the
        plane.

        :type theSurface: OCC.wrapper.BRepGProp.BRepGProp_Face
        :type theDomain: OCC.wrapper.BRepGProp.BRepGProp_Domain
        :type thePlane: OCC.wrapper.gp.gp_Pln
        :type theTolerance: float
        :type theCGFlag: bool
        :type theIFlag: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_VinertGK_Perform(self, *args)


    def GetErrorReached(self, *args):
        """
        GetErrorReached(BRepGProp_VinertGK self) -> Standard_Real

        Returns the relative reached computation error.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepGProp.BRepGProp_VinertGK_GetErrorReached(self, *args)

    __swig_destroy__ = _BRepGProp.delete_BRepGProp_VinertGK
BRepGProp_VinertGK_swigregister = _BRepGProp.BRepGProp_VinertGK_swigregister
BRepGProp_VinertGK_swigregister(BRepGProp_VinertGK)




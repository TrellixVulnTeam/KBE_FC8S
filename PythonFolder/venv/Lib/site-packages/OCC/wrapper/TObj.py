# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TObj')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TObj')
    _TObj = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TObj', [dirname(__file__)])
        except ImportError:
            import _TObj
            return _TObj
        try:
            _mod = imp.load_module('_TObj', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TObj = swig_import_helper()
    del swig_import_helper
else:
    import _TObj
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TObj.delete_SwigPyIterator

    def value(self):
        return _TObj.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TObj.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TObj.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TObj.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TObj.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TObj.SwigPyIterator_copy(self)

    def next(self):
        return _TObj.SwigPyIterator_next(self)

    def __next__(self):
        return _TObj.SwigPyIterator___next__(self)

    def previous(self):
        return _TObj.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TObj.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TObj.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TObj.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TObj.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TObj.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TObj.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TObj.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TObj.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TObj.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TObj.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TObj.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TObj.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TObj.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TObj.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TObj.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TObj.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TObj.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TObj.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TObj.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TObj.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TObj.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TObj.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TObj.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TObj.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TObj.ptr_to_number(item)
ptr_to_number = _TObj.ptr_to_number

def HashCode(*args):
    return _TObj.HashCode(*args)
HashCode = _TObj.HashCode

def ptr_equal(a, b):
    return _TObj.ptr_equal(a, b)
ptr_equal = _TObj.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDocStd
else:
    import TDocStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import CDF
else:
    import CDF
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import CDM
else:
    import CDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Resource
else:
    import Resource
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PCDM
else:
    import PCDM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import LDOM
else:
    import LDOM
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Storage
else:
    import Storage
del _swig_python_version_info
TObj_FreeOnly = _TObj.TObj_FreeOnly
TObj_KeepDepending = _TObj.TObj_KeepDepending
TObj_Forced = _TObj.TObj_Forced
class TObj_ObjectIterator(Standard.Standard_Transient):
    """
    This class provides an iterator by objects in a partition.
    (implements TObj_ObjectIterator interface)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_ObjectIterator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_ObjectIterator(self) 
            return h


    def More(self, *args):
        """
        More(TObj_ObjectIterator self) -> Standard_Boolean

        Returns True if iteration is not finished and method Current()
        will give the object.
        Default implementation returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_ObjectIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TObj_ObjectIterator self)

        Iterates to the next object
        Default implementation does nothing


        """
        return _TObj.TObj_ObjectIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(TObj_ObjectIterator self) -> Handle_TObj_Object

        Returns current object (or null if iteration has finished)
        Default implementation returns null handle

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_ObjectIterator_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_ObjectIterator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_ObjectIterator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_ObjectIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """
        This class provides an iterator by objects in a partition.
        (implements TObj_ObjectIterator interface)
        """
        this = _TObj.new_TObj_ObjectIterator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _TObj.delete_TObj_ObjectIterator
TObj_ObjectIterator_swigregister = _TObj.TObj_ObjectIterator_swigregister
TObj_ObjectIterator_swigregister(TObj_ObjectIterator)

def TObj_ObjectIterator_get_type_name(*args):
    """
    TObj_ObjectIterator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_ObjectIterator_get_type_name(*args)

def TObj_ObjectIterator_get_type_descriptor(*args):
    """
    TObj_ObjectIterator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_ObjectIterator_get_type_descriptor(*args)

class TObj_LabelIterator(TObj_ObjectIterator):
    """This class is a basis for OCAF based iterators."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_LabelIterator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_LabelIterator(self) 
            return h


    def More(self, *args):
        """
        More(TObj_LabelIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_LabelIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TObj_LabelIterator self)

        Move to the next Item


        """
        return _TObj.TObj_LabelIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(TObj_LabelIterator self) -> Handle_TObj_Object

        Returns the current item

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_LabelIterator_Value(self, *args)


    def LabelValue(self, *args):
        """
        Returns the label of the current item

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TObj.TObj_LabelIterator_LabelValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_LabelIterator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_LabelIterator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_LabelIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_LabelIterator
TObj_LabelIterator_swigregister = _TObj.TObj_LabelIterator_swigregister
TObj_LabelIterator_swigregister(TObj_LabelIterator)

def TObj_LabelIterator_get_type_name(*args):
    """
    TObj_LabelIterator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_LabelIterator_get_type_name(*args)

def TObj_LabelIterator_get_type_descriptor(*args):
    """
    TObj_LabelIterator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_LabelIterator_get_type_descriptor(*args)

class TObj_TModel(TDF.TDF_Attribute):
    """
    Attribute to store OCAF-based models in OCAF tree
    The persistency mechanism of the TObj_TModel allowes to save
    and restore various types of models without recompilation of the schema
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_TModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_TModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_TModel self) -> TObj_TModel

        Empty constructor


        """
        this = _TObj.new_TObj_TModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetID(*args):
        """
        GetID() -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.TObj_TModel_GetID(*args)

    GetID = staticmethod(GetID)

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.TObj_TModel_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(TObj_TModel self, Handle_TObj_Model theModel)

        Sets the the Model object

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_TModel_Set(self, *args)


    def Model(self, *args):
        """
        Model(TObj_TModel self) -> Handle_TObj_Model

        Returns the Model object

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_TModel_Model(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TObj_TModel self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TModel attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TModel_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(TObj_TModel self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TModel_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TObj_TModel self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_TModel_Paste(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_TModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_TModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_TModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_TModel
TObj_TModel_swigregister = _TObj.TObj_TModel_swigregister
TObj_TModel_swigregister(TObj_TModel)

def TObj_TModel_GetID(*args):
    """
    TObj_TModel_GetID() -> Standard_GUID

    This method is used in implementation of ID()

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TObj.TObj_TModel_GetID(*args)

def TObj_TModel_get_type_name(*args):
    """
    TObj_TModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_TModel_get_type_name(*args)

def TObj_TModel_get_type_descriptor(*args):
    """
    TObj_TModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_TModel_get_type_descriptor(*args)

class TObj_ReferenceIterator(TObj_LabelIterator):
    """
    This class provides an iterator by references of the object
    (implements TObj_ReferenceIterator interface)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_ReferenceIterator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_ReferenceIterator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_ReferenceIterator self, TDF_Label theLabel, Handle_Standard_Type theType=0, Standard_Boolean const theRecursive) -> TObj_ReferenceIterator

        Creates the iterator on references in partition
        theType narrows a variety of iterated objects

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :type theRecursive: bool

        """
        this = _TObj.new_TObj_ReferenceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_ReferenceIterator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_ReferenceIterator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_ReferenceIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_ReferenceIterator
TObj_ReferenceIterator_swigregister = _TObj.TObj_ReferenceIterator_swigregister
TObj_ReferenceIterator_swigregister(TObj_ReferenceIterator)

def TObj_ReferenceIterator_get_type_name(*args):
    """
    TObj_ReferenceIterator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_ReferenceIterator_get_type_name(*args)

def TObj_ReferenceIterator_get_type_descriptor(*args):
    """
    TObj_ReferenceIterator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_ReferenceIterator_get_type_descriptor(*args)

class TObj_Model(Standard.Standard_Transient):
    """
    Base class for OCAF based models.
    Defines common behaviour for all models based on TObject 
    classes, basic services to access model objects and common
    operations with the model.
    Provides default implementation for many methods.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_Model
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_Model(self) 
            return h


    def SetMessenger(self, *args):
        """
        SetMessenger(TObj_Model self, Handle_Message_Messenger theMsgr)

        Set messenger to use for messages output

        :type theMsgr: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.TObj_Model_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(TObj_Model self) -> Handle_Message_Messenger

        Get messenger used for messages output (by default, the messenger from
        application is used)

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.TObj_Model_Messenger(self, *args)


    def Load(self, *args):
        """
        Load(TObj_Model self, TCollection_ExtendedString theFile) -> Standard_Boolean

        Load the OCAF model from a file. If the filename is empty or file does
        not exists, it just initializes model by empty data.

        :type theFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_Load(self, *args)


    def SaveAs(self, *args):
        """
        SaveAs(TObj_Model self, TCollection_ExtendedString theFile) -> Standard_Boolean

        Save the model to a file

        :type theFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_SaveAs(self, *args)


    def Save(self, *args):
        """
        Save(TObj_Model self) -> Standard_Boolean

        Save the model to the same file

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_Save(self, *args)


    def Close(self, *args):
        """
        Close(TObj_Model self) -> Standard_Boolean

        Close the model

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_Close(self, *args)


    def CloseDocument(self, *args):
        """
        CloseDocument(TObj_Model self, Handle_TDocStd_Document theDoc)

        Close Free OCAF document

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.TObj_Model_CloseDocument(self, *args)


    def GetDocumentModel(*args):
        """
        GetDocumentModel(TDF_Label theLabel) -> Handle_TObj_Model

        Returns model which contains a document with the label,
        or NULL handle if label is NULL

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_Model_GetDocumentModel(*args)

    GetDocumentModel = staticmethod(GetDocumentModel)

    def GetFile(self, *args):
        """
        GetFile(TObj_Model self) -> Handle_TCollection_HExtendedString

        Returns the full file name this model is to be saved to, 
        or null if the model was not saved yet

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.TObj_Model_GetFile(self, *args)


    def GetObjects(self, *args):
        """
        GetObjects(TObj_Model self) -> Handle_TObj_ObjectIterator

        Returns an Iterator on all objects in the Model

        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.TObj_Model_GetObjects(self, *args)


    def GetChildren(self, *args):
        """
        GetChildren(TObj_Model self) -> Handle_TObj_ObjectIterator

        Returns an Iterator on objects in the main partition

        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.TObj_Model_GetChildren(self, *args)


    def FindObject(self, *args):
        """
        FindObject(TObj_Model self, Handle_TCollection_HExtendedString theName, Handle_TObj_TNameContainer theDictionary) -> Handle_TObj_Object

        Returns an Object by given Name (or Null if not found).

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Model_FindObject(self, *args)


    def GetChecker(self, *args):
        """
        GetChecker(TObj_Model self) -> Handle_TObj_CheckModel

        Returns the tool checking model consistency.
        Descendant may redefine it to return its own tool.

        :rtype: OCC.wrapper.TObj.Handle_TObj_CheckModel

        """
        return _TObj.TObj_Model_GetChecker(self, *args)


    def GetRoot(self, *args):
        """
        GetRoot(TObj_Model self) -> Handle_TObj_Object

        Returns root object of model

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Model_GetRoot(self, *args)


    def GetMainPartition(self, *args):
        """
        GetMainPartition(TObj_Model self) -> Handle_TObj_Partition

        Returns root object of model

        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.TObj_Model_GetMainPartition(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(TObj_Model self) -> TDF_Label

        Returns OCAF label on which model data are stored.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Model_GetLabel(self, *args)


    def GetModelName(self, *args):
        """
        GetModelName(TObj_Model self) -> Handle_TCollection_HExtendedString

        Returns the name of the model

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.TObj_Model_GetModelName(self, *args)


    def SetNewName(*args):
        """
        SetNewName(Handle_TObj_Object theObject)

        Sets new unique name for the object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Model_SetNewName(*args)

    SetNewName = staticmethod(SetNewName)

    def IsRegisteredName(self, *args):
        """
        IsRegisteredName(TObj_Model self, Handle_TCollection_HExtendedString theName, Handle_TObj_TNameContainer theDictionary) -> Standard_Boolean

        Returns True is name is registered in the names map
        The input argument may be NULL handle, then model check in own global container

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_IsRegisteredName(self, *args)


    def RegisterName(self, *args):
        """
        RegisterName(TObj_Model self, Handle_TCollection_HExtendedString theName, TDF_Label theLabel, Handle_TObj_TNameContainer theDictionary)

        Register name in the map
        The input argument may be NULL handle, then model check in own global container

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.TObj_Model_RegisterName(self, *args)


    def UnRegisterName(self, *args):
        """
        UnRegisterName(TObj_Model self, Handle_TCollection_HExtendedString theName, Handle_TObj_TNameContainer theDictionary)

        Unregisters name from the map
        The input argument may be NULL handle, then model check in own global container

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.TObj_Model_UnRegisterName(self, *args)


    def HasOpenCommand(self, *args):
        """
        HasOpenCommand(TObj_Model self) -> Standard_Boolean

        Returns True if a Command transaction is open
        Starting, finishing the transaction

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_HasOpenCommand(self, *args)


    def OpenCommand(self, *args):
        """
        OpenCommand(TObj_Model self)

        Open a new command transaction.


        """
        return _TObj.TObj_Model_OpenCommand(self, *args)


    def CommitCommand(self, *args):
        """
        CommitCommand(TObj_Model self)

        Commit the Command transaction. Do nothing If there is no Command
        transaction open.


        """
        return _TObj.TObj_Model_CommitCommand(self, *args)


    def AbortCommand(self, *args):
        """
        AbortCommand(TObj_Model self)

        Abort the  Command  transaction. Do nothing If there is no Command
        transaction open.


        """
        return _TObj.TObj_Model_AbortCommand(self, *args)


    def IsModified(self, *args):
        """
        IsModified(TObj_Model self) -> Standard_Boolean

        Modification status

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_IsModified(self, *args)


    def SetModified(self, *args):
        """
        SetModified(TObj_Model self, Standard_Boolean const theModified)

        Sets modification status

        :type theModified: bool

        """
        return _TObj.TObj_Model_SetModified(self, *args)


    def GetApplication(self, *args):
        """
        GetApplication(TObj_Model self) -> Handle_TObj_Application

        Returns handle to static instance of the relevant application class

        :rtype: OCC.wrapper.TObj.Handle_TObj_Application

        """
        return _TObj.TObj_Model_GetApplication(self, *args)


    def GetFormat(self, *args):
        """
        GetFormat(TObj_Model self) -> TCollection_ExtendedString

        Returns the format for save/restore.
        This implementation returns "BinOcaf". The method should be redefined
        for those models that should use another format.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TObj.TObj_Model_GetFormat(self, *args)


    def GetFormatVersion(self, *args):
        """
        GetFormatVersion(TObj_Model self) -> Standard_Integer

        Returns the version of format stored in TObj file

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Model_GetFormatVersion(self, *args)


    def Update(self, *args):
        """
        Update(TObj_Model self) -> Standard_Boolean

        this method is called before activating this model

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_Update(self, *args)


    def GetGUID(self, *args):
        """
        GetGUID(TObj_Model self) -> Standard_GUID

        Defines interface GUID for TObj_Model

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.TObj_Model_GetGUID(self, *args)


    def GetDictionary(self, *args):
        """
        GetDictionary(TObj_Model self) -> Handle_TObj_TNameContainer

        Returns the map of names of the objects

        :rtype: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.TObj_Model_GetDictionary(self, *args)


    def GetDocument(self, *args):
        """
        GetDocument(TObj_Model self) -> Handle_TDocStd_Document

        Returns OCAF document of Model

        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.TObj_Model_GetDocument(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(TObj_Model self, TDF_Label theLabel)

        Sets OCAF label on which model data are stored.
        Used by persistence mechanism.

        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Model_SetLabel(self, *args)


    def Paste(self, *args):
        """
        Paste(TObj_Model self, Handle_TObj_Model theModel, Handle_TDF_RelocationTable theRelocTable=0) -> Standard_Boolean

        Pastes me to the new model
        references will not be copied if theRelocTable is not 0
        if theRelocTable is not NULL theRelocTable is filled by objects

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Model_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TObj_Model self) -> Handle_TObj_Model

        This function have to create a new model with type like me

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_Model_NewEmpty(self, *args)


    def CopyReferences(self, *args):
        """
        CopyReferences(TObj_Model self, Handle_TObj_Model theTarget, Handle_TDF_RelocationTable theRelocTable)

        Copy references from me to the other

        :type theTarget: OCC.wrapper.TObj.Handle_TObj_Model
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_Model_CopyReferences(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_Model_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_Model_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_Model_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


TObj_Model_swigregister = _TObj.TObj_Model_swigregister
TObj_Model_swigregister(TObj_Model)

def TObj_Model_GetDocumentModel(*args):
    """
    TObj_Model_GetDocumentModel(TDF_Label theLabel) -> Handle_TObj_Model

    Returns model which contains a document with the label,
    or NULL handle if label is NULL

    :type theLabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TObj.Handle_TObj_Model

    """
    return _TObj.TObj_Model_GetDocumentModel(*args)

def TObj_Model_SetNewName(*args):
    """
    TObj_Model_SetNewName(Handle_TObj_Object theObject)

    Sets new unique name for the object

    :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

    """
    return _TObj.TObj_Model_SetNewName(*args)

def TObj_Model_get_type_name(*args):
    """
    TObj_Model_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_Model_get_type_name(*args)

def TObj_Model_get_type_descriptor(*args):
    """
    TObj_Model_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_Model_get_type_descriptor(*args)

class TObj_TNameContainer(TDF.TDF_Attribute):
    """
    This class provides OCAF Attribute to storing the unique names of object in
    model. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_TNameContainer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_TNameContainer(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_TNameContainer self) -> TObj_TNameContainer

        Empty constructor


        """
        this = _TObj.new_TObj_TNameContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetID(*args):
        """
        GetID() -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.TObj_TNameContainer_GetID(*args)

    GetID = staticmethod(GetID)

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.TObj_TNameContainer_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RecordName(self, *args):
        """
        RecordName(TObj_TNameContainer self, Handle_TCollection_HExtendedString theName, TDF_Label theLabel)

        Records name with label attached

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_TNameContainer_RecordName(self, *args)


    def RemoveName(self, *args):
        """
        RemoveName(TObj_TNameContainer self, Handle_TCollection_HExtendedString theName)

        Remove name from the map

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.TObj_TNameContainer_RemoveName(self, *args)


    def IsRegistered(self, *args):
        """
        IsRegistered(TObj_TNameContainer self, Handle_TCollection_HExtendedString theName) -> Standard_Boolean

        Return True is theName is registered in the Map

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_TNameContainer_IsRegistered(self, *args)


    def Clear(self, *args):
        """
        Clear(TObj_TNameContainer self)

        Remove all names registered in container


        """
        return _TObj.TObj_TNameContainer_Clear(self, *args)


    def Set(self, *args):
        """
        Set(TObj_TNameContainer self, TDF_Label theLabel) -> Handle_TObj_TNameContainer
        Set(TObj_TNameContainer self, TObj_DataMapOfNameLabel const & theElem)

        Sets the TObj_DataMapOfNameLabel object

        :type theElem: OCC.wrapper.TObj.TObj_DataMapOfNameLabel

        """
        return _TObj.TObj_TNameContainer_Set(self, *args)


    def Get(self, *args):
        """
        Returns the TObj_DataMapOfNameLabel object

        :rtype: OCC.wrapper.TObj.TObj_DataMapOfNameLabel

        """
        res = _TObj.TObj_TNameContainer_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewEmpty(self, *args):
        """
        NewEmpty(TObj_TNameContainer self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TNameContainer attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TNameContainer_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(TObj_TNameContainer self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TNameContainer_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TObj_TNameContainer self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_TNameContainer_Paste(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_TNameContainer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_TNameContainer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_TNameContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_TNameContainer
TObj_TNameContainer_swigregister = _TObj.TObj_TNameContainer_swigregister
TObj_TNameContainer_swigregister(TObj_TNameContainer)

def TObj_TNameContainer_GetID(*args):
    """
    TObj_TNameContainer_GetID() -> Standard_GUID

    This method is used in implementation of ID()

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TObj.TObj_TNameContainer_GetID(*args)

def TObj_TNameContainer_get_type_name(*args):
    """
    TObj_TNameContainer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_TNameContainer_get_type_name(*args)

def TObj_TNameContainer_get_type_descriptor(*args):
    """
    TObj_TNameContainer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_TNameContainer_get_type_descriptor(*args)

class TObj_SequenceIterator(TObj_ObjectIterator):
    """This class is an iterator on sequence"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_SequenceIterator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_SequenceIterator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_SequenceIterator self, Handle_TObj_HSequenceOfObject theObjects, Handle_Standard_Type theType=0) -> TObj_SequenceIterator

        Creates an iterator an initialize it by sequence of objects.

        :type theObjects: OCC.wrapper.TObj.Handle_TObj_HSequenceOfObject
        :type theType: OCC.wrapper.Standard.Handle_Standard_Type

        """
        this = _TObj.new_TObj_SequenceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def More(self, *args):
        """
        More(TObj_SequenceIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_SequenceIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TObj_SequenceIterator self)

        Move to the next Item


        """
        return _TObj.TObj_SequenceIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(TObj_SequenceIterator self) -> Handle_TObj_Object

        Returns the current item

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_SequenceIterator_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_SequenceIterator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_SequenceIterator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_SequenceIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_SequenceIterator
TObj_SequenceIterator_swigregister = _TObj.TObj_SequenceIterator_swigregister
TObj_SequenceIterator_swigregister(TObj_SequenceIterator)

def TObj_SequenceIterator_get_type_name(*args):
    """
    TObj_SequenceIterator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_SequenceIterator_get_type_name(*args)

def TObj_SequenceIterator_get_type_descriptor(*args):
    """
    TObj_SequenceIterator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_SequenceIterator_get_type_descriptor(*args)

class TObj_HSequenceOfObject(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_HSequenceOfObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_HSequenceOfObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_HSequenceOfObject self) -> TObj_HSequenceOfObject
        __init__(TObj_HSequenceOfObject self, NCollection_Sequence_Handle_TObj_Object theOther) -> TObj_HSequenceOfObject

        :type theOther: OCC.wrapper.TObj.TObj_SequenceOfObject

        """
        this = _TObj.new_TObj_HSequenceOfObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TObj.TObj_SequenceOfObject

        """
        res = _TObj.TObj_HSequenceOfObject_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSequence(self, *args):
        """
        ChangeSequence(TObj_HSequenceOfObject self) -> NCollection_Sequence_Handle_TObj_Object

        :rtype: OCC.wrapper.TObj.TObj_SequenceOfObject

        """
        return _TObj.TObj_HSequenceOfObject_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_HSequenceOfObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_HSequenceOfObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_HSequenceOfObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        return _TObj.TObj_HSequenceOfObject_Append(self, *args)
    __swig_destroy__ = _TObj.delete_TObj_HSequenceOfObject
TObj_HSequenceOfObject_swigregister = _TObj.TObj_HSequenceOfObject_swigregister
TObj_HSequenceOfObject_swigregister(TObj_HSequenceOfObject)

def TObj_HSequenceOfObject_get_type_name(*args):
    """
    TObj_HSequenceOfObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_HSequenceOfObject_get_type_name(*args)

def TObj_HSequenceOfObject_get_type_descriptor(*args):
    """
    TObj_HSequenceOfObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_HSequenceOfObject_get_type_descriptor(*args)

class TObj_OcafObjectIterator(TObj_LabelIterator):
    """
    This class provides an iterator by objects in a partition.
    (implements TObj_ObjectIterator interface)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_OcafObjectIterator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_OcafObjectIterator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_OcafObjectIterator self, TDF_Label theLabel, Handle_Standard_Type theType=0, Standard_Boolean const theRecursive) -> TObj_OcafObjectIterator

        Creates the iterator on objects in the sub labels of theLabel
        theType narrows a variety of iterated objects

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :type theRecursive: bool

        """
        this = _TObj.new_TObj_OcafObjectIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_OcafObjectIterator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_OcafObjectIterator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_OcafObjectIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_OcafObjectIterator
TObj_OcafObjectIterator_swigregister = _TObj.TObj_OcafObjectIterator_swigregister
TObj_OcafObjectIterator_swigregister(TObj_OcafObjectIterator)

def TObj_OcafObjectIterator_get_type_name(*args):
    """
    TObj_OcafObjectIterator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_OcafObjectIterator_get_type_name(*args)

def TObj_OcafObjectIterator_get_type_descriptor(*args):
    """
    TObj_OcafObjectIterator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_OcafObjectIterator_get_type_descriptor(*args)

class TObj_Object(Standard.Standard_Transient):
    """Basis class for transient objects in OCAF-based models"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_Object
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_Object(self) 
            return h

    Visible = _TObj.TObj_Object_Visible
    ObjectState_Hidden = _TObj.TObj_Object_ObjectState_Hidden
    ObjectState_Saved = _TObj.TObj_Object_ObjectState_Saved
    ObjectState_Imported = _TObj.TObj_Object_ObjectState_Imported
    ObjectState_ImportedByFile = _TObj.TObj_Object_ObjectState_ImportedByFile
    ObjectState_Ordered = _TObj.TObj_Object_ObjectState_Ordered

    def GetModel(self, *args):
        """
        GetModel(TObj_Object self) -> Handle_TObj_Model

        Returns the model to which the object belongs

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_Object_GetModel(self, *args)


    def GetChildren(self, *args):
        """
        GetChildren(TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the child objects.
        This method provides tree-like view of the objects hierarchy.
        The references to other objects are not considered as children.
        theType narrows a variety of iterated objects
        The default implementation search for children on 1 sublavel
        of the children sub label

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.TObj_Object_GetChildren(self, *args)


    def GetChildLabel(self, *args):
        """
        GetChildLabel(TObj_Object self) -> TDF_Label

        Returns the label under which children are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Object_GetChildLabel(self, *args)


    def getChildLabel(self, *args):
        """
        getChildLabel(TObj_Object self, Standard_Integer const theRank) -> TDF_Label

        Returns the label for child with rank

        :type theRank: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Object_getChildLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(TObj_Object self) -> TDF_Label

        Returns the OCAF label on which object`s data are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Object_GetLabel(self, *args)


    def GetDataLabel(self, *args):
        """
        GetDataLabel(TObj_Object self) -> TDF_Label

        Returns the label which is the root for data OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Object_GetDataLabel(self, *args)


    def GetReferenceLabel(self, *args):
        """
        GetReferenceLabel(TObj_Object self) -> TDF_Label

        Returns the label which is the root for reference OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Object_GetReferenceLabel(self, *args)


    def GetDictionary(self, *args):
        """
        GetDictionary(TObj_Object self) -> Handle_TObj_TNameContainer

        Returns the map of names of the objects
        Default implementation returns global Dictionary of the model

        :rtype: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.TObj_Object_GetDictionary(self, *args)


    def GetName(self, *args):
        """
        GetName(TObj_Object self) -> Handle_TCollection_HExtendedString
        GetName(TObj_Object self, TCollection_ExtendedString theName) -> Standard_Boolean
        GetName(TObj_Object self, TCollection_AsciiString theName) -> Standard_Boolean

        Returns the Standard_True is object has name and returns name to theName

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_GetName(self, *args)


    def SetName(self, *args):
        """
        SetName(TObj_Object self, Handle_TCollection_HExtendedString theName) -> Standard_Boolean
        SetName(TObj_Object self, Handle_TCollection_HAsciiString theName) -> Standard_Boolean
        SetName(TObj_Object self, Standard_CString const name) -> Standard_Boolean

        Sets name of the object. Returns False if theName is not unique.

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_SetName(self, *args)


    def GetNameForClone(self, *args):
        """
        GetNameForClone(TObj_Object self, Handle_TObj_Object arg2) -> Handle_TCollection_HExtendedString

        Returns name for copy
        default implementation returns the same name

        :type : OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.TObj_Object_GetNameForClone(self, *args)


    def HasReference(self, *args):
        """
        HasReference(TObj_Object self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if object has reference to indicated object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_HasReference(self, *args)


    def GetReferences(self, *args):
        """
        GetReferences(TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns an Iterator containing objects that compose the this one
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.TObj_Object_GetReferences(self, *args)


    def RemoveAllReferences(self, *args):
        """
        RemoveAllReferences(TObj_Object self)

        Remove all references to other objects, by removing all reference attributes


        """
        return _TObj.TObj_Object_RemoveAllReferences(self, *args)


    def GetBackReferences(self, *args):
        """
        GetBackReferences(TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the objects which depend on this one.
        These reffering objects may belong to other models.
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.TObj_Object_GetBackReferences(self, *args)


    def AddBackReference(self, *args):
        """
        AddBackReference(TObj_Object self, Handle_TObj_Object theObject)

        Registers another object as being dependent on this one.
        Stores back references under sublabel 2 (purely transient data,
        not subject to persistency).

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Object_AddBackReference(self, *args)


    def RemoveBackReference(self, *args):
        """
        RemoveBackReference(TObj_Object self, Handle_TObj_Object theObject, Standard_Boolean const theSingleOnly)

        Removes information on dependent object (back reference).
        If theSingleOnly is true only the first back reference is removed in the 
        case of duplicate items.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theSingleOnly: bool

        """
        return _TObj.TObj_Object_RemoveBackReference(self, *args)


    def RemoveBackReferences(self, *args):
        """
        RemoveBackReferences(TObj_Object self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Removes all back reference by removing references from other to me.

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_RemoveBackReferences(self, *args)


    def ClearBackReferences(self, *args):
        """
        ClearBackReferences(TObj_Object self)

        The default implementation just clear the back references container


        """
        return _TObj.TObj_Object_ClearBackReferences(self, *args)


    def HasBackReferences(self, *args):
        """
        HasBackReferences(TObj_Object self) -> Standard_Boolean

        Returns TRUE if obejct has 1 or more back references

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_HasBackReferences(self, *args)


    def ReplaceReference(self, *args):
        """
        ReplaceReference(TObj_Object self, Handle_TObj_Object theOldObject, Handle_TObj_Object theNewObject)

        Replace reference from old object to new object.
        If it is not possible, may raise exception.
        If new object is null then simple remove reference to old object.

        :type theOldObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theNewObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Object_ReplaceReference(self, *args)


    def GetBadReference(self, *args):
        """
        GetBadReference(TObj_Object self, TDF_Label theRoot, TDF_Label theBadReference) -> Standard_Boolean

        Return True if this refers to the model theRoot belongs
        to and a referred label is not a descendant of theRoot.
        In this case theBadReference returns the currently referred label.

        :type theRoot: OCC.wrapper.TDF.TDF_Label
        :type theBadReference: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_GetBadReference(self, *args)


    def RelocateReferences(self, *args):
        """
        RelocateReferences(TObj_Object self, TDF_Label theFromRoot, TDF_Label theToRoot, Standard_Boolean const theUpdateBackRefs) -> Standard_Boolean

        Make that each reference pointing to a descendant label of
        theFromRoot to point to an equivalent label under theToRoot.
        Return False if a resulting reference does not point to
        an TObj_Object
        Example:
        a referred object label = 0:3:24:7:2:7
        theFromRoot             = 0:3:24
        theToRoot               = 0:2
        a new referred label    = 0:2:7:2:7

        :type theFromRoot: OCC.wrapper.TDF.TDF_Label
        :type theToRoot: OCC.wrapper.TDF.TDF_Label
        :type theUpdateBackRefs: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_RelocateReferences(self, *args)


    def CanRemoveReference(self, *args):
        """
        CanRemoveReference(TObj_Object self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if the referred object theObject can be deleted 
        without deletion of this object.
        Default implementation does nothing and returns False.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_CanRemoveReference(self, *args)


    def RemoveReference(self, *args):
        """
        RemoveReference(TObj_Object self, Handle_TObj_Object theObject)

        Removes reference to the object by replace reference to NULL object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Object_RemoveReference(self, *args)


    def BeforeForgetReference(self, *args):
        """
        BeforeForgetReference(TObj_Object self, TDF_Label arg2)

        Invokes from TObj_TReference::BeforeForget().
        theLabel - label on that reference become removed
        Default implementation is empty

        :type : OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Object_BeforeForgetReference(self, *args)


    def CanDetach(self, *args):
        """
        CanDetach(TObj_Object self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Checks if object can be detached with specified mode

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_CanDetach(self, *args)


    def Detach(*args):
        """
        Detach(TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean
        Detach(TDF_Label theLabel, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Deletes the object from the label. Checks if object can be deleted.
        Finds object on the label and detaches it by calling previos method.
        Returns true if there is no object on the label after detaching

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_Detach(*args)

    Detach = staticmethod(Detach)

    def GetObj(*args):
        """
        GetObj(TDF_Label theLabel, Handle_TObj_Object theResult, Standard_Boolean const isSuper) -> Standard_Boolean

        Returns the Object attached to a given label.
        Returns False if no object of type TObj_Object is stored on the
        specified label.
        If isSuper is true tries to find on the super labels.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theResult: OCC.wrapper.TObj.Handle_TObj_Object
        :type isSuper: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_GetObj(*args)

    GetObj = staticmethod(GetObj)

    def GetFatherObject(self, *args):
        """
        GetFatherObject(TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_Object

        Returns the father object, which may be NULL
        theType gives type of father object to search

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Object_GetFatherObject(self, *args)


    def IsAlive(self, *args):
        """
        IsAlive(TObj_Object self) -> Standard_Boolean

        Checks that object alive in model
        Default implementation checks that object has TObject attribute at own label.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_IsAlive(self, *args)


    def Clone(self, *args):
        """
        Clone(TObj_Object self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable=0) -> Handle_TObj_Object

        Copy me to other label theTargetLabel
        New object will not have all the reference that has me.
        Coping object with data and childs, but change name by adding string "_copy"
        As result return handle of new object (null handle is something wrong)
        NOTE: BackReferences not coping.
        After clonning all objects it is neccessary to call copy references
        with the same relocation table

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Object_Clone(self, *args)


    def CopyReferences(self, *args):
        """
        CopyReferences(TObj_Object self, Handle_TObj_Object theTargetObject, Handle_TDF_RelocationTable theRelocTable)

        Coping the references.
        return Standard_False is Target object is different type

        :type theTargetObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_Object_CopyReferences(self, *args)


    def CopyChildren(self, *args):
        """
        CopyChildren(TObj_Object self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable)

        Coping the children from source label to the target.

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_Object_CopyChildren(self, *args)


    def GetOrder(self, *args):
        """
        GetOrder(TObj_Object self) -> Standard_Integer

        returns order of object (or tag of their label if order is not initialised)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Object_GetOrder(self, *args)


    def SetOrder(self, *args):
        """
        SetOrder(TObj_Object self, Standard_Integer const & theIndx) -> Standard_Boolean

        sets order of object

        :type theIndx: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_SetOrder(self, *args)


    def GetTypeFlags(self, *args):
        """
        GetTypeFlags(TObj_Object self) -> Standard_Integer

        Returns flags (bitmask) that define properties of objects of that type
        By default returns flag Visible

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Object_GetTypeFlags(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(TObj_Object self) -> Standard_Integer

        Returns mask of seted flags

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Object_GetFlags(self, *args)


    def SetFlags(self, *args):
        """
        SetFlags(TObj_Object self, Standard_Integer const theMask)

        Sets flags with defined mask.

        :type theMask: int

        """
        return _TObj.TObj_Object_SetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(TObj_Object self, Standard_Integer const theMask) -> Standard_Boolean

        tests flags by the mask.

        :type theMask: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Object_TestFlags(self, *args)


    def ClearFlags(self, *args):
        """
        ClearFlags(TObj_Object self, Standard_Integer const theMask)

        clears flags by the mask.

        :type theMask: int

        """
        return _TObj.TObj_Object_ClearFlags(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(TObj_Object self)

        Preforms updating the links and dependances of the object which are not
        stored in persistence. Should be redefined if necessary.


        """
        return _TObj.TObj_Object_AfterRetrieval(self, *args)


    def BeforeStoring(self, *args):
        """
        BeforeStoring(TObj_Object self)

        Preforms storing the objects transient fields in OCAF document
        which were outside transaction mechanism.
        Default implementation doesnot nothing


        """
        return _TObj.TObj_Object_BeforeStoring(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_Object_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_Object_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_Object_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_Object
TObj_Object_swigregister = _TObj.TObj_Object_swigregister
TObj_Object_swigregister(TObj_Object)

def TObj_Object_Detach(*args):
    """
    Detach(TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean
    TObj_Object_Detach(TDF_Label theLabel, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

    Deletes the object from the label. Checks if object can be deleted.
    Finds object on the label and detaches it by calling previos method.
    Returns true if there is no object on the label after detaching

    :type theLabel: OCC.wrapper.TDF.TDF_Label
    :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TObj.TObj_Object_Detach(*args)

def TObj_Object_GetObj(*args):
    """
    TObj_Object_GetObj(TDF_Label theLabel, Handle_TObj_Object theResult, Standard_Boolean const isSuper) -> Standard_Boolean

    Returns the Object attached to a given label.
    Returns False if no object of type TObj_Object is stored on the
    specified label.
    If isSuper is true tries to find on the super labels.

    :type theLabel: OCC.wrapper.TDF.TDF_Label
    :type theResult: OCC.wrapper.TObj.Handle_TObj_Object
    :type isSuper: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TObj.TObj_Object_GetObj(*args)

def TObj_Object_get_type_name(*args):
    """
    TObj_Object_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_Object_get_type_name(*args)

def TObj_Object_get_type_descriptor(*args):
    """
    TObj_Object_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_Object_get_type_descriptor(*args)

class TObj_Partition(TObj_Object):
    """
    This class privides tool handling one of partitions (the set of
    homogenious elements) in the OCAF based model`s data structure
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_Partition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_Partition(self) 
            return h


    def Create(*args):
        """
        Create(TDF_Label theLabel) -> Handle_TObj_Partition

        Creates a new partition on given label.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.TObj_Partition_Create(*args)

    Create = staticmethod(Create)

    def SetName(self, *args):
        """
        SetName(TObj_Partition self, Handle_TCollection_HExtendedString theName) -> Standard_Boolean

        Sets name of the object. partition does not check unique of own name

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Partition_SetName(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(TObj_Partition self)

        Preforms updating the links and dependances of the object which are not
        stored in persistence. Does not register the partition name


        """
        return _TObj.TObj_Partition_AfterRetrieval(self, *args)


    def NewLabel(self, *args):
        """
        NewLabel(TObj_Partition self) -> TDF_Label

        Creates and Returns label for new object in partition.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_Partition_NewLabel(self, *args)


    def SetNamePrefix(self, *args):
        """
        SetNamePrefix(TObj_Partition self, Handle_TCollection_HExtendedString thePrefix)

        Sets prefix for names of the objects in partition.

        :type thePrefix: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.TObj_Partition_SetNamePrefix(self, *args)


    def GetNamePrefix(self, *args):
        """
        GetNamePrefix(TObj_Partition self) -> Handle_TCollection_HExtendedString

        Returns prefix for names of the objects in partition.

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.TObj_Partition_GetNamePrefix(self, *args)


    def GetNewName(self, *args):
        """
        GetNewName(TObj_Partition self, Standard_Boolean const theIsToChangeCount) -> Handle_TCollection_HExtendedString

        Generates and returns name for new object in partition.
        if theIsToChangeCount is true partition icrease own counter
        to generate new name next time starting from new counter value

        :type theIsToChangeCount: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.TObj_Partition_GetNewName(self, *args)


    def GetLastIndex(self, *args):
        """
        GetLastIndex(TObj_Partition self) -> Standard_Integer

        Return Last index in partition (reserved);

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Partition_GetLastIndex(self, *args)


    def SetLastIndex(self, *args):
        """
        SetLastIndex(TObj_Partition self, Standard_Integer const theIndex)

        Sets Last index in partition (reserved);

        :type theIndex: int

        """
        return _TObj.TObj_Partition_SetLastIndex(self, *args)


    def GetPartition(*args):
        """
        GetPartition(Handle_TObj_Object theObject) -> Handle_TObj_Partition

        Returns the partition in which object is stored. Null partition
        returned if not found

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.TObj_Partition_GetPartition(*args)

    GetPartition = staticmethod(GetPartition)

    def Update(self, *args):
        """
        Update(TObj_Partition self) -> Standard_Boolean

        Does nothing in the partition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Partition_Update(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_Partition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_Partition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_Partition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_Partition
TObj_Partition_swigregister = _TObj.TObj_Partition_swigregister
TObj_Partition_swigregister(TObj_Partition)

def TObj_Partition_Create(*args):
    """
    TObj_Partition_Create(TDF_Label theLabel) -> Handle_TObj_Partition

    Creates a new partition on given label.

    :type theLabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

    """
    return _TObj.TObj_Partition_Create(*args)

def TObj_Partition_GetPartition(*args):
    """
    TObj_Partition_GetPartition(Handle_TObj_Object theObject) -> Handle_TObj_Partition

    Returns the partition in which object is stored. Null partition
    returned if not found

    :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
    :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

    """
    return _TObj.TObj_Partition_GetPartition(*args)

def TObj_Partition_get_type_name(*args):
    """
    TObj_Partition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_Partition_get_type_name(*args)

def TObj_Partition_get_type_descriptor(*args):
    """
    TObj_Partition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_Partition_get_type_descriptor(*args)

class TObj_ModelIterator(TObj_ObjectIterator):
    """This class provides an iterator by all objects in the model."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_ModelIterator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_ModelIterator(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_ModelIterator self, Handle_TObj_Model theModel) -> TObj_ModelIterator

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

        """
        this = _TObj.new_TObj_ModelIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def More(self, *args):
        """
        More(TObj_ModelIterator self) -> Standard_Boolean

        Returns True if iteration is not finished and method Value()
        will give the object

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_ModelIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TObj_ModelIterator self)

        Iterates to the next object


        """
        return _TObj.TObj_ModelIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(TObj_ModelIterator self) -> Handle_TObj_Object

        Returns current object (or MainObj of Model if iteration has finished)

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_ModelIterator_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_ModelIterator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_ModelIterator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_ModelIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_ModelIterator
TObj_ModelIterator_swigregister = _TObj.TObj_ModelIterator_swigregister
TObj_ModelIterator_swigregister(TObj_ModelIterator)

def TObj_ModelIterator_get_type_name(*args):
    """
    TObj_ModelIterator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_ModelIterator_get_type_name(*args)

def TObj_ModelIterator_get_type_descriptor(*args):
    """
    TObj_ModelIterator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_ModelIterator_get_type_descriptor(*args)

class NCollection_Sequence_Handle_TObj_ObjectIterator(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> NCollection_Sequence< opencascade::handle< TObj_ObjectIterator > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> NCollection_Sequence< opencascade::handle< TObj_ObjectIterator > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> NCollection_Sequence< opencascade::handle< TObj_ObjectIterator > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> NCollection_Sequence< opencascade::handle< TObj_ObjectIterator > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TObj.new_NCollection_Sequence_Handle_TObj_ObjectIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TObj_ObjectIterator self)

        Reverse sequence


        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TObj_ObjectIterator self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TObj_ObjectIterator self, NCollection_Sequence_Handle_TObj_ObjectIterator theOther) -> NCollection_Sequence_Handle_TObj_ObjectIterator

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TObj_ObjectIterator self, NCollection_Sequence_Handle_TObj_ObjectIterator theOther) -> NCollection_Sequence_Handle_TObj_ObjectIterator

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TObj_ObjectIterator self, NCollection_Sequence< opencascade::handle< TObj_ObjectIterator > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TObj_ObjectIterator self, Handle_TObj_ObjectIterator theItem)
        Append(NCollection_Sequence_Handle_TObj_ObjectIterator self, NCollection_Sequence_Handle_TObj_ObjectIterator theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TObj_ObjectIterator self, Handle_TObj_ObjectIterator theItem)
        Prepend(NCollection_Sequence_Handle_TObj_ObjectIterator self, NCollection_Sequence_Handle_TObj_ObjectIterator theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex, Handle_TObj_ObjectIterator theItem)
        InsertBefore(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TObj_ObjectIterator theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TObj_ObjectIterator self, NCollection_Sequence< opencascade::handle< TObj_ObjectIterator > >::Iterator & thePosition, Handle_TObj_ObjectIterator theItem)
        InsertAfter(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TObj_ObjectIterator theSeq)
        InsertAfter(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex, Handle_TObj_ObjectIterator theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TObj_ObjectIterator theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> Handle_TObj_ObjectIterator

        First item access

        :rtype: TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TObj_ObjectIterator self) -> Handle_TObj_ObjectIterator

        Last item access

        :rtype: TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex) -> Handle_TObj_ObjectIterator

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TObj_ObjectIterator self, Standard_Integer const theIndex, Handle_TObj_ObjectIterator theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_SetValue(self, *args)


    def __iter__(self):
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator___iter__(self)
    __swig_destroy__ = _TObj.delete_NCollection_Sequence_Handle_TObj_ObjectIterator
NCollection_Sequence_Handle_TObj_ObjectIterator_swigregister = _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_swigregister
NCollection_Sequence_Handle_TObj_ObjectIterator_swigregister(NCollection_Sequence_Handle_TObj_ObjectIterator)

def NCollection_Sequence_Handle_TObj_ObjectIterator_delNode(*args):
    """
    NCollection_Sequence_Handle_TObj_ObjectIterator_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_delNode(*args)

class NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TObj.new_NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TObj.delete_NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper

    def __next__(self):
        return _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper_swigregister = _TObj.NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper_swigregister
NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper_swigregister(NCollection_Sequence_Handle_TObj_ObjectIterator_IteratorHelper)


try:
	TObj_SequenceOfIterator = NCollection_Sequence_Handle_TObj_ObjectIterator
except NameError:
	pass # does not exist, probably ignored

class Handle_TObj_Partition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_Partition self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_Partition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_Partition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_Partition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_Partition self, TObj_Partition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_Partition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_Partition self, Handle_TObj_Partition theHandle) -> Handle_TObj_Partition
        assign(Handle_TObj_Partition self, TObj_Partition thePtr) -> Handle_TObj_Partition
        assign(Handle_TObj_Partition self, Handle_TObj_Partition theHandle) -> Handle_TObj_Partition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_Partition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_Partition self) -> TObj_Partition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_Partition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_Partition self) -> TObj_Partition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_Partition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_Partition self) -> TObj_Partition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_Partition___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_Partition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_Partition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_Partition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_Partition_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_Partition

    def Create(self, *args):
        """
        Create(Handle_TObj_Partition self, TDF_Label theLabel) -> Handle_TObj_Partition

        Creates a new partition on given label.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.Handle_TObj_Partition_Create(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_TObj_Partition self, Handle_TCollection_HExtendedString theName) -> Standard_Boolean

        Sets name of the object. partition does not check unique of own name

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_SetName(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_Partition self)

        Preforms updating the links and dependances of the object which are not
        stored in persistence. Does not register the partition name


        """
        return _TObj.Handle_TObj_Partition_AfterRetrieval(self, *args)


    def NewLabel(self, *args):
        """
        NewLabel(Handle_TObj_Partition self) -> TDF_Label

        Creates and Returns label for new object in partition.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Partition_NewLabel(self, *args)


    def SetNamePrefix(self, *args):
        """
        SetNamePrefix(Handle_TObj_Partition self, Handle_TCollection_HExtendedString thePrefix)

        Sets prefix for names of the objects in partition.

        :type thePrefix: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_Partition_SetNamePrefix(self, *args)


    def GetNamePrefix(self, *args):
        """
        GetNamePrefix(Handle_TObj_Partition self) -> Handle_TCollection_HExtendedString

        Returns prefix for names of the objects in partition.

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_Partition_GetNamePrefix(self, *args)


    def GetNewName(self, *args):
        """
        GetNewName(Handle_TObj_Partition self, Standard_Boolean const theIsToChangeCount) -> Handle_TCollection_HExtendedString

        Generates and returns name for new object in partition.
        if theIsToChangeCount is true partition icrease own counter
        to generate new name next time starting from new counter value

        :type theIsToChangeCount: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_Partition_GetNewName(self, *args)


    def GetLastIndex(self, *args):
        """
        GetLastIndex(Handle_TObj_Partition self) -> Standard_Integer

        Return Last index in partition (reserved);

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Partition_GetLastIndex(self, *args)


    def SetLastIndex(self, *args):
        """
        SetLastIndex(Handle_TObj_Partition self, Standard_Integer const theIndex)

        Sets Last index in partition (reserved);

        :type theIndex: int

        """
        return _TObj.Handle_TObj_Partition_SetLastIndex(self, *args)


    def GetPartition(self, *args):
        """
        GetPartition(Handle_TObj_Partition self, Handle_TObj_Object theObject) -> Handle_TObj_Partition

        Returns the partition in which object is stored. Null partition
        returned if not found

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.Handle_TObj_Partition_GetPartition(self, *args)


    def Update(self, *args):
        """
        Update(Handle_TObj_Partition self) -> Standard_Boolean

        Does nothing in the partition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_Update(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_Partition self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_Partition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Partition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Partition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModel(self, *args):
        """
        GetModel(Handle_TObj_Partition self) -> Handle_TObj_Model

        Returns the model to which the object belongs

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.Handle_TObj_Partition_GetModel(self, *args)


    def GetChildren(self, *args):
        """
        GetChildren(Handle_TObj_Partition self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the child objects.
        This method provides tree-like view of the objects hierarchy.
        The references to other objects are not considered as children.
        theType narrows a variety of iterated objects
        The default implementation search for children on 1 sublavel
        of the children sub label

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Partition_GetChildren(self, *args)


    def GetChildLabel(self, *args):
        """
        GetChildLabel(Handle_TObj_Partition self) -> TDF_Label

        Returns the label under which children are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Partition_GetChildLabel(self, *args)


    def getChildLabel(self, *args):
        """
        getChildLabel(Handle_TObj_Partition self, Standard_Integer const theRank) -> TDF_Label

        Returns the label for child with rank

        :type theRank: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Partition_getChildLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_TObj_Partition self) -> TDF_Label

        Returns the OCAF label on which object`s data are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Partition_GetLabel(self, *args)


    def GetDataLabel(self, *args):
        """
        GetDataLabel(Handle_TObj_Partition self) -> TDF_Label

        Returns the label which is the root for data OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Partition_GetDataLabel(self, *args)


    def GetReferenceLabel(self, *args):
        """
        GetReferenceLabel(Handle_TObj_Partition self) -> TDF_Label

        Returns the label which is the root for reference OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Partition_GetReferenceLabel(self, *args)


    def GetDictionary(self, *args):
        """
        GetDictionary(Handle_TObj_Partition self) -> Handle_TObj_TNameContainer

        Returns the map of names of the objects
        Default implementation returns global Dictionary of the model

        :rtype: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.Handle_TObj_Partition_GetDictionary(self, *args)


    def GetName(self, *args):
        """
        GetName(Handle_TObj_Partition self) -> Handle_TCollection_HExtendedString
        GetName(Handle_TObj_Partition self, TCollection_ExtendedString theName) -> Standard_Boolean
        GetName(Handle_TObj_Partition self, TCollection_AsciiString theName) -> Standard_Boolean

        Returns the Standard_True is object has name and returns name to theName

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_GetName(self, *args)


    def GetNameForClone(self, *args):
        """
        GetNameForClone(Handle_TObj_Partition self, Handle_TObj_Object arg2) -> Handle_TCollection_HExtendedString

        Returns name for copy
        default implementation returns the same name

        :type : OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_Partition_GetNameForClone(self, *args)


    def HasReference(self, *args):
        """
        HasReference(Handle_TObj_Partition self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if object has reference to indicated object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_HasReference(self, *args)


    def GetReferences(self, *args):
        """
        GetReferences(Handle_TObj_Partition self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns an Iterator containing objects that compose the this one
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Partition_GetReferences(self, *args)


    def RemoveAllReferences(self, *args):
        """
        RemoveAllReferences(Handle_TObj_Partition self)

        Remove all references to other objects, by removing all reference attributes


        """
        return _TObj.Handle_TObj_Partition_RemoveAllReferences(self, *args)


    def GetBackReferences(self, *args):
        """
        GetBackReferences(Handle_TObj_Partition self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the objects which depend on this one.
        These reffering objects may belong to other models.
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Partition_GetBackReferences(self, *args)


    def AddBackReference(self, *args):
        """
        AddBackReference(Handle_TObj_Partition self, Handle_TObj_Object theObject)

        Registers another object as being dependent on this one.
        Stores back references under sublabel 2 (purely transient data,
        not subject to persistency).

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Partition_AddBackReference(self, *args)


    def RemoveBackReference(self, *args):
        """
        RemoveBackReference(Handle_TObj_Partition self, Handle_TObj_Object theObject, Standard_Boolean const theSingleOnly)

        Removes information on dependent object (back reference).
        If theSingleOnly is true only the first back reference is removed in the 
        case of duplicate items.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theSingleOnly: bool

        """
        return _TObj.Handle_TObj_Partition_RemoveBackReference(self, *args)


    def RemoveBackReferences(self, *args):
        """
        RemoveBackReferences(Handle_TObj_Partition self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Removes all back reference by removing references from other to me.

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_RemoveBackReferences(self, *args)


    def ClearBackReferences(self, *args):
        """
        ClearBackReferences(Handle_TObj_Partition self)

        The default implementation just clear the back references container


        """
        return _TObj.Handle_TObj_Partition_ClearBackReferences(self, *args)


    def HasBackReferences(self, *args):
        """
        HasBackReferences(Handle_TObj_Partition self) -> Standard_Boolean

        Returns TRUE if obejct has 1 or more back references

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_HasBackReferences(self, *args)


    def ReplaceReference(self, *args):
        """
        ReplaceReference(Handle_TObj_Partition self, Handle_TObj_Object theOldObject, Handle_TObj_Object theNewObject)

        Replace reference from old object to new object.
        If it is not possible, may raise exception.
        If new object is null then simple remove reference to old object.

        :type theOldObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theNewObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Partition_ReplaceReference(self, *args)


    def GetBadReference(self, *args):
        """
        GetBadReference(Handle_TObj_Partition self, TDF_Label theRoot, TDF_Label theBadReference) -> Standard_Boolean

        Return True if this refers to the model theRoot belongs
        to and a referred label is not a descendant of theRoot.
        In this case theBadReference returns the currently referred label.

        :type theRoot: OCC.wrapper.TDF.TDF_Label
        :type theBadReference: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_GetBadReference(self, *args)


    def RelocateReferences(self, *args):
        """
        RelocateReferences(Handle_TObj_Partition self, TDF_Label theFromRoot, TDF_Label theToRoot, Standard_Boolean const theUpdateBackRefs) -> Standard_Boolean

        Make that each reference pointing to a descendant label of
        theFromRoot to point to an equivalent label under theToRoot.
        Return False if a resulting reference does not point to
        an TObj_Object
        Example:
        a referred object label = 0:3:24:7:2:7
        theFromRoot             = 0:3:24
        theToRoot               = 0:2
        a new referred label    = 0:2:7:2:7

        :type theFromRoot: OCC.wrapper.TDF.TDF_Label
        :type theToRoot: OCC.wrapper.TDF.TDF_Label
        :type theUpdateBackRefs: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_RelocateReferences(self, *args)


    def CanRemoveReference(self, *args):
        """
        CanRemoveReference(Handle_TObj_Partition self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if the referred object theObject can be deleted 
        without deletion of this object.
        Default implementation does nothing and returns False.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_CanRemoveReference(self, *args)


    def RemoveReference(self, *args):
        """
        RemoveReference(Handle_TObj_Partition self, Handle_TObj_Object theObject)

        Removes reference to the object by replace reference to NULL object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Partition_RemoveReference(self, *args)


    def BeforeForgetReference(self, *args):
        """
        BeforeForgetReference(Handle_TObj_Partition self, TDF_Label arg2)

        Invokes from TObj_TReference::BeforeForget().
        theLabel - label on that reference become removed
        Default implementation is empty

        :type : OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Partition_BeforeForgetReference(self, *args)


    def CanDetach(self, *args):
        """
        CanDetach(Handle_TObj_Partition self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Checks if object can be detached with specified mode

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_CanDetach(self, *args)


    def Detach(self, *args):
        """
        Detach(Handle_TObj_Partition self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean
        Detach(Handle_TObj_Partition self, TDF_Label theLabel, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Deletes the object from the label. Checks if object can be deleted.
        Finds object on the label and detaches it by calling previos method.
        Returns true if there is no object on the label after detaching

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_Detach(self, *args)


    def GetObj(self, *args):
        """
        GetObj(Handle_TObj_Partition self, TDF_Label theLabel, Handle_TObj_Object theResult, Standard_Boolean const isSuper) -> Standard_Boolean

        Returns the Object attached to a given label.
        Returns False if no object of type TObj_Object is stored on the
        specified label.
        If isSuper is true tries to find on the super labels.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theResult: OCC.wrapper.TObj.Handle_TObj_Object
        :type isSuper: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_GetObj(self, *args)


    def GetFatherObject(self, *args):
        """
        GetFatherObject(Handle_TObj_Partition self, Handle_Standard_Type theType=0) -> Handle_TObj_Object

        Returns the father object, which may be NULL
        theType gives type of father object to search

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Partition_GetFatherObject(self, *args)


    def IsAlive(self, *args):
        """
        IsAlive(Handle_TObj_Partition self) -> Standard_Boolean

        Checks that object alive in model
        Default implementation checks that object has TObject attribute at own label.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_IsAlive(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_TObj_Partition self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable=0) -> Handle_TObj_Object

        Copy me to other label theTargetLabel
        New object will not have all the reference that has me.
        Coping object with data and childs, but change name by adding string "_copy"
        As result return handle of new object (null handle is something wrong)
        NOTE: BackReferences not coping.
        After clonning all objects it is neccessary to call copy references
        with the same relocation table

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Partition_Clone(self, *args)


    def CopyReferences(self, *args):
        """
        CopyReferences(Handle_TObj_Partition self, Handle_TObj_Object theTargetObject, Handle_TDF_RelocationTable theRelocTable)

        Coping the references.
        return Standard_False is Target object is different type

        :type theTargetObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_Partition_CopyReferences(self, *args)


    def CopyChildren(self, *args):
        """
        CopyChildren(Handle_TObj_Partition self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable)

        Coping the children from source label to the target.

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_Partition_CopyChildren(self, *args)


    def GetOrder(self, *args):
        """
        GetOrder(Handle_TObj_Partition self) -> Standard_Integer

        returns order of object (or tag of their label if order is not initialised)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Partition_GetOrder(self, *args)


    def SetOrder(self, *args):
        """
        SetOrder(Handle_TObj_Partition self, Standard_Integer const & theIndx) -> Standard_Boolean

        sets order of object

        :type theIndx: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_SetOrder(self, *args)


    def GetTypeFlags(self, *args):
        """
        GetTypeFlags(Handle_TObj_Partition self) -> Standard_Integer

        Returns flags (bitmask) that define properties of objects of that type
        By default returns flag Visible

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Partition_GetTypeFlags(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_TObj_Partition self) -> Standard_Integer

        Returns mask of seted flags

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Partition_GetFlags(self, *args)


    def SetFlags(self, *args):
        """
        SetFlags(Handle_TObj_Partition self, Standard_Integer const theMask)

        Sets flags with defined mask.

        :type theMask: int

        """
        return _TObj.Handle_TObj_Partition_SetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_TObj_Partition self, Standard_Integer const theMask) -> Standard_Boolean

        tests flags by the mask.

        :type theMask: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_TestFlags(self, *args)


    def ClearFlags(self, *args):
        """
        ClearFlags(Handle_TObj_Partition self, Standard_Integer const theMask)

        clears flags by the mask.

        :type theMask: int

        """
        return _TObj.Handle_TObj_Partition_ClearFlags(self, *args)


    def BeforeStoring(self, *args):
        """
        BeforeStoring(Handle_TObj_Partition self)

        Preforms storing the objects transient fields in OCAF document
        which were outside transaction mechanism.
        Default implementation doesnot nothing


        """
        return _TObj.Handle_TObj_Partition_BeforeStoring(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_Partition self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_Partition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_Partition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_Partition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_Partition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_Partition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Partition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_Partition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_Partition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_Partition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Partition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_Partition self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_Partition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_Partition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Partition_DecrementRefCounter(self, *args)

Handle_TObj_Partition_swigregister = _TObj.Handle_TObj_Partition_swigregister
Handle_TObj_Partition_swigregister(Handle_TObj_Partition)

def Handle_TObj_Partition_DownCast(thing):
    return _TObj.Handle_TObj_Partition_DownCast(thing)
Handle_TObj_Partition_DownCast = _TObj.Handle_TObj_Partition_DownCast

class TObj_HiddenPartition(TObj_Partition):
    """This class is partition is predefined hidden flag"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_HiddenPartition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_HiddenPartition(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_HiddenPartition self, TDF_Label theLabel) -> TObj_HiddenPartition

        constructor

        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        this = _TObj.new_TObj_HiddenPartition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetTypeFlags(self, *args):
        """
        GetTypeFlags(TObj_HiddenPartition self) -> Standard_Integer

        Returns all flags of father except Visible

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_HiddenPartition_GetTypeFlags(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_HiddenPartition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_HiddenPartition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_HiddenPartition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_HiddenPartition
TObj_HiddenPartition_swigregister = _TObj.TObj_HiddenPartition_swigregister
TObj_HiddenPartition_swigregister(TObj_HiddenPartition)

def TObj_HiddenPartition_get_type_name(*args):
    """
    TObj_HiddenPartition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_HiddenPartition_get_type_name(*args)

def TObj_HiddenPartition_get_type_descriptor(*args):
    """
    TObj_HiddenPartition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_HiddenPartition_get_type_descriptor(*args)

class Handle_TObj_LabelIterator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_LabelIterator self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_LabelIterator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_LabelIterator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_LabelIterator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_LabelIterator self, TObj_LabelIterator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_LabelIterator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_LabelIterator self, Handle_TObj_LabelIterator theHandle) -> Handle_TObj_LabelIterator
        assign(Handle_TObj_LabelIterator self, TObj_LabelIterator thePtr) -> Handle_TObj_LabelIterator
        assign(Handle_TObj_LabelIterator self, Handle_TObj_LabelIterator theHandle) -> Handle_TObj_LabelIterator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_LabelIterator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_LabelIterator self) -> TObj_LabelIterator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_LabelIterator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_LabelIterator self) -> TObj_LabelIterator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_LabelIterator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_LabelIterator self) -> TObj_LabelIterator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_LabelIterator___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_LabelIterator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_LabelIterator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_LabelIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_LabelIterator_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_LabelIterator

    def More(self, *args):
        """
        More(Handle_TObj_LabelIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_LabelIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_TObj_LabelIterator self)

        Move to the next Item


        """
        return _TObj.Handle_TObj_LabelIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TObj_LabelIterator self) -> Handle_TObj_Object

        Returns the current item

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_LabelIterator_Value(self, *args)


    def LabelValue(self, *args):
        """
        Returns the label of the current item

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TObj.Handle_TObj_LabelIterator_LabelValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_LabelIterator self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_LabelIterator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_LabelIterator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_LabelIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_LabelIterator self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_LabelIterator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_LabelIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_LabelIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_LabelIterator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_LabelIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_LabelIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_LabelIterator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_LabelIterator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_LabelIterator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_LabelIterator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_LabelIterator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_LabelIterator self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_LabelIterator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_LabelIterator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_LabelIterator_DecrementRefCounter(self, *args)

Handle_TObj_LabelIterator_swigregister = _TObj.Handle_TObj_LabelIterator_swigregister
Handle_TObj_LabelIterator_swigregister(Handle_TObj_LabelIterator)

def Handle_TObj_LabelIterator_DownCast(thing):
    return _TObj.Handle_TObj_LabelIterator_DownCast(thing)
Handle_TObj_LabelIterator_DownCast = _TObj.Handle_TObj_LabelIterator_DownCast

class TObj_Application(TDocStd.TDocStd_Application):
    """
    This is a base class for OCAF based TObj models
    with declared virtual methods

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_Application
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_Application(self) 
            return h


    def GetInstance(*args):
        """
        GetInstance() -> Handle_TObj_Application

        Returns static instance of the application

        :rtype: OCC.wrapper.TObj.Handle_TObj_Application

        """
        return _TObj.TObj_Application_GetInstance(*args)

    GetInstance = staticmethod(GetInstance)

    def Messenger(self, *args):
        """
        Messenger(TObj_Application self) -> Handle_Message_Messenger

        Returns reference to associated messenger handle

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.TObj_Application_Messenger(self, *args)


    def SaveDocument(self, *args):
        """
        SaveDocument(TObj_Application self, Handle_TDocStd_Document theSourceDoc, TCollection_ExtendedString theTargetFile) -> Standard_Boolean

        Saving the OCAF document to a file

        :type theSourceDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theTargetFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Application_SaveDocument(self, *args)


    def LoadDocument(self, *args):
        """
        LoadDocument(TObj_Application self, TCollection_ExtendedString theSourceFile, Handle_TDocStd_Document theTargetDoc) -> Standard_Boolean

        Loading the OCAF document from a file

        :type theSourceFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theTargetDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Application_LoadDocument(self, *args)


    def CreateNewDocument(self, *args):
        """
        CreateNewDocument(TObj_Application self, Handle_TDocStd_Document theDoc, TCollection_ExtendedString theFormat) -> Standard_Boolean

        Create the OCAF document from scratch

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Application_CreateNewDocument(self, *args)


    def ErrorMessage(self, *args):
        """
        ErrorMessage(TObj_Application self, TCollection_ExtendedString theMsg, Message_Gravity const theLevel)
        ErrorMessage(TObj_Application self, TCollection_ExtendedString theMsg)

        Signal error during Load or Save
        Default imiplementation invoke previous declaration with 0

        :type theMsg: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TObj.TObj_Application_ErrorMessage(self, *args)


    def SetVerbose(self, *args):
        """
        SetVerbose(TObj_Application self, Standard_Boolean const isVerbose)

        Sets the verbose flag, meaning that load/save models should show
        CPU and elapsed times

        :type isVerbose: bool

        """
        return _TObj.TObj_Application_SetVerbose(self, *args)


    def IsVerbose(self, *args):
        """
        IsVerbose(TObj_Application self) -> Standard_Boolean

        Returns the verbose flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_Application_IsVerbose(self, *args)


    def ResourcesName(self, *args):
        """
        ResourcesName(TObj_Application self) -> Standard_CString

        Return name of resource (i.e. "TObj")

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _TObj.TObj_Application_ResourcesName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_Application_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_Application_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_Application
TObj_Application_swigregister = _TObj.TObj_Application_swigregister
TObj_Application_swigregister(TObj_Application)

def TObj_Application_GetInstance(*args):
    """
    TObj_Application_GetInstance() -> Handle_TObj_Application

    Returns static instance of the application

    :rtype: OCC.wrapper.TObj.Handle_TObj_Application

    """
    return _TObj.TObj_Application_GetInstance(*args)

def TObj_Application_get_type_name(*args):
    """
    TObj_Application_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_Application_get_type_name(*args)

def TObj_Application_get_type_descriptor(*args):
    """
    TObj_Application_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_Application_get_type_descriptor(*args)

class TObj_TIntSparseArray(TDF.TDF_Attribute):
    """
    OCAF Attribute to store a set of positive integer values in the OCAF tree.
    Each value is identified by ID (positive integer).
    The supporting underlying data structure is NCollection_SparseArray of integers.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_TIntSparseArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_TIntSparseArray(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_TIntSparseArray self) -> TObj_TIntSparseArray

        Empty constructor


        """
        this = _TObj.new_TObj_TIntSparseArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetID(*args):
        """
        GetID() -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.TObj_TIntSparseArray_GetID(*args)

    GetID = staticmethod(GetID)

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.TObj_TIntSparseArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(*args):
        """
        Set(TDF_Label theLabel) -> Handle_TObj_TIntSparseArray

        Creates TObj_TIntSparseArray attribute on given label.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_TIntSparseArray

        """
        return _TObj.TObj_TIntSparseArray_Set(*args)

    Set = staticmethod(Set)

    def Size(self, *args):
        """
        Size(TObj_TIntSparseArray self) -> Standard_Size

        Returns the number of stored values in the set

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _TObj.TObj_TIntSparseArray_Size(self, *args)


    def HasValue(self, *args):
        """
        HasValue(TObj_TIntSparseArray self, Standard_Size const theId) -> Standard_Boolean

        Returns true if the value with the given ID is present.

        :type theId: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_TIntSparseArray_HasValue(self, *args)


    def Value(self, *args):
        """
        Value(TObj_TIntSparseArray self, Standard_Size const theId) -> Standard_Integer

        Returns the value by its ID.
        Raises an exception if no value is stored with this ID

        :type theId: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_TIntSparseArray_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TObj_TIntSparseArray self, Standard_Size const theId, Standard_Integer const theValue)

        Sets the value with the given ID.
        Raises an exception if theId is not positive

        :type theId: int
        :type theValue: int

        """
        return _TObj.TObj_TIntSparseArray_SetValue(self, *args)


    def UnsetValue(self, *args):
        """
        UnsetValue(TObj_TIntSparseArray self, Standard_Size const theId)

        Unsets the value with the given ID.
        Raises an exception if theId is not positive

        :type theId: int

        """
        return _TObj.TObj_TIntSparseArray_UnsetValue(self, *args)


    def Clear(self, *args):
        """
        Clear(TObj_TIntSparseArray self)

        Clears the set


        """
        return _TObj.TObj_TIntSparseArray_Clear(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TObj_TIntSparseArray self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TIntSparseArray attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TIntSparseArray_NewEmpty(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(TObj_TIntSparseArray self) -> Handle_TDF_Attribute

        Moves this delta into a new other attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TIntSparseArray_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(TObj_TIntSparseArray self, Handle_TDF_Attribute theDelta)

        Restores the set using info saved in backup attribute theDelta.

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TIntSparseArray_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TObj_TIntSparseArray self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_TIntSparseArray_Paste(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(TObj_TIntSparseArray self)

        It is called just before Commit or Abort transaction
        and does Backup() to create a delta


        """
        return _TObj.TObj_TIntSparseArray_BeforeCommitTransaction(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TObj_TIntSparseArray self, Handle_TDF_AttributeDelta theDelta, Standard_Boolean const toForce) -> Standard_Boolean

        Clears my modification delta; called after application of theDelta

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type toForce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_TIntSparseArray_AfterUndo(self, *args)


    def SetDoBackup(self, *args):
        """
        SetDoBackup(TObj_TIntSparseArray self, Standard_Boolean const toDo)

        Sets the flag pointing to the necessity to maintain a modification delta.
        It is called by the retrieval driver

        :type toDo: bool

        """
        return _TObj.TObj_TIntSparseArray_SetDoBackup(self, *args)


    def ClearDelta(self, *args):
        """ClearDelta(TObj_TIntSparseArray self)"""
        return _TObj.TObj_TIntSparseArray_ClearDelta(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_TIntSparseArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_TIntSparseArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_TIntSparseArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def getIterator(self):
        return _TObj.TObj_TIntSparseArray_getIterator(self)
    __swig_destroy__ = _TObj.delete_TObj_TIntSparseArray
TObj_TIntSparseArray_swigregister = _TObj.TObj_TIntSparseArray_swigregister
TObj_TIntSparseArray_swigregister(TObj_TIntSparseArray)

def TObj_TIntSparseArray_GetID(*args):
    """
    TObj_TIntSparseArray_GetID() -> Standard_GUID

    This method is used in implementation of ID()

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TObj.TObj_TIntSparseArray_GetID(*args)

def TObj_TIntSparseArray_Set(*args):
    """
    TObj_TIntSparseArray_Set(TDF_Label theLabel) -> Handle_TObj_TIntSparseArray

    Creates TObj_TIntSparseArray attribute on given label.

    :type theLabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TObj.Handle_TObj_TIntSparseArray

    """
    return _TObj.TObj_TIntSparseArray_Set(*args)

def TObj_TIntSparseArray_get_type_name(*args):
    """
    TObj_TIntSparseArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_TIntSparseArray_get_type_name(*args)

def TObj_TIntSparseArray_get_type_descriptor(*args):
    """
    TObj_TIntSparseArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_TIntSparseArray_get_type_descriptor(*args)

class TObj_TReference(TDF.TDF_Attribute):
    """
    Attribute for storing references to the objects which implement
    TObj_Object interface in the OCAF tree.
    Its persistency mechanism provides transparent method for storing
    cross-model references.
    Each reference, when created, registers itself in the referred object,
    to support back references
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_TReference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_TReference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_TReference self) -> TObj_TReference

        Empty constructor


        """
        this = _TObj.new_TObj_TReference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetID(*args):
        """
        GetID() -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.TObj_TReference_GetID(*args)

    GetID = staticmethod(GetID)

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.TObj_TReference_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(TObj_TReference self, TDF_Label theLabel, Handle_TObj_Object theObject, Handle_TObj_Object theMaster) -> Handle_TObj_TReference
        Set(TObj_TReference self, Handle_TObj_Object theObject, TDF_Label theMasterLabel)
        Set(TObj_TReference self, TDF_Label theLabel, TDF_Label theMasterLabel)

        Sets the reference to the theObject at indicated Label.
        It is method for persistent only. Don`t use anywhere else.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theMasterLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_TReference_Set(self, *args)


    def Get(self, *args):
        """
        Get(TObj_TReference self) -> Handle_TObj_Object

        Returns the referenced theObject

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_TReference_Get(self, *args)


    def GetMasterLabel(self, *args):
        """
        GetMasterLabel(TObj_TReference self) -> TDF_Label

        Returns the Label of master object.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_TReference_GetMasterLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(TObj_TReference self) -> TDF_Label

        Returns the referred label.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.TObj_TReference_GetLabel(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TObj_TReference self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TReference attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TReference_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(TObj_TReference self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TReference_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TObj_TReference self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_TReference_Paste(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(TObj_TReference self)

        Remove back references of it reference if it is in other document.


        """
        return _TObj.TObj_TReference_BeforeForget(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(TObj_TReference self, Handle_TDF_AttributeDelta theDelta, Standard_Boolean const isForced) -> Standard_Boolean

        It is necessary for tranzaction mechanism (Undo/Redo).

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type isForced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_TReference_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TObj_TReference self, Handle_TDF_AttributeDelta theDelta, Standard_Boolean const isForced) -> Standard_Boolean

        It is necessary for tranzaction mechanism (Undo/Redo).

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type isForced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_TReference_AfterUndo(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(TObj_TReference self)

        Check if back reference exists for reference.


        """
        return _TObj.TObj_TReference_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(TObj_TReference self, Standard_Boolean const forceIt) -> Standard_Boolean

        Called after retrieval reference from file.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_TReference_AfterRetrieval(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_TReference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_TReference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_TReference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_TReference
TObj_TReference_swigregister = _TObj.TObj_TReference_swigregister
TObj_TReference_swigregister(TObj_TReference)

def TObj_TReference_GetID(*args):
    """
    TObj_TReference_GetID() -> Standard_GUID

    This method is used in implementation of ID()

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TObj.TObj_TReference_GetID(*args)

def TObj_TReference_get_type_name(*args):
    """
    TObj_TReference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_TReference_get_type_name(*args)

def TObj_TReference_get_type_descriptor(*args):
    """
    TObj_TReference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_TReference_get_type_descriptor(*args)

class Handle_TObj_TNameContainer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_TNameContainer self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_TNameContainer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_TNameContainer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_TNameContainer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_TNameContainer self, TObj_TNameContainer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_TNameContainer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_TNameContainer self, Handle_TObj_TNameContainer theHandle) -> Handle_TObj_TNameContainer
        assign(Handle_TObj_TNameContainer self, TObj_TNameContainer thePtr) -> Handle_TObj_TNameContainer
        assign(Handle_TObj_TNameContainer self, Handle_TObj_TNameContainer theHandle) -> Handle_TObj_TNameContainer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_TNameContainer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_TNameContainer self) -> TObj_TNameContainer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_TNameContainer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_TNameContainer self) -> TObj_TNameContainer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_TNameContainer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_TNameContainer self) -> TObj_TNameContainer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_TNameContainer___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_TNameContainer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_TNameContainer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_TNameContainer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_TNameContainer_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_TNameContainer

    def GetID(self, *args):
        """
        GetID(Handle_TObj_TNameContainer self) -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.Handle_TObj_TNameContainer_GetID(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.Handle_TObj_TNameContainer_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TObj_TNameContainer self, TDF_Label theLabel) -> Handle_TObj_TNameContainer
        Set(Handle_TObj_TNameContainer self, TObj_DataMapOfNameLabel const & theElem)

        Sets the TObj_DataMapOfNameLabel object

        :type theElem: OCC.wrapper.TObj.TObj_DataMapOfNameLabel

        """
        return _TObj.Handle_TObj_TNameContainer_Set(self, *args)


    def RecordName(self, *args):
        """
        RecordName(Handle_TObj_TNameContainer self, Handle_TCollection_HExtendedString theName, TDF_Label theLabel)

        Records name with label attached

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TNameContainer_RecordName(self, *args)


    def RemoveName(self, *args):
        """
        RemoveName(Handle_TObj_TNameContainer self, Handle_TCollection_HExtendedString theName)

        Remove name from the map

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_TNameContainer_RemoveName(self, *args)


    def IsRegistered(self, *args):
        """
        IsRegistered(Handle_TObj_TNameContainer self, Handle_TCollection_HExtendedString theName) -> Standard_Boolean

        Return True is theName is registered in the Map

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsRegistered(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_TObj_TNameContainer self)

        Remove all names registered in container


        """
        return _TObj.Handle_TObj_TNameContainer_Clear(self, *args)


    def Get(self, *args):
        """
        Returns the TObj_DataMapOfNameLabel object

        :rtype: OCC.wrapper.TObj.TObj_DataMapOfNameLabel

        """
        res = _TObj.Handle_TObj_TNameContainer_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TObj_TNameContainer self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TNameContainer attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TNameContainer_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TObj_TNameContainer self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TNameContainer_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TObj_TNameContainer self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_TNameContainer_Paste(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_TNameContainer self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_TNameContainer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TNameContainer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TNameContainer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TObj_TNameContainer self, Standard_GUID arg2)
        SetID(Handle_TObj_TNameContainer self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TObj.Handle_TObj_TNameContainer_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TObj_TNameContainer self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TNameContainer_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TObj_TNameContainer self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TNameContainer_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TObj_TNameContainer self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TNameContainer_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TObj_TNameContainer self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TObj_TNameContainer self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TObj_TNameContainer self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TObj_TNameContainer self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TObj_TNameContainer self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TObj_TNameContainer self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TNameContainer_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TObj_TNameContainer self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TObj_TNameContainer self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TObj.Handle_TObj_TNameContainer_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TObj_TNameContainer self)

        Something to do after adding an Attribute to a label.


        """
        return _TObj.Handle_TObj_TNameContainer_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TObj_TNameContainer self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TNameContainer_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TObj_TNameContainer self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TObj.Handle_TObj_TNameContainer_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TObj_TNameContainer self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TNameContainer_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_TNameContainer self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TObj_TNameContainer self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TObj_TNameContainer self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TObj_TNameContainer self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TObj.Handle_TObj_TNameContainer_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TObj_TNameContainer self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TObj.Handle_TObj_TNameContainer_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TObj_TNameContainer self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TObj_TNameContainer self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TNameContainer_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TObj_TNameContainer self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TObj.Handle_TObj_TNameContainer_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TObj_TNameContainer self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TObj.Handle_TObj_TNameContainer_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TObj_TNameContainer self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TObj.Handle_TObj_TNameContainer_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TObj_TNameContainer self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TObj.Handle_TObj_TNameContainer_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TObj_TNameContainer self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TObj.Handle_TObj_TNameContainer_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TObj_TNameContainer self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TNameContainer_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TObj_TNameContainer self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TNameContainer___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TObj_TNameContainer self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TObj.Handle_TObj_TNameContainer_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TObj_TNameContainer self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TObj.Handle_TObj_TNameContainer_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_TNameContainer self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_TNameContainer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_TNameContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_TNameContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_TNameContainer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_TNameContainer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TNameContainer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_TNameContainer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_TNameContainer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_TNameContainer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TNameContainer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_TNameContainer self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_TNameContainer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_TNameContainer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TNameContainer_DecrementRefCounter(self, *args)

Handle_TObj_TNameContainer_swigregister = _TObj.Handle_TObj_TNameContainer_swigregister
Handle_TObj_TNameContainer_swigregister(Handle_TObj_TNameContainer)

def Handle_TObj_TNameContainer_DownCast(thing):
    return _TObj.Handle_TObj_TNameContainer_DownCast(thing)
Handle_TObj_TNameContainer_DownCast = _TObj.Handle_TObj_TNameContainer_DownCast

class Handle_TObj_TModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_TModel self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_TModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_TModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_TModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_TModel self, TObj_TModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_TModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_TModel self, Handle_TObj_TModel theHandle) -> Handle_TObj_TModel
        assign(Handle_TObj_TModel self, TObj_TModel thePtr) -> Handle_TObj_TModel
        assign(Handle_TObj_TModel self, Handle_TObj_TModel theHandle) -> Handle_TObj_TModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_TModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_TModel self) -> TObj_TModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_TModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_TModel self) -> TObj_TModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_TModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_TModel self) -> TObj_TModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_TModel___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_TModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_TModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_TModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_TModel_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_TModel

    def GetID(self, *args):
        """
        GetID(Handle_TObj_TModel self) -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.Handle_TObj_TModel_GetID(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.Handle_TObj_TModel_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TObj_TModel self, Handle_TObj_Model theModel)

        Sets the the Model object

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.Handle_TObj_TModel_Set(self, *args)


    def Model(self, *args):
        """
        Model(Handle_TObj_TModel self) -> Handle_TObj_Model

        Returns the Model object

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.Handle_TObj_TModel_Model(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TObj_TModel self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TModel attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TModel_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TObj_TModel self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TModel_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TObj_TModel self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_TModel_Paste(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_TModel self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_TModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TObj_TModel self, Standard_GUID arg2)
        SetID(Handle_TObj_TModel self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TObj.Handle_TObj_TModel_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TObj_TModel self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TModel_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TObj_TModel self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TModel_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TObj_TModel self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TModel_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TObj_TModel self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TObj_TModel self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TObj_TModel self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TObj_TModel self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TObj_TModel self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TObj_TModel self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TModel_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TObj_TModel self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TObj_TModel self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TObj.Handle_TObj_TModel_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TObj_TModel self)

        Something to do after adding an Attribute to a label.


        """
        return _TObj.Handle_TObj_TModel_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TObj_TModel self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TModel_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TObj_TModel self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TObj.Handle_TObj_TModel_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TObj_TModel self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TModel_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_TModel self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TObj_TModel self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TObj_TModel self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TObj_TModel self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TObj.Handle_TObj_TModel_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TObj_TModel self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TObj.Handle_TObj_TModel_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TObj_TModel self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TObj_TModel self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TModel_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TObj_TModel self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TObj.Handle_TObj_TModel_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TObj_TModel self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TObj.Handle_TObj_TModel_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TObj_TModel self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TObj.Handle_TObj_TModel_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TObj_TModel self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TObj.Handle_TObj_TModel_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TObj_TModel self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TObj.Handle_TObj_TModel_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TObj_TModel self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TModel_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TObj_TModel self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TModel___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TObj_TModel self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TObj.Handle_TObj_TModel_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TObj_TModel self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TObj.Handle_TObj_TModel_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_TModel self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_TModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_TModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_TModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_TModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_TModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_TModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_TModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_TModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_TModel self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_TModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_TModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TModel_DecrementRefCounter(self, *args)

Handle_TObj_TModel_swigregister = _TObj.Handle_TObj_TModel_swigregister
Handle_TObj_TModel_swigregister(Handle_TObj_TModel)

def Handle_TObj_TModel_DownCast(thing):
    return _TObj.Handle_TObj_TModel_DownCast(thing)
Handle_TObj_TModel_DownCast = _TObj.Handle_TObj_TModel_DownCast

class TObj_Assistant(object):
    """
    This class provides interface to the static data
    to be used during save or load models.

    Static data:
    1. DataMap of Modeller name - handle to model to be used in loading of references
    2. Indexed map of Standard_Type to be used during save or load of object type
    3. Handle to the current model - model that is loaded at the current moment
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FindModel(*args):
        """
        FindModel(Standard_CString const theName) -> Handle_TObj_Model

        Finds model by name

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_Assistant_FindModel(*args)

    FindModel = staticmethod(FindModel)

    def BindModel(*args):
        """
        BindModel(Handle_TObj_Model theModel)

        Binds model to the map

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_Assistant_BindModel(*args)

    BindModel = staticmethod(BindModel)

    def ClearModelMap(*args):
        """
        ClearModelMap()

        Clears all records from the model map


        """
        return _TObj.TObj_Assistant_ClearModelMap(*args)

    ClearModelMap = staticmethod(ClearModelMap)

    def FindType(*args):
        """
        FindType(Standard_Integer const theTypeIndex) -> Handle_Standard_Type

        Finds Standard_Type by index;
        returns NULL handle if not found

        :type theTypeIndex: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_Assistant_FindType(*args)

    FindType = staticmethod(FindType)

    def FindTypeIndex(*args):
        """
        FindTypeIndex(Handle_Standard_Type theType) -> Standard_Integer

        Rinds index by Standard_Type;
        returns 0 if not found

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Assistant_FindTypeIndex(*args)

    FindTypeIndex = staticmethod(FindTypeIndex)

    def BindType(*args):
        """
        BindType(Handle_Standard_Type theType) -> Standard_Integer

        Binds Standard_Type to the map;
        returns index of bound type

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Assistant_BindType(*args)

    BindType = staticmethod(BindType)

    def ClearTypeMap(*args):
        """
        ClearTypeMap()

        Clears map of types


        """
        return _TObj.TObj_Assistant_ClearTypeMap(*args)

    ClearTypeMap = staticmethod(ClearTypeMap)

    def SetCurrentModel(*args):
        """
        SetCurrentModel(Handle_TObj_Model theModel)

        Sets current model

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_Assistant_SetCurrentModel(*args)

    SetCurrentModel = staticmethod(SetCurrentModel)

    def GetCurrentModel(*args):
        """
        GetCurrentModel() -> Handle_TObj_Model

        Returns current model

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.TObj_Assistant_GetCurrentModel(*args)

    GetCurrentModel = staticmethod(GetCurrentModel)

    def UnSetCurrentModel(*args):
        """
        UnSetCurrentModel()

        Unsets current model


        """
        return _TObj.TObj_Assistant_UnSetCurrentModel(*args)

    UnSetCurrentModel = staticmethod(UnSetCurrentModel)

    def GetAppVersion(*args):
        """
        GetAppVersion() -> Standard_Integer

        Returns the version of application which wrote the currently read document.
        Returns 0 if it has not been set yet for the current document.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.TObj_Assistant_GetAppVersion(*args)

    GetAppVersion = staticmethod(GetAppVersion)

    def __init__(self):
        """
        This class provides interface to the static data
        to be used during save or load models.

        Static data:
        1. DataMap of Modeller name - handle to model to be used in loading of references
        2. Indexed map of Standard_Type to be used during save or load of object type
        3. Handle to the current model - model that is loaded at the current moment
        """
        this = _TObj.new_TObj_Assistant()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TObj.delete_TObj_Assistant
TObj_Assistant_swigregister = _TObj.TObj_Assistant_swigregister
TObj_Assistant_swigregister(TObj_Assistant)

def TObj_Assistant_FindModel(*args):
    """
    TObj_Assistant_FindModel(Standard_CString const theName) -> Handle_TObj_Model

    Finds model by name

    :type theName: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.TObj.Handle_TObj_Model

    """
    return _TObj.TObj_Assistant_FindModel(*args)

def TObj_Assistant_BindModel(*args):
    """
    TObj_Assistant_BindModel(Handle_TObj_Model theModel)

    Binds model to the map

    :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

    """
    return _TObj.TObj_Assistant_BindModel(*args)

def TObj_Assistant_ClearModelMap(*args):
    """
    TObj_Assistant_ClearModelMap()

    Clears all records from the model map


    """
    return _TObj.TObj_Assistant_ClearModelMap(*args)

def TObj_Assistant_FindType(*args):
    """
    TObj_Assistant_FindType(Standard_Integer const theTypeIndex) -> Handle_Standard_Type

    Finds Standard_Type by index;
    returns NULL handle if not found

    :type theTypeIndex: int
    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_Assistant_FindType(*args)

def TObj_Assistant_FindTypeIndex(*args):
    """
    TObj_Assistant_FindTypeIndex(Handle_Standard_Type theType) -> Standard_Integer

    Rinds index by Standard_Type;
    returns 0 if not found

    :type theType: OCC.wrapper.Standard.Handle_Standard_Type
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TObj.TObj_Assistant_FindTypeIndex(*args)

def TObj_Assistant_BindType(*args):
    """
    TObj_Assistant_BindType(Handle_Standard_Type theType) -> Standard_Integer

    Binds Standard_Type to the map;
    returns index of bound type

    :type theType: OCC.wrapper.Standard.Handle_Standard_Type
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TObj.TObj_Assistant_BindType(*args)

def TObj_Assistant_ClearTypeMap(*args):
    """
    TObj_Assistant_ClearTypeMap()

    Clears map of types


    """
    return _TObj.TObj_Assistant_ClearTypeMap(*args)

def TObj_Assistant_SetCurrentModel(*args):
    """
    TObj_Assistant_SetCurrentModel(Handle_TObj_Model theModel)

    Sets current model

    :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

    """
    return _TObj.TObj_Assistant_SetCurrentModel(*args)

def TObj_Assistant_GetCurrentModel(*args):
    """
    TObj_Assistant_GetCurrentModel() -> Handle_TObj_Model

    Returns current model

    :rtype: OCC.wrapper.TObj.Handle_TObj_Model

    """
    return _TObj.TObj_Assistant_GetCurrentModel(*args)

def TObj_Assistant_UnSetCurrentModel(*args):
    """
    TObj_Assistant_UnSetCurrentModel()

    Unsets current model


    """
    return _TObj.TObj_Assistant_UnSetCurrentModel(*args)

def TObj_Assistant_GetAppVersion(*args):
    """
    TObj_Assistant_GetAppVersion() -> Standard_Integer

    Returns the version of application which wrote the currently read document.
    Returns 0 if it has not been set yet for the current document.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TObj.TObj_Assistant_GetAppVersion(*args)

class Handle_TObj_ReferenceIterator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_ReferenceIterator self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_ReferenceIterator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_ReferenceIterator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_ReferenceIterator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_ReferenceIterator self, TObj_ReferenceIterator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_ReferenceIterator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_ReferenceIterator self, Handle_TObj_ReferenceIterator theHandle) -> Handle_TObj_ReferenceIterator
        assign(Handle_TObj_ReferenceIterator self, TObj_ReferenceIterator thePtr) -> Handle_TObj_ReferenceIterator
        assign(Handle_TObj_ReferenceIterator self, Handle_TObj_ReferenceIterator theHandle) -> Handle_TObj_ReferenceIterator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_ReferenceIterator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_ReferenceIterator self) -> TObj_ReferenceIterator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_ReferenceIterator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_ReferenceIterator self) -> TObj_ReferenceIterator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_ReferenceIterator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_ReferenceIterator self) -> TObj_ReferenceIterator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_ReferenceIterator___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_ReferenceIterator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_ReferenceIterator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_ReferenceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_ReferenceIterator_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_ReferenceIterator

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_ReferenceIterator self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_ReferenceIterator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_ReferenceIterator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_ReferenceIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def More(self, *args):
        """
        More(Handle_TObj_ReferenceIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ReferenceIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_TObj_ReferenceIterator self)

        Move to the next Item


        """
        return _TObj.Handle_TObj_ReferenceIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TObj_ReferenceIterator self) -> Handle_TObj_Object

        Returns the current item

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_ReferenceIterator_Value(self, *args)


    def LabelValue(self, *args):
        """
        Returns the label of the current item

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TObj.Handle_TObj_ReferenceIterator_LabelValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_ReferenceIterator self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_ReferenceIterator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_ReferenceIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_ReferenceIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ReferenceIterator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_ReferenceIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_ReferenceIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ReferenceIterator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_ReferenceIterator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_ReferenceIterator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_ReferenceIterator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_ReferenceIterator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_ReferenceIterator self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_ReferenceIterator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_ReferenceIterator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_ReferenceIterator_DecrementRefCounter(self, *args)

Handle_TObj_ReferenceIterator_swigregister = _TObj.Handle_TObj_ReferenceIterator_swigregister
Handle_TObj_ReferenceIterator_swigregister(Handle_TObj_ReferenceIterator)

def Handle_TObj_ReferenceIterator_DownCast(thing):
    return _TObj.Handle_TObj_ReferenceIterator_DownCast(thing)
Handle_TObj_ReferenceIterator_DownCast = _TObj.Handle_TObj_ReferenceIterator_DownCast

class Handle_TObj_Object(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_Object self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_Object_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_Object self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_Object_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_Object self, TObj_Object thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_Object_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_Object self, Handle_TObj_Object theHandle) -> Handle_TObj_Object
        assign(Handle_TObj_Object self, TObj_Object thePtr) -> Handle_TObj_Object
        assign(Handle_TObj_Object self, Handle_TObj_Object theHandle) -> Handle_TObj_Object

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_Object_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_Object self) -> TObj_Object

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_Object_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_Object self) -> TObj_Object

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_Object___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_Object self) -> TObj_Object

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_Object___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_Object___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_Object___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_Object(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_Object_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_Object

    def GetModel(self, *args):
        """
        GetModel(Handle_TObj_Object self) -> Handle_TObj_Model

        Returns the model to which the object belongs

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.Handle_TObj_Object_GetModel(self, *args)


    def GetChildren(self, *args):
        """
        GetChildren(Handle_TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the child objects.
        This method provides tree-like view of the objects hierarchy.
        The references to other objects are not considered as children.
        theType narrows a variety of iterated objects
        The default implementation search for children on 1 sublavel
        of the children sub label

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Object_GetChildren(self, *args)


    def GetChildLabel(self, *args):
        """
        GetChildLabel(Handle_TObj_Object self) -> TDF_Label

        Returns the label under which children are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Object_GetChildLabel(self, *args)


    def getChildLabel(self, *args):
        """
        getChildLabel(Handle_TObj_Object self, Standard_Integer const theRank) -> TDF_Label

        Returns the label for child with rank

        :type theRank: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Object_getChildLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_TObj_Object self) -> TDF_Label

        Returns the OCAF label on which object`s data are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Object_GetLabel(self, *args)


    def GetDataLabel(self, *args):
        """
        GetDataLabel(Handle_TObj_Object self) -> TDF_Label

        Returns the label which is the root for data OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Object_GetDataLabel(self, *args)


    def GetReferenceLabel(self, *args):
        """
        GetReferenceLabel(Handle_TObj_Object self) -> TDF_Label

        Returns the label which is the root for reference OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Object_GetReferenceLabel(self, *args)


    def GetDictionary(self, *args):
        """
        GetDictionary(Handle_TObj_Object self) -> Handle_TObj_TNameContainer

        Returns the map of names of the objects
        Default implementation returns global Dictionary of the model

        :rtype: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.Handle_TObj_Object_GetDictionary(self, *args)


    def GetName(self, *args):
        """
        GetName(Handle_TObj_Object self) -> Handle_TCollection_HExtendedString
        GetName(Handle_TObj_Object self, TCollection_ExtendedString theName) -> Standard_Boolean
        GetName(Handle_TObj_Object self, TCollection_AsciiString theName) -> Standard_Boolean

        Returns the Standard_True is object has name and returns name to theName

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_GetName(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_TObj_Object self, Handle_TCollection_HExtendedString theName) -> Standard_Boolean
        SetName(Handle_TObj_Object self, Handle_TCollection_HAsciiString theName) -> Standard_Boolean
        SetName(Handle_TObj_Object self, Standard_CString const name) -> Standard_Boolean

        Sets name of the object. Returns False if theName is not unique.

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_SetName(self, *args)


    def GetNameForClone(self, *args):
        """
        GetNameForClone(Handle_TObj_Object self, Handle_TObj_Object arg2) -> Handle_TCollection_HExtendedString

        Returns name for copy
        default implementation returns the same name

        :type : OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_Object_GetNameForClone(self, *args)


    def HasReference(self, *args):
        """
        HasReference(Handle_TObj_Object self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if object has reference to indicated object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_HasReference(self, *args)


    def GetReferences(self, *args):
        """
        GetReferences(Handle_TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns an Iterator containing objects that compose the this one
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Object_GetReferences(self, *args)


    def RemoveAllReferences(self, *args):
        """
        RemoveAllReferences(Handle_TObj_Object self)

        Remove all references to other objects, by removing all reference attributes


        """
        return _TObj.Handle_TObj_Object_RemoveAllReferences(self, *args)


    def GetBackReferences(self, *args):
        """
        GetBackReferences(Handle_TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the objects which depend on this one.
        These reffering objects may belong to other models.
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Object_GetBackReferences(self, *args)


    def AddBackReference(self, *args):
        """
        AddBackReference(Handle_TObj_Object self, Handle_TObj_Object theObject)

        Registers another object as being dependent on this one.
        Stores back references under sublabel 2 (purely transient data,
        not subject to persistency).

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Object_AddBackReference(self, *args)


    def RemoveBackReference(self, *args):
        """
        RemoveBackReference(Handle_TObj_Object self, Handle_TObj_Object theObject, Standard_Boolean const theSingleOnly)

        Removes information on dependent object (back reference).
        If theSingleOnly is true only the first back reference is removed in the 
        case of duplicate items.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theSingleOnly: bool

        """
        return _TObj.Handle_TObj_Object_RemoveBackReference(self, *args)


    def RemoveBackReferences(self, *args):
        """
        RemoveBackReferences(Handle_TObj_Object self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Removes all back reference by removing references from other to me.

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_RemoveBackReferences(self, *args)


    def ClearBackReferences(self, *args):
        """
        ClearBackReferences(Handle_TObj_Object self)

        The default implementation just clear the back references container


        """
        return _TObj.Handle_TObj_Object_ClearBackReferences(self, *args)


    def HasBackReferences(self, *args):
        """
        HasBackReferences(Handle_TObj_Object self) -> Standard_Boolean

        Returns TRUE if obejct has 1 or more back references

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_HasBackReferences(self, *args)


    def ReplaceReference(self, *args):
        """
        ReplaceReference(Handle_TObj_Object self, Handle_TObj_Object theOldObject, Handle_TObj_Object theNewObject)

        Replace reference from old object to new object.
        If it is not possible, may raise exception.
        If new object is null then simple remove reference to old object.

        :type theOldObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theNewObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Object_ReplaceReference(self, *args)


    def GetBadReference(self, *args):
        """
        GetBadReference(Handle_TObj_Object self, TDF_Label theRoot, TDF_Label theBadReference) -> Standard_Boolean

        Return True if this refers to the model theRoot belongs
        to and a referred label is not a descendant of theRoot.
        In this case theBadReference returns the currently referred label.

        :type theRoot: OCC.wrapper.TDF.TDF_Label
        :type theBadReference: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_GetBadReference(self, *args)


    def RelocateReferences(self, *args):
        """
        RelocateReferences(Handle_TObj_Object self, TDF_Label theFromRoot, TDF_Label theToRoot, Standard_Boolean const theUpdateBackRefs) -> Standard_Boolean

        Make that each reference pointing to a descendant label of
        theFromRoot to point to an equivalent label under theToRoot.
        Return False if a resulting reference does not point to
        an TObj_Object
        Example:
        a referred object label = 0:3:24:7:2:7
        theFromRoot             = 0:3:24
        theToRoot               = 0:2
        a new referred label    = 0:2:7:2:7

        :type theFromRoot: OCC.wrapper.TDF.TDF_Label
        :type theToRoot: OCC.wrapper.TDF.TDF_Label
        :type theUpdateBackRefs: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_RelocateReferences(self, *args)


    def CanRemoveReference(self, *args):
        """
        CanRemoveReference(Handle_TObj_Object self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if the referred object theObject can be deleted 
        without deletion of this object.
        Default implementation does nothing and returns False.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_CanRemoveReference(self, *args)


    def RemoveReference(self, *args):
        """
        RemoveReference(Handle_TObj_Object self, Handle_TObj_Object theObject)

        Removes reference to the object by replace reference to NULL object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Object_RemoveReference(self, *args)


    def BeforeForgetReference(self, *args):
        """
        BeforeForgetReference(Handle_TObj_Object self, TDF_Label arg2)

        Invokes from TObj_TReference::BeforeForget().
        theLabel - label on that reference become removed
        Default implementation is empty

        :type : OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Object_BeforeForgetReference(self, *args)


    def CanDetach(self, *args):
        """
        CanDetach(Handle_TObj_Object self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Checks if object can be detached with specified mode

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_CanDetach(self, *args)


    def Detach(self, *args):
        """
        Detach(Handle_TObj_Object self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean
        Detach(Handle_TObj_Object self, TDF_Label theLabel, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Deletes the object from the label. Checks if object can be deleted.
        Finds object on the label and detaches it by calling previos method.
        Returns true if there is no object on the label after detaching

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_Detach(self, *args)


    def GetObj(self, *args):
        """
        GetObj(Handle_TObj_Object self, TDF_Label theLabel, Handle_TObj_Object theResult, Standard_Boolean const isSuper) -> Standard_Boolean

        Returns the Object attached to a given label.
        Returns False if no object of type TObj_Object is stored on the
        specified label.
        If isSuper is true tries to find on the super labels.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theResult: OCC.wrapper.TObj.Handle_TObj_Object
        :type isSuper: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_GetObj(self, *args)


    def GetFatherObject(self, *args):
        """
        GetFatherObject(Handle_TObj_Object self, Handle_Standard_Type theType=0) -> Handle_TObj_Object

        Returns the father object, which may be NULL
        theType gives type of father object to search

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Object_GetFatherObject(self, *args)


    def IsAlive(self, *args):
        """
        IsAlive(Handle_TObj_Object self) -> Standard_Boolean

        Checks that object alive in model
        Default implementation checks that object has TObject attribute at own label.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_IsAlive(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_TObj_Object self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable=0) -> Handle_TObj_Object

        Copy me to other label theTargetLabel
        New object will not have all the reference that has me.
        Coping object with data and childs, but change name by adding string "_copy"
        As result return handle of new object (null handle is something wrong)
        NOTE: BackReferences not coping.
        After clonning all objects it is neccessary to call copy references
        with the same relocation table

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Object_Clone(self, *args)


    def CopyReferences(self, *args):
        """
        CopyReferences(Handle_TObj_Object self, Handle_TObj_Object theTargetObject, Handle_TDF_RelocationTable theRelocTable)

        Coping the references.
        return Standard_False is Target object is different type

        :type theTargetObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_Object_CopyReferences(self, *args)


    def CopyChildren(self, *args):
        """
        CopyChildren(Handle_TObj_Object self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable)

        Coping the children from source label to the target.

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_Object_CopyChildren(self, *args)


    def GetOrder(self, *args):
        """
        GetOrder(Handle_TObj_Object self) -> Standard_Integer

        returns order of object (or tag of their label if order is not initialised)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Object_GetOrder(self, *args)


    def SetOrder(self, *args):
        """
        SetOrder(Handle_TObj_Object self, Standard_Integer const & theIndx) -> Standard_Boolean

        sets order of object

        :type theIndx: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_SetOrder(self, *args)


    def GetTypeFlags(self, *args):
        """
        GetTypeFlags(Handle_TObj_Object self) -> Standard_Integer

        Returns flags (bitmask) that define properties of objects of that type
        By default returns flag Visible

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Object_GetTypeFlags(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_TObj_Object self) -> Standard_Integer

        Returns mask of seted flags

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Object_GetFlags(self, *args)


    def SetFlags(self, *args):
        """
        SetFlags(Handle_TObj_Object self, Standard_Integer const theMask)

        Sets flags with defined mask.

        :type theMask: int

        """
        return _TObj.Handle_TObj_Object_SetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_TObj_Object self, Standard_Integer const theMask) -> Standard_Boolean

        tests flags by the mask.

        :type theMask: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_TestFlags(self, *args)


    def ClearFlags(self, *args):
        """
        ClearFlags(Handle_TObj_Object self, Standard_Integer const theMask)

        clears flags by the mask.

        :type theMask: int

        """
        return _TObj.Handle_TObj_Object_ClearFlags(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_Object self)

        Preforms updating the links and dependances of the object which are not
        stored in persistence. Should be redefined if necessary.


        """
        return _TObj.Handle_TObj_Object_AfterRetrieval(self, *args)


    def BeforeStoring(self, *args):
        """
        BeforeStoring(Handle_TObj_Object self)

        Preforms storing the objects transient fields in OCAF document
        which were outside transaction mechanism.
        Default implementation doesnot nothing


        """
        return _TObj.Handle_TObj_Object_BeforeStoring(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_Object self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_Object_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Object_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Object_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_Object self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_Object_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_Object self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_Object self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_Object self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_Object self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Object_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_Object self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_Object_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_Object self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Object_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_Object self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_Object_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_Object self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Object_DecrementRefCounter(self, *args)

Handle_TObj_Object_swigregister = _TObj.Handle_TObj_Object_swigregister
Handle_TObj_Object_swigregister(Handle_TObj_Object)

def Handle_TObj_Object_DownCast(thing):
    return _TObj.Handle_TObj_Object_DownCast(thing)
Handle_TObj_Object_DownCast = _TObj.Handle_TObj_Object_DownCast

class Handle_TObj_ModelIterator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_ModelIterator self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_ModelIterator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_ModelIterator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_ModelIterator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_ModelIterator self, TObj_ModelIterator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_ModelIterator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_ModelIterator self, Handle_TObj_ModelIterator theHandle) -> Handle_TObj_ModelIterator
        assign(Handle_TObj_ModelIterator self, TObj_ModelIterator thePtr) -> Handle_TObj_ModelIterator
        assign(Handle_TObj_ModelIterator self, Handle_TObj_ModelIterator theHandle) -> Handle_TObj_ModelIterator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_ModelIterator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_ModelIterator self) -> TObj_ModelIterator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_ModelIterator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_ModelIterator self) -> TObj_ModelIterator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_ModelIterator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_ModelIterator self) -> TObj_ModelIterator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_ModelIterator___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_ModelIterator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_ModelIterator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_ModelIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_ModelIterator_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_ModelIterator

    def More(self, *args):
        """
        More(Handle_TObj_ModelIterator self) -> Standard_Boolean

        Returns True if iteration is not finished and method Value()
        will give the object

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ModelIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_TObj_ModelIterator self)

        Iterates to the next object


        """
        return _TObj.Handle_TObj_ModelIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TObj_ModelIterator self) -> Handle_TObj_Object

        Returns current object (or MainObj of Model if iteration has finished)

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_ModelIterator_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_ModelIterator self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_ModelIterator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_ModelIterator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_ModelIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_ModelIterator self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_ModelIterator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_ModelIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_ModelIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ModelIterator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_ModelIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_ModelIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ModelIterator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_ModelIterator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_ModelIterator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_ModelIterator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_ModelIterator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_ModelIterator self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_ModelIterator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_ModelIterator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_ModelIterator_DecrementRefCounter(self, *args)

Handle_TObj_ModelIterator_swigregister = _TObj.Handle_TObj_ModelIterator_swigregister
Handle_TObj_ModelIterator_swigregister(Handle_TObj_ModelIterator)

def Handle_TObj_ModelIterator_DownCast(thing):
    return _TObj.Handle_TObj_ModelIterator_DownCast(thing)
Handle_TObj_ModelIterator_DownCast = _TObj.Handle_TObj_ModelIterator_DownCast

class Handle_TObj_TReference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_TReference self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_TReference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_TReference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_TReference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_TReference self, TObj_TReference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_TReference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_TReference self, Handle_TObj_TReference theHandle) -> Handle_TObj_TReference
        assign(Handle_TObj_TReference self, TObj_TReference thePtr) -> Handle_TObj_TReference
        assign(Handle_TObj_TReference self, Handle_TObj_TReference theHandle) -> Handle_TObj_TReference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_TReference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_TReference self) -> TObj_TReference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_TReference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_TReference self) -> TObj_TReference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_TReference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_TReference self) -> TObj_TReference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_TReference___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_TReference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_TReference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_TReference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_TReference_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_TReference

    def GetID(self, *args):
        """
        GetID(Handle_TObj_TReference self) -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.Handle_TObj_TReference_GetID(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.Handle_TObj_TReference_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TObj_TReference self, TDF_Label theLabel, Handle_TObj_Object theObject, Handle_TObj_Object theMaster) -> Handle_TObj_TReference
        Set(Handle_TObj_TReference self, Handle_TObj_Object theObject, TDF_Label theMasterLabel)
        Set(Handle_TObj_TReference self, TDF_Label theLabel, TDF_Label theMasterLabel)

        Sets the reference to the theObject at indicated Label.
        It is method for persistent only. Don`t use anywhere else.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theMasterLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TReference_Set(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TObj_TReference self) -> Handle_TObj_Object

        Returns the referenced theObject

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_TReference_Get(self, *args)


    def GetMasterLabel(self, *args):
        """
        GetMasterLabel(Handle_TObj_TReference self) -> TDF_Label

        Returns the Label of master object.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TReference_GetMasterLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_TObj_TReference self) -> TDF_Label

        Returns the referred label.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TReference_GetLabel(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TObj_TReference self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TReference attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TReference_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TObj_TReference self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TReference_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TObj_TReference self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_TReference_Paste(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TObj_TReference self)

        Remove back references of it reference if it is in other document.


        """
        return _TObj.Handle_TObj_TReference_BeforeForget(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TObj_TReference self, Handle_TDF_AttributeDelta theDelta, Standard_Boolean const isForced) -> Standard_Boolean

        It is necessary for tranzaction mechanism (Undo/Redo).

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type isForced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TObj_TReference self, Handle_TDF_AttributeDelta theDelta, Standard_Boolean const isForced) -> Standard_Boolean

        It is necessary for tranzaction mechanism (Undo/Redo).

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type isForced: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_AfterUndo(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TObj_TReference self)

        Check if back reference exists for reference.


        """
        return _TObj.Handle_TObj_TReference_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_TReference self, Standard_Boolean const forceIt) -> Standard_Boolean

        Called after retrieval reference from file.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_AfterRetrieval(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_TReference self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_TReference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TReference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TReference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TObj_TReference self, Standard_GUID arg2)
        SetID(Handle_TObj_TReference self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TObj.Handle_TObj_TReference_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TObj_TReference self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TReference_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TObj_TReference self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TReference_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TObj_TReference self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TReference_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TObj_TReference self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TObj_TReference self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TObj_TReference self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TObj_TReference self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TObj_TReference self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TObj_TReference self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TReference_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TObj_TReference self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TObj_TReference self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TObj.Handle_TObj_TReference_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TObj_TReference self)

        Something to do after adding an Attribute to a label.


        """
        return _TObj.Handle_TObj_TReference_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TObj_TReference self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TReference_BeforeRemoval(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TObj_TReference self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TObj.Handle_TObj_TReference_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TObj_TReference self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TObj.Handle_TObj_TReference_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TObj_TReference self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TObj_TReference self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TReference_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TObj_TReference self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TObj.Handle_TObj_TReference_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TObj_TReference self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TObj.Handle_TObj_TReference_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TObj_TReference self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TObj.Handle_TObj_TReference_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TObj_TReference self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TObj.Handle_TObj_TReference_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TObj_TReference self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TObj.Handle_TObj_TReference_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TObj_TReference self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TReference_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TObj_TReference self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TReference___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TObj_TReference self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TObj.Handle_TObj_TReference_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TObj_TReference self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TObj.Handle_TObj_TReference_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_TReference self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_TReference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_TReference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_TReference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_TReference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_TReference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TReference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_TReference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_TReference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_TReference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TReference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_TReference self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_TReference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_TReference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TReference_DecrementRefCounter(self, *args)

Handle_TObj_TReference_swigregister = _TObj.Handle_TObj_TReference_swigregister
Handle_TObj_TReference_swigregister(Handle_TObj_TReference)

def Handle_TObj_TReference_DownCast(thing):
    return _TObj.Handle_TObj_TReference_DownCast(thing)
Handle_TObj_TReference_DownCast = _TObj.Handle_TObj_TReference_DownCast

class Handle_TObj_SequenceIterator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_SequenceIterator self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_SequenceIterator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_SequenceIterator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_SequenceIterator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_SequenceIterator self, TObj_SequenceIterator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_SequenceIterator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_SequenceIterator self, Handle_TObj_SequenceIterator theHandle) -> Handle_TObj_SequenceIterator
        assign(Handle_TObj_SequenceIterator self, TObj_SequenceIterator thePtr) -> Handle_TObj_SequenceIterator
        assign(Handle_TObj_SequenceIterator self, Handle_TObj_SequenceIterator theHandle) -> Handle_TObj_SequenceIterator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_SequenceIterator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_SequenceIterator self) -> TObj_SequenceIterator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_SequenceIterator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_SequenceIterator self) -> TObj_SequenceIterator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_SequenceIterator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_SequenceIterator self) -> TObj_SequenceIterator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_SequenceIterator___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_SequenceIterator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_SequenceIterator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_SequenceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_SequenceIterator_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_SequenceIterator

    def More(self, *args):
        """
        More(Handle_TObj_SequenceIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_SequenceIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_TObj_SequenceIterator self)

        Move to the next Item


        """
        return _TObj.Handle_TObj_SequenceIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TObj_SequenceIterator self) -> Handle_TObj_Object

        Returns the current item

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_SequenceIterator_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_SequenceIterator self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_SequenceIterator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_SequenceIterator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_SequenceIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_SequenceIterator self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_SequenceIterator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_SequenceIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_SequenceIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_SequenceIterator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_SequenceIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_SequenceIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_SequenceIterator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_SequenceIterator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_SequenceIterator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_SequenceIterator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_SequenceIterator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_SequenceIterator self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_SequenceIterator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_SequenceIterator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_SequenceIterator_DecrementRefCounter(self, *args)

Handle_TObj_SequenceIterator_swigregister = _TObj.Handle_TObj_SequenceIterator_swigregister
Handle_TObj_SequenceIterator_swigregister(Handle_TObj_SequenceIterator)

def Handle_TObj_SequenceIterator_DownCast(thing):
    return _TObj.Handle_TObj_SequenceIterator_DownCast(thing)
Handle_TObj_SequenceIterator_DownCast = _TObj.Handle_TObj_SequenceIterator_DownCast

class Handle_TObj_Application(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_Application self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_Application_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_Application self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_Application_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_Application self, TObj_Application thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_Application_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_Application self, Handle_TObj_Application theHandle) -> Handle_TObj_Application
        assign(Handle_TObj_Application self, TObj_Application thePtr) -> Handle_TObj_Application
        assign(Handle_TObj_Application self, Handle_TObj_Application theHandle) -> Handle_TObj_Application

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_Application_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_Application self) -> TObj_Application

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_Application_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_Application self) -> TObj_Application

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_Application___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_Application self) -> TObj_Application

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_Application___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_Application___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_Application___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_Application(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_Application_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_Application

    def GetInstance(self, *args):
        """
        GetInstance(Handle_TObj_Application self) -> Handle_TObj_Application

        Returns static instance of the application

        :rtype: OCC.wrapper.TObj.Handle_TObj_Application

        """
        return _TObj.Handle_TObj_Application_GetInstance(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Handle_TObj_Application self) -> Handle_Message_Messenger

        Returns reference to associated messenger handle

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.Handle_TObj_Application_Messenger(self, *args)


    def SaveDocument(self, *args):
        """
        SaveDocument(Handle_TObj_Application self, Handle_TDocStd_Document theSourceDoc, TCollection_ExtendedString theTargetFile) -> Standard_Boolean

        Saving the OCAF document to a file

        :type theSourceDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theTargetFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_SaveDocument(self, *args)


    def LoadDocument(self, *args):
        """
        LoadDocument(Handle_TObj_Application self, TCollection_ExtendedString theSourceFile, Handle_TDocStd_Document theTargetDoc) -> Standard_Boolean

        Loading the OCAF document from a file

        :type theSourceFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theTargetDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_LoadDocument(self, *args)


    def CreateNewDocument(self, *args):
        """
        CreateNewDocument(Handle_TObj_Application self, Handle_TDocStd_Document theDoc, TCollection_ExtendedString theFormat) -> Standard_Boolean

        Create the OCAF document from scratch

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_CreateNewDocument(self, *args)


    def ErrorMessage(self, *args):
        """
        ErrorMessage(Handle_TObj_Application self, TCollection_ExtendedString theMsg, Message_Gravity const theLevel)
        ErrorMessage(Handle_TObj_Application self, TCollection_ExtendedString theMsg)

        Signal error during Load or Save
        Default imiplementation invoke previous declaration with 0

        :type theMsg: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TObj.Handle_TObj_Application_ErrorMessage(self, *args)


    def SetVerbose(self, *args):
        """
        SetVerbose(Handle_TObj_Application self, Standard_Boolean const isVerbose)

        Sets the verbose flag, meaning that load/save models should show
        CPU and elapsed times

        :type isVerbose: bool

        """
        return _TObj.Handle_TObj_Application_SetVerbose(self, *args)


    def IsVerbose(self, *args):
        """
        IsVerbose(Handle_TObj_Application self) -> Standard_Boolean

        Returns the verbose flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_IsVerbose(self, *args)


    def ResourcesName(self, *args):
        """
        ResourcesName(Handle_TObj_Application self) -> Standard_CString

        Return name of resource (i.e. "TObj")

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _TObj.Handle_TObj_Application_ResourcesName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_Application self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_Application_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Application_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDriverLoaded(self, *args):
        """
        IsDriverLoaded(Handle_TObj_Application self) -> Standard_Boolean

        Check if meta data driver was successfully loaded
        by the application constructor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_IsDriverLoaded(self, *args)


    def MessageDriver(self, *args):
        """
        MessageDriver(Handle_TObj_Application self) -> Handle_Message_Messenger

        Redefines message driver, by default outputs to cout.

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.Handle_TObj_Application_MessageDriver(self, *args)


    def Resources(self, *args):
        """
        Resources(Handle_TObj_Application self) -> Handle_Resource_Manager

        Returns resource manager defining supported persistent formats.

        Default implementation loads resource file with name ResourcesName(),
        unless field myResources is already initialized (either by
        previous call or in any other way).

        The resource manager should define:

        * Format name for each file extension supported:
        - [Extension].FileFormat: [Format]

        * For each format supported (as returned by Formats()),
        its extension, description string, and (when applicable)
        GUIDs of storage and retrieval plugins:
        - [Format].Description: [Description]
        - [Format].FileExtension: [Extension]
        - [Format].RetrievalPlugin: [GUID] (optional)
        - [Format].StoragePlugin: [GUID] (optional)

        :rtype: OCC.wrapper.Resource.Handle_Resource_Manager

        """
        return _TObj.Handle_TObj_Application_Resources(self, *args)


    def DefineFormat(self, *args):
        """
        DefineFormat(Handle_TObj_Application self, TCollection_AsciiString theFormat, TCollection_AsciiString theDescription, TCollection_AsciiString theExtension, Handle_PCDM_RetrievalDriver theReader, Handle_PCDM_StorageDriver theWriter)

        Sets up resources and registers read and storage drivers for
        the specified format.

        @param theFormat - unique name for the format, used to identify it.
        @param theDescription - textual description of the format.
        @param theExtension - extension of the files in that format. 
        The same extension can be used by several formats.
        @param theReader - instance of the read driver for the format.
        Null value is allowed (no possibility to read).
        @param theWriter - instance of the write driver for the format.
        Null value is allowed (no possibility to write).

        :type theFormat: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theDescription: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theExtension: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theReader: OCC.wrapper.PCDM.Handle_PCDM_RetrievalDriver
        :type theWriter: OCC.wrapper.PCDM.Handle_PCDM_StorageDriver

        """
        return _TObj.Handle_TObj_Application_DefineFormat(self, *args)


    def ReadingFormats(self, *args):
        """
        ReadingFormats(Handle_TObj_Application self, NCollection_Sequence_TCollection_AsciiString theFormats)

        Returns the sequence of reading formats supported by the application.

        @param theFormats - sequence of reading formats. Output parameter.

        :type theFormats: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TObj.Handle_TObj_Application_ReadingFormats(self, *args)


    def WritingFormats(self, *args):
        """
        WritingFormats(Handle_TObj_Application self, NCollection_Sequence_TCollection_AsciiString theFormats)

        Returns the sequence of writing formats supported by the application.

        @param theFormats - sequence of writing formats. Output parameter.

        :type theFormats: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TObj.Handle_TObj_Application_WritingFormats(self, *args)


    def NbDocuments(self, *args):
        """
        NbDocuments(Handle_TObj_Application self) -> Standard_Integer

        returns the number of documents handled by the current applicative session.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Application_NbDocuments(self, *args)


    def GetDocument(self, *args):
        """
        GetDocument(Handle_TObj_Application self, Standard_Integer const index, Handle_TDocStd_Document aDoc)

        Constructs the new document aDoc.
        aDoc is identified by the index index which is
        any integer between 1 and n where n is the
        number of documents returned by NbDocument.
        Example
        Handle(TDocStd_Application)
        anApp;
        if (!CafTest::Find(A)) return 1;
        Handle(TDocStd) aDoc;
        Standard_Integer nbdoc = anApp->NbDocuments();
        for (Standard_Integer i = 1; i <= nbdoc; i++) {
        aApp->GetDocument(i,aDoc);

        :type index: int
        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Application_GetDocument(self, *args)


    def NewDocument(self, *args):
        """
        NewDocument(Handle_TObj_Application self, TCollection_ExtendedString format, Handle_TDocStd_Document aDoc)

        Constructs the empty new document aDoc.
        This document will have the format format.
        If InitDocument is redefined for a specific
        application, the new document is handled by the
        applicative session.

        :type format: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Application_NewDocument(self, *args)


    def InitDocument(self, *args):
        """
        InitDocument(Handle_TObj_Application self, Handle_TDocStd_Document aDoc)

        Initialize the document aDoc for the applicative session.
        This virtual function is called by NewDocument
        and is to be redefined for each specific application.
        Modified flag (different of disk version)
        =============
        to open/save a document
        =======================

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Application_InitDocument(self, *args)


    def Close(self, *args):
        """
        Close(Handle_TObj_Application self, Handle_TDocStd_Document aDoc)

        Close the given document. the document is not any more
        handled by the applicative session.

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Application_Close(self, *args)


    def IsInSession(self, *args):
        """
        IsInSession(Handle_TObj_Application self, TCollection_ExtendedString path) -> Standard_Integer

        Returns an index for the document found in the
        path path in this applicative session.
        If the returned value is 0, the document is not
        present in the applicative session.
        This method can be used for the interactive part
        of an application. For instance, on a call to
        Open, the document to be opened may already
        be in memory. IsInSession checks to see if this
        is the case. Open can be made to depend on
        the value of the index returned: if IsInSession
        returns 0, the document is opened; if it returns
        another value, a message is displayed asking the
        user if he wants to override the version of the
        document in memory.
        Example:
        Standard_Integer insession = A->IsInSession(aDoc);
        if (insession > 0) {
        cout << "document " << insession << " is already in session" << endl;
        return 0;
        }

        :type path: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Application_IsInSession(self, *args)


    def Open(self, *args):
        """
        Open(Handle_TObj_Application self, TCollection_ExtendedString path, Handle_TDocStd_Document aDoc) -> PCDM_ReaderStatus
        Open(Handle_TObj_Application self, Standard_IStream & theIStream, Handle_TDocStd_Document theDoc) -> PCDM_ReaderStatus

        Retrieves aDoc from standard SEEKABLE stream theIStream.
        the stream should support SEEK fuctionality

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _TObj.Handle_TObj_Application_Open(self, *args)


    def SaveAs(self, *args):
        """
        SaveAs(Handle_TObj_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString path) -> PCDM_StoreStatus
        SaveAs(Handle_TObj_Application self, Handle_TDocStd_Document theDoc, Standard_OStream & theOStream) -> PCDM_StoreStatus
        SaveAs(Handle_TObj_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString path, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus
        SaveAs(Handle_TObj_Application self, Handle_TDocStd_Document theDoc, Standard_OStream & theOStream, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus

        Save theDoc TO standard SEEKABLE stream theOStream.
        the stream should support SEEK fuctionality

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theOStream: OCC.wrapper.Standard.Standard_OStream
        :type theStatusMessage: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _TObj.Handle_TObj_Application_SaveAs(self, *args)


    def Save(self, *args):
        """
        Save(Handle_TObj_Application self, Handle_TDocStd_Document aDoc) -> PCDM_StoreStatus
        Save(Handle_TObj_Application self, Handle_TDocStd_Document aDoc, TCollection_ExtendedString theStatusMessage) -> PCDM_StoreStatus

        Save the document overwriting the previous file

        :type aDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document
        :type theStatusMessage: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_StoreStatus

        """
        return _TObj.Handle_TObj_Application_Save(self, *args)


    def OnOpenTransaction(self, *args):
        """
        OnOpenTransaction(Handle_TObj_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each OpenTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Application_OnOpenTransaction(self, *args)


    def OnCommitTransaction(self, *args):
        """
        OnCommitTransaction(Handle_TObj_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each CommitTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Application_OnCommitTransaction(self, *args)


    def OnAbortTransaction(self, *args):
        """
        OnAbortTransaction(Handle_TObj_Application self, Handle_TDocStd_Document theDoc)

        Notification that is fired at each AbortTransaction event.

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Application_OnAbortTransaction(self, *args)


    def Load(self, *args):
        """
        Load(Handle_TObj_Application self, Standard_GUID aGUID) -> Handle_CDF_Application

        plugs an application.

        Open is used
        - for opening a Document that has been created in an application
        - for opening a Document from the database
        - for opening a Document from a file.
        The Open methods always add the document in the session directory and
        calls the virtual Activate method. The document is considered to be
        opened until Close is used. To be storable, a document must be
        opened by an application since the application resources are
        needed to store it.

        :type aGUID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.CDF.Handle_CDF_Application

        """
        return _TObj.Handle_TObj_Application_Load(self, *args)


    def CanClose(self, *args):
        """
        CanClose(Handle_TObj_Application self, Handle_CDM_Document aDocument) -> CDM_CanCloseStatus

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.CDM.CDM_CanCloseStatus

        """
        return _TObj.Handle_TObj_Application_CanClose(self, *args)


    def Retrieve(self, *args):
        """
        Retrieve(Handle_TObj_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document
        Retrieve(Handle_TObj_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion, Standard_Boolean const UseStorageConfiguration) -> Handle_CDM_Document

        This method retrieves  a  document from the database.
        If the  Document references other documents which have
        been  updated, the  latest version of  these documents
        will    be   used  if   {UseStorageConfiguration}  is
        Standard_True.  --  If the DBMS is  only  based on the
        OS, this syntax  should not be used.

        If the DBMS is EUCLID/Design Manager, {aFolder}, {aName}
        and  {aVersion} have the form they have in
        EUCLID/Design Manager. For example:

        Handle(CDM_Document) theDocument=myApplication->Retrieve("|user|cascade","box","2");
        A link is kept with the database through an instance
        of CDM_MetaData

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type UseStorageConfiguration: bool
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TObj.Handle_TObj_Application_Retrieve(self, *args)


    def CanRetrieve(self, *args):
        """
        CanRetrieve(Handle_TObj_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName) -> PCDM_ReaderStatus
        CanRetrieve(Handle_TObj_Application self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aVersion) -> PCDM_ReaderStatus

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _TObj.Handle_TObj_Application_CanRetrieve(self, *args)


    def GetRetrieveStatus(self, *args):
        """
        GetRetrieveStatus(Handle_TObj_Application self) -> PCDM_ReaderStatus

        Checks  status  after  Retrieve

        :rtype: OCC.wrapper.PCDM.PCDM_ReaderStatus

        """
        return _TObj.Handle_TObj_Application_GetRetrieveStatus(self, *args)


    def Read(self, *args):
        """
        Read(Handle_TObj_Application self, Standard_IStream & theIStream) -> Handle_CDM_Document

        Reads aDoc from standard SEEKABLE stream theIStream,
        the stream should support SEEK fuctionality

        :type theIStream: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TObj.Handle_TObj_Application_Read(self, *args)


    def ReaderFromFormat(self, *args):
        """
        ReaderFromFormat(Handle_TObj_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_Reader

        Returns instance of read driver for specified format.

        Default implementation uses plugin mechanism to load reader dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].RetrievalPlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if reader is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_Reader

        """
        return _TObj.Handle_TObj_Application_ReaderFromFormat(self, *args)


    def WriterFromFormat(self, *args):
        """
        WriterFromFormat(Handle_TObj_Application self, TCollection_ExtendedString aFormat) -> Handle_PCDM_StorageDriver

        Returns instance of storage driver for specified format.

        Default implementation uses plugin mechanism to load driver dynamically.
        For this to work, application resources should define GUID of
        the plugin as value of [Format].StoragePlugin, and "Plugin"
        resource should define name of plugin library to be loaded as
        value of [GUID].Location. Plugin library should provide
        method PLUGINFACTORY returning instance of the reader for the
        same GUID (see Plugin_Macro.hxx).

        In case if driver is not available, will raise Standard_NoSuchObject
        or other exception if raised by plugin loader.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.PCDM.Handle_PCDM_StorageDriver

        """
        return _TObj.Handle_TObj_Application_WriterFromFormat(self, *args)


    def Format(self, *args):
        """
        Format(Handle_TObj_Application self, TCollection_ExtendedString aFileName, TCollection_ExtendedString theFormat) -> Standard_Boolean

        try to  retrieve a Format  directly in the  file or in
        application   resource  by using   extension. returns
        True if found;

        :type aFileName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_Format(self, *args)


    def DefaultFolder(self, *args):
        """
        DefaultFolder(Handle_TObj_Application self) -> Standard_ExtString

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _TObj.Handle_TObj_Application_DefaultFolder(self, *args)


    def SetDefaultFolder(self, *args):
        """
        SetDefaultFolder(Handle_TObj_Application self, Standard_ExtString const aFolder) -> Standard_Boolean

        :type aFolder: OCC.wrapper.Standard.Standard_ExtString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_SetDefaultFolder(self, *args)


    def BeginOfUpdate(self, *args):
        """
        BeginOfUpdate(Handle_TObj_Application self, Handle_CDM_Document aDocument)

        this method is called before the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _TObj.Handle_TObj_Application_BeginOfUpdate(self, *args)


    def EndOfUpdate(self, *args):
        """
        EndOfUpdate(Handle_TObj_Application self, Handle_CDM_Document aDocument, Standard_Boolean const theStatus, TCollection_ExtendedString ErrorString)

        this method is called affter the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type theStatus: bool
        :type ErrorString: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TObj.Handle_TObj_Application_EndOfUpdate(self, *args)


    def Write(self, *args):
        """
        Write(Handle_TObj_Application self, Standard_ExtString const aString)

        writes the string in the application MessagerDriver.

        :type aString: OCC.wrapper.Standard.Standard_ExtString

        """
        return _TObj.Handle_TObj_Application_Write(self, *args)


    def Name(self, *args):
        """
        Name(Handle_TObj_Application self) -> TCollection_ExtendedString

        Returns the application name.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TObj.Handle_TObj_Application_Name(self, *args)


    def Version(self, *args):
        """
        Version(Handle_TObj_Application self) -> TCollection_AsciiString

        Returns the application version.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TObj.Handle_TObj_Application_Version(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_Application self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_Application_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Application_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_Application self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_Application_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_Application self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Application_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_Application self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_Application_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_Application self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Application_DecrementRefCounter(self, *args)

Handle_TObj_Application_swigregister = _TObj.Handle_TObj_Application_swigregister
Handle_TObj_Application_swigregister(Handle_TObj_Application)

def Handle_TObj_Application_DownCast(thing):
    return _TObj.Handle_TObj_Application_DownCast(thing)
Handle_TObj_Application_DownCast = _TObj.Handle_TObj_Application_DownCast

class Handle_TObj_Model(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_Model self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_Model_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_Model self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_Model_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_Model self, TObj_Model thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_Model_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_Model self, Handle_TObj_Model theHandle) -> Handle_TObj_Model
        assign(Handle_TObj_Model self, TObj_Model thePtr) -> Handle_TObj_Model
        assign(Handle_TObj_Model self, Handle_TObj_Model theHandle) -> Handle_TObj_Model

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_Model_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_Model self) -> TObj_Model

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_Model_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_Model self) -> TObj_Model

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_Model___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_Model self) -> TObj_Model

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_Model___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_Model___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_Model___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_Model(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_Model_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_Model

    def SetMessenger(self, *args):
        """
        SetMessenger(Handle_TObj_Model self, Handle_Message_Messenger theMsgr)

        Set messenger to use for messages output

        :type theMsgr: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.Handle_TObj_Model_SetMessenger(self, *args)


    def Messenger(self, *args):
        """
        Messenger(Handle_TObj_Model self) -> Handle_Message_Messenger

        Get messenger used for messages output (by default, the messenger from
        application is used)

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.Handle_TObj_Model_Messenger(self, *args)


    def Load(self, *args):
        """
        Load(Handle_TObj_Model self, TCollection_ExtendedString theFile) -> Standard_Boolean

        Load the OCAF model from a file. If the filename is empty or file does
        not exists, it just initializes model by empty data.

        :type theFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_Load(self, *args)


    def SaveAs(self, *args):
        """
        SaveAs(Handle_TObj_Model self, TCollection_ExtendedString theFile) -> Standard_Boolean

        Save the model to a file

        :type theFile: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_SaveAs(self, *args)


    def Save(self, *args):
        """
        Save(Handle_TObj_Model self) -> Standard_Boolean

        Save the model to the same file

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_Save(self, *args)


    def Close(self, *args):
        """
        Close(Handle_TObj_Model self) -> Standard_Boolean

        Close the model

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_Close(self, *args)


    def CloseDocument(self, *args):
        """
        CloseDocument(Handle_TObj_Model self, Handle_TDocStd_Document theDoc)

        Close Free OCAF document

        :type theDoc: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Model_CloseDocument(self, *args)


    def GetDocumentModel(self, *args):
        """
        GetDocumentModel(Handle_TObj_Model self, TDF_Label theLabel) -> Handle_TObj_Model

        Returns model which contains a document with the label,
        or NULL handle if label is NULL

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.Handle_TObj_Model_GetDocumentModel(self, *args)


    def GetFile(self, *args):
        """
        GetFile(Handle_TObj_Model self) -> Handle_TCollection_HExtendedString

        Returns the full file name this model is to be saved to, 
        or null if the model was not saved yet

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_Model_GetFile(self, *args)


    def GetObjects(self, *args):
        """
        GetObjects(Handle_TObj_Model self) -> Handle_TObj_ObjectIterator

        Returns an Iterator on all objects in the Model

        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Model_GetObjects(self, *args)


    def GetChildren(self, *args):
        """
        GetChildren(Handle_TObj_Model self) -> Handle_TObj_ObjectIterator

        Returns an Iterator on objects in the main partition

        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_Model_GetChildren(self, *args)


    def FindObject(self, *args):
        """
        FindObject(Handle_TObj_Model self, Handle_TCollection_HExtendedString theName, Handle_TObj_TNameContainer theDictionary) -> Handle_TObj_Object

        Returns an Object by given Name (or Null if not found).

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Model_FindObject(self, *args)


    def GetChecker(self, *args):
        """
        GetChecker(Handle_TObj_Model self) -> Handle_TObj_CheckModel

        Returns the tool checking model consistency.
        Descendant may redefine it to return its own tool.

        :rtype: OCC.wrapper.TObj.Handle_TObj_CheckModel

        """
        return _TObj.Handle_TObj_Model_GetChecker(self, *args)


    def GetRoot(self, *args):
        """
        GetRoot(Handle_TObj_Model self) -> Handle_TObj_Object

        Returns root object of model

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Model_GetRoot(self, *args)


    def GetMainPartition(self, *args):
        """
        GetMainPartition(Handle_TObj_Model self) -> Handle_TObj_Partition

        Returns root object of model

        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.Handle_TObj_Model_GetMainPartition(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_TObj_Model self) -> TDF_Label

        Returns OCAF label on which model data are stored.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Model_GetLabel(self, *args)


    def GetModelName(self, *args):
        """
        GetModelName(Handle_TObj_Model self) -> Handle_TCollection_HExtendedString

        Returns the name of the model

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_Model_GetModelName(self, *args)


    def SetNewName(self, *args):
        """
        SetNewName(Handle_TObj_Model self, Handle_TObj_Object theObject)

        Sets new unique name for the object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_Model_SetNewName(self, *args)


    def IsRegisteredName(self, *args):
        """
        IsRegisteredName(Handle_TObj_Model self, Handle_TCollection_HExtendedString theName, Handle_TObj_TNameContainer theDictionary) -> Standard_Boolean

        Returns True is name is registered in the names map
        The input argument may be NULL handle, then model check in own global container

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_IsRegisteredName(self, *args)


    def RegisterName(self, *args):
        """
        RegisterName(Handle_TObj_Model self, Handle_TCollection_HExtendedString theName, TDF_Label theLabel, Handle_TObj_TNameContainer theDictionary)

        Register name in the map
        The input argument may be NULL handle, then model check in own global container

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.Handle_TObj_Model_RegisterName(self, *args)


    def UnRegisterName(self, *args):
        """
        UnRegisterName(Handle_TObj_Model self, Handle_TCollection_HExtendedString theName, Handle_TObj_TNameContainer theDictionary)

        Unregisters name from the map
        The input argument may be NULL handle, then model check in own global container

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :type theDictionary: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.Handle_TObj_Model_UnRegisterName(self, *args)


    def HasOpenCommand(self, *args):
        """
        HasOpenCommand(Handle_TObj_Model self) -> Standard_Boolean

        Returns True if a Command transaction is open
        Starting, finishing the transaction

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_HasOpenCommand(self, *args)


    def OpenCommand(self, *args):
        """
        OpenCommand(Handle_TObj_Model self)

        Open a new command transaction.


        """
        return _TObj.Handle_TObj_Model_OpenCommand(self, *args)


    def CommitCommand(self, *args):
        """
        CommitCommand(Handle_TObj_Model self)

        Commit the Command transaction. Do nothing If there is no Command
        transaction open.


        """
        return _TObj.Handle_TObj_Model_CommitCommand(self, *args)


    def AbortCommand(self, *args):
        """
        AbortCommand(Handle_TObj_Model self)

        Abort the  Command  transaction. Do nothing If there is no Command
        transaction open.


        """
        return _TObj.Handle_TObj_Model_AbortCommand(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_TObj_Model self) -> Standard_Boolean

        Modification status

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_IsModified(self, *args)


    def SetModified(self, *args):
        """
        SetModified(Handle_TObj_Model self, Standard_Boolean const theModified)

        Sets modification status

        :type theModified: bool

        """
        return _TObj.Handle_TObj_Model_SetModified(self, *args)


    def GetApplication(self, *args):
        """
        GetApplication(Handle_TObj_Model self) -> Handle_TObj_Application

        Returns handle to static instance of the relevant application class

        :rtype: OCC.wrapper.TObj.Handle_TObj_Application

        """
        return _TObj.Handle_TObj_Model_GetApplication(self, *args)


    def GetFormat(self, *args):
        """
        GetFormat(Handle_TObj_Model self) -> TCollection_ExtendedString

        Returns the format for save/restore.
        This implementation returns "BinOcaf". The method should be redefined
        for those models that should use another format.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TObj.Handle_TObj_Model_GetFormat(self, *args)


    def GetFormatVersion(self, *args):
        """
        GetFormatVersion(Handle_TObj_Model self) -> Standard_Integer

        Returns the version of format stored in TObj file

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Model_GetFormatVersion(self, *args)


    def Update(self, *args):
        """
        Update(Handle_TObj_Model self) -> Standard_Boolean

        this method is called before activating this model

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_Update(self, *args)


    def GetGUID(self, *args):
        """
        GetGUID(Handle_TObj_Model self) -> Standard_GUID

        Defines interface GUID for TObj_Model

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.Handle_TObj_Model_GetGUID(self, *args)


    def GetDictionary(self, *args):
        """
        GetDictionary(Handle_TObj_Model self) -> Handle_TObj_TNameContainer

        Returns the map of names of the objects

        :rtype: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.Handle_TObj_Model_GetDictionary(self, *args)


    def GetDocument(self, *args):
        """
        GetDocument(Handle_TObj_Model self) -> Handle_TDocStd_Document

        Returns OCAF document of Model

        :rtype: OCC.wrapper.TDocStd.Handle_TDocStd_Document

        """
        return _TObj.Handle_TObj_Model_GetDocument(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_TObj_Model self, TDF_Label theLabel)

        Sets OCAF label on which model data are stored.
        Used by persistence mechanism.

        :type theLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_Model_SetLabel(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TObj_Model self, Handle_TObj_Model theModel, Handle_TDF_RelocationTable theRelocTable=0) -> Standard_Boolean

        Pastes me to the new model
        references will not be copied if theRelocTable is not 0
        if theRelocTable is not NULL theRelocTable is filled by objects

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TObj_Model self) -> Handle_TObj_Model

        This function have to create a new model with type like me

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.Handle_TObj_Model_NewEmpty(self, *args)


    def CopyReferences(self, *args):
        """
        CopyReferences(Handle_TObj_Model self, Handle_TObj_Model theTarget, Handle_TDF_RelocationTable theRelocTable)

        Copy references from me to the other

        :type theTarget: OCC.wrapper.TObj.Handle_TObj_Model
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_Model_CopyReferences(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_Model self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_Model_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Model_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_Model_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_Model self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_Model_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_Model self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_Model self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_Model self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_Model self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_Model_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_Model self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_Model_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_Model self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Model_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_Model self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_Model_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_Model self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_Model_DecrementRefCounter(self, *args)

Handle_TObj_Model_swigregister = _TObj.Handle_TObj_Model_swigregister
Handle_TObj_Model_swigregister(Handle_TObj_Model)

def Handle_TObj_Model_DownCast(thing):
    return _TObj.Handle_TObj_Model_DownCast(thing)
Handle_TObj_Model_DownCast = _TObj.Handle_TObj_Model_DownCast

class TObj_TObject(TDF.TDF_Attribute):
    """
    Purpose: OCAF Attribute to storing objects (interfaces) of OCAF-based 
    modelers in the OCAF tree.
    The persistency mechanism of the TObj_TObject allowes to save
    and restore objects of various subtypes without recompilation of the schema
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_TObject
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_TObject(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_TObject self) -> TObj_TObject

        Empty constructor


        """
        this = _TObj.new_TObj_TObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetID(*args):
        """
        GetID() -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.TObj_TObject_GetID(*args)

    GetID = staticmethod(GetID)

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.TObj_TObject_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(TObj_TObject self, TDF_Label theLabel, Handle_TObj_Object theElem) -> Handle_TObj_TObject
        Set(TObj_TObject self, Handle_TObj_Object theElem)

        Sets the TObj_Object object

        :type theElem: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_TObject_Set(self, *args)


    def Get(self, *args):
        """
        Get(TObj_TObject self) -> Handle_TObj_Object

        Returns the TObj_Object object

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_TObject_Get(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TObj_TObject self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TObject attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TObject_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(TObj_TObject self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TObject_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TObj_TObject self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_TObject_Paste(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(TObj_TObject self)

        Tell TObj_Object to die,
        i.e. (myElem->IsAlive() == false) after that


        """
        return _TObj.TObj_TObject_BeforeForget(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TObj_TObject self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Tell TObj_Object to rise from the dead,
        i.e. (myElem->IsAlive() == true) after that

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_TObject_AfterUndo(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_TObject_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_TObject_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_TObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_TObject
TObj_TObject_swigregister = _TObj.TObj_TObject_swigregister
TObj_TObject_swigregister(TObj_TObject)

def TObj_TObject_GetID(*args):
    """
    TObj_TObject_GetID() -> Standard_GUID

    This method is used in implementation of ID()

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TObj.TObj_TObject_GetID(*args)

def TObj_TObject_get_type_name(*args):
    """
    TObj_TObject_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_TObject_get_type_name(*args)

def TObj_TObject_get_type_descriptor(*args):
    """
    TObj_TObject_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_TObject_get_type_descriptor(*args)

class Handle_TObj_OcafObjectIterator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_OcafObjectIterator self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_OcafObjectIterator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_OcafObjectIterator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_OcafObjectIterator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_OcafObjectIterator self, TObj_OcafObjectIterator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_OcafObjectIterator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_OcafObjectIterator self, Handle_TObj_OcafObjectIterator theHandle) -> Handle_TObj_OcafObjectIterator
        assign(Handle_TObj_OcafObjectIterator self, TObj_OcafObjectIterator thePtr) -> Handle_TObj_OcafObjectIterator
        assign(Handle_TObj_OcafObjectIterator self, Handle_TObj_OcafObjectIterator theHandle) -> Handle_TObj_OcafObjectIterator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_OcafObjectIterator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_OcafObjectIterator self) -> TObj_OcafObjectIterator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_OcafObjectIterator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_OcafObjectIterator self) -> TObj_OcafObjectIterator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_OcafObjectIterator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_OcafObjectIterator self) -> TObj_OcafObjectIterator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_OcafObjectIterator___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_OcafObjectIterator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_OcafObjectIterator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_OcafObjectIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_OcafObjectIterator_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_OcafObjectIterator

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_OcafObjectIterator self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_OcafObjectIterator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_OcafObjectIterator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_OcafObjectIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def More(self, *args):
        """
        More(Handle_TObj_OcafObjectIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_OcafObjectIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_TObj_OcafObjectIterator self)

        Move to the next Item


        """
        return _TObj.Handle_TObj_OcafObjectIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TObj_OcafObjectIterator self) -> Handle_TObj_Object

        Returns the current item

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_OcafObjectIterator_Value(self, *args)


    def LabelValue(self, *args):
        """
        Returns the label of the current item

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TObj.Handle_TObj_OcafObjectIterator_LabelValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_OcafObjectIterator self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_OcafObjectIterator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_OcafObjectIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_OcafObjectIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_OcafObjectIterator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_OcafObjectIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_OcafObjectIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_OcafObjectIterator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_OcafObjectIterator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_OcafObjectIterator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_OcafObjectIterator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_OcafObjectIterator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_OcafObjectIterator self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_OcafObjectIterator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_OcafObjectIterator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_OcafObjectIterator_DecrementRefCounter(self, *args)

Handle_TObj_OcafObjectIterator_swigregister = _TObj.Handle_TObj_OcafObjectIterator_swigregister
Handle_TObj_OcafObjectIterator_swigregister(Handle_TObj_OcafObjectIterator)

def Handle_TObj_OcafObjectIterator_DownCast(thing):
    return _TObj.Handle_TObj_OcafObjectIterator_DownCast(thing)
Handle_TObj_OcafObjectIterator_DownCast = _TObj.Handle_TObj_OcafObjectIterator_DownCast

class Handle_TObj_TObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_TObject self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_TObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_TObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_TObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_TObject self, TObj_TObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_TObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_TObject self, Handle_TObj_TObject theHandle) -> Handle_TObj_TObject
        assign(Handle_TObj_TObject self, TObj_TObject thePtr) -> Handle_TObj_TObject
        assign(Handle_TObj_TObject self, Handle_TObj_TObject theHandle) -> Handle_TObj_TObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_TObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_TObject self) -> TObj_TObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_TObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_TObject self) -> TObj_TObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_TObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_TObject self) -> TObj_TObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_TObject___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_TObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_TObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_TObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_TObject_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_TObject

    def GetID(self, *args):
        """
        GetID(Handle_TObj_TObject self) -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.Handle_TObj_TObject_GetID(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.Handle_TObj_TObject_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TObj_TObject self, TDF_Label theLabel, Handle_TObj_Object theElem) -> Handle_TObj_TObject
        Set(Handle_TObj_TObject self, Handle_TObj_Object theElem)

        Sets the TObj_Object object

        :type theElem: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_TObject_Set(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TObj_TObject self) -> Handle_TObj_Object

        Returns the TObj_Object object

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_TObject_Get(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TObj_TObject self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TObject attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TObject_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TObj_TObject self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TObject_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TObj_TObject self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_TObject_Paste(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TObj_TObject self)

        Tell TObj_Object to die,
        i.e. (myElem->IsAlive() == false) after that


        """
        return _TObj.Handle_TObj_TObject_BeforeForget(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TObj_TObject self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Tell TObj_Object to rise from the dead,
        i.e. (myElem->IsAlive() == true) after that

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_AfterUndo(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_TObject self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_TObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TObj_TObject self, Standard_GUID arg2)
        SetID(Handle_TObj_TObject self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TObj.Handle_TObj_TObject_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TObj_TObject self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TObject_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TObj_TObject self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TObject_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TObj_TObject self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TObject_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TObj_TObject self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TObj_TObject self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TObj_TObject self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TObj_TObject self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TObj_TObject self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TObj_TObject self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TObject_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TObj_TObject self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TObj_TObject self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TObj.Handle_TObj_TObject_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TObj_TObject self)

        Something to do after adding an Attribute to a label.


        """
        return _TObj.Handle_TObj_TObject_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TObj_TObject self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TObject_BeforeRemoval(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TObj_TObject self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TObject_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_TObject self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TObj_TObject self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_BeforeUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TObj_TObject self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TObj.Handle_TObj_TObject_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TObj_TObject self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TObj.Handle_TObj_TObject_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TObj_TObject self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TObj_TObject self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TObject_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TObj_TObject self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TObj.Handle_TObj_TObject_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TObj_TObject self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TObj.Handle_TObj_TObject_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TObj_TObject self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TObj.Handle_TObj_TObject_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TObj_TObject self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TObj.Handle_TObj_TObject_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TObj_TObject self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TObj.Handle_TObj_TObject_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TObj_TObject self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TObject_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TObj_TObject self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TObject___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TObj_TObject self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TObj.Handle_TObj_TObject_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TObj_TObject self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TObj.Handle_TObj_TObject_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_TObject self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_TObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_TObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_TObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_TObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_TObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_TObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_TObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_TObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_TObject self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_TObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_TObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TObject_DecrementRefCounter(self, *args)

Handle_TObj_TObject_swigregister = _TObj.Handle_TObj_TObject_swigregister
Handle_TObj_TObject_swigregister(Handle_TObj_TObject)

def Handle_TObj_TObject_DownCast(thing):
    return _TObj.Handle_TObj_TObject_DownCast(thing)
Handle_TObj_TObject_DownCast = _TObj.Handle_TObj_TObject_DownCast

class TObj_TXYZ(TDF.TDF_Attribute):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_TXYZ
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_TXYZ(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_TXYZ self) -> TObj_TXYZ

        Empty constructor


        """
        this = _TObj.new_TObj_TXYZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetID(*args):
        """
        GetID() -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.TObj_TXYZ_GetID(*args)

    GetID = staticmethod(GetID)

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.TObj_TXYZ_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(TObj_TXYZ self, TDF_Label theLabel, gp_XYZ theXYZ) -> Handle_TObj_TXYZ
        Set(TObj_TXYZ self, gp_XYZ theXYZ)

        Sets the XYZ

        :type theXYZ: OCC.wrapper.gp.gp_XYZ

        """
        return _TObj.TObj_TXYZ_Set(self, *args)


    def Get(self, *args):
        """
        Get(TObj_TXYZ self) -> gp_XYZ

        Returns the XYZ

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _TObj.TObj_TXYZ_Get(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TObj_TXYZ self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TXYZ attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TXYZ_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(TObj_TXYZ self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.TObj_TXYZ_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TObj_TXYZ self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.TObj_TXYZ_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TObj_TXYZ self, Standard_OStream & theOS) -> Standard_OStream &

        This method dumps the attribute value into the stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.TObj_TXYZ_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_TXYZ_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_TXYZ_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_TXYZ_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_TXYZ
TObj_TXYZ_swigregister = _TObj.TObj_TXYZ_swigregister
TObj_TXYZ_swigregister(TObj_TXYZ)

def TObj_TXYZ_GetID(*args):
    """
    TObj_TXYZ_GetID() -> Standard_GUID

    This method is used in implementation of ID()

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TObj.TObj_TXYZ_GetID(*args)

def TObj_TXYZ_get_type_name(*args):
    """
    TObj_TXYZ_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_TXYZ_get_type_name(*args)

def TObj_TXYZ_get_type_descriptor(*args):
    """
    TObj_TXYZ_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_TXYZ_get_type_descriptor(*args)

class Handle_TObj_ObjectIterator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_ObjectIterator self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_ObjectIterator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_ObjectIterator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_ObjectIterator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_ObjectIterator self, TObj_ObjectIterator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_ObjectIterator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_ObjectIterator self, Handle_TObj_ObjectIterator theHandle) -> Handle_TObj_ObjectIterator
        assign(Handle_TObj_ObjectIterator self, TObj_ObjectIterator thePtr) -> Handle_TObj_ObjectIterator
        assign(Handle_TObj_ObjectIterator self, Handle_TObj_ObjectIterator theHandle) -> Handle_TObj_ObjectIterator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_ObjectIterator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_ObjectIterator self) -> TObj_ObjectIterator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_ObjectIterator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_ObjectIterator self) -> TObj_ObjectIterator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_ObjectIterator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_ObjectIterator self) -> TObj_ObjectIterator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_ObjectIterator___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_ObjectIterator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_ObjectIterator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_ObjectIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_ObjectIterator_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_ObjectIterator

    def More(self, *args):
        """
        More(Handle_TObj_ObjectIterator self) -> Standard_Boolean

        Returns True if iteration is not finished and method Current()
        will give the object.
        Default implementation returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ObjectIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_TObj_ObjectIterator self)

        Iterates to the next object
        Default implementation does nothing


        """
        return _TObj.Handle_TObj_ObjectIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TObj_ObjectIterator self) -> Handle_TObj_Object

        Returns current object (or null if iteration has finished)
        Default implementation returns null handle

        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_ObjectIterator_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_ObjectIterator self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_ObjectIterator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_ObjectIterator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_ObjectIterator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_ObjectIterator self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_ObjectIterator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_ObjectIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_ObjectIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ObjectIterator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_ObjectIterator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_ObjectIterator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_ObjectIterator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_ObjectIterator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_ObjectIterator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_ObjectIterator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_ObjectIterator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_ObjectIterator self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_ObjectIterator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_ObjectIterator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_ObjectIterator_DecrementRefCounter(self, *args)

Handle_TObj_ObjectIterator_swigregister = _TObj.Handle_TObj_ObjectIterator_swigregister
Handle_TObj_ObjectIterator_swigregister(Handle_TObj_ObjectIterator)

def Handle_TObj_ObjectIterator_DownCast(thing):
    return _TObj.Handle_TObj_ObjectIterator_DownCast(thing)
Handle_TObj_ObjectIterator_DownCast = _TObj.Handle_TObj_ObjectIterator_DownCast

class TObj_Persistence(object):
    """
    This class is intended to be a root of tools (one per class)
    to manage persistence of objects inherited from TObj_Object
    It provides a mechanism to recover correctly typed
    objects (subtypes of TObj_Object) out of their persistent names

    This is a special kind of object, it automatically registers itself
    in a global map when created, and the only thing it does is to
    create a new object of the type that it manages, by request
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CreateNewObject(*args):
        """
        CreateNewObject(Standard_CString const theType, TDF_Label theLabel) -> Handle_TObj_Object

        Creates and returns a new object of the registered type
        If the type is not registered, returns Null handle

        :type theType: OCC.wrapper.Standard.Standard_CString
        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.TObj_Persistence_CreateNewObject(*args)

    CreateNewObject = staticmethod(CreateNewObject)

    def DumpTypes(*args):
        """
        DumpTypes(Standard_OStream & theOs)

        Dumps names of all the types registered for persistence to the
        specified stream

        :type theOs: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.TObj_Persistence_DumpTypes(*args)

    DumpTypes = staticmethod(DumpTypes)
TObj_Persistence_swigregister = _TObj.TObj_Persistence_swigregister
TObj_Persistence_swigregister(TObj_Persistence)

def TObj_Persistence_CreateNewObject(*args):
    """
    TObj_Persistence_CreateNewObject(Standard_CString const theType, TDF_Label theLabel) -> Handle_TObj_Object

    Creates and returns a new object of the registered type
    If the type is not registered, returns Null handle

    :type theType: OCC.wrapper.Standard.Standard_CString
    :type theLabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TObj.Handle_TObj_Object

    """
    return _TObj.TObj_Persistence_CreateNewObject(*args)

def TObj_Persistence_DumpTypes(*args):
    """
    TObj_Persistence_DumpTypes(Standard_OStream & theOs)

    Dumps names of all the types registered for persistence to the
    specified stream

    :type theOs: OCC.wrapper.Standard.Standard_OStream

    """
    return _TObj.TObj_Persistence_DumpTypes(*args)

class Handle_TObj_HiddenPartition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_HiddenPartition self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_HiddenPartition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_HiddenPartition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_HiddenPartition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_HiddenPartition self, TObj_HiddenPartition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_HiddenPartition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_HiddenPartition self, Handle_TObj_HiddenPartition theHandle) -> Handle_TObj_HiddenPartition
        assign(Handle_TObj_HiddenPartition self, TObj_HiddenPartition thePtr) -> Handle_TObj_HiddenPartition
        assign(Handle_TObj_HiddenPartition self, Handle_TObj_HiddenPartition theHandle) -> Handle_TObj_HiddenPartition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_HiddenPartition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_HiddenPartition self) -> TObj_HiddenPartition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_HiddenPartition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_HiddenPartition self) -> TObj_HiddenPartition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_HiddenPartition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_HiddenPartition self) -> TObj_HiddenPartition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_HiddenPartition___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_HiddenPartition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_HiddenPartition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_HiddenPartition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_HiddenPartition_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_HiddenPartition

    def GetTypeFlags(self, *args):
        """
        GetTypeFlags(Handle_TObj_HiddenPartition self) -> Standard_Integer

        Returns all flags of father except Visible

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HiddenPartition_GetTypeFlags(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_HiddenPartition self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_HiddenPartition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_HiddenPartition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_HiddenPartition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Create(self, *args):
        """
        Create(Handle_TObj_HiddenPartition self, TDF_Label theLabel) -> Handle_TObj_Partition

        Creates a new partition on given label.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.Handle_TObj_HiddenPartition_Create(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_TObj_HiddenPartition self, Handle_TCollection_HExtendedString theName) -> Standard_Boolean

        Sets name of the object. partition does not check unique of own name

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_SetName(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_HiddenPartition self)

        Preforms updating the links and dependances of the object which are not
        stored in persistence. Does not register the partition name


        """
        return _TObj.Handle_TObj_HiddenPartition_AfterRetrieval(self, *args)


    def NewLabel(self, *args):
        """
        NewLabel(Handle_TObj_HiddenPartition self) -> TDF_Label

        Creates and Returns label for new object in partition.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_HiddenPartition_NewLabel(self, *args)


    def SetNamePrefix(self, *args):
        """
        SetNamePrefix(Handle_TObj_HiddenPartition self, Handle_TCollection_HExtendedString thePrefix)

        Sets prefix for names of the objects in partition.

        :type thePrefix: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_HiddenPartition_SetNamePrefix(self, *args)


    def GetNamePrefix(self, *args):
        """
        GetNamePrefix(Handle_TObj_HiddenPartition self) -> Handle_TCollection_HExtendedString

        Returns prefix for names of the objects in partition.

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_HiddenPartition_GetNamePrefix(self, *args)


    def GetNewName(self, *args):
        """
        GetNewName(Handle_TObj_HiddenPartition self, Standard_Boolean const theIsToChangeCount) -> Handle_TCollection_HExtendedString

        Generates and returns name for new object in partition.
        if theIsToChangeCount is true partition icrease own counter
        to generate new name next time starting from new counter value

        :type theIsToChangeCount: bool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_HiddenPartition_GetNewName(self, *args)


    def GetLastIndex(self, *args):
        """
        GetLastIndex(Handle_TObj_HiddenPartition self) -> Standard_Integer

        Return Last index in partition (reserved);

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HiddenPartition_GetLastIndex(self, *args)


    def SetLastIndex(self, *args):
        """
        SetLastIndex(Handle_TObj_HiddenPartition self, Standard_Integer const theIndex)

        Sets Last index in partition (reserved);

        :type theIndex: int

        """
        return _TObj.Handle_TObj_HiddenPartition_SetLastIndex(self, *args)


    def GetPartition(self, *args):
        """
        GetPartition(Handle_TObj_HiddenPartition self, Handle_TObj_Object theObject) -> Handle_TObj_Partition

        Returns the partition in which object is stored. Null partition
        returned if not found

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.TObj.Handle_TObj_Partition

        """
        return _TObj.Handle_TObj_HiddenPartition_GetPartition(self, *args)


    def Update(self, *args):
        """
        Update(Handle_TObj_HiddenPartition self) -> Standard_Boolean

        Does nothing in the partition.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_Update(self, *args)


    def GetModel(self, *args):
        """
        GetModel(Handle_TObj_HiddenPartition self) -> Handle_TObj_Model

        Returns the model to which the object belongs

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        return _TObj.Handle_TObj_HiddenPartition_GetModel(self, *args)


    def GetChildren(self, *args):
        """
        GetChildren(Handle_TObj_HiddenPartition self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the child objects.
        This method provides tree-like view of the objects hierarchy.
        The references to other objects are not considered as children.
        theType narrows a variety of iterated objects
        The default implementation search for children on 1 sublavel
        of the children sub label

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_HiddenPartition_GetChildren(self, *args)


    def GetChildLabel(self, *args):
        """
        GetChildLabel(Handle_TObj_HiddenPartition self) -> TDF_Label

        Returns the label under which children are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_HiddenPartition_GetChildLabel(self, *args)


    def getChildLabel(self, *args):
        """
        getChildLabel(Handle_TObj_HiddenPartition self, Standard_Integer const theRank) -> TDF_Label

        Returns the label for child with rank

        :type theRank: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_HiddenPartition_getChildLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_TObj_HiddenPartition self) -> TDF_Label

        Returns the OCAF label on which object`s data are stored

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_HiddenPartition_GetLabel(self, *args)


    def GetDataLabel(self, *args):
        """
        GetDataLabel(Handle_TObj_HiddenPartition self) -> TDF_Label

        Returns the label which is the root for data OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_HiddenPartition_GetDataLabel(self, *args)


    def GetReferenceLabel(self, *args):
        """
        GetReferenceLabel(Handle_TObj_HiddenPartition self) -> TDF_Label

        Returns the label which is the root for reference OCAF sub-tree

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_HiddenPartition_GetReferenceLabel(self, *args)


    def GetDictionary(self, *args):
        """
        GetDictionary(Handle_TObj_HiddenPartition self) -> Handle_TObj_TNameContainer

        Returns the map of names of the objects
        Default implementation returns global Dictionary of the model

        :rtype: OCC.wrapper.TObj.Handle_TObj_TNameContainer

        """
        return _TObj.Handle_TObj_HiddenPartition_GetDictionary(self, *args)


    def GetName(self, *args):
        """
        GetName(Handle_TObj_HiddenPartition self) -> Handle_TCollection_HExtendedString
        GetName(Handle_TObj_HiddenPartition self, TCollection_ExtendedString theName) -> Standard_Boolean
        GetName(Handle_TObj_HiddenPartition self, TCollection_AsciiString theName) -> Standard_Boolean

        Returns the Standard_True is object has name and returns name to theName

        :type theName: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_GetName(self, *args)


    def GetNameForClone(self, *args):
        """
        GetNameForClone(Handle_TObj_HiddenPartition self, Handle_TObj_Object arg2) -> Handle_TCollection_HExtendedString

        Returns name for copy
        default implementation returns the same name

        :type : OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HExtendedString

        """
        return _TObj.Handle_TObj_HiddenPartition_GetNameForClone(self, *args)


    def HasReference(self, *args):
        """
        HasReference(Handle_TObj_HiddenPartition self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if object has reference to indicated object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_HasReference(self, *args)


    def GetReferences(self, *args):
        """
        GetReferences(Handle_TObj_HiddenPartition self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns an Iterator containing objects that compose the this one
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_HiddenPartition_GetReferences(self, *args)


    def RemoveAllReferences(self, *args):
        """
        RemoveAllReferences(Handle_TObj_HiddenPartition self)

        Remove all references to other objects, by removing all reference attributes


        """
        return _TObj.Handle_TObj_HiddenPartition_RemoveAllReferences(self, *args)


    def GetBackReferences(self, *args):
        """
        GetBackReferences(Handle_TObj_HiddenPartition self, Handle_Standard_Type theType=0) -> Handle_TObj_ObjectIterator

        Returns iterator for the objects which depend on this one.
        These reffering objects may belong to other models.
        theType narrows a variety of iterated objects

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_ObjectIterator

        """
        return _TObj.Handle_TObj_HiddenPartition_GetBackReferences(self, *args)


    def AddBackReference(self, *args):
        """
        AddBackReference(Handle_TObj_HiddenPartition self, Handle_TObj_Object theObject)

        Registers another object as being dependent on this one.
        Stores back references under sublabel 2 (purely transient data,
        not subject to persistency).

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_HiddenPartition_AddBackReference(self, *args)


    def RemoveBackReference(self, *args):
        """
        RemoveBackReference(Handle_TObj_HiddenPartition self, Handle_TObj_Object theObject, Standard_Boolean const theSingleOnly)

        Removes information on dependent object (back reference).
        If theSingleOnly is true only the first back reference is removed in the 
        case of duplicate items.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theSingleOnly: bool

        """
        return _TObj.Handle_TObj_HiddenPartition_RemoveBackReference(self, *args)


    def RemoveBackReferences(self, *args):
        """
        RemoveBackReferences(Handle_TObj_HiddenPartition self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Removes all back reference by removing references from other to me.

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_RemoveBackReferences(self, *args)


    def ClearBackReferences(self, *args):
        """
        ClearBackReferences(Handle_TObj_HiddenPartition self)

        The default implementation just clear the back references container


        """
        return _TObj.Handle_TObj_HiddenPartition_ClearBackReferences(self, *args)


    def HasBackReferences(self, *args):
        """
        HasBackReferences(Handle_TObj_HiddenPartition self) -> Standard_Boolean

        Returns TRUE if obejct has 1 or more back references

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_HasBackReferences(self, *args)


    def ReplaceReference(self, *args):
        """
        ReplaceReference(Handle_TObj_HiddenPartition self, Handle_TObj_Object theOldObject, Handle_TObj_Object theNewObject)

        Replace reference from old object to new object.
        If it is not possible, may raise exception.
        If new object is null then simple remove reference to old object.

        :type theOldObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theNewObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_HiddenPartition_ReplaceReference(self, *args)


    def GetBadReference(self, *args):
        """
        GetBadReference(Handle_TObj_HiddenPartition self, TDF_Label theRoot, TDF_Label theBadReference) -> Standard_Boolean

        Return True if this refers to the model theRoot belongs
        to and a referred label is not a descendant of theRoot.
        In this case theBadReference returns the currently referred label.

        :type theRoot: OCC.wrapper.TDF.TDF_Label
        :type theBadReference: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_GetBadReference(self, *args)


    def RelocateReferences(self, *args):
        """
        RelocateReferences(Handle_TObj_HiddenPartition self, TDF_Label theFromRoot, TDF_Label theToRoot, Standard_Boolean const theUpdateBackRefs) -> Standard_Boolean

        Make that each reference pointing to a descendant label of
        theFromRoot to point to an equivalent label under theToRoot.
        Return False if a resulting reference does not point to
        an TObj_Object
        Example:
        a referred object label = 0:3:24:7:2:7
        theFromRoot             = 0:3:24
        theToRoot               = 0:2
        a new referred label    = 0:2:7:2:7

        :type theFromRoot: OCC.wrapper.TDF.TDF_Label
        :type theToRoot: OCC.wrapper.TDF.TDF_Label
        :type theUpdateBackRefs: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_RelocateReferences(self, *args)


    def CanRemoveReference(self, *args):
        """
        CanRemoveReference(Handle_TObj_HiddenPartition self, Handle_TObj_Object theObject) -> Standard_Boolean

        Returns True if the referred object theObject can be deleted 
        without deletion of this object.
        Default implementation does nothing and returns False.

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_CanRemoveReference(self, *args)


    def RemoveReference(self, *args):
        """
        RemoveReference(Handle_TObj_HiddenPartition self, Handle_TObj_Object theObject)

        Removes reference to the object by replace reference to NULL object

        :type theObject: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_HiddenPartition_RemoveReference(self, *args)


    def BeforeForgetReference(self, *args):
        """
        BeforeForgetReference(Handle_TObj_HiddenPartition self, TDF_Label arg2)

        Invokes from TObj_TReference::BeforeForget().
        theLabel - label on that reference become removed
        Default implementation is empty

        :type : OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_HiddenPartition_BeforeForgetReference(self, *args)


    def CanDetach(self, *args):
        """
        CanDetach(Handle_TObj_HiddenPartition self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Checks if object can be detached with specified mode

        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_CanDetach(self, *args)


    def Detach(self, *args):
        """
        Detach(Handle_TObj_HiddenPartition self, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean
        Detach(Handle_TObj_HiddenPartition self, TDF_Label theLabel, TObj_DeletingMode const theMode=TObj_FreeOnly) -> Standard_Boolean

        Deletes the object from the label. Checks if object can be deleted.
        Finds object on the label and detaches it by calling previos method.
        Returns true if there is no object on the label after detaching

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theMode: OCC.wrapper.TObj.TObj_DeletingMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_Detach(self, *args)


    def GetObj(self, *args):
        """
        GetObj(Handle_TObj_HiddenPartition self, TDF_Label theLabel, Handle_TObj_Object theResult, Standard_Boolean const isSuper) -> Standard_Boolean

        Returns the Object attached to a given label.
        Returns False if no object of type TObj_Object is stored on the
        specified label.
        If isSuper is true tries to find on the super labels.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :type theResult: OCC.wrapper.TObj.Handle_TObj_Object
        :type isSuper: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_GetObj(self, *args)


    def GetFatherObject(self, *args):
        """
        GetFatherObject(Handle_TObj_HiddenPartition self, Handle_Standard_Type theType=0) -> Handle_TObj_Object

        Returns the father object, which may be NULL
        theType gives type of father object to search

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_HiddenPartition_GetFatherObject(self, *args)


    def IsAlive(self, *args):
        """
        IsAlive(Handle_TObj_HiddenPartition self) -> Standard_Boolean

        Checks that object alive in model
        Default implementation checks that object has TObject attribute at own label.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_IsAlive(self, *args)


    def Clone(self, *args):
        """
        Clone(Handle_TObj_HiddenPartition self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable=0) -> Handle_TObj_Object

        Copy me to other label theTargetLabel
        New object will not have all the reference that has me.
        Coping object with data and childs, but change name by adding string "_copy"
        As result return handle of new object (null handle is something wrong)
        NOTE: BackReferences not coping.
        After clonning all objects it is neccessary to call copy references
        with the same relocation table

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :rtype: OCC.wrapper.TObj.Handle_TObj_Object

        """
        return _TObj.Handle_TObj_HiddenPartition_Clone(self, *args)


    def CopyReferences(self, *args):
        """
        CopyReferences(Handle_TObj_HiddenPartition self, Handle_TObj_Object theTargetObject, Handle_TDF_RelocationTable theRelocTable)

        Coping the references.
        return Standard_False is Target object is different type

        :type theTargetObject: OCC.wrapper.TObj.Handle_TObj_Object
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_HiddenPartition_CopyReferences(self, *args)


    def CopyChildren(self, *args):
        """
        CopyChildren(Handle_TObj_HiddenPartition self, TDF_Label theTargetLabel, Handle_TDF_RelocationTable theRelocTable)

        Coping the children from source label to the target.

        :type theTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type theRelocTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_HiddenPartition_CopyChildren(self, *args)


    def GetOrder(self, *args):
        """
        GetOrder(Handle_TObj_HiddenPartition self) -> Standard_Integer

        returns order of object (or tag of their label if order is not initialised)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HiddenPartition_GetOrder(self, *args)


    def SetOrder(self, *args):
        """
        SetOrder(Handle_TObj_HiddenPartition self, Standard_Integer const & theIndx) -> Standard_Boolean

        sets order of object

        :type theIndx: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_SetOrder(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_TObj_HiddenPartition self) -> Standard_Integer

        Returns mask of seted flags

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HiddenPartition_GetFlags(self, *args)


    def SetFlags(self, *args):
        """
        SetFlags(Handle_TObj_HiddenPartition self, Standard_Integer const theMask)

        Sets flags with defined mask.

        :type theMask: int

        """
        return _TObj.Handle_TObj_HiddenPartition_SetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_TObj_HiddenPartition self, Standard_Integer const theMask) -> Standard_Boolean

        tests flags by the mask.

        :type theMask: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_TestFlags(self, *args)


    def ClearFlags(self, *args):
        """
        ClearFlags(Handle_TObj_HiddenPartition self, Standard_Integer const theMask)

        clears flags by the mask.

        :type theMask: int

        """
        return _TObj.Handle_TObj_HiddenPartition_ClearFlags(self, *args)


    def BeforeStoring(self, *args):
        """
        BeforeStoring(Handle_TObj_HiddenPartition self)

        Preforms storing the objects transient fields in OCAF document
        which were outside transaction mechanism.
        Default implementation doesnot nothing


        """
        return _TObj.Handle_TObj_HiddenPartition_BeforeStoring(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_HiddenPartition self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_HiddenPartition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_HiddenPartition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_HiddenPartition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_HiddenPartition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_HiddenPartition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HiddenPartition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_HiddenPartition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_HiddenPartition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_HiddenPartition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HiddenPartition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_HiddenPartition self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_HiddenPartition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_HiddenPartition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HiddenPartition_DecrementRefCounter(self, *args)

Handle_TObj_HiddenPartition_swigregister = _TObj.Handle_TObj_HiddenPartition_swigregister
Handle_TObj_HiddenPartition_swigregister(Handle_TObj_HiddenPartition)

def Handle_TObj_HiddenPartition_DownCast(thing):
    return _TObj.Handle_TObj_HiddenPartition_DownCast(thing)
Handle_TObj_HiddenPartition_DownCast = _TObj.Handle_TObj_HiddenPartition_DownCast

class Handle_TObj_HSequenceOfObject(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_HSequenceOfObject self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_HSequenceOfObject_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_HSequenceOfObject self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_HSequenceOfObject_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_HSequenceOfObject self, TObj_HSequenceOfObject thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_HSequenceOfObject_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_HSequenceOfObject self, Handle_TObj_HSequenceOfObject theHandle) -> Handle_TObj_HSequenceOfObject
        assign(Handle_TObj_HSequenceOfObject self, TObj_HSequenceOfObject thePtr) -> Handle_TObj_HSequenceOfObject
        assign(Handle_TObj_HSequenceOfObject self, Handle_TObj_HSequenceOfObject theHandle) -> Handle_TObj_HSequenceOfObject

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_HSequenceOfObject_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_HSequenceOfObject self) -> TObj_HSequenceOfObject

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_HSequenceOfObject_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_HSequenceOfObject self) -> TObj_HSequenceOfObject

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_HSequenceOfObject___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_HSequenceOfObject self) -> TObj_HSequenceOfObject

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_HSequenceOfObject___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_HSequenceOfObject___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_HSequenceOfObject___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_HSequenceOfObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_HSequenceOfObject_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_HSequenceOfObject

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TObj.TObj_SequenceOfObject

        """
        res = _TObj.Handle_TObj_HSequenceOfObject_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        return _TObj.Handle_TObj_HSequenceOfObject_Append(self, *args)

    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TObj_HSequenceOfObject self) -> NCollection_Sequence_Handle_TObj_Object

        :rtype: OCC.wrapper.TObj.TObj_SequenceOfObject

        """
        return _TObj.Handle_TObj_HSequenceOfObject_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_HSequenceOfObject self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_HSequenceOfObject_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_HSequenceOfObject_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_HSequenceOfObject_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TObj_HSequenceOfObject self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_HSequenceOfObject_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_HSequenceOfObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_HSequenceOfObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HSequenceOfObject_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_HSequenceOfObject self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_HSequenceOfObject self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_HSequenceOfObject_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_HSequenceOfObject self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_HSequenceOfObject_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_HSequenceOfObject self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HSequenceOfObject_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_HSequenceOfObject self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_HSequenceOfObject_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_HSequenceOfObject self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_HSequenceOfObject_DecrementRefCounter(self, *args)

Handle_TObj_HSequenceOfObject_swigregister = _TObj.Handle_TObj_HSequenceOfObject_swigregister
Handle_TObj_HSequenceOfObject_swigregister(Handle_TObj_HSequenceOfObject)

def Handle_TObj_HSequenceOfObject_DownCast(thing):
    return _TObj.Handle_TObj_HSequenceOfObject_DownCast(thing)
Handle_TObj_HSequenceOfObject_DownCast = _TObj.Handle_TObj_HSequenceOfObject_DownCast

class NCollection_Sequence_Handle_TObj_Object(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TObj_Object self) -> NCollection_Sequence< opencascade::handle< TObj_Object > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TObj_Object self) -> NCollection_Sequence< opencascade::handle< TObj_Object > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TObj_Object self) -> NCollection_Sequence< opencascade::handle< TObj_Object > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TObj_Object self) -> NCollection_Sequence< opencascade::handle< TObj_Object > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TObj.new_NCollection_Sequence_Handle_TObj_Object(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TObj_Object self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TObj_Object self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TObj_Object self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TObj_Object self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TObj_Object self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TObj_Object self)

        Reverse sequence


        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TObj_Object self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TObj_Object self, NCollection_Sequence_Handle_TObj_Object theOther) -> NCollection_Sequence_Handle_TObj_Object

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TObj_Object self, NCollection_Sequence_Handle_TObj_Object theOther) -> NCollection_Sequence_Handle_TObj_Object

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TObj_Object self, NCollection_Sequence< opencascade::handle< TObj_Object > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TObj_Object self, Handle_TObj_Object theItem)
        Append(NCollection_Sequence_Handle_TObj_Object self, NCollection_Sequence_Handle_TObj_Object theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TObj_Object self, Handle_TObj_Object theItem)
        Prepend(NCollection_Sequence_Handle_TObj_Object self, NCollection_Sequence_Handle_TObj_Object theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex, Handle_TObj_Object theItem)
        InsertBefore(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TObj_Object theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TObj_Object self, NCollection_Sequence< opencascade::handle< TObj_Object > >::Iterator & thePosition, Handle_TObj_Object theItem)
        InsertAfter(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TObj_Object theSeq)
        InsertAfter(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex, Handle_TObj_Object theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TObj_Object theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_Object_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TObj_Object self) -> Handle_TObj_Object

        First item access

        :rtype: TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_Object_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TObj_Object self) -> Handle_TObj_Object

        Last item access

        :rtype: TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_Object_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex) -> Handle_TObj_Object

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_Sequence_Handle_TObj_Object___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TObj_Object self, Standard_Integer const theIndex, Handle_TObj_Object theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TObj.NCollection_Sequence_Handle_TObj_Object_SetValue(self, *args)


    def __iter__(self):
        return _TObj.NCollection_Sequence_Handle_TObj_Object___iter__(self)
    __swig_destroy__ = _TObj.delete_NCollection_Sequence_Handle_TObj_Object
NCollection_Sequence_Handle_TObj_Object_swigregister = _TObj.NCollection_Sequence_Handle_TObj_Object_swigregister
NCollection_Sequence_Handle_TObj_Object_swigregister(NCollection_Sequence_Handle_TObj_Object)

def NCollection_Sequence_Handle_TObj_Object_delNode(*args):
    """
    NCollection_Sequence_Handle_TObj_Object_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TObj.NCollection_Sequence_Handle_TObj_Object_delNode(*args)

class NCollection_Sequence_Handle_TObj_Object_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TObj.new_NCollection_Sequence_Handle_TObj_Object_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TObj.delete_NCollection_Sequence_Handle_TObj_Object_IteratorHelper

    def __next__(self):
        return _TObj.NCollection_Sequence_Handle_TObj_Object_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TObj_Object_IteratorHelper_swigregister = _TObj.NCollection_Sequence_Handle_TObj_Object_IteratorHelper_swigregister
NCollection_Sequence_Handle_TObj_Object_IteratorHelper_swigregister(NCollection_Sequence_Handle_TObj_Object_IteratorHelper)


try:
	TObj_SequenceOfObject = NCollection_Sequence_Handle_TObj_Object
except NameError:
	pass # does not exist, probably ignored

class Handle_TObj_TIntSparseArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_TIntSparseArray self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_TIntSparseArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_TIntSparseArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_TIntSparseArray self, TObj_TIntSparseArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_TIntSparseArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_TIntSparseArray self, Handle_TObj_TIntSparseArray theHandle) -> Handle_TObj_TIntSparseArray
        assign(Handle_TObj_TIntSparseArray self, TObj_TIntSparseArray thePtr) -> Handle_TObj_TIntSparseArray
        assign(Handle_TObj_TIntSparseArray self, Handle_TObj_TIntSparseArray theHandle) -> Handle_TObj_TIntSparseArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_TIntSparseArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_TIntSparseArray self) -> TObj_TIntSparseArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_TIntSparseArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_TIntSparseArray self) -> TObj_TIntSparseArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_TIntSparseArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_TIntSparseArray self) -> TObj_TIntSparseArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_TIntSparseArray___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_TIntSparseArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_TIntSparseArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_TIntSparseArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_TIntSparseArray_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_TIntSparseArray

    def GetID(self, *args):
        """
        GetID(Handle_TObj_TIntSparseArray self) -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.Handle_TObj_TIntSparseArray_GetID(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.Handle_TObj_TIntSparseArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TObj_TIntSparseArray self, TDF_Label theLabel) -> Handle_TObj_TIntSparseArray

        Creates TObj_TIntSparseArray attribute on given label.

        :type theLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TObj.Handle_TObj_TIntSparseArray

        """
        return _TObj.Handle_TObj_TIntSparseArray_Set(self, *args)


    def Size(self, *args):
        """
        Size(Handle_TObj_TIntSparseArray self) -> Standard_Size

        Returns the number of stored values in the set

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _TObj.Handle_TObj_TIntSparseArray_Size(self, *args)


    def HasValue(self, *args):
        """
        HasValue(Handle_TObj_TIntSparseArray self, Standard_Size const theId) -> Standard_Boolean

        Returns true if the value with the given ID is present.

        :type theId: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_HasValue(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TObj_TIntSparseArray self, Standard_Size const theId) -> Standard_Integer

        Returns the value by its ID.
        Raises an exception if no value is stored with this ID

        :type theId: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TIntSparseArray_Value(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TObj_TIntSparseArray self, Standard_Size const theId, Standard_Integer const theValue)

        Sets the value with the given ID.
        Raises an exception if theId is not positive

        :type theId: int
        :type theValue: int

        """
        return _TObj.Handle_TObj_TIntSparseArray_SetValue(self, *args)


    def UnsetValue(self, *args):
        """
        UnsetValue(Handle_TObj_TIntSparseArray self, Standard_Size const theId)

        Unsets the value with the given ID.
        Raises an exception if theId is not positive

        :type theId: int

        """
        return _TObj.Handle_TObj_TIntSparseArray_UnsetValue(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_TObj_TIntSparseArray self)

        Clears the set


        """
        return _TObj.Handle_TObj_TIntSparseArray_Clear(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TObj_TIntSparseArray self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TIntSparseArray attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TIntSparseArray_NewEmpty(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TObj_TIntSparseArray self) -> Handle_TDF_Attribute

        Moves this delta into a new other attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TIntSparseArray_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TObj_TIntSparseArray self, Handle_TDF_Attribute theDelta)

        Restores the set using info saved in backup attribute theDelta.

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TIntSparseArray_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TObj_TIntSparseArray self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_TIntSparseArray_Paste(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TObj_TIntSparseArray self)

        It is called just before Commit or Abort transaction
        and does Backup() to create a delta


        """
        return _TObj.Handle_TObj_TIntSparseArray_BeforeCommitTransaction(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TObj_TIntSparseArray self, Handle_TDF_AttributeDelta theDelta, Standard_Boolean const toForce) -> Standard_Boolean

        Clears my modification delta; called after application of theDelta

        :type theDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type toForce: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_AfterUndo(self, *args)


    def SetDoBackup(self, *args):
        """
        SetDoBackup(Handle_TObj_TIntSparseArray self, Standard_Boolean const toDo)

        Sets the flag pointing to the necessity to maintain a modification delta.
        It is called by the retrieval driver

        :type toDo: bool

        """
        return _TObj.Handle_TObj_TIntSparseArray_SetDoBackup(self, *args)


    def ClearDelta(self, *args):
        """ClearDelta(Handle_TObj_TIntSparseArray self)"""
        return _TObj.Handle_TObj_TIntSparseArray_ClearDelta(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_TIntSparseArray self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_TIntSparseArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TIntSparseArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TIntSparseArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def getIterator(self):
        return _TObj.Handle_TObj_TIntSparseArray_getIterator(self)

    def SetID(self, *args):
        """
        SetID(Handle_TObj_TIntSparseArray self, Standard_GUID arg2)
        SetID(Handle_TObj_TIntSparseArray self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TObj.Handle_TObj_TIntSparseArray_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TObj_TIntSparseArray self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TIntSparseArray_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TObj_TIntSparseArray self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TIntSparseArray_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TObj_TIntSparseArray self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TIntSparseArray_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TObj_TIntSparseArray self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TObj_TIntSparseArray self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TObj_TIntSparseArray self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TObj_TIntSparseArray self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TObj_TIntSparseArray self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TObj_TIntSparseArray self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TIntSparseArray_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TObj_TIntSparseArray self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TObj_TIntSparseArray self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TObj.Handle_TObj_TIntSparseArray_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TObj_TIntSparseArray self)

        Something to do after adding an Attribute to a label.


        """
        return _TObj.Handle_TObj_TIntSparseArray_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TObj_TIntSparseArray self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TIntSparseArray_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TObj_TIntSparseArray self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TObj.Handle_TObj_TIntSparseArray_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TObj_TIntSparseArray self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TIntSparseArray_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_TIntSparseArray self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TObj_TIntSparseArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_BeforeUndo(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TObj_TIntSparseArray self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TObj.Handle_TObj_TIntSparseArray_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TObj_TIntSparseArray self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsBackuped(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TObj_TIntSparseArray self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TObj.Handle_TObj_TIntSparseArray_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TObj_TIntSparseArray self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TObj.Handle_TObj_TIntSparseArray_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TObj_TIntSparseArray self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TObj.Handle_TObj_TIntSparseArray_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TObj_TIntSparseArray self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TObj.Handle_TObj_TIntSparseArray_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TObj_TIntSparseArray self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TObj.Handle_TObj_TIntSparseArray_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TObj_TIntSparseArray self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TIntSparseArray_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TObj_TIntSparseArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TIntSparseArray___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TObj_TIntSparseArray self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TObj.Handle_TObj_TIntSparseArray_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TObj_TIntSparseArray self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TObj.Handle_TObj_TIntSparseArray_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_TIntSparseArray self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_TIntSparseArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_TIntSparseArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_TIntSparseArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_TIntSparseArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_TIntSparseArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TIntSparseArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_TIntSparseArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_TIntSparseArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_TIntSparseArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TIntSparseArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_TIntSparseArray self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_TIntSparseArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_TIntSparseArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TIntSparseArray_DecrementRefCounter(self, *args)

Handle_TObj_TIntSparseArray_swigregister = _TObj.Handle_TObj_TIntSparseArray_swigregister
Handle_TObj_TIntSparseArray_swigregister(Handle_TObj_TIntSparseArray)

def Handle_TObj_TIntSparseArray_DownCast(thing):
    return _TObj.Handle_TObj_TIntSparseArray_DownCast(thing)
Handle_TObj_TIntSparseArray_DownCast = _TObj.Handle_TObj_TIntSparseArray_DownCast

class TObj_CheckModel(Message.Message_Algorithm):
    """
    This class provides consistency check of the TObj model.
    It collects all inconsistencies in the status bits and prepaires
    messages to be sent using SendStatusMessages (SendMessages) method.
    It supports also the fix mode, in which some inconsistencies are
    corrected.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TObj_CheckModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TObj_CheckModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TObj_CheckModel self, Handle_TObj_Model theModel) -> TObj_CheckModel

        Initialize checker by model

        :type theModel: OCC.wrapper.TObj.Handle_TObj_Model

        """
        this = _TObj.new_TObj_CheckModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetToFix(self, *args):
        """
        SetToFix(TObj_CheckModel self, Standard_Boolean const theToFix)

        Sets flag allowing fixing inconsistencies

        :type theToFix: bool

        """
        return _TObj.TObj_CheckModel_SetToFix(self, *args)


    def IsToFix(self, *args):
        """
        IsToFix(TObj_CheckModel self) -> Standard_Boolean

        Returns true if it is allowed to fix inconsistencies

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_CheckModel_IsToFix(self, *args)


    def GetModel(self, *args):
        """
        Returns the checked model

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        res = _TObj.TObj_CheckModel_GetModel(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(TObj_CheckModel self) -> Standard_Boolean

        Performs all checks. Descendants should call parent method before
        doing own checks.
        This implementation checks OCAF references and back references
        between objects of the model.
        Returns true if no inconsistencies found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.TObj_CheckModel_Perform(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TObj.TObj_CheckModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TObj.TObj_CheckModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.TObj_CheckModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TObj.delete_TObj_CheckModel
TObj_CheckModel_swigregister = _TObj.TObj_CheckModel_swigregister
TObj_CheckModel_swigregister(TObj_CheckModel)

def TObj_CheckModel_get_type_name(*args):
    """
    TObj_CheckModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TObj.TObj_CheckModel_get_type_name(*args)

def TObj_CheckModel_get_type_descriptor(*args):
    """
    TObj_CheckModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TObj.TObj_CheckModel_get_type_descriptor(*args)

class Handle_TObj_CheckModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_CheckModel self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_CheckModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_CheckModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_CheckModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_CheckModel self, TObj_CheckModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_CheckModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_CheckModel self, Handle_TObj_CheckModel theHandle) -> Handle_TObj_CheckModel
        assign(Handle_TObj_CheckModel self, TObj_CheckModel thePtr) -> Handle_TObj_CheckModel
        assign(Handle_TObj_CheckModel self, Handle_TObj_CheckModel theHandle) -> Handle_TObj_CheckModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_CheckModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_CheckModel self) -> TObj_CheckModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_CheckModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_CheckModel self) -> TObj_CheckModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_CheckModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_CheckModel self) -> TObj_CheckModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_CheckModel___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_CheckModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_CheckModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_CheckModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_CheckModel_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_CheckModel

    def SetToFix(self, *args):
        """
        SetToFix(Handle_TObj_CheckModel self, Standard_Boolean const theToFix)

        Sets flag allowing fixing inconsistencies

        :type theToFix: bool

        """
        return _TObj.Handle_TObj_CheckModel_SetToFix(self, *args)


    def IsToFix(self, *args):
        """
        IsToFix(Handle_TObj_CheckModel self) -> Standard_Boolean

        Returns true if it is allowed to fix inconsistencies

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_CheckModel_IsToFix(self, *args)


    def GetModel(self, *args):
        """
        Returns the checked model

        :rtype: OCC.wrapper.TObj.Handle_TObj_Model

        """
        res = _TObj.Handle_TObj_CheckModel_GetModel(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(Handle_TObj_CheckModel self) -> Standard_Boolean

        Performs all checks. Descendants should call parent method before
        doing own checks.
        This implementation checks OCAF references and back references
        between objects of the model.
        Returns true if no inconsistencies found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_CheckModel_Perform(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_CheckModel self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_CheckModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_CheckModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_CheckModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetStatus(self, *args):
        """
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat)
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat, Standard_Integer const theInt)
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat, Standard_CString const theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat, TCollection_AsciiString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat, Handle_TCollection_HAsciiString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat, TCollection_ExtendedString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat, Handle_TCollection_HExtendedString theStr, Standard_Boolean const noRepetitions)
        SetStatus(Handle_TObj_CheckModel self, Message_Status const & theStat, Message_Msg theMsg)

        Sets status with preformatted message. This message will be
        used directly to report the status; automatic generation of
        status messages will be disabled for it.

        :type theStat: OCC.wrapper.Message.Message_Status
        :type theMsg: OCC.wrapper.Message.Message_Msg

        """
        return _TObj.Handle_TObj_CheckModel_SetStatus(self, *args)


    def GetStatus(self, *args):
        """
        Returns copy of exec status of algorithm

        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        res = _TObj.Handle_TObj_CheckModel_GetStatus(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeStatus(self, *args):
        """
        ChangeStatus(Handle_TObj_CheckModel self) -> Message_ExecStatus

        Returns exec status of algorithm

        :rtype: OCC.wrapper.Message.Message_ExecStatus

        """
        return _TObj.Handle_TObj_CheckModel_ChangeStatus(self, *args)


    def ClearStatus(self, *args):
        """
        ClearStatus(Handle_TObj_CheckModel self)

        Clear exec status of algorithm


        """
        return _TObj.Handle_TObj_CheckModel_ClearStatus(self, *args)


    def SetMessenger(self, *args):
        """
        SetMessenger(Handle_TObj_CheckModel self, Handle_Message_Messenger theMsgr)

        Sets messenger to algorithm

        :type theMsgr: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.Handle_TObj_CheckModel_SetMessenger(self, *args)


    def GetMessenger(self, *args):
        """
        GetMessenger(Handle_TObj_CheckModel self) -> Handle_Message_Messenger

        Returns messenger of algorithm.
        The returned handle is always non-null and can
        be used for sending messages.

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _TObj.Handle_TObj_CheckModel_GetMessenger(self, *args)


    def SendStatusMessages(self, *args):
        """
        SendStatusMessages(Handle_TObj_CheckModel self, Message_ExecStatus theFilter, Message_Gravity const theTraceLevel=Message_Warning, Standard_Integer const theMaxCount=20)

        Print messages for all status flags that have been set during
        algorithm execution, excluding statuses that are NOT set
        in theFilter.

        The messages are taken from resource file, names being
        constructed as {dynamic class type}.{status name},
        for instance, "Message_Algorithm.Fail5".
        If message is not found in resources for this class and all
        its base types, surrogate text is printed.

        For the statuses having number or string parameters,
        theMaxCount defines maximal number of numbers or strings to be
        included in the message

        Note that this method is virtual; this allows descendant
        classes to customize message output (e.g. by adding
        messages from other sub-algorithms)

        :type theFilter: OCC.wrapper.Message.Message_ExecStatus
        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity
        :type theMaxCount: int

        """
        return _TObj.Handle_TObj_CheckModel_SendStatusMessages(self, *args)


    def SendMessages(self, *args):
        """
        SendMessages(Handle_TObj_CheckModel self, Message_Gravity const theTraceLevel=Message_Warning, Standard_Integer const theMaxCount=20)

        Convenient variant of SendStatusMessages() with theFilter
        having defined all WARN, ALARM, and FAIL (but not DONE)
        status flags

        :type theTraceLevel: OCC.wrapper.Message.Message_Gravity
        :type theMaxCount: int

        """
        return _TObj.Handle_TObj_CheckModel_SendMessages(self, *args)


    def AddStatus(self, *args):
        """
        AddStatus(Handle_TObj_CheckModel self, Handle_Message_Algorithm theOther)
        AddStatus(Handle_TObj_CheckModel self, Message_ExecStatus theStatus, Handle_Message_Algorithm theOther)

        Add statuses to this algorithm from other algorithm, but
        only those items are moved that correspond to statuses
        set in theStatus

        :type theStatus: OCC.wrapper.Message.Message_ExecStatus
        :type theOther: OCC.wrapper.Message.Handle_Message_Algorithm

        """
        return _TObj.Handle_TObj_CheckModel_AddStatus(self, *args)


    def GetMessageNumbers(self, *args):
        """
        GetMessageNumbers(Handle_TObj_CheckModel self, Message_Status const & theStatus) -> Handle_TColStd_HPackedMapOfInteger

        Return the numbers associated with the indicated status;
        Null handle if no such status or no numbers associated with it

        :type theStatus: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _TObj.Handle_TObj_CheckModel_GetMessageNumbers(self, *args)


    def GetMessageStrings(self, *args):
        """
        GetMessageStrings(Handle_TObj_CheckModel self, Message_Status const & theStatus) -> Handle_TColStd_HSequenceOfHExtendedString

        Return the strings associated with the indicated status;
        Null handle if no such status or no strings associated with it

        :type theStatus: OCC.wrapper.Message.Message_Status
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHExtendedString

        """
        return _TObj.Handle_TObj_CheckModel_GetMessageStrings(self, *args)


    def PrepareReport(self, *args):
        """
        PrepareReport(Handle_TObj_CheckModel self, Handle_TColStd_HPackedMapOfInteger theError, Standard_Integer const theMaxCount) -> TCollection_ExtendedString
        PrepareReport(Handle_TObj_CheckModel self, NCollection_Sequence_Handle_TCollection_HExtendedString theReportSeq, Standard_Integer const theMaxCount) -> TCollection_ExtendedString

        Prepares a string containing a list of names contained
        in theReportSeq sequence, but not more than theMaxCount

        :type theReportSeq: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString
        :type theMaxCount: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TObj.Handle_TObj_CheckModel_PrepareReport(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_CheckModel self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_CheckModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_CheckModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_CheckModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_CheckModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_CheckModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_CheckModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_CheckModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_CheckModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_CheckModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_CheckModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_CheckModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_CheckModel self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_CheckModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_CheckModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_CheckModel_DecrementRefCounter(self, *args)

Handle_TObj_CheckModel_swigregister = _TObj.Handle_TObj_CheckModel_swigregister
Handle_TObj_CheckModel_swigregister(Handle_TObj_CheckModel)

def Handle_TObj_CheckModel_DownCast(thing):
    return _TObj.Handle_TObj_CheckModel_DownCast(thing)
Handle_TObj_CheckModel_DownCast = _TObj.Handle_TObj_CheckModel_DownCast

class Handle_TObj_TXYZ(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TObj_TXYZ self)

        Nullify the handle


        """
        return _TObj.Handle_TObj_TXYZ_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TObj_TXYZ self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TObj.Handle_TObj_TXYZ_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TObj_TXYZ self, TObj_TXYZ thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TObj.Handle_TObj_TXYZ_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TObj_TXYZ self, Handle_TObj_TXYZ theHandle) -> Handle_TObj_TXYZ
        assign(Handle_TObj_TXYZ self, TObj_TXYZ thePtr) -> Handle_TObj_TXYZ
        assign(Handle_TObj_TXYZ self, Handle_TObj_TXYZ theHandle) -> Handle_TObj_TXYZ

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TObj.Handle_TObj_TXYZ_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TObj_TXYZ self) -> TObj_TXYZ

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TObj.Handle_TObj_TXYZ_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TObj_TXYZ self) -> TObj_TXYZ

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TObj.Handle_TObj_TXYZ___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TObj_TXYZ self) -> TObj_TXYZ

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TObj.Handle_TObj_TXYZ___ref__(self, *args)


    def __hash__(self):
        return _TObj.Handle_TObj_TXYZ___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TObj.Handle_TObj_TXYZ___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TObj.new_Handle_TObj_TXYZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TObj.Handle_TObj_TXYZ_DownCast)
    __swig_destroy__ = _TObj.delete_Handle_TObj_TXYZ

    def GetID(self, *args):
        """
        GetID(Handle_TObj_TXYZ self) -> Standard_GUID

        This method is used in implementation of ID()

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TObj.Handle_TObj_TXYZ_GetID(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TObj.Handle_TObj_TXYZ_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TObj_TXYZ self, TDF_Label theLabel, gp_XYZ theXYZ) -> Handle_TObj_TXYZ
        Set(Handle_TObj_TXYZ self, gp_XYZ theXYZ)

        Sets the XYZ

        :type theXYZ: OCC.wrapper.gp.gp_XYZ

        """
        return _TObj.Handle_TObj_TXYZ_Set(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TObj_TXYZ self) -> gp_XYZ

        Returns the XYZ

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _TObj.Handle_TObj_TXYZ_Get(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TObj_TXYZ self) -> Handle_TDF_Attribute

        Returns an new empty TObj_TXYZ attribute. It is used by the
        copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TXYZ_NewEmpty(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TObj_TXYZ self, Handle_TDF_Attribute theWith)

        Restores the backuped contents from <theWith> into this one. It is used 
        when aborting a transaction.

        :type theWith: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TXYZ_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TObj_TXYZ self, Handle_TDF_Attribute theInto, Handle_TDF_RelocationTable theRT)

        This method is used when copying an attribute from a source structure
        into a target structure.

        :type theInto: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type theRT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TObj.Handle_TObj_TXYZ_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TObj_TXYZ self, Standard_OStream & theOS) -> Standard_OStream &

        This method dumps the attribute value into the stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TXYZ_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TObj_TXYZ self) -> char const *

        :rtype: const char *

        """
        return _TObj.Handle_TObj_TXYZ_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TXYZ_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TObj.Handle_TObj_TXYZ_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TObj_TXYZ self, Standard_GUID arg2)
        SetID(Handle_TObj_TXYZ self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TObj.Handle_TObj_TXYZ_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TObj_TXYZ self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TObj.Handle_TObj_TXYZ_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TObj_TXYZ self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TXYZ_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TObj_TXYZ self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TXYZ_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TObj_TXYZ self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TObj_TXYZ self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TObj_TXYZ self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TObj_TXYZ self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TObj_TXYZ self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TObj_TXYZ self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TXYZ_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TObj_TXYZ self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TObj_TXYZ self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TObj.Handle_TObj_TXYZ_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TObj_TXYZ self)

        Something to do after adding an Attribute to a label.


        """
        return _TObj.Handle_TObj_TXYZ_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TObj_TXYZ self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TXYZ_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TObj_TXYZ self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TObj.Handle_TObj_TXYZ_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TObj_TXYZ self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TObj.Handle_TObj_TXYZ_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TObj_TXYZ self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TObj_TXYZ self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TObj_TXYZ self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TObj_TXYZ self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TObj.Handle_TObj_TXYZ_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TObj_TXYZ self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TObj.Handle_TObj_TXYZ_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TObj_TXYZ self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TObj_TXYZ self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TObj.Handle_TObj_TXYZ_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TObj_TXYZ self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TObj.Handle_TObj_TXYZ_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TObj_TXYZ self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TObj.Handle_TObj_TXYZ_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TObj_TXYZ self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TObj.Handle_TObj_TXYZ_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TObj_TXYZ self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TObj.Handle_TObj_TXYZ_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TObj_TXYZ self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TObj.Handle_TObj_TXYZ_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TObj_TXYZ self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TObj.Handle_TObj_TXYZ___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TObj_TXYZ self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TObj.Handle_TObj_TXYZ_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TObj_TXYZ self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TObj.Handle_TObj_TXYZ_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TObj_TXYZ self)

        Memory deallocator for transient classes


        """
        return _TObj.Handle_TObj_TXYZ_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TObj_TXYZ self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TObj_TXYZ self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TObj_TXYZ self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TObj_TXYZ self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.Handle_TObj_TXYZ_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TObj_TXYZ self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TObj.Handle_TObj_TXYZ_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TObj_TXYZ self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TXYZ_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TObj_TXYZ self)

        Increments the reference counter of this object


        """
        return _TObj.Handle_TObj_TXYZ_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TObj_TXYZ self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TObj.Handle_TObj_TXYZ_DecrementRefCounter(self, *args)

Handle_TObj_TXYZ_swigregister = _TObj.Handle_TObj_TXYZ_swigregister
Handle_TObj_TXYZ_swigregister(Handle_TObj_TXYZ)

def Handle_TObj_TXYZ_DownCast(thing):
    return _TObj.Handle_TObj_TXYZ_DownCast(thing)
Handle_TObj_TXYZ_DownCast = _TObj.Handle_TObj_TXYZ_DownCast

class NCollection_SparseArray_Standard_Integer(NCollection.NCollection_SparseArrayBase):
    """
    Dynamically resizable sparse array of objects

    This class is similar to NCollection_Vector: it works like virtually
    unlimited array of items accessible by index; however unlike simple
    Vector it distinguishes items that have been set from the ones that
    have not been set explicitly.

    This class can be also seen as equivalence of
    NCollection_DataMap<Standard_Integer,TheItemType>
    with the only one practical difference: it can be much less 
    memory-expensive if items are small (e.g. Integer or Handle).

    The index starts from 0, i.e. should be non-negative. Memory is allocated
    when item is set by SetValue(). 

    Iterator returns only defined items; 
    the item can be tested for being defined by IsSet(), 
    and undefined by UnsetValue().

    The attempt to access the item that has not been set will result
    in OutOfRange exception in Debug mode; in Release mode this will either
    return null-filled object or cause access violation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, theIncrement):
        """
        Dynamically resizable sparse array of objects

        This class is similar to NCollection_Vector: it works like virtually
        unlimited array of items accessible by index; however unlike simple
        Vector it distinguishes items that have been set from the ones that
        have not been set explicitly.

        This class can be also seen as equivalence of
        NCollection_DataMap<Standard_Integer,TheItemType>
        with the only one practical difference: it can be much less 
        memory-expensive if items are small (e.g. Integer or Handle).

        The index starts from 0, i.e. should be non-negative. Memory is allocated
        when item is set by SetValue(). 

        Iterator returns only defined items; 
        the item can be tested for being defined by IsSet(), 
        and undefined by UnsetValue().

        The attempt to access the item that has not been set will result
        in OutOfRange exception in Debug mode; in Release mode this will either
        return null-filled object or cause access violation.
        """
        this = _TObj.new_NCollection_SparseArray_Standard_Integer(theIncrement)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(NCollection_SparseArray_Standard_Integer self, NCollection_SparseArray_Standard_Integer theOther) -> NCollection_SparseArray_Standard_Integer

        Explicit assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_SparseArray
        :rtype: OCC.wrapper.NCollection.NCollection_SparseArray

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_Assign(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_SparseArray_Standard_Integer self, NCollection_SparseArray_Standard_Integer theOther)

        Exchange the data of two arrays;
        can be used primarily to move contents of theOther into the new array
        in a fast way (without creation of duplicated data)

        :type theOther: OCC.wrapper.NCollection.NCollection_SparseArray

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_Exchange(self, *args)


    def Value(self, *args):
        """
        Direct const access to the item 

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_SparseArray_Standard_Integer_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_SparseArray_Standard_Integer self, Standard_Size const theIndex) -> int &

        Modification access to the item

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Const access to the item - operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_SparseArray_Standard_Integer___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_SparseArray_Standard_Integer self, Standard_Size const theIndex, int const & theValue) -> int &

        Set a value at specified index method

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_SetValue(self, *args)


    def Extent(self, *args):
        """
        Extent(NCollection_SparseArray_Standard_Integer self) -> Standard_Size

        Returns number of items in the array

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_SparseArray_Standard_Integer self) -> Standard_Boolean

        Returns True if array is empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_IsEmpty(self, *args)


    def Find(self, *args):
        """
        Direct const access to the item 

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TObj.NCollection_SparseArray_Standard_Integer_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_SparseArray_Standard_Integer self, Standard_Size const theIndex) -> int &

        Modification access to the item

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_ChangeFind(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_SparseArray_Standard_Integer self, Standard_Size const theIndex, int const & theValue) -> int &

        Set a value as explicit method

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_Bind(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_SparseArray_Standard_Integer self, Standard_Size const theIndex) -> Standard_Boolean

        Returns True if the item is defined

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_SparseArray_Standard_Integer self, Standard_Size const theIndex) -> Standard_Boolean

        Remove the item from array

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TObj.NCollection_SparseArray_Standard_Integer_UnBind(self, *args)

    __swig_destroy__ = _TObj.delete_NCollection_SparseArray_Standard_Integer
NCollection_SparseArray_Standard_Integer_swigregister = _TObj.NCollection_SparseArray_Standard_Integer_swigregister
NCollection_SparseArray_Standard_Integer_swigregister(NCollection_SparseArray_Standard_Integer)


try:
	TObj_TIntSparseArray_VecOfData = NCollection_SparseArray_Standard_Integer
except NameError:
	pass # does not exist, probably ignored




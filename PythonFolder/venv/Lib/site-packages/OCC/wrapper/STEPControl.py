# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_STEPControl')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_STEPControl')
    _STEPControl = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_STEPControl', [dirname(__file__)])
        except ImportError:
            import _STEPControl
            return _STEPControl
        try:
            _mod = imp.load_module('_STEPControl', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _STEPControl = swig_import_helper()
    del swig_import_helper
else:
    import _STEPControl
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _STEPControl.delete_SwigPyIterator

    def value(self):
        return _STEPControl.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _STEPControl.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _STEPControl.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _STEPControl.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _STEPControl.SwigPyIterator_equal(self, x)

    def copy(self):
        return _STEPControl.SwigPyIterator_copy(self)

    def next(self):
        return _STEPControl.SwigPyIterator_next(self)

    def __next__(self):
        return _STEPControl.SwigPyIterator___next__(self)

    def previous(self):
        return _STEPControl.SwigPyIterator_previous(self)

    def advance(self, n):
        return _STEPControl.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _STEPControl.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _STEPControl.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _STEPControl.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _STEPControl.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _STEPControl.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _STEPControl.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _STEPControl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPControl.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_STEPControl.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPControl.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPControl.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPControl.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _STEPControl.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _STEPControl.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _STEPControl.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPControl.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_STEPControl.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPControl.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPControl.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPControl.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _STEPControl.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _STEPControl.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _STEPControl.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _STEPControl.ptr_to_number(item)
ptr_to_number = _STEPControl.ptr_to_number

def HashCode(*args):
    return _STEPControl.HashCode(*args)
HashCode = _STEPControl.HashCode

def ptr_equal(a, b):
    return _STEPControl.ptr_equal(a, b)
ptr_equal = _STEPControl.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Transfer
else:
    import Transfer
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepShape
else:
    import StepShape
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TransferBRep
else:
    import TransferBRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XSControl
else:
    import XSControl
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFSelect
else:
    import IFSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
STEPControl_AsIs = _STEPControl.STEPControl_AsIs
STEPControl_ManifoldSolidBrep = _STEPControl.STEPControl_ManifoldSolidBrep
STEPControl_BrepWithVoids = _STEPControl.STEPControl_BrepWithVoids
STEPControl_FacetedBrep = _STEPControl.STEPControl_FacetedBrep
STEPControl_FacetedBrepAndBrepWithVoids = _STEPControl.STEPControl_FacetedBrepAndBrepWithVoids
STEPControl_ShellBasedSurfaceModel = _STEPControl.STEPControl_ShellBasedSurfaceModel
STEPControl_GeometricCurveSet = _STEPControl.STEPControl_GeometricCurveSet
STEPControl_Hybrid = _STEPControl.STEPControl_Hybrid
class STEPControl_ActorRead(Transfer.Transfer_ActorOfTransientProcess):
    """
    This class performs the transfer of an Entity from
    AP214 and AP203, either Geometric or Topologic.

    I.E. for each type of Entity, it invokes the appropriate Tool
    then returns the Binder which contains the Result
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPControl_ActorRead
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPControl_ActorRead(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPControl_ActorRead self) -> STEPControl_ActorRead

        This class performs the transfer of an Entity from
        AP214 and AP203, either Geometric or Topologic.

        I.E. for each type of Entity, it invokes the appropriate Tool
        then returns the Binder which contains the Result
        """
        this = _STEPControl.new_STEPControl_ActorRead(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Recognize(self, *args):
        """
        Recognize(STEPControl_ActorRead self, Handle_Standard_Transient start) -> Standard_Boolean

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.STEPControl_ActorRead_Recognize(self, *args)


    def Transfer(self, *args):
        """
        Transfer(STEPControl_ActorRead self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorRead_Transfer(self, *args)


    def TransferShape(self, *args):
        """
        TransferShape(STEPControl_ActorRead self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorRead_TransferShape(self, *args)


    def PrepareUnits(self, *args):
        """
        PrepareUnits(STEPControl_ActorRead self, Handle_StepRepr_Representation rep, Handle_Transfer_TransientProcess TP)

        set units and tolerances context by given ShapeRepresentation

        :type rep: OCC.wrapper.StepRepr.Handle_StepRepr_Representation
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _STEPControl.STEPControl_ActorRead_PrepareUnits(self, *args)


    def ResetUnits(self, *args):
        """
        ResetUnits(STEPControl_ActorRead self)

        reset units and tolerances context to default
        (mm, radians, read.precision.val, etc.)


        """
        return _STEPControl.STEPControl_ActorRead_ResetUnits(self, *args)


    def ComputeTransformation(self, *args):
        """
        ComputeTransformation(STEPControl_ActorRead self, Handle_StepGeom_Axis2Placement3d Origin, Handle_StepGeom_Axis2Placement3d Target, Handle_StepRepr_Representation OrigContext, Handle_StepRepr_Representation TargContext, Handle_Transfer_TransientProcess TP, gp_Trsf Trsf) -> Standard_Boolean

        Computes transformation defined by two axis placements (in MAPPED_ITEM
        or ITEM_DEFINED_TRANSFORMATION) taking into account their
        representation contexts (i.e. units, which may be different)
        Returns True if transformation is computed and is not an identity.

        :type Origin: OCC.wrapper.STEPControl.Handle_StepGeom_Axis2Placement3d
        :type Target: OCC.wrapper.STEPControl.Handle_StepGeom_Axis2Placement3d
        :type OrigContext: OCC.wrapper.StepRepr.Handle_StepRepr_Representation
        :type TargContext: OCC.wrapper.StepRepr.Handle_StepRepr_Representation
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type Trsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.STEPControl_ActorRead_ComputeTransformation(self, *args)


    def ComputeSRRWT(self, *args):
        """
        ComputeSRRWT(STEPControl_ActorRead self, Handle_StepRepr_RepresentationRelationship SRR, Handle_Transfer_TransientProcess TP, gp_Trsf Trsf) -> Standard_Boolean

        Computes transformation defined by given
        REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION

        :type SRR: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationRelationship
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type Trsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.STEPControl_ActorRead_ComputeSRRWT(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPControl.STEPControl_ActorRead_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPControl.STEPControl_ActorRead_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.STEPControl_ActorRead_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPControl.delete_STEPControl_ActorRead
STEPControl_ActorRead_swigregister = _STEPControl.STEPControl_ActorRead_swigregister
STEPControl_ActorRead_swigregister(STEPControl_ActorRead)

def STEPControl_ActorRead_get_type_name(*args):
    """
    STEPControl_ActorRead_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPControl.STEPControl_ActorRead_get_type_name(*args)

def STEPControl_ActorRead_get_type_descriptor(*args):
    """
    STEPControl_ActorRead_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPControl.STEPControl_ActorRead_get_type_descriptor(*args)

class STEPControl_Controller(XSControl.XSControl_Controller):
    """defines basic controller for STEP processor"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPControl_Controller
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPControl_Controller(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPControl_Controller self) -> STEPControl_Controller

        Initializes the use of STEP Norm (the first time) and
        returns a Controller


        """
        this = _STEPControl.new_STEPControl_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewModel(self, *args):
        """
        NewModel(STEPControl_Controller self) -> Handle_Interface_InterfaceModel

        Creates a new empty Model ready to receive data of the Norm.
        It is taken from STEP Template Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _STEPControl.STEPControl_Controller_NewModel(self, *args)


    def Customise(self, *args):
        """
        Customise(STEPControl_Controller self, Handle_XSControl_WorkSession WS)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPControl.STEPControl_Controller_Customise(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(STEPControl_Controller self, TopoDS_Shape shape, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Shape and transfers it to the InterfaceModel
        (already created by NewModel for instance)
        <modeshape> is to be interpreted by each kind of XstepAdaptor
        Returns a status : 0 OK  1 No result  2 Fail  -1 bad modeshape
        -2 bad model (requires a StepModel)
        modeshape : 1 Facetted BRep, 2 Shell, 3 Manifold Solid

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPControl.STEPControl_Controller_TransferWriteShape(self, *args)


    def Init(*args):
        """
        Init() -> Standard_Boolean

        Standard Initialisation. It creates a Controller for STEP
        and records it to various names, available to select it later
        Returns True when done, False if could not be done

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.STEPControl_Controller_Init(*args)

    Init = staticmethod(Init)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPControl.STEPControl_Controller_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPControl.STEPControl_Controller_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.STEPControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPControl.delete_STEPControl_Controller
STEPControl_Controller_swigregister = _STEPControl.STEPControl_Controller_swigregister
STEPControl_Controller_swigregister(STEPControl_Controller)

def STEPControl_Controller_Init(*args):
    """
    STEPControl_Controller_Init() -> Standard_Boolean

    Standard Initialisation. It creates a Controller for STEP
    and records it to various names, available to select it later
    Returns True when done, False if could not be done

    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPControl.STEPControl_Controller_Init(*args)

def STEPControl_Controller_get_type_name(*args):
    """
    STEPControl_Controller_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPControl.STEPControl_Controller_get_type_name(*args)

def STEPControl_Controller_get_type_descriptor(*args):
    """
    STEPControl_Controller_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPControl.STEPControl_Controller_get_type_descriptor(*args)

class Handle_STEPControl_Controller(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPControl_Controller self)

        Nullify the handle


        """
        return _STEPControl.Handle_STEPControl_Controller_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPControl_Controller self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPControl.Handle_STEPControl_Controller_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPControl_Controller self, STEPControl_Controller thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPControl.Handle_STEPControl_Controller_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPControl_Controller self, Handle_STEPControl_Controller theHandle) -> Handle_STEPControl_Controller
        assign(Handle_STEPControl_Controller self, STEPControl_Controller thePtr) -> Handle_STEPControl_Controller
        assign(Handle_STEPControl_Controller self, Handle_STEPControl_Controller theHandle) -> Handle_STEPControl_Controller

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPControl.Handle_STEPControl_Controller_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPControl_Controller self) -> STEPControl_Controller

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPControl.Handle_STEPControl_Controller_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPControl_Controller self) -> STEPControl_Controller

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPControl.Handle_STEPControl_Controller___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPControl_Controller self) -> STEPControl_Controller

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPControl.Handle_STEPControl_Controller___ref__(self, *args)


    def __hash__(self):
        return _STEPControl.Handle_STEPControl_Controller___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPControl.Handle_STEPControl_Controller___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPControl.new_Handle_STEPControl_Controller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPControl.Handle_STEPControl_Controller_DownCast)
    __swig_destroy__ = _STEPControl.delete_Handle_STEPControl_Controller

    def NewModel(self, *args):
        """
        NewModel(Handle_STEPControl_Controller self) -> Handle_Interface_InterfaceModel

        Creates a new empty Model ready to receive data of the Norm.
        It is taken from STEP Template Model

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _STEPControl.Handle_STEPControl_Controller_NewModel(self, *args)


    def Customise(self, *args):
        """
        Customise(Handle_STEPControl_Controller self, Handle_XSControl_WorkSession WS)

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPControl.Handle_STEPControl_Controller_Customise(self, *args)


    def TransferWriteShape(self, *args):
        """
        TransferWriteShape(Handle_STEPControl_Controller self, TopoDS_Shape shape, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Shape and transfers it to the InterfaceModel
        (already created by NewModel for instance)
        <modeshape> is to be interpreted by each kind of XstepAdaptor
        Returns a status : 0 OK  1 No result  2 Fail  -1 bad modeshape
        -2 bad model (requires a StepModel)
        modeshape : 1 Facetted BRep, 2 Shell, 3 Manifold Solid

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPControl.Handle_STEPControl_Controller_TransferWriteShape(self, *args)


    def Init(self, *args):
        """
        Init(Handle_STEPControl_Controller self) -> Standard_Boolean

        Standard Initialisation. It creates a Controller for STEP
        and records it to various names, available to select it later
        Returns True when done, False if could not be done

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_Controller_Init(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPControl_Controller self) -> char const *

        :rtype: const char *

        """
        return _STEPControl.Handle_STEPControl_Controller_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.Handle_STEPControl_Controller_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.Handle_STEPControl_Controller_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetNames(self, *args):
        """
        SetNames(Handle_STEPControl_Controller self, Standard_CString const theLongName, Standard_CString const theShortName)

        Changes names
        if a name is empty, the formerly set one remains
        Remark : Does not call Record or AutoRecord

        :type theLongName: OCC.wrapper.Standard.Standard_CString
        :type theShortName: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPControl.Handle_STEPControl_Controller_SetNames(self, *args)


    def AutoRecord(self, *args):
        """
        AutoRecord(Handle_STEPControl_Controller self)

        Records <me> is a general dictionary under Short and Long
        Names (see method Name)


        """
        return _STEPControl.Handle_STEPControl_Controller_AutoRecord(self, *args)


    def Record(self, *args):
        """
        Record(Handle_STEPControl_Controller self, Standard_CString const name)

        Records <me> in a general dictionary under a name
        Error if <name> already used for another one

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPControl.Handle_STEPControl_Controller_Record(self, *args)


    def Recorded(self, *args):
        """
        Recorded(Handle_STEPControl_Controller self, Standard_CString const name) -> Handle_XSControl_Controller

        Returns the Controller attached to a given name
        Returns a Null Handle if <name> is unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.XSControl.Handle_XSControl_Controller

        """
        return _STEPControl.Handle_STEPControl_Controller_Recorded(self, *args)


    def Name(self, *args):
        """
        Name(Handle_STEPControl_Controller self, Standard_Boolean const rsc) -> Standard_CString

        Returns a name, as given when initializing :
        rsc = False (D) : True Name attached to the Norm (long name)
        rsc = True : Name of the ressource set (i.e. short name)

        :type rsc: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPControl.Handle_STEPControl_Controller_Name(self, *args)


    def Protocol(self, *args):
        """
        Returns the Protocol attached to the Norm (from field)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        res = _STEPControl.Handle_STEPControl_Controller_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WorkLibrary(self, *args):
        """
        Returns the WorkLibrary attached to the Norm. Remark that it
        has to be in phase with the Protocol  (read from field)

        :rtype: OCC.wrapper.IFSelect.Handle_IFSelect_WorkLibrary

        """
        res = _STEPControl.Handle_STEPControl_Controller_WorkLibrary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ActorRead(self, *args):
        """
        ActorRead(Handle_STEPControl_Controller self, Handle_Interface_InterfaceModel model) -> Handle_Transfer_ActorOfTransientProcess

        Returns the Actor for Read attached to the pair (norm,appli)
        It can be adapted for data of the input Model, as required
        Can be read from field then adapted with Model as required

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfTransientProcess

        """
        return _STEPControl.Handle_STEPControl_Controller_ActorRead(self, *args)


    def ActorWrite(self, *args):
        """
        ActorWrite(Handle_STEPControl_Controller self) -> Handle_Transfer_ActorOfFinderProcess

        Returns the Actor for Write attached to the pair (norm,appli)
        Read from field. Can be redefined

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfFinderProcess

        """
        return _STEPControl.Handle_STEPControl_Controller_ActorWrite(self, *args)


    def SetModeWrite(self, *args):
        """
        SetModeWrite(Handle_STEPControl_Controller self, Standard_Integer const modemin, Standard_Integer const modemax, Standard_Boolean const shape)

        Sets mininum and maximum values for modetrans (write)
        Erases formerly recorded bounds and values
        Actually only for shape
        Then, for each value a little help can be attached

        :type modemin: int
        :type modemax: int
        :type shape: bool

        """
        return _STEPControl.Handle_STEPControl_Controller_SetModeWrite(self, *args)


    def SetModeWriteHelp(self, *args):
        """
        SetModeWriteHelp(Handle_STEPControl_Controller self, Standard_Integer const modetrans, Standard_CString const help, Standard_Boolean const shape)

        Attaches a short line of help to a value of modetrans (write)

        :type modetrans: int
        :type help: OCC.wrapper.Standard.Standard_CString
        :type shape: bool

        """
        return _STEPControl.Handle_STEPControl_Controller_SetModeWriteHelp(self, *args)


    def ModeWriteBounds(self, *args):
        """
        ModeWriteBounds(Handle_STEPControl_Controller self, Standard_Boolean const shape) -> Standard_Boolean

        Returns recorded min and max values for modetrans (write)
        Actually only for shapes
        Returns True if bounds are set, False else (then, free value)

        :type modemin: int
        :type modemax: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_Controller_ModeWriteBounds(self, *args)


    def IsModeWrite(self, *args):
        """
        IsModeWrite(Handle_STEPControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_Boolean

        Tells if a value of <modetrans> is a good value(within bounds)
        Actually only for shapes

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_Controller_IsModeWrite(self, *args)


    def ModeWriteHelp(self, *args):
        """
        ModeWriteHelp(Handle_STEPControl_Controller self, Standard_Integer const modetrans, Standard_Boolean const shape) -> Standard_CString

        Returns the help line recorded for a value of modetrans
        empty if help not defined or not within bounds or if values are free

        :type modetrans: int
        :type shape: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPControl.Handle_STEPControl_Controller_ModeWriteHelp(self, *args)


    def RecognizeWriteTransient(self, *args):
        """
        RecognizeWriteTransient(Handle_STEPControl_Controller self, Handle_Standard_Transient obj, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if <obj> (an application object) is a valid candidate
        for a transfer to a Model.
        By default, asks the ActorWrite if known (through a
        TransientMapper). Can be redefined

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_Controller_RecognizeWriteTransient(self, *args)


    def TransferWriteTransient(self, *args):
        """
        TransferWriteTransient(Handle_STEPControl_Controller self, Handle_Standard_Transient obj, Handle_Transfer_FinderProcess FP, Handle_Interface_InterfaceModel model, Standard_Integer const modetrans=0) -> IFSelect_ReturnStatus

        Takes one Transient Object and transfers it to an
        InterfaceModel (already created, e.g. by NewModel)
        (result is recorded in the model by AddWithRefs)
        FP records produced results and checks

        Default uses ActorWrite; can be redefined as necessary
        Returned value is a status, as follows :
        0  OK ,  1 No Result ,  2 Fail (e.g. exception raised)
        -1 bad conditions ,  -2 bad model or null model
        For type of object not recognized : should return 1

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type modetrans: int
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPControl.Handle_STEPControl_Controller_TransferWriteTransient(self, *args)


    def RecognizeWriteShape(self, *args):
        """
        RecognizeWriteShape(Handle_STEPControl_Controller self, TopoDS_Shape shape, Standard_Integer const modetrans=0) -> Standard_Boolean

        Tells if a shape is valid for a transfer to a model
        Asks the ActorWrite (through a ShapeMapper)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type modetrans: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_Controller_RecognizeWriteShape(self, *args)


    def AddSessionItem(self, *args):
        """
        AddSessionItem(Handle_STEPControl_Controller self, Handle_Standard_Transient theItem, Standard_CString const theName, Standard_Boolean const toApply)

        Records a Session Item, to be added for customisation of the Work Session.
        It must have a specific name.
        <setapplied> is used if <item> is a GeneralModifier, to decide
        If set to true, <item> will be applied to the hook list "send".
        Else, it is not applied to any hook list.
        Remark : this method is to be called at Create time,
        the recorded items will be used by Customise
        Warning : if <name> conflicts, the last recorded item is kept

        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theName: OCC.wrapper.Standard.Standard_CString
        :type toApply: bool

        """
        return _STEPControl.Handle_STEPControl_Controller_AddSessionItem(self, *args)


    def SessionItem(self, *args):
        """
        SessionItem(Handle_STEPControl_Controller self, Standard_CString const theName) -> Handle_Standard_Transient

        Returns an item given its name to record in a Session
        If <name> is unknown, returns a Null Handle

        :type theName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPControl.Handle_STEPControl_Controller_SessionItem(self, *args)


    def AdaptorSession(self, *args):
        """
        :rtype: OCC.wrapper.XSControl.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient

        """
        res = _STEPControl.Handle_STEPControl_Controller_AdaptorSession(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_STEPControl_Controller self)

        Memory deallocator for transient classes


        """
        return _STEPControl.Handle_STEPControl_Controller_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_Controller_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPControl_Controller self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPControl_Controller self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_Controller_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPControl_Controller self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPControl.Handle_STEPControl_Controller_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPControl_Controller self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_Controller_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPControl_Controller self)

        Increments the reference counter of this object


        """
        return _STEPControl.Handle_STEPControl_Controller_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPControl_Controller self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_Controller_DecrementRefCounter(self, *args)

Handle_STEPControl_Controller_swigregister = _STEPControl.Handle_STEPControl_Controller_swigregister
Handle_STEPControl_Controller_swigregister(Handle_STEPControl_Controller)

def Handle_STEPControl_Controller_DownCast(thing):
    return _STEPControl.Handle_STEPControl_Controller_DownCast(thing)
Handle_STEPControl_Controller_DownCast = _STEPControl.Handle_STEPControl_Controller_DownCast

class STEPControl_ActorWrite(Transfer.Transfer_ActorOfFinderProcess):
    """
    This class performs the transfer of a Shape from TopoDS
    to AP203 or AP214 (CD2 or DIS)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_STEPControl_ActorWrite
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_STEPControl_ActorWrite(self) 
            return h


    def __init__(self, *args):
        """
        __init__(STEPControl_ActorWrite self) -> STEPControl_ActorWrite

        This class performs the transfer of a Shape from TopoDS
        to AP203 or AP214 (CD2 or DIS)
        """
        this = _STEPControl.new_STEPControl_ActorWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Recognize(self, *args):
        """
        Recognize(STEPControl_ActorWrite self, Handle_Transfer_Finder start) -> Standard_Boolean

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.STEPControl_ActorWrite_Recognize(self, *args)


    def Transfer(self, *args):
        """
        Transfer(STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_FinderProcess FP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_Transfer(self, *args)


    def TransferSubShape(self, *args):
        """
        TransferSubShape(STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_StepGeom_Axis2Placement3d AX1, Handle_Transfer_FinderProcess FP, Handle_TopTools_HSequenceOfShape shapeGroup=0, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type AX1: OCC.wrapper.STEPControl.Handle_StepGeom_Axis2Placement3d
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type shapeGroup: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_TransferSubShape(self, *args)


    def TransferShape(self, *args):
        """
        TransferShape(STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_Transfer_FinderProcess FP, Handle_TopTools_HSequenceOfShape shapeGroup=0, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type shapeGroup: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_TransferShape(self, *args)


    def TransferCompound(self, *args):
        """
        TransferCompound(STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_Transfer_FinderProcess FP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_TransferCompound(self, *args)


    def SetMode(self, *args):
        """
        SetMode(STEPControl_ActorWrite self, STEPControl_StepModelType const M)

        :type M: OCC.wrapper.STEPControl.STEPControl_StepModelType

        """
        return _STEPControl.STEPControl_ActorWrite_SetMode(self, *args)


    def Mode(self, *args):
        """
        Mode(STEPControl_ActorWrite self) -> STEPControl_StepModelType

        :rtype: OCC.wrapper.STEPControl.STEPControl_StepModelType

        """
        return _STEPControl.STEPControl_ActorWrite_Mode(self, *args)


    def SetGroupMode(self, *args):
        """
        SetGroupMode(STEPControl_ActorWrite self, Standard_Integer const mode)

        :type mode: int

        """
        return _STEPControl.STEPControl_ActorWrite_SetGroupMode(self, *args)


    def GroupMode(self, *args):
        """
        GroupMode(STEPControl_ActorWrite self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.STEPControl_ActorWrite_GroupMode(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(STEPControl_ActorWrite self, Standard_Real const Tol)

        :type Tol: float

        """
        return _STEPControl.STEPControl_ActorWrite_SetTolerance(self, *args)


    def IsAssembly(self, *args):
        """
        IsAssembly(STEPControl_ActorWrite self, TopoDS_Shape S) -> Standard_Boolean

        Customizable method to check whether shape S should
        be written as assembly or not
        Default implementation uses flag GroupMode and analyses
        the shape itself
        NOTE: this method can modify shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.STEPControl_ActorWrite_IsAssembly(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _STEPControl.STEPControl_ActorWrite_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _STEPControl.STEPControl_ActorWrite_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.STEPControl_ActorWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPControl.delete_STEPControl_ActorWrite
STEPControl_ActorWrite_swigregister = _STEPControl.STEPControl_ActorWrite_swigregister
STEPControl_ActorWrite_swigregister(STEPControl_ActorWrite)

def STEPControl_ActorWrite_get_type_name(*args):
    """
    STEPControl_ActorWrite_get_type_name() -> char const *

    :rtype: const char *

    """
    return _STEPControl.STEPControl_ActorWrite_get_type_name(*args)

def STEPControl_ActorWrite_get_type_descriptor(*args):
    """
    STEPControl_ActorWrite_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _STEPControl.STEPControl_ActorWrite_get_type_descriptor(*args)

class STEPControl_Reader(XSControl.XSControl_Reader):
    """
    Reads STEP files, checks them and translates their contents
    into Open CASCADE models. The STEP data can be that of
    a whole model or that of a specific list of entities in the model.
    As in XSControl_Reader, you specify the list using a selection.
    For the translation of iges files it is possible to use next sequence:
    To change translation parameters
    class Interface_Static should be used before beginning of
    translation  (see STEP Parameters and General Parameters)
    Creation of reader - STEPControl_Reader reader;
    To load s file in a model use method reader.ReadFile("filename.stp")
    To print load results reader.PrintCheckLoad(failsonly,mode)
    where mode is equal to the value of enumeration IFSelect_PrintCount
    For definition number of candidates :
    Standard_Integer nbroots = reader. NbRootsForTransfer();
    To transfer entities from a model the following methods can be used:
    for the whole model - reader.TransferRoots();
    to transfer a list of entities: reader.TransferList(list);
    to transfer one entity Handle(Standard_Transient)
    ent = reader.RootForTransfer(num);
    reader.TransferEntity(ent), or
    reader.TransferOneRoot(num), or
    reader.TransferOne(num), or
    reader.TransferRoot(num)
    To obtain the result the following method can be used:
    reader.NbShapes() and reader.Shape(num); or reader.OneShape();
    To print the results of transfer use method:
    reader.PrintCheckTransfer(failwarn,mode);
    where printfail is equal to the value of enumeration
    IFSelect_PrintFail, mode see above; or reader.PrintStatsTransfer();
    Gets correspondence between a STEP entity and a result
    shape obtained from it.
    Handle(XSControl_WorkSession)
    WS = reader.WS();
    if ( WS->TransferReader()->HasResult(ent) )
    TopoDS_Shape shape = WS->TransferReader()->ShapeResult(ent);
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPControl_Reader self) -> STEPControl_Reader
        __init__(STEPControl_Reader self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch) -> STEPControl_Reader

        Creates a Reader for STEP from an already existing Session
        Clears the session if it was not yet set for STEP

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        this = _STEPControl.new_STEPControl_Reader(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def StepModel(self, *args):
        """
        StepModel(STEPControl_Reader self) -> Handle_StepData_StepModel

        Returns the model as a StepModel.
        It can then be consulted (header, product)

        :rtype: OCC.wrapper.StepData.Handle_StepData_StepModel

        """
        return _STEPControl.STEPControl_Reader_StepModel(self, *args)


    def TransferRoot(self, *args):
        """
        TransferRoot(STEPControl_Reader self, Standard_Integer const num=1) -> Standard_Boolean

        Transfers a root given its rank in the list of candidate roots
        Default is the first one
        Returns True if a shape has resulted, false else
        Same as inherited TransferOneRoot, kept for compatibility

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.STEPControl_Reader_TransferRoot(self, *args)


    def NbRootsForTransfer(self, *args):
        """
        NbRootsForTransfer(STEPControl_Reader self) -> Standard_Integer

        Determines the list of root entities from Model which are candidate for
        a transfer to a Shape (type of entities is PRODUCT)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.STEPControl_Reader_NbRootsForTransfer(self, *args)


    def FileUnits(self, *args):
        """
        FileUnits(STEPControl_Reader self, NCollection_Sequence_TCollection_AsciiString theUnitLengthNames, NCollection_Sequence_TCollection_AsciiString theUnitAngleNames, NCollection_Sequence_TCollection_AsciiString theUnitSolidAngleNames)

        Returns sequence of all unit names for shape representations
        found in file

        :type theUnitLengthNames: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :type theUnitAngleNames: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :type theUnitSolidAngleNames: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _STEPControl.STEPControl_Reader_FileUnits(self, *args)

    __swig_destroy__ = _STEPControl.delete_STEPControl_Reader
STEPControl_Reader_swigregister = _STEPControl.STEPControl_Reader_swigregister
STEPControl_Reader_swigregister(STEPControl_Reader)

class Handle_STEPControl_ActorRead(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPControl_ActorRead self)

        Nullify the handle


        """
        return _STEPControl.Handle_STEPControl_ActorRead_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPControl_ActorRead self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPControl.Handle_STEPControl_ActorRead_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPControl_ActorRead self, STEPControl_ActorRead thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPControl.Handle_STEPControl_ActorRead_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPControl_ActorRead self, Handle_STEPControl_ActorRead theHandle) -> Handle_STEPControl_ActorRead
        assign(Handle_STEPControl_ActorRead self, STEPControl_ActorRead thePtr) -> Handle_STEPControl_ActorRead
        assign(Handle_STEPControl_ActorRead self, Handle_STEPControl_ActorRead theHandle) -> Handle_STEPControl_ActorRead

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPControl.Handle_STEPControl_ActorRead_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPControl_ActorRead self) -> STEPControl_ActorRead

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPControl.Handle_STEPControl_ActorRead_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPControl_ActorRead self) -> STEPControl_ActorRead

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPControl.Handle_STEPControl_ActorRead___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPControl_ActorRead self) -> STEPControl_ActorRead

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPControl.Handle_STEPControl_ActorRead___ref__(self, *args)


    def __hash__(self):
        return _STEPControl.Handle_STEPControl_ActorRead___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPControl.Handle_STEPControl_ActorRead___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPControl.new_Handle_STEPControl_ActorRead(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPControl.Handle_STEPControl_ActorRead_DownCast)
    __swig_destroy__ = _STEPControl.delete_Handle_STEPControl_ActorRead

    def Recognize(self, *args):
        """
        Recognize(Handle_STEPControl_ActorRead self, Handle_Standard_Transient start) -> Standard_Boolean

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorRead_Recognize(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_STEPControl_ActorRead self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorRead_Transfer(self, *args)


    def TransferShape(self, *args):
        """
        TransferShape(Handle_STEPControl_ActorRead self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorRead_TransferShape(self, *args)


    def PrepareUnits(self, *args):
        """
        PrepareUnits(Handle_STEPControl_ActorRead self, Handle_StepRepr_Representation rep, Handle_Transfer_TransientProcess TP)

        set units and tolerances context by given ShapeRepresentation

        :type rep: OCC.wrapper.StepRepr.Handle_StepRepr_Representation
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        return _STEPControl.Handle_STEPControl_ActorRead_PrepareUnits(self, *args)


    def ResetUnits(self, *args):
        """
        ResetUnits(Handle_STEPControl_ActorRead self)

        reset units and tolerances context to default
        (mm, radians, read.precision.val, etc.)


        """
        return _STEPControl.Handle_STEPControl_ActorRead_ResetUnits(self, *args)


    def ComputeTransformation(self, *args):
        """
        ComputeTransformation(Handle_STEPControl_ActorRead self, Handle_StepGeom_Axis2Placement3d Origin, Handle_StepGeom_Axis2Placement3d Target, Handle_StepRepr_Representation OrigContext, Handle_StepRepr_Representation TargContext, Handle_Transfer_TransientProcess TP, gp_Trsf Trsf) -> Standard_Boolean

        Computes transformation defined by two axis placements (in MAPPED_ITEM
        or ITEM_DEFINED_TRANSFORMATION) taking into account their
        representation contexts (i.e. units, which may be different)
        Returns True if transformation is computed and is not an identity.

        :type Origin: OCC.wrapper.STEPControl.Handle_StepGeom_Axis2Placement3d
        :type Target: OCC.wrapper.STEPControl.Handle_StepGeom_Axis2Placement3d
        :type OrigContext: OCC.wrapper.StepRepr.Handle_StepRepr_Representation
        :type TargContext: OCC.wrapper.StepRepr.Handle_StepRepr_Representation
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type Trsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorRead_ComputeTransformation(self, *args)


    def ComputeSRRWT(self, *args):
        """
        ComputeSRRWT(Handle_STEPControl_ActorRead self, Handle_StepRepr_RepresentationRelationship SRR, Handle_Transfer_TransientProcess TP, gp_Trsf Trsf) -> Standard_Boolean

        Computes transformation defined by given
        REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION

        :type SRR: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationRelationship
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type Trsf: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorRead_ComputeSRRWT(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPControl_ActorRead self) -> char const *

        :rtype: const char *

        """
        return _STEPControl.Handle_STEPControl_ActorRead_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.Handle_STEPControl_ActorRead_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.Handle_STEPControl_ActorRead_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transferring(self, *args):
        """
        Transferring(Handle_STEPControl_ActorRead self, Handle_Standard_Transient start, Handle_Transfer_ProcessForTransient TP)

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForTransient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorRead_Transferring(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Handle_STEPControl_ActorRead self, Handle_Standard_Transient start, Handle_Transfer_TransientProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPControl.Handle_STEPControl_ActorRead_TransferTransient(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_STEPControl_ActorRead self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _STEPControl.Handle_STEPControl_ActorRead_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_STEPControl_ActorRead self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorRead_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_STEPControl_ActorRead self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _STEPControl.Handle_STEPControl_ActorRead_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_STEPControl_ActorRead self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorRead_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_STEPControl_ActorRead self, Handle_Transfer_ActorOfProcessForTransient next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _STEPControl.Handle_STEPControl_ActorRead_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_STEPControl_ActorRead self) -> Handle_Transfer_ActorOfProcessForTransient

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForTransient

        """
        return _STEPControl.Handle_STEPControl_ActorRead_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPControl_ActorRead self)

        Memory deallocator for transient classes


        """
        return _STEPControl.Handle_STEPControl_ActorRead_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPControl_ActorRead self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPControl_ActorRead self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorRead_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPControl_ActorRead self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPControl_ActorRead self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorRead_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPControl_ActorRead self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPControl.Handle_STEPControl_ActorRead_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPControl_ActorRead self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_ActorRead_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPControl_ActorRead self)

        Increments the reference counter of this object


        """
        return _STEPControl.Handle_STEPControl_ActorRead_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPControl_ActorRead self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_ActorRead_DecrementRefCounter(self, *args)

Handle_STEPControl_ActorRead_swigregister = _STEPControl.Handle_STEPControl_ActorRead_swigregister
Handle_STEPControl_ActorRead_swigregister(Handle_STEPControl_ActorRead)

def Handle_STEPControl_ActorRead_DownCast(thing):
    return _STEPControl.Handle_STEPControl_ActorRead_DownCast(thing)
Handle_STEPControl_ActorRead_DownCast = _STEPControl.Handle_STEPControl_ActorRead_DownCast

class Handle_STEPControl_ActorWrite(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_STEPControl_ActorWrite self)

        Nullify the handle


        """
        return _STEPControl.Handle_STEPControl_ActorWrite_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_STEPControl_ActorWrite self) -> bool

        Check for being null

        :rtype: bool

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_STEPControl_ActorWrite self, STEPControl_ActorWrite thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_STEPControl_ActorWrite self, Handle_STEPControl_ActorWrite theHandle) -> Handle_STEPControl_ActorWrite
        assign(Handle_STEPControl_ActorWrite self, STEPControl_ActorWrite thePtr) -> Handle_STEPControl_ActorWrite
        assign(Handle_STEPControl_ActorWrite self, Handle_STEPControl_ActorWrite theHandle) -> Handle_STEPControl_ActorWrite

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_STEPControl_ActorWrite self) -> STEPControl_ActorWrite

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_STEPControl_ActorWrite self) -> STEPControl_ActorWrite

        Member access operator (note non-const)

        :rtype: T *

        """
        return _STEPControl.Handle_STEPControl_ActorWrite___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_STEPControl_ActorWrite self) -> STEPControl_ActorWrite

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _STEPControl.Handle_STEPControl_ActorWrite___ref__(self, *args)


    def __hash__(self):
        return _STEPControl.Handle_STEPControl_ActorWrite___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _STEPControl.Handle_STEPControl_ActorWrite___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _STEPControl.new_Handle_STEPControl_ActorWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_STEPControl.Handle_STEPControl_ActorWrite_DownCast)
    __swig_destroy__ = _STEPControl.delete_Handle_STEPControl_ActorWrite

    def Recognize(self, *args):
        """
        Recognize(Handle_STEPControl_ActorWrite self, Handle_Transfer_Finder start) -> Standard_Boolean

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_Recognize(self, *args)


    def Transfer(self, *args):
        """
        Transfer(Handle_STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_FinderProcess FP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_Transfer(self, *args)


    def TransferSubShape(self, *args):
        """
        TransferSubShape(Handle_STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_StepGeom_Axis2Placement3d AX1, Handle_Transfer_FinderProcess FP, Handle_TopTools_HSequenceOfShape shapeGroup=0, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type AX1: OCC.wrapper.STEPControl.Handle_StepGeom_Axis2Placement3d
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type shapeGroup: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_TransferSubShape(self, *args)


    def TransferShape(self, *args):
        """
        TransferShape(Handle_STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_Transfer_FinderProcess FP, Handle_TopTools_HSequenceOfShape shapeGroup=0, Standard_Boolean const isManifold)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type shapeGroup: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type isManifold: bool
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_TransferShape(self, *args)


    def TransferCompound(self, *args):
        """
        TransferCompound(Handle_STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_StepShape_ShapeDefinitionRepresentation SDR, Handle_Transfer_FinderProcess FP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type SDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type FP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_TransferCompound(self, *args)


    def SetMode(self, *args):
        """
        SetMode(Handle_STEPControl_ActorWrite self, STEPControl_StepModelType const M)

        :type M: OCC.wrapper.STEPControl.STEPControl_StepModelType

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_SetMode(self, *args)


    def Mode(self, *args):
        """
        Mode(Handle_STEPControl_ActorWrite self) -> STEPControl_StepModelType

        :rtype: OCC.wrapper.STEPControl.STEPControl_StepModelType

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_Mode(self, *args)


    def SetGroupMode(self, *args):
        """
        SetGroupMode(Handle_STEPControl_ActorWrite self, Standard_Integer const mode)

        :type mode: int

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_SetGroupMode(self, *args)


    def GroupMode(self, *args):
        """
        GroupMode(Handle_STEPControl_ActorWrite self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_GroupMode(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_STEPControl_ActorWrite self, Standard_Real const Tol)

        :type Tol: float

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_SetTolerance(self, *args)


    def IsAssembly(self, *args):
        """
        IsAssembly(Handle_STEPControl_ActorWrite self, TopoDS_Shape S) -> Standard_Boolean

        Customizable method to check whether shape S should
        be written as assembly or not
        Default implementation uses flag GroupMode and analyses
        the shape itself
        NOTE: this method can modify shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_IsAssembly(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_STEPControl_ActorWrite self) -> char const *

        :rtype: const char *

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.Handle_STEPControl_ActorWrite_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _STEPControl.Handle_STEPControl_ActorWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModeTrans(self, *args):
        """
        ModeTrans(Handle_STEPControl_ActorWrite self) -> Standard_Integer &

        Returns the Transfer Mode, modifiable

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_ModeTrans(self, *args)


    def Transferring(self, *args):
        """
        Transferring(Handle_STEPControl_ActorWrite self, Handle_Transfer_Finder start, Handle_Transfer_ProcessForFinder TP)

        :type start: OCC.wrapper.Transfer.Handle_Transfer_Finder
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_ProcessForFinder
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_Transferring(self, *args)


    def TransferTransient(self, *args):
        """
        TransferTransient(Handle_STEPControl_ActorWrite self, Handle_Standard_Transient start, Handle_Transfer_FinderProcess TP) -> Handle_Standard_Transient

        :type start: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TP: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_TransferTransient(self, *args)


    def TransientResult(self, *args):
        """
        TransientResult(Handle_STEPControl_ActorWrite self, Handle_Standard_Transient res) -> Handle_Transfer_SimpleBinderOfTransient

        Prepares and Returns a Binder for a Transient Result
        Returns a Null Handle if <res> is itself Null

        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Transfer.Handle_Transfer_SimpleBinderOfTransient

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_TransientResult(self, *args)


    def NullResult(self, *args):
        """
        NullResult(Handle_STEPControl_ActorWrite self)

        Returns a Binder for No Result, i.e. a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_Binder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_NullResult(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_STEPControl_ActorWrite self, Standard_Boolean const mode)

        If <mode> is True, commands an Actor to be set at the
        end of the list of Actors (see SetNext)
        If it is False (creation default), each add Actor is
        set at the beginning of the list
        This allows to define default Actors (which are Last)

        :type mode: bool

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_SetLast(self, *args)


    def IsLast(self, *args):
        """
        IsLast(Handle_STEPControl_ActorWrite self) -> Standard_Boolean

        Returns the Last status (see SetLast).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_IsLast(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_STEPControl_ActorWrite self, Handle_Transfer_ActorOfProcessForFinder next)

        Defines a Next Actor : it can then be asked to work if
        <me> produces no result for a given type of Object.
        If Next is already set and is not "Last", calls
        SetNext on it. If Next defined and "Last", the new
        actor is added before it in the list

        :type next: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_STEPControl_ActorWrite self) -> Handle_Transfer_ActorOfProcessForFinder

        Returns the Actor defined as Next, or a Null Handle

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_ActorOfProcessForFinder

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_Next(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_STEPControl_ActorWrite self)

        Memory deallocator for transient classes


        """
        return _STEPControl.Handle_STEPControl_ActorWrite_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_STEPControl_ActorWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_STEPControl_ActorWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_STEPControl_ActorWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_STEPControl_ActorWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_STEPControl_ActorWrite self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_STEPControl_ActorWrite self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_STEPControl_ActorWrite self)

        Increments the reference counter of this object


        """
        return _STEPControl.Handle_STEPControl_ActorWrite_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_STEPControl_ActorWrite self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPControl.Handle_STEPControl_ActorWrite_DecrementRefCounter(self, *args)

Handle_STEPControl_ActorWrite_swigregister = _STEPControl.Handle_STEPControl_ActorWrite_swigregister
Handle_STEPControl_ActorWrite_swigregister(Handle_STEPControl_ActorWrite)

def Handle_STEPControl_ActorWrite_DownCast(thing):
    return _STEPControl.Handle_STEPControl_ActorWrite_DownCast(thing)
Handle_STEPControl_ActorWrite_DownCast = _STEPControl.Handle_STEPControl_ActorWrite_DownCast

class STEPControl_Writer(object):
    """
    This class creates and writes
    STEP files from Open CASCADE models. A STEP file can be
    written to an existing STEP file or to a new one.
    Translation can be performed in one or several operations. Each
    translation operation outputs a distinct root entity in the STEP file.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPControl_Writer self) -> STEPControl_Writer
        __init__(STEPControl_Writer self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch) -> STEPControl_Writer

        Creates a Writer from an already existing Session
        If <scratch> is True (D), clears already recorded data

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        this = _STEPControl.new_STEPControl_Writer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolerance(self, *args):
        """
        SetTolerance(STEPControl_Writer self, Standard_Real const Tol)

        Sets a length-measure value that
        will be written to uncertainty-measure-with-unit
        when the next shape is translated.

        :type Tol: float

        """
        return _STEPControl.STEPControl_Writer_SetTolerance(self, *args)


    def UnsetTolerance(self, *args):
        """
        UnsetTolerance(STEPControl_Writer self)

        Unsets the tolerance formerly forced by SetTolerance


        """
        return _STEPControl.STEPControl_Writer_UnsetTolerance(self, *args)


    def SetWS(self, *args):
        """
        SetWS(STEPControl_Writer self, Handle_XSControl_WorkSession WS, Standard_Boolean const scratch)

        Sets a specific session to <me>

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :type scratch: bool

        """
        return _STEPControl.STEPControl_Writer_SetWS(self, *args)


    def WS(self, *args):
        """
        WS(STEPControl_Writer self) -> Handle_XSControl_WorkSession

        Returns the session used in <me>

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        return _STEPControl.STEPControl_Writer_WS(self, *args)


    def Model(self, *args):
        """
        Model(STEPControl_Writer self, Standard_Boolean const newone) -> Handle_StepData_StepModel

        Returns the produced model. Produces a new one if not yet done
        or if <newone> is True
        This method allows for instance to edit product or header
        data before writing.

        :type newone: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_StepModel

        """
        return _STEPControl.STEPControl_Writer_Model(self, *args)


    def Transfer(self, *args):
        """
        Transfer(STEPControl_Writer self, TopoDS_Shape sh, STEPControl_StepModelType const mode, Standard_Boolean const compgraph) -> IFSelect_ReturnStatus

        Translates shape sh to a STEP
        entity. mode defines the STEP entity type to be output:
        - STEPControlStd_AsIs translates a shape to its highest possible
        STEP representation.
        - STEPControlStd_ManifoldSolidBrep translates a shape to a STEP
        manifold_solid_brep or brep_with_voids entity.
        - STEPControlStd_FacetedBrep translates a shape into a STEP
        faceted_brep entity.
        - STEPControlStd_ShellBasedSurfaceModel translates a shape into a STEP
        shell_based_surface_model entity.
        - STEPControlStd_GeometricCurveSet translates a shape into a STEP
        geometric_curve_set entity.

        :type sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mode: OCC.wrapper.STEPControl.STEPControl_StepModelType
        :type compgraph: bool
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPControl.STEPControl_Writer_Transfer(self, *args)


    def Write(self, *args):
        """
        Write(STEPControl_Writer self, Standard_CString const filename) -> IFSelect_ReturnStatus

        Writes a STEP model in the file identified by filename.

        :type filename: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.IFSelect.IFSelect_ReturnStatus

        """
        return _STEPControl.STEPControl_Writer_Write(self, *args)


    def PrintStatsTransfer(self, *args):
        """
        PrintStatsTransfer(STEPControl_Writer self, Standard_Integer const what, Standard_Integer const mode=0)

        Displays the statistics for the
        last translation. what defines the kind of statistics that are displayed:
        - 0 gives general statistics   (number of translated roots,
        number of warnings, number of   fail messages),
        - 1 gives root results,
        - 2 gives statistics for all checked entities,
        - 3 gives the list of translated entities,
        - 4 gives warning and fail messages,
        - 5 gives fail messages only.
        mode is used according to the use of what. If what is 0, mode is
        ignored. If what is 1, 2 or 3, mode defines the following:
        - 0 lists the numbers of STEP entities in a STEP model,
        - 1 gives the number, identifier, type and result type for each
        STEP entity and/or its status (fail, warning, etc.),
        - 2 gives maximum information for each STEP entity (i.e. checks),
        - 3 gives the number of entities by the type of a STEP entity,
        - 4 gives the number of of STEP entities per result type and/or status,
        - 5 gives the number of pairs (STEP or result type and status),
        - 6 gives the number of pairs (STEP or result type and status)
        AND the list of entity numbers in the STEP model.

        :type what: int
        :type mode: int

        """
        return _STEPControl.STEPControl_Writer_PrintStatsTransfer(self, *args)

    __swig_destroy__ = _STEPControl.delete_STEPControl_Writer
STEPControl_Writer_swigregister = _STEPControl.STEPControl_Writer_swigregister
STEPControl_Writer_swigregister(STEPControl_Writer)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomInt')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomInt')
    _GeomInt = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomInt', [dirname(__file__)])
        except ImportError:
            import _GeomInt
            return _GeomInt
        try:
            _mod = imp.load_module('_GeomInt', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomInt = swig_import_helper()
    del swig_import_helper
else:
    import _GeomInt
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomInt.delete_SwigPyIterator

    def value(self):
        return _GeomInt.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GeomInt.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GeomInt.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GeomInt.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GeomInt.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GeomInt.SwigPyIterator_copy(self)

    def next(self):
        return _GeomInt.SwigPyIterator_next(self)

    def __next__(self):
        return _GeomInt.SwigPyIterator___next__(self)

    def previous(self):
        return _GeomInt.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GeomInt.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GeomInt.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GeomInt.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GeomInt.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GeomInt.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GeomInt.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GeomInt.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GeomInt.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomInt.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GeomInt.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomInt.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomInt.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomInt.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GeomInt.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GeomInt.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GeomInt.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomInt.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GeomInt.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomInt.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomInt.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomInt.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GeomInt.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GeomInt.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GeomInt.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GeomInt.ptr_to_number(item)
ptr_to_number = _GeomInt.ptr_to_number

def HashCode(*args):
    return _GeomInt.HashCode(*args)
HashCode = _GeomInt.HashCode

def ptr_equal(a, b):
    return _GeomInt.ptr_equal(a, b)
ptr_equal = _GeomInt.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
class GeomInt_ParameterAndOrientation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ParameterAndOrientation self) -> GeomInt_ParameterAndOrientation
        __init__(GeomInt_ParameterAndOrientation self, Standard_Real const P, TopAbs_Orientation const Or1, TopAbs_Orientation const Or2) -> GeomInt_ParameterAndOrientation

        :type P: float
        :type Or1: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Or2: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        this = _GeomInt.new_GeomInt_ParameterAndOrientation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetOrientation1(self, *args):
        """
        SetOrientation1(GeomInt_ParameterAndOrientation self, TopAbs_Orientation const Or)

        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _GeomInt.GeomInt_ParameterAndOrientation_SetOrientation1(self, *args)


    def SetOrientation2(self, *args):
        """
        SetOrientation2(GeomInt_ParameterAndOrientation self, TopAbs_Orientation const Or)

        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _GeomInt.GeomInt_ParameterAndOrientation_SetOrientation2(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GeomInt_ParameterAndOrientation self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParameterAndOrientation_Parameter(self, *args)


    def Orientation1(self, *args):
        """
        Orientation1(GeomInt_ParameterAndOrientation self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _GeomInt.GeomInt_ParameterAndOrientation_Orientation1(self, *args)


    def Orientation2(self, *args):
        """
        Orientation2(GeomInt_ParameterAndOrientation self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _GeomInt.GeomInt_ParameterAndOrientation_Orientation2(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParameterAndOrientation
GeomInt_ParameterAndOrientation_swigregister = _GeomInt.GeomInt_ParameterAndOrientation_swigregister
GeomInt_ParameterAndOrientation_swigregister(GeomInt_ParameterAndOrientation)

class GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, NCollection_Array1_Standard_Real Param, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Standard_Real const TolTangency) -> GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox
        __init__(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Standard_Real const TolTangency) -> GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox

        initialize the parameters to compute the solution point
        it 's possible to write to optimize:
        IntImp_Int2S inter(S1,S2,Func,TolTangency);
        math_FunctionSetRoot rsnld(inter.Function());
        while ...{
        Param(1)=...
        Param(2)=...
        param(3)=...
        inter.Perform(Param,rsnld);
        }

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type TolTangency: float

        """
        this = _GeomInt.new_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, NCollection_Array1_Standard_Real Param, math_FunctionSetRoot Rsnld) -> IntImp_ConstIsoparametric
        Perform(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, NCollection_Array1_Standard_Real Param, math_FunctionSetRoot Rsnld, IntImp_ConstIsoparametric const ChoixIso) -> IntImp_ConstIsoparametric

        returns the best constant isoparametric to find
        the next intersection's point +stores the solution
        point (the solution point is found with the close point
        to intersect the isoparametric with the other patch;
        the choice of the isoparametic is given by ChoixIso)

        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Rsnld: OCC.wrapper.math.math_FunctionSetRoot
        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.IntImp.IntImp_ConstIsoparametric

        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> Standard_Boolean

        Returns TRUE if the creation completed without failure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> Standard_Boolean

        Returns TRUE when there is no solution to the problem.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsEmpty(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangent(self, *args):
        """
        IsTangent(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> Standard_Boolean

        Returns True if the surfaces are tangent at the
        intersection point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent(self, *args)


    def Direction(self, *args):
        """
        Returns the tangent at the intersection line.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DirectionOnS1(self, *args):
        """
        Returns the tangent at the intersection line in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DirectionOnS2(self, *args):
        """
        Returns the tangent at the intersection line in the
        parametric space of the second surface.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Function(self, *args):
        """
        Function(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox

        return the math function which
        is used to compute the intersection

        :rtype: OCC.wrapper.GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox

        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Function(self, *args)


    def ChangePoint(self, *args):
        """
        ChangePoint(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> IntSurf_PntOn2S

        return the intersection point which is
        enable for changing.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ChangePoint(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheInt2SOfThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _GeomInt.new_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ResConstraintOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _GeomInt.new_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_LastConstraint(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ParFunctionOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_TheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_TheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox Line, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-3, Standard_Real const Tolerance2d=1.0e-6, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> GeomInt_TheComputeLineOfWLApprox
        __init__(GeomInt_TheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox Line, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> GeomInt_TheComputeLineOfWLApprox
        __init__(GeomInt_TheComputeLineOfWLApprox self, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> GeomInt_TheComputeLineOfWLApprox
        __init__(GeomInt_TheComputeLineOfWLApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> GeomInt_TheComputeLineOfWLApprox

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        this = _GeomInt.new_GeomInt_TheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Interpol(self, *args):
        """
        Interpol(GeomInt_TheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox Line)

        Constructs an interpolation of the MultiLine <Line>
        The result will be a C2 curve of degree 3.

        :type Line: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Interpol(self, *args)


    def Init(self, *args):
        """
        Init(GeomInt_TheComputeLineOfWLApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares)

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomInt_TheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Perform(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(GeomInt_TheComputeLineOfWLApprox self, math_Vector ThePar)

        The approximation will begin with the
        set of  parameters <ThePar>.

        :type ThePar: OCC.wrapper.math.math_Vector

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetParameters(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(GeomInt_TheComputeLineOfWLApprox self, NCollection_Array1_Standard_Real Knots)

        The approximation will be done with the
        set of knots <Knots>. The multiplicities will be set
        with the degree and the desired continuity.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnots(self, *args)


    def SetKnotsAndMultiplicities(self, *args):
        """
        SetKnotsAndMultiplicities(GeomInt_TheComputeLineOfWLApprox self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

        The approximation will be done with the
        set of knots <Knots> and the multiplicities <Mults>.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetKnotsAndMultiplicities(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(GeomInt_TheComputeLineOfWLApprox self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(GeomInt_TheComputeLineOfWLApprox self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetTolerances(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(GeomInt_TheComputeLineOfWLApprox self, Standard_Integer const C)

        sets the continuity of the spline.
        if C = 2, the spline will be C2.

        :type C: int

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetContinuity(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(GeomInt_TheComputeLineOfWLApprox self, AppParCurves_Constraint const firstC, AppParCurves_Constraint const lastC)

        changes the first and the last constraint points.

        :type firstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type lastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(GeomInt_TheComputeLineOfWLApprox self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(GeomInt_TheComputeLineOfWLApprox self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(GeomInt_TheComputeLineOfWLApprox self)

        returns the tolerances 2d and 3d of the MultiBSpCurve.

        :type tol3d: float
        :type tol2d: float

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_Error(self, *args)


    def Value(self, *args):
        """
        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _GeomInt.GeomInt_TheComputeLineOfWLApprox_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(GeomInt_TheComputeLineOfWLApprox self) -> AppParCurves_MultiBSpCurve

        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _GeomInt.GeomInt_TheComputeLineOfWLApprox_ChangeValue(self, *args)


    def Parameters(self, *args):
        """
        returns the new parameters of the approximation
        corresponding to the points of the MultiBSpCurve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomInt.GeomInt_TheComputeLineOfWLApprox_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_TheComputeLineOfWLApprox
GeomInt_TheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_TheComputeLineOfWLApprox_swigregister
GeomInt_TheComputeLineOfWLApprox_swigregister(GeomInt_TheComputeLineOfWLApprox)

class GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox
        __init__(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox
        __init__(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox
        __init__(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _GeomInt.new_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector Parameters)
        Perform(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ParLeastSquareOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _GeomInt.new_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_IsSolutionReached(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_Gradient_BFGSOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_LineTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NbVertex(*args):
        """
        NbVertex(Handle_IntPatch_Line L) -> Standard_Integer

        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_LineTool_NbVertex(*args)

    NbVertex = staticmethod(NbVertex)

    def Vertex(*args):
        """
        Vertex(Handle_IntPatch_Line L, Standard_Integer const I) -> IntPatch_Point

        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
        :type I: int
        :rtype: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _GeomInt.GeomInt_LineTool_Vertex(*args)

    Vertex = staticmethod(Vertex)

    def FirstParameter(*args):
        """
        FirstParameter(Handle_IntPatch_Line L) -> Standard_Real

        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_LineTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Handle_IntPatch_Line L) -> Standard_Real

        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_LineTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def DecompositionOfWLine(*args):
        """
        DecompositionOfWLine(Handle_IntPatch_WLine theWLine, Handle_GeomAdaptor_HSurface theSurface1, Handle_GeomAdaptor_HSurface theSurface2, Standard_Real const aTolSum, GeomInt_LineConstructor theLConstructor, NCollection_Sequence_Handle_IntPatch_Line theNewLines) -> Standard_Boolean

        :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type theSurface1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type theSurface2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type aTolSum: float
        :type theLConstructor: OCC.wrapper.GeomInt.GeomInt_LineConstructor
        :type theNewLines: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_LineTool_DecompositionOfWLine(*args)

    DecompositionOfWLine = staticmethod(DecompositionOfWLine)

    def __init__(self):
        this = _GeomInt.new_GeomInt_LineTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomInt.delete_GeomInt_LineTool
GeomInt_LineTool_swigregister = _GeomInt.GeomInt_LineTool_swigregister
GeomInt_LineTool_swigregister(GeomInt_LineTool)

def GeomInt_LineTool_NbVertex(*args):
    """
    GeomInt_LineTool_NbVertex(Handle_IntPatch_Line L) -> Standard_Integer

    :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GeomInt.GeomInt_LineTool_NbVertex(*args)

def GeomInt_LineTool_Vertex(*args):
    """
    GeomInt_LineTool_Vertex(Handle_IntPatch_Line L, Standard_Integer const I) -> IntPatch_Point

    :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
    :type I: int
    :rtype: OCC.wrapper.IntPatch.IntPatch_Point

    """
    return _GeomInt.GeomInt_LineTool_Vertex(*args)

def GeomInt_LineTool_FirstParameter(*args):
    """
    GeomInt_LineTool_FirstParameter(Handle_IntPatch_Line L) -> Standard_Real

    :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _GeomInt.GeomInt_LineTool_FirstParameter(*args)

def GeomInt_LineTool_LastParameter(*args):
    """
    GeomInt_LineTool_LastParameter(Handle_IntPatch_Line L) -> Standard_Real

    :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _GeomInt.GeomInt_LineTool_LastParameter(*args)

def GeomInt_LineTool_DecompositionOfWLine(*args):
    """
    GeomInt_LineTool_DecompositionOfWLine(Handle_IntPatch_WLine theWLine, Handle_GeomAdaptor_HSurface theSurface1, Handle_GeomAdaptor_HSurface theSurface2, Standard_Real const aTolSum, GeomInt_LineConstructor theLConstructor, NCollection_Sequence_Handle_IntPatch_Line theNewLines) -> Standard_Boolean

    :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
    :type theSurface1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
    :type theSurface2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
    :type aTolSum: float
    :type theLConstructor: OCC.wrapper.GeomInt.GeomInt_LineConstructor
    :type theNewLines: OCC.wrapper.IntPatch.IntPatch_SequenceOfLine
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomInt.GeomInt_LineTool_DecompositionOfWLine(*args)

class GeomInt_TheMultiLineToolOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstPoint(*args):
        """
        FirstPoint(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

        Returns the number of multipoints of the TheMultiLine.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_FirstPoint(*args)

    FirstPoint = staticmethod(FirstPoint)

    def LastPoint(*args):
        """
        LastPoint(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

        Returns the number of multipoints of the TheMultiLine.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_LastPoint(*args)

    LastPoint = staticmethod(LastPoint)

    def NbP2d(*args):
        """
        NbP2d(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

        Returns the number of 2d points of a TheMultiLine.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP2d(*args)

    NbP2d = staticmethod(NbP2d)

    def NbP3d(*args):
        """
        NbP3d(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

        Returns the number of 3d points of a TheMultiLine.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP3d(*args)

    NbP3d = staticmethod(NbP3d)

    def Value(*args):
        """
        Value(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
        Value(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
        Value(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

        returns the 3d and 2d points of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type MPointIndex: int
        :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Value(*args)

    Value = staticmethod(Value)

    def Tangency(*args):
        """
        Tangency(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Tangency(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Tangency(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        returns the 3d and 2d points of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Tangency(*args)

    Tangency = staticmethod(Tangency)

    def Curvature(*args):
        """
        Curvature(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Curvature(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Curvature(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        returns the 3d and 2d curvature of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Curvature(*args)

    Curvature = staticmethod(Curvature)

    def MakeMLBetween(*args):
        """
        MakeMLBetween(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const NbPMin) -> GeomInt_TheMultiLineOfWLApprox

        Is called if WhatStatus returned "PointsAdded".

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type I1: int
        :type I2: int
        :type NbPMin: int
        :rtype: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween(*args)

    MakeMLBetween = staticmethod(MakeMLBetween)

    def MakeMLOneMorePoint(*args):
        """
        MakeMLOneMorePoint(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const indbad, GeomInt_TheMultiLineOfWLApprox OtherLine) -> Standard_Boolean

        Is called when the Bezier curve contains a loop

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type I1: int
        :type I2: int
        :type indbad: int
        :type OtherLine: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint(*args)

    MakeMLOneMorePoint = staticmethod(MakeMLOneMorePoint)

    def WhatStatus(*args):
        """
        WhatStatus(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const I1, Standard_Integer const I2) -> Approx_Status

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type I1: int
        :type I2: int
        :rtype: OCC.wrapper.Approx.Approx_Status

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_WhatStatus(*args)

    WhatStatus = staticmethod(WhatStatus)

    def Dump(*args):
        """
        Dump(GeomInt_TheMultiLineOfWLApprox ML)

        Dump of the current multi-line.

        :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

        """
        return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Dump(*args)

    Dump = staticmethod(Dump)

    def __init__(self):
        this = _GeomInt.new_GeomInt_TheMultiLineToolOfWLApprox()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomInt.delete_GeomInt_TheMultiLineToolOfWLApprox
GeomInt_TheMultiLineToolOfWLApprox_swigregister = _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_swigregister
GeomInt_TheMultiLineToolOfWLApprox_swigregister(GeomInt_TheMultiLineToolOfWLApprox)

def GeomInt_TheMultiLineToolOfWLApprox_FirstPoint(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_FirstPoint(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

    Returns the number of multipoints of the TheMultiLine.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_FirstPoint(*args)

def GeomInt_TheMultiLineToolOfWLApprox_LastPoint(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_LastPoint(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

    Returns the number of multipoints of the TheMultiLine.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_LastPoint(*args)

def GeomInt_TheMultiLineToolOfWLApprox_NbP2d(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_NbP2d(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

    Returns the number of 2d points of a TheMultiLine.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP2d(*args)

def GeomInt_TheMultiLineToolOfWLApprox_NbP3d(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_NbP3d(GeomInt_TheMultiLineOfWLApprox ML) -> Standard_Integer

    Returns the number of 3d points of a TheMultiLine.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_NbP3d(*args)

def GeomInt_TheMultiLineToolOfWLApprox_Value(*args):
    """
    Value(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
    Value(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
    GeomInt_TheMultiLineToolOfWLApprox_Value(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

    returns the 3d and 2d points of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :type MPointIndex: int
    :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Value(*args)

def GeomInt_TheMultiLineToolOfWLApprox_Tangency(*args):
    """
    Tangency(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
    Tangency(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
    GeomInt_TheMultiLineToolOfWLApprox_Tangency(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

    returns the 3d and 2d points of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :type MPointIndex: int
    :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Tangency(*args)

def GeomInt_TheMultiLineToolOfWLApprox_Curvature(*args):
    """
    Curvature(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
    Curvature(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
    GeomInt_TheMultiLineToolOfWLApprox_Curvature(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

    returns the 3d and 2d curvature of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :type MPointIndex: int
    :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Curvature(*args)

def GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const NbPMin) -> GeomInt_TheMultiLineOfWLApprox

    Is called if WhatStatus returned "PointsAdded".

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :type I1: int
    :type I2: int
    :type NbPMin: int
    :rtype: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLBetween(*args)

def GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const indbad, GeomInt_TheMultiLineOfWLApprox OtherLine) -> Standard_Boolean

    Is called when the Bezier curve contains a loop

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :type I1: int
    :type I2: int
    :type indbad: int
    :type OtherLine: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_MakeMLOneMorePoint(*args)

def GeomInt_TheMultiLineToolOfWLApprox_WhatStatus(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_WhatStatus(GeomInt_TheMultiLineOfWLApprox ML, Standard_Integer const I1, Standard_Integer const I2) -> Approx_Status

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
    :type I1: int
    :type I2: int
    :rtype: OCC.wrapper.Approx.Approx_Status

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_WhatStatus(*args)

def GeomInt_TheMultiLineToolOfWLApprox_Dump(*args):
    """
    GeomInt_TheMultiLineToolOfWLApprox_Dump(GeomInt_TheMultiLineOfWLApprox ML)

    Dump of the current multi-line.

    :type ML: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

    """
    return _GeomInt.GeomInt_TheMultiLineToolOfWLApprox_Dump(*args)

class GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2) -> GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        this = _GeomInt.new_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Values(self, *args)


    def ComputeParameters(self, *args):
        """
        ComputeParameters(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, IntImp_ConstIsoparametric const ChoixIso, NCollection_Array1_Standard_Real Param, math_Vector UVap, math_Vector BornInf, math_Vector BornSup, math_Vector Tolerance)

        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UVap: OCC.wrapper.math.math_Vector
        :type BornInf: OCC.wrapper.math.math_Vector
        :type BornSup: OCC.wrapper.math.math_Vector
        :type Tolerance: OCC.wrapper.math.math_Vector

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_ComputeParameters(self, *args)


    def Root(self, *args):
        """
        Root(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> Standard_Real

        returns somme des fi*fi

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Root(self, *args)


    def Point(self, *args):
        """
        Point(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Point(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self, math_Vector UVap, NCollection_Array1_Standard_Real Param) -> Standard_Boolean

        :type UVap: OCC.wrapper.math.math_Vector
        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BestChoix: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_IsTangent(self, *args)


    def Direction(self, *args):
        """
        Direction(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> gp_Dir

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_Direction(self, *args)


    def DirectionOnS1(self, *args):
        """
        DirectionOnS1(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> gp_Dir2d

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args):
        """
        DirectionOnS2(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox self) -> gp_Dir2d

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_DirectionOnS2(self, *args)


    def AuxillarSurface1(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AuxillarSurface2(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_AuxillarSurface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheFunctionOfTheInt2SOfThePrmPrmSvSurfacesOfWLApprox)

class GeomInt_MyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=200) -> GeomInt_MyGradientbisOfTheComputeLineOfWLApprox

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating Bezier curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int

        """
        this = _GeomInt.new_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox self) -> AppParCurves_MultiCurve

        returns all the Bezier curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Value(self, *args)


    def Error(self, *args):
        """
        Error(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_AverageError(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyGradientbisOfTheComputeLineOfWLApprox
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_MyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_MyGradientbisOfTheComputeLineOfWLApprox)

class NCollection_Vector_Standard_Real(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_Standard_Real self) -> NCollection_Vector< Standard_Real >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _GeomInt.NCollection_Vector_Standard_Real_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_Standard_Real self) -> NCollection_Vector< Standard_Real >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _GeomInt.NCollection_Vector_Standard_Real_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_Standard_Real self) -> NCollection_Vector< Standard_Real >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _GeomInt.NCollection_Vector_Standard_Real_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_Standard_Real self) -> NCollection_Vector< Standard_Real >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _GeomInt.NCollection_Vector_Standard_Real_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _GeomInt.new_NCollection_Vector_Standard_Real(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_Standard_Real self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Vector_Standard_Real_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_Standard_Real self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Vector_Standard_Real_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_Standard_Real self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Vector_Standard_Real_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_Standard_Real self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Vector_Standard_Real_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_Standard_Real self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.NCollection_Vector_Standard_Real_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_Standard_Real self, NCollection_Vector_Standard_Real theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _GeomInt.NCollection_Vector_Standard_Real_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_Standard_Real self, NCollection_Vector_Standard_Real theOther) -> NCollection_Vector_Standard_Real

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _GeomInt.NCollection_Vector_Standard_Real_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_Standard_Real self, double const & theValue) -> double &

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Vector_Standard_Real_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_Standard_Real self) -> double &

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Vector_Standard_Real_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Vector_Standard_Real_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Vector_Standard_Real_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_Standard_Real self) -> double &

        @return first element

        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Vector_Standard_Real_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Vector_Standard_Real_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_Standard_Real self) -> double &

        @return last element

        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Vector_Standard_Real_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Vector_Standard_Real___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Vector_Standard_Real_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_Standard_Real self, Standard_Integer const theIndex) -> double &

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Vector_Standard_Real_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_Standard_Real self, Standard_Integer const theIndex, double const & theValue) -> double &

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Vector_Standard_Real_SetValue(self, *args)

    __swig_destroy__ = _GeomInt.delete_NCollection_Vector_Standard_Real
NCollection_Vector_Standard_Real_swigregister = _GeomInt.NCollection_Vector_Standard_Real_swigregister
NCollection_Vector_Standard_Real_swigregister(NCollection_Vector_Standard_Real)


try:
	GeomInt_VectorOfReal = NCollection_Vector_Standard_Real
except NameError:
	pass # does not exist, probably ignored

class GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=1) -> GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox
        __init__(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations, Standard_Real const lambda1, Standard_Real const lambda2) -> GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating BSpline curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int
        :type lambda1: float
        :type lambda2: float

        """
        this = _GeomInt.new_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self) -> AppParCurves_MultiBSpCurve

        returns all the BSpline curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Value(self, *args)


    def Error(self, *args):
        """
        Error(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_AverageError(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_MyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_TheMultiLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_TheMultiLineOfWLApprox self) -> GeomInt_TheMultiLineOfWLApprox
        __init__(GeomInt_TheMultiLineOfWLApprox self, Handle_IntPatch_WLine line, Standard_Address const PtrSvSurfaces, Standard_Integer const NbP3d, Standard_Integer const NbP2d, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Real const xo, Standard_Real const yo, Standard_Real const zo, Standard_Real const u1o, Standard_Real const v1o, Standard_Real const u2o, Standard_Real const v2o, Standard_Boolean const P2DOnFirst, Standard_Integer const IndMin=0, Standard_Integer const IndMax=0) -> GeomInt_TheMultiLineOfWLApprox
        __init__(GeomInt_TheMultiLineOfWLApprox self, Handle_IntPatch_WLine line, Standard_Integer const NbP3d, Standard_Integer const NbP2d, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Real const xo, Standard_Real const yo, Standard_Real const zo, Standard_Real const u1o, Standard_Real const v1o, Standard_Real const u2o, Standard_Real const v2o, Standard_Boolean const P2DOnFirst, Standard_Integer const IndMin=0, Standard_Integer const IndMax=0) -> GeomInt_TheMultiLineOfWLApprox

        No Extra points will be added on the current line

        :type line: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type NbP3d: int
        :type NbP2d: int
        :type ApproxU1V1: bool
        :type ApproxU2V2: bool
        :type xo: float
        :type yo: float
        :type zo: float
        :type u1o: float
        :type v1o: float
        :type u2o: float
        :type v2o: float
        :type P2DOnFirst: bool
        :type IndMin: int
        :type IndMax: int

        """
        this = _GeomInt.new_GeomInt_TheMultiLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstPoint(self, *args):
        """
        FirstPoint(GeomInt_TheMultiLineOfWLApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_FirstPoint(self, *args)


    def LastPoint(self, *args):
        """
        LastPoint(GeomInt_TheMultiLineOfWLApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_LastPoint(self, *args)


    def NbP2d(self, *args):
        """
        NbP2d(GeomInt_TheMultiLineOfWLApprox self) -> Standard_Integer

        Returns the number of 2d points of a TheLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP2d(self, *args)


    def NbP3d(self, *args):
        """
        NbP3d(GeomInt_TheMultiLineOfWLApprox self) -> Standard_Integer

        Returns the number of 3d points of a TheLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_NbP3d(self, *args)


    def WhatStatus(self, *args):
        """
        WhatStatus(GeomInt_TheMultiLineOfWLApprox self) -> Approx_Status

        :rtype: OCC.wrapper.Approx.Approx_Status

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_WhatStatus(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
        Value(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
        Value(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

        returns the 3d and 2d points of the multipoint <MPointIndex>.

        :type MPointIndex: int
        :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_Value(self, *args)


    def Tangency(self, *args):
        """
        Tangency(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Tangency(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Tangency(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        Returns the 3d and 2d points of the multipoint <MPointIndex>.

        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_Tangency(self, *args)


    def MakeMLBetween(self, *args):
        """
        MakeMLBetween(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const Low, Standard_Integer const High, Standard_Integer const NbPointsToInsert) -> GeomInt_TheMultiLineOfWLApprox

        Tries to make a sub-line between <Low> and <High> points of this line
        by adding <NbPointsToInsert> new points

        :type Low: int
        :type High: int
        :type NbPointsToInsert: int
        :rtype: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLBetween(self, *args)


    def MakeMLOneMorePoint(self, *args):
        """
        MakeMLOneMorePoint(GeomInt_TheMultiLineOfWLApprox self, Standard_Integer const Low, Standard_Integer const High, Standard_Integer const indbad, GeomInt_TheMultiLineOfWLApprox OtherLine) -> Standard_Boolean

        Tries to make a sub-line between <Low> and <High> points of this line
        by adding one more point between (indbad-1)-th and indbad-th points

        :type Low: int
        :type High: int
        :type indbad: int
        :type OtherLine: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_MakeMLOneMorePoint(self, *args)


    def Dump(self, *args):
        """
        Dump(GeomInt_TheMultiLineOfWLApprox self)

        Dump of the current multi-line.


        """
        return _GeomInt.GeomInt_TheMultiLineOfWLApprox_Dump(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheMultiLineOfWLApprox
GeomInt_TheMultiLineOfWLApprox_swigregister = _GeomInt.GeomInt_TheMultiLineOfWLApprox_swigregister
GeomInt_TheMultiLineOfWLApprox_swigregister(GeomInt_TheMultiLineOfWLApprox)

class GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self) -> GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox
        __init__(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, Handle_Adaptor3d_HSurface PS, IntSurf_Quadric IS) -> GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox
        __init__(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, IntSurf_Quadric IS) -> GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox

        :type IS: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        this = _GeomInt.new_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetImplicitSurface(self, *args):
        """
        SetImplicitSurface(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, IntSurf_Quadric IS)

        :type IS: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_SetImplicitSurface(self, *args)


    def Set(self, *args):
        """
        Set(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, Handle_Adaptor3d_HSurface PS)
        Set(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, Standard_Real const Tolerance)

        :type Tolerance: float

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Set(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Values(self, *args)


    def Root(self, *args):
        """
        Root(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Root(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self) -> Standard_Real

        Returns the value Tol so that if Abs(Func.Root())<Tol
        the function is considered null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Tolerance(self, *args)


    def Point(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangent(self, *args):
        """
        IsTangent(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_IsTangent(self, *args)


    def Direction3d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_Direction2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PSurface(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_PSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ISurface(self, *args):
        """
        ISurface(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox self) -> IntSurf_Quadric

        :rtype: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        return _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_ISurface(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheZerImpFuncOfTheImpPrmSvSurfacesOfWLApprox)

class GeomInt_LineConstructor(object):
    """Splits given Line."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_LineConstructor self) -> GeomInt_LineConstructor

        Empty constructor


        """
        this = _GeomInt.new_GeomInt_LineConstructor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(GeomInt_LineConstructor self, Handle_Adaptor3d_TopolTool D1, Handle_Adaptor3d_TopolTool D2, Handle_GeomAdaptor_HSurface S1, Handle_GeomAdaptor_HSurface S2)

        Initializes me by two surfaces and corresponding
        tools which represent boundaries of surfaces

        :type D1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type D2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type S1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type S2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface

        """
        return _GeomInt.GeomInt_LineConstructor_Load(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomInt_LineConstructor self, Handle_IntPatch_Line L)

        Splits line

        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line

        """
        return _GeomInt.GeomInt_LineConstructor_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomInt_LineConstructor self) -> Standard_Boolean

        Returns True if splitting was successful

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_LineConstructor_IsDone(self, *args)


    def NbParts(self, *args):
        """
        NbParts(GeomInt_LineConstructor self) -> Standard_Integer

        Returns number of splits

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_LineConstructor_NbParts(self, *args)


    def Part(self, *args):
        """
        Part(GeomInt_LineConstructor self, Standard_Integer const I)

        Return first and last parameters
        for given index of split

        :type I: int
        :type WFirst: float
        :type WLast: float

        """
        return _GeomInt.GeomInt_LineConstructor_Part(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_LineConstructor
GeomInt_LineConstructor_swigregister = _GeomInt.GeomInt_LineConstructor_swigregister
GeomInt_LineConstructor_swigregister(GeomInt_LineConstructor)

class GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _GeomInt.new_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_LastConstraint(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ParFunctionOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_ThePrmPrmSvSurfacesOfWLApprox(ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ThePrmPrmSvSurfacesOfWLApprox self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor3d_HSurface Surf2) -> GeomInt_ThePrmPrmSvSurfacesOfWLApprox

        :type Surf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        this = _GeomInt.new_GeomInt_ThePrmPrmSvSurfacesOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Compute(self, *args):
        """
        Compute(GeomInt_ThePrmPrmSvSurfacesOfWLApprox self, gp_Pnt Pt, gp_Vec Tg, gp_Vec2d Tguv1, gp_Vec2d Tguv2) -> Standard_Boolean

        returns True if Tg,Tguv1 Tguv2 can be computed.

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type Tg: OCC.wrapper.gp.gp_Vec
        :type Tguv1: OCC.wrapper.gp.gp_Vec2d
        :type Tguv2: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_Compute(self, *args)


    def Pnt(self, *args):
        """
        Pnt(GeomInt_ThePrmPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Pnt P)

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_Pnt(self, *args)


    def SeekPoint(self, *args):
        """
        SeekPoint(GeomInt_ThePrmPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, IntSurf_PntOn2S Point) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Point: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_SeekPoint(self, *args)


    def Tangency(self, *args):
        """
        Tangency(GeomInt_ThePrmPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_Tangency(self, *args)


    def TangencyOnSurf1(self, *args):
        """
        TangencyOnSurf1(GeomInt_ThePrmPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_TangencyOnSurf1(self, *args)


    def TangencyOnSurf2(self, *args):
        """
        TangencyOnSurf2(GeomInt_ThePrmPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_TangencyOnSurf2(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_ThePrmPrmSvSurfacesOfWLApprox
GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swigregister
GeomInt_ThePrmPrmSvSurfacesOfWLApprox_swigregister(GeomInt_ThePrmPrmSvSurfacesOfWLApprox)

class NCollection_Sequence_GeomInt_ParameterAndOrientation(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> NCollection_Sequence< GeomInt_ParameterAndOrientation >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> NCollection_Sequence< GeomInt_ParameterAndOrientation >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> NCollection_Sequence< GeomInt_ParameterAndOrientation >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> NCollection_Sequence< GeomInt_ParameterAndOrientation >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _GeomInt.new_NCollection_Sequence_GeomInt_ParameterAndOrientation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_GeomInt_ParameterAndOrientation self)

        Reverse sequence


        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_GeomInt_ParameterAndOrientation self, NCollection_Sequence_GeomInt_ParameterAndOrientation theOther) -> NCollection_Sequence_GeomInt_ParameterAndOrientation

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_GeomInt_ParameterAndOrientation self, NCollection_Sequence_GeomInt_ParameterAndOrientation theOther) -> NCollection_Sequence_GeomInt_ParameterAndOrientation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_GeomInt_ParameterAndOrientation self, NCollection_Sequence< GeomInt_ParameterAndOrientation >::Iterator & thePosition)
        Remove(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_GeomInt_ParameterAndOrientation self, GeomInt_ParameterAndOrientation theItem)
        Append(NCollection_Sequence_GeomInt_ParameterAndOrientation self, NCollection_Sequence_GeomInt_ParameterAndOrientation theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_GeomInt_ParameterAndOrientation self, GeomInt_ParameterAndOrientation theItem)
        Prepend(NCollection_Sequence_GeomInt_ParameterAndOrientation self, NCollection_Sequence_GeomInt_ParameterAndOrientation theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex, GeomInt_ParameterAndOrientation theItem)
        InsertBefore(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex, NCollection_Sequence_GeomInt_ParameterAndOrientation theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_GeomInt_ParameterAndOrientation self, NCollection_Sequence< GeomInt_ParameterAndOrientation >::Iterator & thePosition, GeomInt_ParameterAndOrientation theItem)
        InsertAfter(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex, NCollection_Sequence_GeomInt_ParameterAndOrientation theSeq)
        InsertAfter(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex, GeomInt_ParameterAndOrientation theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex, NCollection_Sequence_GeomInt_ParameterAndOrientation theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> GeomInt_ParameterAndOrientation

        First item access

        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_GeomInt_ParameterAndOrientation self) -> GeomInt_ParameterAndOrientation

        Last item access

        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex) -> GeomInt_ParameterAndOrientation

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_GeomInt_ParameterAndOrientation self, Standard_Integer const theIndex, GeomInt_ParameterAndOrientation theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_SetValue(self, *args)


    def __iter__(self):
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation___iter__(self)
    __swig_destroy__ = _GeomInt.delete_NCollection_Sequence_GeomInt_ParameterAndOrientation
NCollection_Sequence_GeomInt_ParameterAndOrientation_swigregister = _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_swigregister
NCollection_Sequence_GeomInt_ParameterAndOrientation_swigregister(NCollection_Sequence_GeomInt_ParameterAndOrientation)

def NCollection_Sequence_GeomInt_ParameterAndOrientation_delNode(*args):
    """
    NCollection_Sequence_GeomInt_ParameterAndOrientation_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_delNode(*args)

class NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GeomInt.new_NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomInt.delete_NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper

    def __next__(self):
        return _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper___next__(self)
NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper_swigregister = _GeomInt.NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper_swigregister
NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper_swigregister(NCollection_Sequence_GeomInt_ParameterAndOrientation_IteratorHelper)


try:
	GeomInt_SequenceOfParameterAndOrientation = NCollection_Sequence_GeomInt_ParameterAndOrientation
except NameError:
	pass # does not exist, probably ignored

class GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const NbPol) -> GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox

        initializes the fields of the function. The approximating
        curve has <NbPol> control points.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbPol: int

        """
        this = _GeomInt.new_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        CurveValue(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> AppParCurves_MultiBSpCurve

        returns the MultiBSpCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_CurveValue(self, *args)


    def Error(self, *args):
        """
        Error(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiBSpCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiBSpCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_MaxError2d(self, *args)


    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        multiline.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used to approximate the
        multiline.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_Index(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstConstraint(self, *args):
        """
        FirstConstraint(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_LastConstraint(self, *args)


    def SetFirstLambda(self, *args):
        """
        SetFirstLambda(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, Standard_Real const l1)

        :type l1: float

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetFirstLambda(self, *args)


    def SetLastLambda(self, *args):
        """
        SetLastLambda(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox self, Standard_Real const l2)

        :type l2: float

        """
        return _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_SetLastLambda(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpParFunctionOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox
        __init__(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox
        __init__(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox
        __init__(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _GeomInt.new_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector Parameters)
        Perform(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpParLeastSquareOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_TheImpPrmSvSurfacesOfWLApprox(ApproxInt.ApproxInt_SvSurfaces):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, Handle_Adaptor3d_HSurface Surf1, IntSurf_Quadric Surf2) -> GeomInt_TheImpPrmSvSurfacesOfWLApprox
        __init__(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, IntSurf_Quadric Surf1, Handle_Adaptor3d_HSurface Surf2) -> GeomInt_TheImpPrmSvSurfacesOfWLApprox

        :type Surf1: OCC.wrapper.IntSurf.IntSurf_Quadric
        :type Surf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        this = _GeomInt.new_GeomInt_TheImpPrmSvSurfacesOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Compute(self, *args):
        """
        Compute(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, gp_Pnt Pt, gp_Vec Tg, gp_Vec2d Tguv1, gp_Vec2d Tguv2) -> Standard_Boolean

        returns True if Tg,Tguv1 Tguv2 can be computed.

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type Tg: OCC.wrapper.gp.gp_Vec
        :type Tguv1: OCC.wrapper.gp.gp_Vec2d
        :type Tguv2: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_Compute(self, *args)


    def Pnt(self, *args):
        """
        Pnt(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Pnt P)

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_Pnt(self, *args)


    def SeekPoint(self, *args):
        """
        SeekPoint(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, IntSurf_PntOn2S Point) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Point: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_SeekPoint(self, *args)


    def Tangency(self, *args):
        """
        Tangency(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_Tangency(self, *args)


    def TangencyOnSurf1(self, *args):
        """
        TangencyOnSurf1(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_TangencyOnSurf1(self, *args)


    def TangencyOnSurf2(self, *args):
        """
        TangencyOnSurf2(GeomInt_TheImpPrmSvSurfacesOfWLApprox self, Standard_Real const u1, Standard_Real const v1, Standard_Real const u2, Standard_Real const v2, gp_Vec2d Tg) -> Standard_Boolean

        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type Tg: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_TangencyOnSurf2(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_TheImpPrmSvSurfacesOfWLApprox
GeomInt_TheImpPrmSvSurfacesOfWLApprox_swigregister = _GeomInt.GeomInt_TheImpPrmSvSurfacesOfWLApprox_swigregister
GeomInt_TheImpPrmSvSurfacesOfWLApprox_swigregister(GeomInt_TheImpPrmSvSurfacesOfWLApprox)

class GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _GeomInt.new_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_IsSolutionReached(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_Gradient_BFGSOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox
        __init__(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox
        __init__(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox
        __init__(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _GeomInt.new_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector Parameters)
        Perform(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_ParLeastSquareOfMyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=200) -> GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating Bezier curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int

        """
        this = _GeomInt.new_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox self) -> AppParCurves_MultiCurve

        returns all the Bezier curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Value(self, *args)


    def Error(self, *args):
        """
        Error(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_AverageError(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swigregister
GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox_swigregister(GeomInt_MyGradientOfTheComputeLineBezierOfWLApprox)

class GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _GeomInt.new_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_IsSolutionReached(self, *args)

    __swig_destroy__ = _GeomInt.delete_GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox
GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister
GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox_swigregister(GeomInt_BSpGradient_BFGSOfMyBSplGradientOfTheComputeLineOfWLApprox)

class GeomInt_(object):
    """
    Provides intersections on between two surfaces of Geom.
    The result are curves from Geom.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AdjustPeriodic(*args):
        """
        AdjustPeriodic(Standard_Real const thePar, Standard_Real const theParMin, Standard_Real const theParMax, Standard_Real const thePeriod, Standard_Real const theEps=0.0) -> Standard_Boolean

        Adjusts the parameter <thePar> to the range [theParMin,  theParMax]

        :type thePar: float
        :type theParMin: float
        :type theParMax: float
        :type thePeriod: float
        :type theNewPar: float
        :type theOffset: float
        :type theEps: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt__AdjustPeriodic(*args)

    AdjustPeriodic = staticmethod(AdjustPeriodic)

    def __init__(self):
        """
        Provides intersections on between two surfaces of Geom.
        The result are curves from Geom.
        """
        this = _GeomInt.new_GeomInt_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomInt.delete_GeomInt_
GeomInt__swigregister = _GeomInt.GeomInt__swigregister
GeomInt__swigregister(GeomInt_)

def GeomInt__AdjustPeriodic(*args):
    """
    GeomInt__AdjustPeriodic(Standard_Real const thePar, Standard_Real const theParMin, Standard_Real const theParMax, Standard_Real const thePeriod, Standard_Real const theEps=0.0) -> Standard_Boolean

    Adjusts the parameter <thePar> to the range [theParMin,  theParMax]

    :type thePar: float
    :type theParMin: float
    :type theParMax: float
    :type thePeriod: float
    :type theNewPar: float
    :type theOffset: float
    :type theEps: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomInt.GeomInt__AdjustPeriodic(*args)

class GeomInt_IntSS(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_IntSS self) -> GeomInt_IntSS
        __init__(GeomInt_IntSS self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, Standard_Real const Tol, Standard_Boolean const Approx, Standard_Boolean const ApproxS1, Standard_Boolean const ApproxS2) -> GeomInt_IntSS

        performs general intersection of two surfaces just now

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float
        :type Approx: bool
        :type ApproxS1: bool
        :type ApproxS2: bool

        """
        this = _GeomInt.new_GeomInt_IntSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomInt_IntSS self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, Standard_Real const Tol, Standard_Boolean const Approx, Standard_Boolean const ApproxS1, Standard_Boolean const ApproxS2)
        Perform(GeomInt_IntSS self, Handle_GeomAdaptor_HSurface HS1, Handle_GeomAdaptor_HSurface HS2, Standard_Real const Tol, Standard_Boolean const Approx, Standard_Boolean const ApproxS1, Standard_Boolean const ApproxS2)
        Perform(GeomInt_IntSS self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, Standard_Real const Tol, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Boolean const Approx, Standard_Boolean const ApproxS1, Standard_Boolean const ApproxS2)
        Perform(GeomInt_IntSS self, Handle_GeomAdaptor_HSurface HS1, Handle_GeomAdaptor_HSurface HS2, Standard_Real const Tol, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2, Standard_Boolean const Approx, Standard_Boolean const ApproxS1, Standard_Boolean const ApproxS2)

        intersection of adapted surfaces using a starting point

        :type HS1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type HS2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type Tol: float
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float
        :type Approx: bool
        :type ApproxS1: bool
        :type ApproxS2: bool

        """
        return _GeomInt.GeomInt_IntSS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomInt_IntSS self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_IntSS_IsDone(self, *args)


    def TolReached3d(self, *args):
        """
        TolReached3d(GeomInt_IntSS self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_IntSS_TolReached3d(self, *args)


    def TolReached2d(self, *args):
        """
        TolReached2d(GeomInt_IntSS self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_IntSS_TolReached2d(self, *args)


    def NbLines(self, *args):
        """
        NbLines(GeomInt_IntSS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_IntSS_NbLines(self, *args)


    def Line(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _GeomInt.GeomInt_IntSS_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasLineOnS1(self, *args):
        """
        HasLineOnS1(GeomInt_IntSS self, Standard_Integer const Index) -> Standard_Boolean

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_IntSS_HasLineOnS1(self, *args)


    def LineOnS1(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _GeomInt.GeomInt_IntSS_LineOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasLineOnS2(self, *args):
        """
        HasLineOnS2(GeomInt_IntSS self, Standard_Integer const Index) -> Standard_Boolean

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_IntSS_HasLineOnS2(self, *args)


    def LineOnS2(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _GeomInt.GeomInt_IntSS_LineOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbBoundaries(self, *args):
        """
        NbBoundaries(GeomInt_IntSS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_IntSS_NbBoundaries(self, *args)


    def Boundary(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _GeomInt.GeomInt_IntSS_Boundary(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbPoints(self, *args):
        """
        NbPoints(GeomInt_IntSS self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_IntSS_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(GeomInt_IntSS self, Standard_Integer const Index) -> gp_Pnt

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomInt.GeomInt_IntSS_Point(self, *args)


    def Pnt2d(self, *args):
        """
        Pnt2d(GeomInt_IntSS self, Standard_Integer const Index, Standard_Boolean const OnFirst) -> gp_Pnt2d

        :type Index: int
        :type OnFirst: bool
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GeomInt.GeomInt_IntSS_Pnt2d(self, *args)


    def TreatRLine(*args):
        """
        TreatRLine(Handle_IntPatch_RLine theRL, Handle_GeomAdaptor_HSurface theHS1, Handle_GeomAdaptor_HSurface theHS2, Handle_Geom_Curve theC3d, Handle_Geom2d_Curve theC2d1, Handle_Geom2d_Curve theC2d2)

        converts RLine to Geom(2d)_Curve.

        :type theRL: OCC.wrapper.IntPatch.Handle_IntPatch_RLine
        :type theHS1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type theHS2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
        :type theC3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type theC2d1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theC2d2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theTolReached: float

        """
        return _GeomInt.GeomInt_IntSS_TreatRLine(*args)

    TreatRLine = staticmethod(TreatRLine)

    def BuildPCurves(*args):
        """
        BuildPCurves(Standard_Real const f, Standard_Real const l, Handle_Geom_Surface S, Handle_Geom_Curve C, Handle_Geom2d_Curve C2d)

        creates 2D-curve on given surface from given 3D-curve

        :type f: float
        :type l: float
        :type Tol: float
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type C2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _GeomInt.GeomInt_IntSS_BuildPCurves(*args)

    BuildPCurves = staticmethod(BuildPCurves)

    def TrimILineOnSurfBoundaries(*args):
        """
        TrimILineOnSurfBoundaries(Handle_Geom2d_Curve theC2d1, Handle_Geom2d_Curve theC2d2, Bnd_Box2d theBound1, Bnd_Box2d theBound2, NCollection_Vector_Standard_Real theArrayOfParameters)

        puts into theArrayOfParameters the parameters of intersection
        points of given theC2d1 and theC2d2 curves with the boundaries
        of the source surface.

        :type theC2d1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theC2d2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theBound1: OCC.wrapper.Bnd.Bnd_Box2d
        :type theBound2: OCC.wrapper.Bnd.Bnd_Box2d
        :type theArrayOfParameters: OCC.wrapper.GeomInt.GeomInt_VectorOfReal

        """
        return _GeomInt.GeomInt_IntSS_TrimILineOnSurfBoundaries(*args)

    TrimILineOnSurfBoundaries = staticmethod(TrimILineOnSurfBoundaries)

    def MakeBSpline(*args):
        """
        MakeBSpline(Handle_IntPatch_WLine WL, Standard_Integer const ideb, Standard_Integer const ifin) -> Handle_Geom_Curve

        :type WL: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type ideb: int
        :type ifin: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomInt.GeomInt_IntSS_MakeBSpline(*args)

    MakeBSpline = staticmethod(MakeBSpline)

    def MakeBSpline2d(*args):
        """
        MakeBSpline2d(Handle_IntPatch_WLine theWLine, Standard_Integer const ideb, Standard_Integer const ifin, Standard_Boolean const onFirst) -> Handle_Geom2d_BSplineCurve

        :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type ideb: int
        :type ifin: int
        :type onFirst: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _GeomInt.GeomInt_IntSS_MakeBSpline2d(*args)

    MakeBSpline2d = staticmethod(MakeBSpline2d)
    __swig_destroy__ = _GeomInt.delete_GeomInt_IntSS
GeomInt_IntSS_swigregister = _GeomInt.GeomInt_IntSS_swigregister
GeomInt_IntSS_swigregister(GeomInt_IntSS)

def GeomInt_IntSS_TreatRLine(*args):
    """
    GeomInt_IntSS_TreatRLine(Handle_IntPatch_RLine theRL, Handle_GeomAdaptor_HSurface theHS1, Handle_GeomAdaptor_HSurface theHS2, Handle_Geom_Curve theC3d, Handle_Geom2d_Curve theC2d1, Handle_Geom2d_Curve theC2d2)

    converts RLine to Geom(2d)_Curve.

    :type theRL: OCC.wrapper.IntPatch.Handle_IntPatch_RLine
    :type theHS1: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
    :type theHS2: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface
    :type theC3d: OCC.wrapper.Geom.Handle_Geom_Curve
    :type theC2d1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theC2d2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theTolReached: float

    """
    return _GeomInt.GeomInt_IntSS_TreatRLine(*args)

def GeomInt_IntSS_BuildPCurves(*args):
    """
    GeomInt_IntSS_BuildPCurves(Standard_Real const f, Standard_Real const l, Handle_Geom_Surface S, Handle_Geom_Curve C, Handle_Geom2d_Curve C2d)

    creates 2D-curve on given surface from given 3D-curve

    :type f: float
    :type l: float
    :type Tol: float
    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :type C2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _GeomInt.GeomInt_IntSS_BuildPCurves(*args)

def GeomInt_IntSS_TrimILineOnSurfBoundaries(*args):
    """
    GeomInt_IntSS_TrimILineOnSurfBoundaries(Handle_Geom2d_Curve theC2d1, Handle_Geom2d_Curve theC2d2, Bnd_Box2d theBound1, Bnd_Box2d theBound2, NCollection_Vector_Standard_Real theArrayOfParameters)

    puts into theArrayOfParameters the parameters of intersection
    points of given theC2d1 and theC2d2 curves with the boundaries
    of the source surface.

    :type theC2d1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theC2d2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theBound1: OCC.wrapper.Bnd.Bnd_Box2d
    :type theBound2: OCC.wrapper.Bnd.Bnd_Box2d
    :type theArrayOfParameters: OCC.wrapper.GeomInt.GeomInt_VectorOfReal

    """
    return _GeomInt.GeomInt_IntSS_TrimILineOnSurfBoundaries(*args)

def GeomInt_IntSS_MakeBSpline(*args):
    """
    GeomInt_IntSS_MakeBSpline(Handle_IntPatch_WLine WL, Standard_Integer const ideb, Standard_Integer const ifin) -> Handle_Geom_Curve

    :type WL: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
    :type ideb: int
    :type ifin: int
    :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _GeomInt.GeomInt_IntSS_MakeBSpline(*args)

def GeomInt_IntSS_MakeBSpline2d(*args):
    """
    GeomInt_IntSS_MakeBSpline2d(Handle_IntPatch_WLine theWLine, Standard_Integer const ideb, Standard_Integer const ifin, Standard_Boolean const onFirst) -> Handle_Geom2d_BSplineCurve

    :type theWLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
    :type ideb: int
    :type ifin: int
    :type onFirst: bool
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _GeomInt.GeomInt_IntSS_MakeBSpline2d(*args)

class GeomInt_WLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GeomInt_WLApprox self) -> GeomInt_WLApprox"""
        this = _GeomInt.new_GeomInt_WLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomInt_WLApprox self, Handle_Adaptor3d_HSurface Surf1, Handle_Adaptor3d_HSurface Surf2, Handle_IntPatch_WLine aLine, Standard_Boolean const ApproxXYZ, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Integer const indicemin=0, Standard_Integer const indicemax=0)
        Perform(GeomInt_WLApprox self, Handle_IntPatch_WLine aLine, Standard_Boolean const ApproxXYZ, Standard_Boolean const ApproxU1V1, Standard_Boolean const ApproxU2V2, Standard_Integer const indicemin=0, Standard_Integer const indicemax=0)

        :type aLine: OCC.wrapper.IntPatch.Handle_IntPatch_WLine
        :type ApproxXYZ: bool
        :type ApproxU1V1: bool
        :type ApproxU2V2: bool
        :type indicemin: int
        :type indicemax: int

        """
        return _GeomInt.GeomInt_WLApprox_Perform(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(GeomInt_WLApprox self, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const DegMin, Standard_Integer const DegMax, Standard_Integer const NbIterMax, Standard_Integer const NbPntMax=30, Standard_Boolean const ApproxWithTangency, Approx_ParametrizationType const Parametrization=Approx_ChordLength)

        :type Tol3d: float
        :type Tol2d: float
        :type DegMin: int
        :type DegMax: int
        :type NbIterMax: int
        :type NbPntMax: int
        :type ApproxWithTangency: bool
        :type Parametrization: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _GeomInt.GeomInt_WLApprox_SetParameters(self, *args)


    def TolReached3d(self, *args):
        """
        TolReached3d(GeomInt_WLApprox self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_WLApprox_TolReached3d(self, *args)


    def TolReached2d(self, *args):
        """
        TolReached2d(GeomInt_WLApprox self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomInt.GeomInt_WLApprox_TolReached2d(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomInt_WLApprox self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_WLApprox_IsDone(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(GeomInt_WLApprox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_WLApprox_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _GeomInt.GeomInt_WLApprox_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_WLApprox
GeomInt_WLApprox_swigregister = _GeomInt.GeomInt_WLApprox_swigregister
GeomInt_WLApprox_swigregister(GeomInt_WLApprox)

class GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox self, GeomInt_TheMultiLineOfWLApprox SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _GeomInt.new_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister = _GeomInt.GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister
GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox_swigregister(GeomInt_ResConstraintOfMyGradientbisOfTheComputeLineOfWLApprox)

class GeomInt_TheComputeLineBezierOfWLApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomInt_TheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox Line, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-3, Standard_Real const Tolerance2d=1.0e-6, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> GeomInt_TheComputeLineBezierOfWLApprox
        __init__(GeomInt_TheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox Line, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> GeomInt_TheComputeLineBezierOfWLApprox
        __init__(GeomInt_TheComputeLineBezierOfWLApprox self, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> GeomInt_TheComputeLineBezierOfWLApprox
        __init__(GeomInt_TheComputeLineBezierOfWLApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> GeomInt_TheComputeLineBezierOfWLApprox

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        this = _GeomInt.new_GeomInt_TheComputeLineBezierOfWLApprox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomInt_TheComputeLineBezierOfWLApprox self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares)

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomInt_TheComputeLineBezierOfWLApprox self, GeomInt_TheMultiLineOfWLApprox Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.GeomInt.GeomInt_TheMultiLineOfWLApprox

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(GeomInt_TheComputeLineBezierOfWLApprox self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(GeomInt_TheComputeLineBezierOfWLApprox self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(GeomInt_TheComputeLineBezierOfWLApprox self, AppParCurves_Constraint const firstC, AppParCurves_Constraint const lastC)

        changes the first and the last constraint points.

        :type firstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type lastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(GeomInt_TheComputeLineBezierOfWLApprox self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(GeomInt_TheComputeLineBezierOfWLApprox self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(GeomInt_TheComputeLineBezierOfWLApprox self, Standard_Integer const Index)

        returns the tolerances 2d and 3d of the <Index> MultiCurve.

        :type Index: int
        :type tol3d: float
        :type tol2d: float

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(GeomInt_TheComputeLineBezierOfWLApprox self) -> Standard_Integer

        Returns the number of MultiCurve doing the approximation
        of the MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        returns the result of the approximation.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(GeomInt_TheComputeLineBezierOfWLApprox self, Standard_Integer const Index=1) -> AppParCurves_MultiCurve

        returns the result of the approximation.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_ChangeValue(self, *args)


    def SplineValue(self, *args):
        """
        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_SplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parametrization(self, *args):
        """
        Parametrization(GeomInt_TheComputeLineBezierOfWLApprox self) -> Approx_ParametrizationType

        returns the type  of  parametrization

        :rtype: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parametrization(self, *args)


    def Parameters(self, *args):
        """
        returns the new parameters of the approximation
        corresponding to the points of the multicurve <Index>.

        :type Index: int
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomInt.delete_GeomInt_TheComputeLineBezierOfWLApprox
GeomInt_TheComputeLineBezierOfWLApprox_swigregister = _GeomInt.GeomInt_TheComputeLineBezierOfWLApprox_swigregister
GeomInt_TheComputeLineBezierOfWLApprox_swigregister(GeomInt_TheComputeLineBezierOfWLApprox)




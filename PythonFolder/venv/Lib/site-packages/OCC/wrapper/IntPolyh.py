# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntPolyh')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntPolyh')
    _IntPolyh = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntPolyh', [dirname(__file__)])
        except ImportError:
            import _IntPolyh
            return _IntPolyh
        try:
            _mod = imp.load_module('_IntPolyh', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntPolyh = swig_import_helper()
    del swig_import_helper
else:
    import _IntPolyh
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntPolyh.delete_SwigPyIterator

    def value(self):
        return _IntPolyh.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntPolyh.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntPolyh.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntPolyh.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntPolyh.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntPolyh.SwigPyIterator_copy(self)

    def next(self):
        return _IntPolyh.SwigPyIterator_next(self)

    def __next__(self):
        return _IntPolyh.SwigPyIterator___next__(self)

    def previous(self):
        return _IntPolyh.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntPolyh.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntPolyh.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntPolyh.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntPolyh.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntPolyh.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntPolyh.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntPolyh.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntPolyh.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntPolyh.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntPolyh.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntPolyh.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntPolyh.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPolyh.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntPolyh.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntPolyh.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntPolyh.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntPolyh.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntPolyh.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntPolyh.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntPolyh.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPolyh.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntPolyh.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntPolyh.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntPolyh.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntPolyh.ptr_to_number(item)
ptr_to_number = _IntPolyh.ptr_to_number

def HashCode(*args):
    return _IntPolyh.HashCode(*args)
HashCode = _IntPolyh.HashCode

def ptr_equal(a, b):
    return _IntPolyh.ptr_equal(a, b)
ptr_equal = _IntPolyh.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
class IntPolyh_Couple(object):
    """
    The class represents the couple of indices with additional
    characteristics such as analyzed flag and an angle.<br>
    In IntPolyh_MaillageAffinage algorithm the class is used as a
    couple of interfering triangles with the intersection angle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_Couple self) -> IntPolyh_Couple
        __init__(IntPolyh_Couple self, Standard_Integer const theTriangle1, Standard_Integer const theTriangle2, Standard_Real const theAngle=-2.0) -> IntPolyh_Couple

        Constructor

        :type theTriangle1: int
        :type theTriangle2: int
        :type theAngle: float

        """
        this = _IntPolyh.new_IntPolyh_Couple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstValue(self, *args):
        """
        FirstValue(IntPolyh_Couple self) -> Standard_Integer

        Returns the first index

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Couple_FirstValue(self, *args)


    def SecondValue(self, *args):
        """
        SecondValue(IntPolyh_Couple self) -> Standard_Integer

        Returns the second index

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Couple_SecondValue(self, *args)


    def IsAnalyzed(self, *args):
        """
        IsAnalyzed(IntPolyh_Couple self) -> Standard_Boolean

        Returns TRUE if the couple has been analyzed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_Couple_IsAnalyzed(self, *args)


    def Angle(self, *args):
        """
        Angle(IntPolyh_Couple self) -> Standard_Real

        Returns the angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Couple_Angle(self, *args)


    def SetCoupleValue(self, *args):
        """
        SetCoupleValue(IntPolyh_Couple self, Standard_Integer const theInd1, Standard_Integer const theInd2)

        Sets the triangles

        :type theInd1: int
        :type theInd2: int

        """
        return _IntPolyh.IntPolyh_Couple_SetCoupleValue(self, *args)


    def SetAnalyzed(self, *args):
        """
        SetAnalyzed(IntPolyh_Couple self, Standard_Boolean const theAnalyzed)

        Sets the analyzed flag

        :type theAnalyzed: bool

        """
        return _IntPolyh.IntPolyh_Couple_SetAnalyzed(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(IntPolyh_Couple self, Standard_Real const theAngle)

        Sets the angle

        :type theAngle: float

        """
        return _IntPolyh.IntPolyh_Couple_SetAngle(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(IntPolyh_Couple self, IntPolyh_Couple theOther) -> Standard_Boolean

        Returns true if the Couple is equal to <theOther>

        :type theOther: OCC.wrapper.IntPolyh.IntPolyh_Couple
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_Couple_IsEqual(self, *args)


    def HashCode(self, *args):
        """
        HashCode(IntPolyh_Couple self, Standard_Integer const theUpper) -> Standard_Integer

        Returns hash code

        :type theUpper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Couple_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(IntPolyh_Couple self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _IntPolyh.IntPolyh_Couple___hash__(self, *args)


    def Dump(self, *args):
        """
        Dump(IntPolyh_Couple self, Standard_Integer const v)

        :type v: int

        """
        return _IntPolyh.IntPolyh_Couple_Dump(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_Couple
IntPolyh_Couple_swigregister = _IntPolyh.IntPolyh_Couple_swigregister
IntPolyh_Couple_swigregister(IntPolyh_Couple)

class IntPolyh_StartPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_StartPoint self) -> IntPolyh_StartPoint
        __init__(IntPolyh_StartPoint self, Standard_Real const xx, Standard_Real const yy, Standard_Real const zz, Standard_Real const uu1, Standard_Real const vv1, Standard_Real const uu2, Standard_Real const vv2, Standard_Integer const T1, Standard_Integer const E1, Standard_Real const LAM1, Standard_Integer const T2, Standard_Integer const E2, Standard_Real const LAM2, Standard_Integer const List) -> IntPolyh_StartPoint

        :type xx: float
        :type yy: float
        :type zz: float
        :type uu1: float
        :type vv1: float
        :type uu2: float
        :type vv2: float
        :type T1: int
        :type E1: int
        :type LAM1: float
        :type T2: int
        :type E2: int
        :type LAM2: float
        :type List: int

        """
        this = _IntPolyh.new_IntPolyh_StartPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def X(self, *args):
        """
        X(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_X(self, *args)


    def Y(self, *args):
        """
        Y(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_Y(self, *args)


    def Z(self, *args):
        """
        Z(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_Z(self, *args)


    def U1(self, *args):
        """
        U1(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_U1(self, *args)


    def V1(self, *args):
        """
        V1(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_V1(self, *args)


    def U2(self, *args):
        """
        U2(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_U2(self, *args)


    def V2(self, *args):
        """
        V2(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_V2(self, *args)


    def T1(self, *args):
        """
        T1(IntPolyh_StartPoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_StartPoint_T1(self, *args)


    def E1(self, *args):
        """
        E1(IntPolyh_StartPoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_StartPoint_E1(self, *args)


    def Lambda1(self, *args):
        """
        Lambda1(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_Lambda1(self, *args)


    def T2(self, *args):
        """
        T2(IntPolyh_StartPoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_StartPoint_T2(self, *args)


    def E2(self, *args):
        """
        E2(IntPolyh_StartPoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_StartPoint_E2(self, *args)


    def Lambda2(self, *args):
        """
        Lambda2(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_Lambda2(self, *args)


    def GetAngle(self, *args):
        """
        GetAngle(IntPolyh_StartPoint self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_StartPoint_GetAngle(self, *args)


    def ChainList(self, *args):
        """
        ChainList(IntPolyh_StartPoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_StartPoint_ChainList(self, *args)


    def GetEdgePoints(self, *args):
        """
        GetEdgePoints(IntPolyh_StartPoint self, IntPolyh_Triangle Triangle) -> Standard_Integer

        :type Triangle: OCC.wrapper.IntPolyh.IntPolyh_Triangle
        :type FirstEdgePoint: int
        :type SecondEdgePoint: int
        :type LastPoint: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_StartPoint_GetEdgePoints(self, *args)


    def SetXYZ(self, *args):
        """
        SetXYZ(IntPolyh_StartPoint self, Standard_Real const XX, Standard_Real const YY, Standard_Real const ZZ)

        :type XX: float
        :type YY: float
        :type ZZ: float

        """
        return _IntPolyh.IntPolyh_StartPoint_SetXYZ(self, *args)


    def SetUV1(self, *args):
        """
        SetUV1(IntPolyh_StartPoint self, Standard_Real const UU1, Standard_Real const VV1)

        :type UU1: float
        :type VV1: float

        """
        return _IntPolyh.IntPolyh_StartPoint_SetUV1(self, *args)


    def SetUV2(self, *args):
        """
        SetUV2(IntPolyh_StartPoint self, Standard_Real const UU2, Standard_Real const VV2)

        :type UU2: float
        :type VV2: float

        """
        return _IntPolyh.IntPolyh_StartPoint_SetUV2(self, *args)


    def SetEdge1(self, *args):
        """
        SetEdge1(IntPolyh_StartPoint self, Standard_Integer const IE1)

        :type IE1: int

        """
        return _IntPolyh.IntPolyh_StartPoint_SetEdge1(self, *args)


    def SetLambda1(self, *args):
        """
        SetLambda1(IntPolyh_StartPoint self, Standard_Real const LAM1)

        :type LAM1: float

        """
        return _IntPolyh.IntPolyh_StartPoint_SetLambda1(self, *args)


    def SetEdge2(self, *args):
        """
        SetEdge2(IntPolyh_StartPoint self, Standard_Integer const IE2)

        :type IE2: int

        """
        return _IntPolyh.IntPolyh_StartPoint_SetEdge2(self, *args)


    def SetLambda2(self, *args):
        """
        SetLambda2(IntPolyh_StartPoint self, Standard_Real const LAM2)

        :type LAM2: float

        """
        return _IntPolyh.IntPolyh_StartPoint_SetLambda2(self, *args)


    def SetCoupleValue(self, *args):
        """
        SetCoupleValue(IntPolyh_StartPoint self, Standard_Integer const IT1, Standard_Integer const IT2)

        :type IT1: int
        :type IT2: int

        """
        return _IntPolyh.IntPolyh_StartPoint_SetCoupleValue(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(IntPolyh_StartPoint self, Standard_Real const ang)

        :type ang: float

        """
        return _IntPolyh.IntPolyh_StartPoint_SetAngle(self, *args)


    def SetChainList(self, *args):
        """
        SetChainList(IntPolyh_StartPoint self, Standard_Integer const ChList)

        :type ChList: int

        """
        return _IntPolyh.IntPolyh_StartPoint_SetChainList(self, *args)


    def CheckSameSP(self, *args):
        """
        CheckSameSP(IntPolyh_StartPoint self, IntPolyh_StartPoint SP) -> Standard_Integer

        :type SP: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_StartPoint_CheckSameSP(self, *args)


    def Dump(self, *args):
        """
        Dump(IntPolyh_StartPoint self)
        Dump(IntPolyh_StartPoint self, Standard_Integer const i)

        :type i: int

        """
        return _IntPolyh.IntPolyh_StartPoint_Dump(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_StartPoint
IntPolyh_StartPoint_swigregister = _IntPolyh.IntPolyh_StartPoint_swigregister
IntPolyh_StartPoint_swigregister(IntPolyh_StartPoint)

class IntPolyh_Triangle(object):
    """
    The class represents the triangle built from three IntPolyh points
    and three IntPolyh edges.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_Triangle self) -> IntPolyh_Triangle
        __init__(IntPolyh_Triangle self, Standard_Integer const thePoint1, Standard_Integer const thePoint2, Standard_Integer const thePoint3) -> IntPolyh_Triangle

        Constructor

        :type thePoint1: int
        :type thePoint2: int
        :type thePoint3: int

        """
        this = _IntPolyh.new_IntPolyh_Triangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstPoint(self, *args):
        """
        FirstPoint(IntPolyh_Triangle self) -> Standard_Integer

        Returns the first point

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_FirstPoint(self, *args)


    def SecondPoint(self, *args):
        """
        SecondPoint(IntPolyh_Triangle self) -> Standard_Integer

        Returns the second point

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_SecondPoint(self, *args)


    def ThirdPoint(self, *args):
        """
        ThirdPoint(IntPolyh_Triangle self) -> Standard_Integer

        Returns the third point

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_ThirdPoint(self, *args)


    def FirstEdge(self, *args):
        """
        FirstEdge(IntPolyh_Triangle self) -> Standard_Integer

        Returns the first edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_FirstEdge(self, *args)


    def FirstEdgeOrientation(self, *args):
        """
        FirstEdgeOrientation(IntPolyh_Triangle self) -> Standard_Integer

        Returns the orientation of the first edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_FirstEdgeOrientation(self, *args)


    def SecondEdge(self, *args):
        """
        SecondEdge(IntPolyh_Triangle self) -> Standard_Integer

        Returns the second edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_SecondEdge(self, *args)


    def SecondEdgeOrientation(self, *args):
        """
        SecondEdgeOrientation(IntPolyh_Triangle self) -> Standard_Integer

        Returns the orientation of the second edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_SecondEdgeOrientation(self, *args)


    def ThirdEdge(self, *args):
        """
        ThirdEdge(IntPolyh_Triangle self) -> Standard_Integer

        Returns the third edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_ThirdEdge(self, *args)


    def ThirdEdgeOrientation(self, *args):
        """
        ThirdEdgeOrientation(IntPolyh_Triangle self) -> Standard_Integer

        Returns the orientation of the third edge

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_ThirdEdgeOrientation(self, *args)


    def Deflection(self, *args):
        """
        Deflection(IntPolyh_Triangle self) -> Standard_Real

        Returns the deflection of the triangle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Triangle_Deflection(self, *args)


    def IsIntersectionPossible(self, *args):
        """
        IsIntersectionPossible(IntPolyh_Triangle self) -> Standard_Boolean

        Returns possibility of the intersection

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_Triangle_IsIntersectionPossible(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(IntPolyh_Triangle self) -> Standard_Boolean

        Returns true if the triangle has interfered the other triangle

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_Triangle_HasIntersection(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(IntPolyh_Triangle self) -> Standard_Boolean

        Returns the Degenerated flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_Triangle_IsDegenerated(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(IntPolyh_Triangle self, Standard_Integer const thePoint)

        Sets the first point

        :type thePoint: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetFirstPoint(self, *args)


    def SetSecondPoint(self, *args):
        """
        SetSecondPoint(IntPolyh_Triangle self, Standard_Integer const thePoint)

        Sets the second point

        :type thePoint: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetSecondPoint(self, *args)


    def SetThirdPoint(self, *args):
        """
        SetThirdPoint(IntPolyh_Triangle self, Standard_Integer const thePoint)

        Sets the third point

        :type thePoint: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetThirdPoint(self, *args)


    def SetFirstEdge(self, *args):
        """
        SetFirstEdge(IntPolyh_Triangle self, Standard_Integer const theEdge, Standard_Integer const theEdgeOrientation)

        Sets the first edge

        :type theEdge: int
        :type theEdgeOrientation: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetFirstEdge(self, *args)


    def SetSecondEdge(self, *args):
        """
        SetSecondEdge(IntPolyh_Triangle self, Standard_Integer const theEdge, Standard_Integer const theEdgeOrientation)

        Sets the second edge

        :type theEdge: int
        :type theEdgeOrientation: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetSecondEdge(self, *args)


    def SetThirdEdge(self, *args):
        """
        SetThirdEdge(IntPolyh_Triangle self, Standard_Integer const theEdge, Standard_Integer const theEdgeOrientation)

        Sets the third edge

        :type theEdge: int
        :type theEdgeOrientation: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetThirdEdge(self, *args)


    def SetDeflection(self, *args):
        """
        SetDeflection(IntPolyh_Triangle self, Standard_Real const theDeflection)

        Sets the deflection

        :type theDeflection: float

        """
        return _IntPolyh.IntPolyh_Triangle_SetDeflection(self, *args)


    def SetIntersectionPossible(self, *args):
        """
        SetIntersectionPossible(IntPolyh_Triangle self, Standard_Boolean const theIP)

        Sets the flag of possibility of intersection

        :type theIP: bool

        """
        return _IntPolyh.IntPolyh_Triangle_SetIntersectionPossible(self, *args)


    def SetIntersection(self, *args):
        """
        SetIntersection(IntPolyh_Triangle self, Standard_Boolean const theInt)

        Sets the flag of intersection

        :type theInt: bool

        """
        return _IntPolyh.IntPolyh_Triangle_SetIntersection(self, *args)


    def SetDegenerated(self, *args):
        """
        SetDegenerated(IntPolyh_Triangle self, Standard_Boolean const theDegFlag)

        Sets the degenerated flag

        :type theDegFlag: bool

        """
        return _IntPolyh.IntPolyh_Triangle_SetDegenerated(self, *args)


    def GetEdgeNumber(self, *args):
        """
        GetEdgeNumber(IntPolyh_Triangle self, Standard_Integer const theEdgeIndex) -> Standard_Integer

        Gets the edge number by the index

        :type theEdgeIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_GetEdgeNumber(self, *args)


    def SetEdge(self, *args):
        """
        SetEdge(IntPolyh_Triangle self, Standard_Integer const theEdgeIndex, Standard_Integer const theEdgeNumber)

        Sets the edge by the index

        :type theEdgeIndex: int
        :type theEdgeNumber: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetEdge(self, *args)


    def GetEdgeOrientation(self, *args):
        """
        GetEdgeOrientation(IntPolyh_Triangle self, Standard_Integer const theEdgeIndex) -> Standard_Integer

        Gets the edges orientation by the index

        :type theEdgeIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_GetEdgeOrientation(self, *args)


    def SetEdgeOrientation(self, *args):
        """
        SetEdgeOrientation(IntPolyh_Triangle self, Standard_Integer const theEdgeIndex, Standard_Integer const theEdgeOrientation)

        Sets the edges orientation by the index

        :type theEdgeIndex: int
        :type theEdgeOrientation: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetEdgeOrientation(self, *args)


    def ComputeDeflection(self, *args):
        """
        ComputeDeflection(IntPolyh_Triangle self, Handle_Adaptor3d_HSurface theSurface, IntPolyh_ArrayOfPoints const & thePoints) -> Standard_Real

        Computes the deflection for the triangle

        :type theSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type thePoints: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPoints
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Triangle_ComputeDeflection(self, *args)


    def GetNextTriangle(self, *args):
        """
        GetNextTriangle(IntPolyh_Triangle self, Standard_Integer const theTriangle, Standard_Integer const theEdgeNum, IntPolyh_ArrayOfEdges const & TEdges) -> Standard_Integer

        Gets the adjacent triangle

        :type theTriangle: int
        :type theEdgeNum: int
        :type TEdges: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfEdges
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Triangle_GetNextTriangle(self, *args)


    def MiddleRefinement(self, *args):
        """
        MiddleRefinement(IntPolyh_Triangle self, Standard_Integer const theTriangleNumber, Handle_Adaptor3d_HSurface theSurface, IntPolyh_ArrayOfPoints & TPoints, IntPolyh_ArrayOfTriangles & TTriangles, IntPolyh_ArrayOfEdges & TEdges)

        Splits the triangle on two to decrease its deflection

        :type theTriangleNumber: int
        :type theSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type TPoints: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPoints
        :type TTriangles: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfTriangles
        :type TEdges: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfEdges

        """
        return _IntPolyh.IntPolyh_Triangle_MiddleRefinement(self, *args)


    def MultipleMiddleRefinement(self, *args):
        """
        MultipleMiddleRefinement(IntPolyh_Triangle self, Standard_Real const theRefineCriterion, Bnd_Box theBox, Standard_Integer const theTriangleNumber, Handle_Adaptor3d_HSurface theSurface, IntPolyh_ArrayOfPoints & TPoints, IntPolyh_ArrayOfTriangles & TTriangles, IntPolyh_ArrayOfEdges & TEdges)

        Splits the current triangle and new triangles until the refinement
        criterion is not achieved

        :type theRefineCriterion: float
        :type theBox: OCC.wrapper.Bnd.Bnd_Box
        :type theTriangleNumber: int
        :type theSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type TPoints: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPoints
        :type TTriangles: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfTriangles
        :type TEdges: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfEdges

        """
        return _IntPolyh.IntPolyh_Triangle_MultipleMiddleRefinement(self, *args)


    def LinkEdges2Triangle(self, *args):
        """
        LinkEdges2Triangle(IntPolyh_Triangle self, IntPolyh_ArrayOfEdges const & TEdges, Standard_Integer const theEdge1, Standard_Integer const theEdge2, Standard_Integer const theEdge3)

        Links edges to triangle

        :type TEdges: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfEdges
        :type theEdge1: int
        :type theEdge2: int
        :type theEdge3: int

        """
        return _IntPolyh.IntPolyh_Triangle_LinkEdges2Triangle(self, *args)


    def SetEdgeAndOrientation(self, *args):
        """
        SetEdgeAndOrientation(IntPolyh_Triangle self, IntPolyh_Edge theEdge, Standard_Integer const theEdgeIndex)

        Sets the appropriate edge and orientation for the triangle.

        :type theEdge: OCC.wrapper.IntPolyh.IntPolyh_Edge
        :type theEdgeIndex: int

        """
        return _IntPolyh.IntPolyh_Triangle_SetEdgeAndOrientation(self, *args)


    def BoundingBox(self, *args):
        """
        Returns the bounding box of the triangle.

        :type thePoints: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPoints
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _IntPolyh.IntPolyh_Triangle_BoundingBox(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(IntPolyh_Triangle self, Standard_Integer const v)

        Dumps the contents of the triangle.

        :type v: int

        """
        return _IntPolyh.IntPolyh_Triangle_Dump(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_Triangle
IntPolyh_Triangle_swigregister = _IntPolyh.IntPolyh_Triangle_swigregister
IntPolyh_Triangle_swigregister(IntPolyh_Triangle)


try:
	IntPolyh_ArrayOfTriangles = IntPolyh_Array_IntPolyh_Triangle
except NameError:
	pass # does not exist, probably ignored


try:
	IntPolyh_ArrayOfTangentZones = IntPolyh_Array_IntPolyh_StartPoint
except NameError:
	pass # does not exist, probably ignored

class IntPolyh_MaillageAffinage(object):
    """
    Low-level algorithm to compute intersection of the surfaces
    by computing the intersection of their triangulations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_MaillageAffinage self, Handle_Adaptor3d_HSurface S1, Standard_Integer const NbSU1, Standard_Integer const NbSV1, Handle_Adaptor3d_HSurface S2, Standard_Integer const NbSU2, Standard_Integer const NbSV2, Standard_Integer const PRINT) -> IntPolyh_MaillageAffinage
        __init__(IntPolyh_MaillageAffinage self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Standard_Integer const PRINT) -> IntPolyh_MaillageAffinage

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type PRINT: int

        """
        this = _IntPolyh.new_IntPolyh_MaillageAffinage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeSampling(self, *args):
        """
        MakeSampling(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars)

        Makes the sampling of the surface -
        Fills the arrays with the parametric values of the sampling points (triangulation nodes).

        :type SurfID: int
        :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_MakeSampling(self, *args)


    def FillArrayOfPnt(self, *args):
        """
        FillArrayOfPnt(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID)
        FillArrayOfPnt(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID, Standard_Boolean const isShiftFwd)
        FillArrayOfPnt(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID, NCollection_Array1_Standard_Real Upars, NCollection_Array1_Standard_Real Vpars, Standard_Real const * theDeflTol=None)
        FillArrayOfPnt(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID, Standard_Boolean const isShiftFwd, NCollection_Array1_Standard_Real Upars, NCollection_Array1_Standard_Real Vpars, Standard_Real const * theDeflTol=None)
        FillArrayOfPnt(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID, Standard_Boolean const isShiftFwd, IntPolyh_ArrayOfPointNormal const & thePoints, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars, Standard_Real const theDeflTol)

        Fills the array of points for the surface taking into account the shift

        :type SurfID: int
        :type isShiftFwd: bool
        :type thePoints: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPointNormal
        :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theDeflTol: float

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_FillArrayOfPnt(self, *args)


    def CommonBox(self, *args):
        """
        CommonBox(IntPolyh_MaillageAffinage self)
        CommonBox(IntPolyh_MaillageAffinage self, Bnd_Box B1, Bnd_Box B2)

        Compute the common box  witch is the intersection
        of the two bounding boxes,  and mark the points of
        the two surfaces that are inside.

        :type B1: OCC.wrapper.Bnd.Bnd_Box
        :type B2: OCC.wrapper.Bnd.Bnd_Box
        :type xMin: float
        :type yMin: float
        :type zMin: float
        :type xMax: float
        :type yMax: float
        :type zMax: float

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_CommonBox(self, *args)


    def FillArrayOfEdges(self, *args):
        """
        FillArrayOfEdges(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID)

        Compute edges from the array of points

        :type SurfID: int

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_FillArrayOfEdges(self, *args)


    def FillArrayOfTriangles(self, *args):
        """
        FillArrayOfTriangles(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID)

        Compute triangles from the array of points, and --
        mark the triangles  that use marked points by the
        CommonBox function.

        :type SurfID: int

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_FillArrayOfTriangles(self, *args)


    def CommonPartRefinement(self, *args):
        """
        CommonPartRefinement(IntPolyh_MaillageAffinage self)

        Refine systematicaly all marked triangles of both surfaces


        """
        return _IntPolyh.IntPolyh_MaillageAffinage_CommonPartRefinement(self, *args)


    def LocalSurfaceRefinement(self, *args):
        """
        LocalSurfaceRefinement(IntPolyh_MaillageAffinage self, Standard_Integer const SurfId)

        Refine systematicaly all marked triangles of ONE surface

        :type SurfId: int

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_LocalSurfaceRefinement(self, *args)


    def ComputeDeflections(self, *args):
        """
        ComputeDeflections(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID)

        Compute deflection  for   all  triangles  of  one
        surface,and sort min and max of deflections

        :type SurfID: int

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_ComputeDeflections(self, *args)


    def TrianglesDeflectionsRefinementBSB(self, *args):
        """
        TrianglesDeflectionsRefinementBSB(IntPolyh_MaillageAffinage self)

        Refine  both  surfaces using  BoundSortBox  as --
        rejection.  The  criterions  used to refine a  --
        triangle are:  The deflection The  size of the --
        bounding boxes   (one surface may be   very small
        compared to the other)


        """
        return _IntPolyh.IntPolyh_MaillageAffinage_TrianglesDeflectionsRefinementBSB(self, *args)


    def TriContact(self, *args):
        """
        TriContact(IntPolyh_MaillageAffinage self, IntPolyh_Point P1, IntPolyh_Point P2, IntPolyh_Point P3, IntPolyh_Point Q1, IntPolyh_Point Q2, IntPolyh_Point Q3) -> Standard_Integer

        This fonction     Check if two triangles   are  in
        contact or no,  return 1 if yes, return 0
        if no.

        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type P2: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type P3: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type Q1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type Q2: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type Q3: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type Angle: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_TriContact(self, *args)


    def TriangleEdgeContact(self, *args):
        """
        TriangleEdgeContact(IntPolyh_MaillageAffinage self, Standard_Integer const TriSurfID, Standard_Integer const EdgeIndice, IntPolyh_Triangle Tri1, IntPolyh_Triangle Tri2, IntPolyh_Point P1, IntPolyh_Point P2, IntPolyh_Point P3, IntPolyh_Point C1, IntPolyh_Point C2, IntPolyh_Point C3, IntPolyh_Point Pe1, IntPolyh_Point Pe2, IntPolyh_Point E, IntPolyh_Point N, IntPolyh_StartPoint SP1, IntPolyh_StartPoint SP2) -> Standard_Integer

        :type TriSurfID: int
        :type EdgeIndice: int
        :type Tri1: OCC.wrapper.IntPolyh.IntPolyh_Triangle
        :type Tri2: OCC.wrapper.IntPolyh.IntPolyh_Triangle
        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type P2: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type P3: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type C1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type C2: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type C3: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type Pe1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type Pe2: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type E: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type N: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type SP1: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :type SP2: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_TriangleEdgeContact(self, *args)


    def StartingPointsResearch(self, *args):
        """
        StartingPointsResearch(IntPolyh_MaillageAffinage self, Standard_Integer const T1, Standard_Integer const T2, IntPolyh_StartPoint SP1, IntPolyh_StartPoint SP2) -> Standard_Integer

        From  two  triangles compute intersection  points.
        If I found   more  than two intersection  points
        that's mean that those triangle are coplanar

        :type T1: int
        :type T2: int
        :type SP1: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :type SP2: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_StartingPointsResearch(self, *args)


    def NextStartingPointsResearch(self, *args):
        """
        NextStartingPointsResearch(IntPolyh_MaillageAffinage self, Standard_Integer const T1, Standard_Integer const T2, IntPolyh_StartPoint SPInit, IntPolyh_StartPoint SPNext) -> Standard_Integer

        from  two triangles  and an intersection   point I
        seach the other point (if it exist).
        This function is used by StartPointChain

        :type T1: int
        :type T2: int
        :type SPInit: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :type SPNext: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_NextStartingPointsResearch(self, *args)


    def TriangleCompare(self, *args):
        """
        TriangleCompare(IntPolyh_MaillageAffinage self) -> Standard_Integer

        Analyse  each couple of  triangles from the two --
        array  of triangles,  to   see  if they are  in
        contact,  and  compute the  incidence.  Then  put
        couples  in contact  in  the  array  of  couples

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_TriangleCompare(self, *args)


    def StartPointsChain(self, *args):
        """
        StartPointsChain(IntPolyh_MaillageAffinage self, IntPolyh_ArrayOfSectionLines & TSectionLines, IntPolyh_ArrayOfTangentZones & TTangentZones) -> Standard_Integer

        Loop on the array of couples. Compute StartPoints.
        Try to chain  the StartPoints into SectionLines or
        put  the  point  in  the    ArrayOfTangentZones if
        chaining it, is not possible.

        :type TSectionLines: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfSectionLines
        :type TTangentZones: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfTangentZones
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_StartPointsChain(self, *args)


    def GetNextChainStartPoint(self, *args):
        """
        GetNextChainStartPoint(IntPolyh_MaillageAffinage self, IntPolyh_StartPoint SPInit, IntPolyh_StartPoint SPNext, IntPolyh_SectionLine MySectionLine, IntPolyh_ArrayOfTangentZones & TTangentZones, Standard_Boolean const Prepend) -> Standard_Integer

        Mainly  used  by StartPointsChain(), this function
        try to compute the next StartPoint.

        :type SPInit: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :type SPNext: OCC.wrapper.IntPolyh.IntPolyh_StartPoint
        :type MySectionLine: OCC.wrapper.IntPolyh.IntPolyh_SectionLine
        :type TTangentZones: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfTangentZones
        :type Prepend: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_GetNextChainStartPoint(self, *args)


    def GetArrayOfPoints(self, *args):
        """
        :type SurfID: int
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPoints

        """
        res = _IntPolyh.IntPolyh_MaillageAffinage_GetArrayOfPoints(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetArrayOfEdges(self, *args):
        """
        :type SurfID: int
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfEdges

        """
        res = _IntPolyh.IntPolyh_MaillageAffinage_GetArrayOfEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetArrayOfTriangles(self, *args):
        """
        :type SurfID: int
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfTriangles

        """
        res = _IntPolyh.IntPolyh_MaillageAffinage_GetArrayOfTriangles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetBox(self, *args):
        """
        GetBox(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID) -> Bnd_Box

        :type SurfID: int
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_GetBox(self, *args)


    def GetCouples(self, *args):
        """
        GetCouples(IntPolyh_MaillageAffinage self) -> NCollection_List_IntPolyh_Couple

        This method returns list of couples of contact triangles.

        :rtype: OCC.wrapper.IntPolyh.IntPolyh_ListOfCouples

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_GetCouples(self, *args)


    def SetEnlargeZone(self, *args):
        """
        SetEnlargeZone(IntPolyh_MaillageAffinage self, Standard_Boolean const EnlargeZone)

        :type EnlargeZone: bool

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_SetEnlargeZone(self, *args)


    def GetEnlargeZone(self, *args):
        """
        GetEnlargeZone(IntPolyh_MaillageAffinage self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_GetEnlargeZone(self, *args)


    def GetMinDeflection(self, *args):
        """
        GetMinDeflection(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID) -> Standard_Real

        returns FlecheMin

        :type SurfID: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_GetMinDeflection(self, *args)


    def GetMaxDeflection(self, *args):
        """
        GetMaxDeflection(IntPolyh_MaillageAffinage self, Standard_Integer const SurfID) -> Standard_Real

        returns FlecheMax

        :type SurfID: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_MaillageAffinage_GetMaxDeflection(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_MaillageAffinage
IntPolyh_MaillageAffinage_swigregister = _IntPolyh.IntPolyh_MaillageAffinage_swigregister
IntPolyh_MaillageAffinage_swigregister(IntPolyh_MaillageAffinage)

class IntPolyh_SectionLine(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_SectionLine self) -> IntPolyh_SectionLine
        __init__(IntPolyh_SectionLine self, Standard_Integer const nn) -> IntPolyh_SectionLine

        :type nn: int

        """
        this = _IntPolyh.new_IntPolyh_SectionLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(IntPolyh_SectionLine self, Standard_Integer const nn)

        :type nn: int

        """
        return _IntPolyh.IntPolyh_SectionLine_Init(self, *args)


    def Value(self, *args):
        """
        :type nn: int
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_StartPoint

        """
        res = _IntPolyh.IntPolyh_SectionLine_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(IntPolyh_SectionLine self, Standard_Integer const nn) -> IntPolyh_StartPoint

        :type nn: int
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_StartPoint

        """
        return _IntPolyh.IntPolyh_SectionLine_ChangeValue(self, *args)


    def __getitem__(self, *args):
        """
        :type nn: int
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_StartPoint

        """
        res = _IntPolyh.IntPolyh_SectionLine_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(IntPolyh_SectionLine self, IntPolyh_SectionLine Other) -> IntPolyh_SectionLine

        :type Other: OCC.wrapper.IntPolyh.IntPolyh_SectionLine
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_SectionLine

        """
        return _IntPolyh.IntPolyh_SectionLine_Copy(self, *args)


    def assign(self, *args):
        """
        assign(IntPolyh_SectionLine self, IntPolyh_SectionLine Other) -> IntPolyh_SectionLine

        :type Other: OCC.wrapper.IntPolyh.IntPolyh_SectionLine
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_SectionLine

        """
        return _IntPolyh.IntPolyh_SectionLine_assign(self, *args)


    def GetN(self, *args):
        """
        GetN(IntPolyh_SectionLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_SectionLine_GetN(self, *args)


    def NbStartPoints(self, *args):
        """
        NbStartPoints(IntPolyh_SectionLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_SectionLine_NbStartPoints(self, *args)


    def IncrementNbStartPoints(self, *args):
        """IncrementNbStartPoints(IntPolyh_SectionLine self)"""
        return _IntPolyh.IntPolyh_SectionLine_IncrementNbStartPoints(self, *args)


    def Destroy(self, *args):
        """Destroy(IntPolyh_SectionLine self)"""
        return _IntPolyh.IntPolyh_SectionLine_Destroy(self, *args)


    def Dump(self, *args):
        """Dump(IntPolyh_SectionLine self)"""
        return _IntPolyh.IntPolyh_SectionLine_Dump(self, *args)


    def Prepend(self, *args):
        """
        Prepend(IntPolyh_SectionLine self, IntPolyh_StartPoint SP)

        :type SP: OCC.wrapper.IntPolyh.IntPolyh_StartPoint

        """
        return _IntPolyh.IntPolyh_SectionLine_Prepend(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_SectionLine
IntPolyh_SectionLine_swigregister = _IntPolyh.IntPolyh_SectionLine_swigregister
IntPolyh_SectionLine_swigregister(IntPolyh_SectionLine)

class IntPolyh_Edge(object):
    """
    The class represents the edge built between the two IntPolyh points.<br>
    It is linked to two IntPolyh triangles.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_Edge self) -> IntPolyh_Edge
        __init__(IntPolyh_Edge self, Standard_Integer const thePoint1, Standard_Integer const thePoint2, Standard_Integer const theTriangle1, Standard_Integer const theTriangle2) -> IntPolyh_Edge

        Constructor

        :type thePoint1: int
        :type thePoint2: int
        :type theTriangle1: int
        :type theTriangle2: int

        """
        this = _IntPolyh.new_IntPolyh_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FirstPoint(self, *args):
        """
        FirstPoint(IntPolyh_Edge self) -> Standard_Integer

        Returns the first point

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Edge_FirstPoint(self, *args)


    def SecondPoint(self, *args):
        """
        SecondPoint(IntPolyh_Edge self) -> Standard_Integer

        Returns the second point

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Edge_SecondPoint(self, *args)


    def FirstTriangle(self, *args):
        """
        FirstTriangle(IntPolyh_Edge self) -> Standard_Integer

        Returns the first triangle

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Edge_FirstTriangle(self, *args)


    def SecondTriangle(self, *args):
        """
        SecondTriangle(IntPolyh_Edge self) -> Standard_Integer

        Returns the second triangle

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Edge_SecondTriangle(self, *args)


    def SetFirstPoint(self, *args):
        """
        SetFirstPoint(IntPolyh_Edge self, Standard_Integer const thePoint)

        Sets the first point

        :type thePoint: int

        """
        return _IntPolyh.IntPolyh_Edge_SetFirstPoint(self, *args)


    def SetSecondPoint(self, *args):
        """
        SetSecondPoint(IntPolyh_Edge self, Standard_Integer const thePoint)

        Sets the second point

        :type thePoint: int

        """
        return _IntPolyh.IntPolyh_Edge_SetSecondPoint(self, *args)


    def SetFirstTriangle(self, *args):
        """
        SetFirstTriangle(IntPolyh_Edge self, Standard_Integer const theTriangle)

        Sets the first triangle

        :type theTriangle: int

        """
        return _IntPolyh.IntPolyh_Edge_SetFirstTriangle(self, *args)


    def SetSecondTriangle(self, *args):
        """
        SetSecondTriangle(IntPolyh_Edge self, Standard_Integer const theTriangle)

        Sets the second triangle

        :type theTriangle: int

        """
        return _IntPolyh.IntPolyh_Edge_SetSecondTriangle(self, *args)


    def Dump(self, *args):
        """
        Dump(IntPolyh_Edge self, Standard_Integer const v)

        :type v: int

        """
        return _IntPolyh.IntPolyh_Edge_Dump(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_Edge
IntPolyh_Edge_swigregister = _IntPolyh.IntPolyh_Edge_swigregister
IntPolyh_Edge_swigregister(IntPolyh_Edge)

class NCollection_Sequence_IntPolyh_StartPoint(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_IntPolyh_StartPoint self) -> NCollection_Sequence< IntPolyh_StartPoint >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_IntPolyh_StartPoint self) -> NCollection_Sequence< IntPolyh_StartPoint >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_IntPolyh_StartPoint self) -> NCollection_Sequence< IntPolyh_StartPoint >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_IntPolyh_StartPoint self) -> NCollection_Sequence< IntPolyh_StartPoint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _IntPolyh.new_NCollection_Sequence_IntPolyh_StartPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_IntPolyh_StartPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_IntPolyh_StartPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_IntPolyh_StartPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_IntPolyh_StartPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_IntPolyh_StartPoint self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_IntPolyh_StartPoint self)

        Reverse sequence


        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_IntPolyh_StartPoint self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_IntPolyh_StartPoint self, NCollection_Sequence_IntPolyh_StartPoint theOther) -> NCollection_Sequence_IntPolyh_StartPoint

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_IntPolyh_StartPoint self, NCollection_Sequence_IntPolyh_StartPoint theOther) -> NCollection_Sequence_IntPolyh_StartPoint

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_IntPolyh_StartPoint self, NCollection_Sequence< IntPolyh_StartPoint >::Iterator & thePosition)
        Remove(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_IntPolyh_StartPoint self, IntPolyh_StartPoint theItem)
        Append(NCollection_Sequence_IntPolyh_StartPoint self, NCollection_Sequence_IntPolyh_StartPoint theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_IntPolyh_StartPoint self, IntPolyh_StartPoint theItem)
        Prepend(NCollection_Sequence_IntPolyh_StartPoint self, NCollection_Sequence_IntPolyh_StartPoint theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex, IntPolyh_StartPoint theItem)
        InsertBefore(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntPolyh_StartPoint theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_IntPolyh_StartPoint self, NCollection_Sequence< IntPolyh_StartPoint >::Iterator & thePosition, IntPolyh_StartPoint theItem)
        InsertAfter(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntPolyh_StartPoint theSeq)
        InsertAfter(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex, IntPolyh_StartPoint theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex, NCollection_Sequence_IntPolyh_StartPoint theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_IntPolyh_StartPoint self) -> IntPolyh_StartPoint

        First item access

        :rtype: TheItemType &

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_IntPolyh_StartPoint self) -> IntPolyh_StartPoint

        Last item access

        :rtype: TheItemType &

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex) -> IntPolyh_StartPoint

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_IntPolyh_StartPoint self, Standard_Integer const theIndex, IntPolyh_StartPoint theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_SetValue(self, *args)


    def __iter__(self):
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint___iter__(self)
    __swig_destroy__ = _IntPolyh.delete_NCollection_Sequence_IntPolyh_StartPoint
NCollection_Sequence_IntPolyh_StartPoint_swigregister = _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_swigregister
NCollection_Sequence_IntPolyh_StartPoint_swigregister(NCollection_Sequence_IntPolyh_StartPoint)

def NCollection_Sequence_IntPolyh_StartPoint_delNode(*args):
    """
    NCollection_Sequence_IntPolyh_StartPoint_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_delNode(*args)

class NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntPolyh.new_NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPolyh.delete_NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper

    def __next__(self):
        return _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper___next__(self)
NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper_swigregister = _IntPolyh.NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper_swigregister
NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper_swigregister(NCollection_Sequence_IntPolyh_StartPoint_IteratorHelper)


try:
	IntPolyh_SeqOfStartPoints = NCollection_Sequence_IntPolyh_StartPoint
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_IntPolyh_Couple(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_IntPolyh_Couple self) -> NCollection_List< IntPolyh_Couple >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_IntPolyh_Couple self) -> NCollection_List< IntPolyh_Couple >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_IntPolyh_Couple self) -> NCollection_List< IntPolyh_Couple >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_IntPolyh_Couple self) -> NCollection_List< IntPolyh_Couple >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _IntPolyh.new_NCollection_List_IntPolyh_Couple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_IntPolyh_Couple self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_IntPolyh_Couple self, NCollection_List_IntPolyh_Couple theOther) -> NCollection_List_IntPolyh_Couple

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_IntPolyh_Couple self, NCollection_List_IntPolyh_Couple theOther) -> NCollection_List_IntPolyh_Couple

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_IntPolyh_Couple self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _IntPolyh.NCollection_List_IntPolyh_Couple_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _IntPolyh.NCollection_List_IntPolyh_Couple_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_IntPolyh_Couple self, IntPolyh_Couple theItem) -> IntPolyh_Couple
        Append(NCollection_List_IntPolyh_Couple self, IntPolyh_Couple theItem, NCollection_List< IntPolyh_Couple >::Iterator & theIter)
        Append(NCollection_List_IntPolyh_Couple self, NCollection_List_IntPolyh_Couple theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_IntPolyh_Couple self, IntPolyh_Couple theItem) -> IntPolyh_Couple
        Prepend(NCollection_List_IntPolyh_Couple self, NCollection_List_IntPolyh_Couple theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_IntPolyh_Couple self)

        RemoveFirst item


        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_IntPolyh_Couple self, NCollection_List< IntPolyh_Couple >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_IntPolyh_Couple self, IntPolyh_Couple theItem, NCollection_List< IntPolyh_Couple >::Iterator & theIter) -> IntPolyh_Couple
        InsertBefore(NCollection_List_IntPolyh_Couple self, NCollection_List_IntPolyh_Couple theOther, NCollection_List< IntPolyh_Couple >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_IntPolyh_Couple self, IntPolyh_Couple theItem, NCollection_List< IntPolyh_Couple >::Iterator & theIter) -> IntPolyh_Couple
        InsertAfter(NCollection_List_IntPolyh_Couple self, NCollection_List_IntPolyh_Couple theOther, NCollection_List< IntPolyh_Couple >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_IntPolyh_Couple self)

        Reverse the list


        """
        return _IntPolyh.NCollection_List_IntPolyh_Couple_Reverse(self, *args)


    def __iter__(self):
        return _IntPolyh.NCollection_List_IntPolyh_Couple___iter__(self)
    __swig_destroy__ = _IntPolyh.delete_NCollection_List_IntPolyh_Couple
NCollection_List_IntPolyh_Couple_swigregister = _IntPolyh.NCollection_List_IntPolyh_Couple_swigregister
NCollection_List_IntPolyh_Couple_swigregister(NCollection_List_IntPolyh_Couple)

class NCollection_List_IntPolyh_Couple_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _IntPolyh.new_NCollection_List_IntPolyh_Couple_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPolyh.delete_NCollection_List_IntPolyh_Couple_IteratorHelper

    def __next__(self):
        return _IntPolyh.NCollection_List_IntPolyh_Couple_IteratorHelper___next__(self)
NCollection_List_IntPolyh_Couple_IteratorHelper_swigregister = _IntPolyh.NCollection_List_IntPolyh_Couple_IteratorHelper_swigregister
NCollection_List_IntPolyh_Couple_IteratorHelper_swigregister(NCollection_List_IntPolyh_Couple_IteratorHelper)


try:
	IntPolyh_ListOfCouples = NCollection_List_IntPolyh_Couple
except NameError:
	pass # does not exist, probably ignored


try:
	IntPolyh_ArrayOfSectionLines = IntPolyh_Array_IntPolyh_SectionLine
except NameError:
	pass # does not exist, probably ignored

class IntPolyh_CoupleMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(IntPolyh_Couple theCouple, Standard_Integer const Upper) -> Standard_Integer

        :type theCouple: OCC.wrapper.IntPolyh.IntPolyh_Couple
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_CoupleMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(IntPolyh_Couple theCouple1, IntPolyh_Couple theCouple2) -> Standard_Boolean

        :type theCouple1: OCC.wrapper.IntPolyh.IntPolyh_Couple
        :type theCouple2: OCC.wrapper.IntPolyh.IntPolyh_Couple
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_CoupleMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _IntPolyh.new_IntPolyh_CoupleMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPolyh.delete_IntPolyh_CoupleMapHasher
IntPolyh_CoupleMapHasher_swigregister = _IntPolyh.IntPolyh_CoupleMapHasher_swigregister
IntPolyh_CoupleMapHasher_swigregister(IntPolyh_CoupleMapHasher)

def IntPolyh_CoupleMapHasher_HashCode(*args):
    """
    IntPolyh_CoupleMapHasher_HashCode(IntPolyh_Couple theCouple, Standard_Integer const Upper) -> Standard_Integer

    :type theCouple: OCC.wrapper.IntPolyh.IntPolyh_Couple
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _IntPolyh.IntPolyh_CoupleMapHasher_HashCode(*args)

def IntPolyh_CoupleMapHasher_IsEqual(*args):
    """
    IntPolyh_CoupleMapHasher_IsEqual(IntPolyh_Couple theCouple1, IntPolyh_Couple theCouple2) -> Standard_Boolean

    :type theCouple1: OCC.wrapper.IntPolyh.IntPolyh_Couple
    :type theCouple2: OCC.wrapper.IntPolyh.IntPolyh_Couple
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _IntPolyh.IntPolyh_CoupleMapHasher_IsEqual(*args)

class IntPolyh_Tools(object):
    """The class provides tools for surface sampling."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsEnlargePossible(*args):
        """
        IsEnlargePossible(Handle_Adaptor3d_HSurface theSurf)

        Checks if the surface can be enlarged in U or V direction.

        :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUEnlarge: bool
        :type theVEnlarge: bool

        """
        return _IntPolyh.IntPolyh_Tools_IsEnlargePossible(*args)

    IsEnlargePossible = staticmethod(IsEnlargePossible)

    def MakeSampling(*args):
        """
        MakeSampling(Handle_Adaptor3d_HSurface theSurf, Standard_Integer const theNbSU, Standard_Integer const theNbSV, Standard_Boolean const theEnlargeZone, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars)

        Makes the sampling of the given surface <theSurf> 
        making the net of <theNbSU> x <theNbSV> sampling points.
        The flag <theEnlargeZone> controls the enlargement of the
        sampling zone on the surface.
        The parameters of the sampling points are stored into
        <theUPars> and <theVPars> arrays.

        :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theNbSU: int
        :type theNbSV: int
        :type theEnlargeZone: bool
        :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _IntPolyh.IntPolyh_Tools_MakeSampling(*args)

    MakeSampling = staticmethod(MakeSampling)

    def ComputeDeflection(*args):
        """
        ComputeDeflection(Handle_Adaptor3d_HSurface theSurf, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars) -> Standard_Real

        Computes the deflection tolerance on the surface for the given sampling.

        :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Tools_ComputeDeflection(*args)

    ComputeDeflection = staticmethod(ComputeDeflection)

    def FillArrayOfPointNormal(*args):
        """
        FillArrayOfPointNormal(Handle_Adaptor3d_HSurface theSurf, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars, IntPolyh_ArrayOfPointNormal & thePoints)

        Fills the array <thePoints> with the points (triangulation nodes) on the surface
        and normal directions of the surface in these points.

        :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoints: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPointNormal

        """
        return _IntPolyh.IntPolyh_Tools_FillArrayOfPointNormal(*args)

    FillArrayOfPointNormal = staticmethod(FillArrayOfPointNormal)

    def __init__(self):
        """The class provides tools for surface sampling."""
        this = _IntPolyh.new_IntPolyh_Tools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntPolyh.delete_IntPolyh_Tools
IntPolyh_Tools_swigregister = _IntPolyh.IntPolyh_Tools_swigregister
IntPolyh_Tools_swigregister(IntPolyh_Tools)

def IntPolyh_Tools_IsEnlargePossible(*args):
    """
    IntPolyh_Tools_IsEnlargePossible(Handle_Adaptor3d_HSurface theSurf)

    Checks if the surface can be enlarged in U or V direction.

    :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theUEnlarge: bool
    :type theVEnlarge: bool

    """
    return _IntPolyh.IntPolyh_Tools_IsEnlargePossible(*args)

def IntPolyh_Tools_MakeSampling(*args):
    """
    IntPolyh_Tools_MakeSampling(Handle_Adaptor3d_HSurface theSurf, Standard_Integer const theNbSU, Standard_Integer const theNbSV, Standard_Boolean const theEnlargeZone, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars)

    Makes the sampling of the given surface <theSurf> 
    making the net of <theNbSU> x <theNbSV> sampling points.
    The flag <theEnlargeZone> controls the enlargement of the
    sampling zone on the surface.
    The parameters of the sampling points are stored into
    <theUPars> and <theVPars> arrays.

    :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theNbSU: int
    :type theNbSV: int
    :type theEnlargeZone: bool
    :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _IntPolyh.IntPolyh_Tools_MakeSampling(*args)

def IntPolyh_Tools_ComputeDeflection(*args):
    """
    IntPolyh_Tools_ComputeDeflection(Handle_Adaptor3d_HSurface theSurf, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars) -> Standard_Real

    Computes the deflection tolerance on the surface for the given sampling.

    :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _IntPolyh.IntPolyh_Tools_ComputeDeflection(*args)

def IntPolyh_Tools_FillArrayOfPointNormal(*args):
    """
    IntPolyh_Tools_FillArrayOfPointNormal(Handle_Adaptor3d_HSurface theSurf, NCollection_Array1_Standard_Real theUPars, NCollection_Array1_Standard_Real theVPars, IntPolyh_ArrayOfPointNormal & thePoints)

    Fills the array <thePoints> with the points (triangulation nodes) on the surface
    and normal directions of the surface in these points.

    :type theSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type theUPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type theVPars: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type thePoints: OCC.wrapper.IntPolyh.IntPolyh_ArrayOfPointNormal

    """
    return _IntPolyh.IntPolyh_Tools_FillArrayOfPointNormal(*args)

class IntPolyh_Point(object):
    """
    The class represents the point on the surface with
    both 3D and 2D points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_Point self) -> IntPolyh_Point
        __init__(IntPolyh_Point self, Standard_Real const x, Standard_Real const y, Standard_Real const z, Standard_Real const u, Standard_Real const v) -> IntPolyh_Point

        Constructor

        :type x: float
        :type y: float
        :type z: float
        :type u: float
        :type v: float

        """
        this = _IntPolyh.new_IntPolyh_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def X(self, *args):
        """
        X(IntPolyh_Point self) -> Standard_Real

        Returns X coordinate of the 3D point

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_X(self, *args)


    def Y(self, *args):
        """
        Y(IntPolyh_Point self) -> Standard_Real

        Returns Y coordinate of the 3D point

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_Y(self, *args)


    def Z(self, *args):
        """
        Z(IntPolyh_Point self) -> Standard_Real

        Returns the Z coordinate of the 3D point

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_Z(self, *args)


    def U(self, *args):
        """
        U(IntPolyh_Point self) -> Standard_Real

        Returns the U coordinate of the 2D point

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_U(self, *args)


    def V(self, *args):
        """
        V(IntPolyh_Point self) -> Standard_Real

        Returns the V coordinate of the 2D point

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_V(self, *args)


    def PartOfCommon(self, *args):
        """
        PartOfCommon(IntPolyh_Point self) -> Standard_Integer

        Returns 0 if the point is not common with the other surface

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Point_PartOfCommon(self, *args)


    def Equal(self, *args):
        """
        Equal(IntPolyh_Point self, IntPolyh_Point Pt)

        Assignment operator

        :type Pt: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_Equal(self, *args)


    def assign(self, *args):
        """
        assign(IntPolyh_Point self, IntPolyh_Point Pt)

        :type Pt: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_assign(self, *args)


    def Set(self, *args):
        """
        Set(IntPolyh_Point self, Standard_Real const x, Standard_Real const y, Standard_Real const z, Standard_Real const u, Standard_Real const v, Standard_Integer const II=1)

        Sets the point

        :type x: float
        :type y: float
        :type z: float
        :type u: float
        :type v: float
        :type II: int

        """
        return _IntPolyh.IntPolyh_Point_Set(self, *args)


    def SetX(self, *args):
        """
        SetX(IntPolyh_Point self, Standard_Real const x)

        Sets the X coordinate for the 3D point

        :type x: float

        """
        return _IntPolyh.IntPolyh_Point_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(IntPolyh_Point self, Standard_Real const y)

        Sets the Y coordinate for the 3D point

        :type y: float

        """
        return _IntPolyh.IntPolyh_Point_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(IntPolyh_Point self, Standard_Real const z)

        Sets the Z coordinate for the 3D point

        :type z: float

        """
        return _IntPolyh.IntPolyh_Point_SetZ(self, *args)


    def SetU(self, *args):
        """
        SetU(IntPolyh_Point self, Standard_Real const u)

        Sets the U coordinate for the 2D point

        :type u: float

        """
        return _IntPolyh.IntPolyh_Point_SetU(self, *args)


    def SetV(self, *args):
        """
        SetV(IntPolyh_Point self, Standard_Real const v)

        Sets the V coordinate for the 2D point

        :type v: float

        """
        return _IntPolyh.IntPolyh_Point_SetV(self, *args)


    def SetPartOfCommon(self, *args):
        """
        SetPartOfCommon(IntPolyh_Point self, Standard_Integer const ii)

        Sets the part of common

        :type ii: int

        """
        return _IntPolyh.IntPolyh_Point_SetPartOfCommon(self, *args)


    def Middle(self, *args):
        """
        Middle(IntPolyh_Point self, Handle_Adaptor3d_HSurface MySurface, IntPolyh_Point P1, IntPolyh_Point P2)

        Creates middle point from P1 and P2 and stores it to this

        :type MySurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type P2: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_Middle(self, *args)


    def Add(self, *args):
        """
        Add(IntPolyh_Point self, IntPolyh_Point P1) -> IntPolyh_Point

        Addition

        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_Add(self, *args)


    def __add__(self, *args):
        """
        __add__(IntPolyh_Point self, IntPolyh_Point P1) -> IntPolyh_Point

        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point___add__(self, *args)


    def Sub(self, *args):
        """
        Sub(IntPolyh_Point self, IntPolyh_Point P1) -> IntPolyh_Point

        Subtraction

        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_Sub(self, *args)


    def __sub__(self, *args):
        """
        __sub__(IntPolyh_Point self, IntPolyh_Point P1) -> IntPolyh_Point

        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point___sub__(self, *args)


    def Divide(self, *args):
        """
        Divide(IntPolyh_Point self, Standard_Real const rr) -> IntPolyh_Point

        Division

        :type rr: float
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_Divide(self, *args)


    def __truediv__(self, *args):
        return _IntPolyh.IntPolyh_Point___truediv__(self, *args)
    __div__ = __truediv__



    def Multiplication(self, *args):
        """
        Multiplication(IntPolyh_Point self, Standard_Real const rr) -> IntPolyh_Point

        Multiplication

        :type rr: float
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_Multiplication(self, *args)


    def __mul__(self, *args):
        """
        __mul__(IntPolyh_Point self, Standard_Real const rr) -> IntPolyh_Point

        :type rr: float
        :rtype: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point___mul__(self, *args)


    def SquareModulus(self, *args):
        """
        SquareModulus(IntPolyh_Point self) -> Standard_Real

        Square modulus

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_SquareModulus(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(IntPolyh_Point self, IntPolyh_Point P2) -> Standard_Real

        Square distance to the other point

        :type P2: OCC.wrapper.IntPolyh.IntPolyh_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_SquareDistance(self, *args)


    def Dot(self, *args):
        """
        Dot(IntPolyh_Point self, IntPolyh_Point P2) -> Standard_Real

        Dot

        :type P2: OCC.wrapper.IntPolyh.IntPolyh_Point
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntPolyh.IntPolyh_Point_Dot(self, *args)


    def Cross(self, *args):
        """
        Cross(IntPolyh_Point self, IntPolyh_Point P1, IntPolyh_Point P2)

        Cross

        :type P1: OCC.wrapper.IntPolyh.IntPolyh_Point
        :type P2: OCC.wrapper.IntPolyh.IntPolyh_Point

        """
        return _IntPolyh.IntPolyh_Point_Cross(self, *args)


    def Dump(self, *args):
        """
        Dump(IntPolyh_Point self)
        Dump(IntPolyh_Point self, Standard_Integer const i)

        Dump

        :type i: int

        """
        return _IntPolyh.IntPolyh_Point_Dump(self, *args)


    def SetDegenerated(self, *args):
        """
        SetDegenerated(IntPolyh_Point self, Standard_Boolean const theFlag)

        Sets the degenerated flag

        :type theFlag: bool

        """
        return _IntPolyh.IntPolyh_Point_SetDegenerated(self, *args)


    def Degenerated(self, *args):
        """
        Degenerated(IntPolyh_Point self) -> Standard_Boolean

        Returns the degenerated flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_Point_Degenerated(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_Point
IntPolyh_Point_swigregister = _IntPolyh.IntPolyh_Point_swigregister
IntPolyh_Point_swigregister(IntPolyh_Point)


try:
	IntPolyh_ArrayOfPoints = IntPolyh_Array_IntPolyh_Point
except NameError:
	pass # does not exist, probably ignored

class IntPolyh_Intersection(object):
    """
    API algorithm for intersection of two surfaces by intersection
    of their triangulations.

    Algorithm provides possibility to intersect surfaces as without
    the precomputed sampling as with it.

    If the numbers of sampling points are not given, it will build the
    net of 10x10 sampling points for each surface.

    The intersection is done inside constructors.
    Before obtaining the results of intersection it is necessary to check
    if intersection has been performed correctly. It can be done by calling
    the *IsDone()* method.

    The results of intersection are the intersection lines and points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntPolyh_Intersection self, Handle_Adaptor3d_HSurface theS1, Handle_Adaptor3d_HSurface theS2) -> IntPolyh_Intersection
        __init__(IntPolyh_Intersection self, Handle_Adaptor3d_HSurface theS1, Standard_Integer const theNbSU1, Standard_Integer const theNbSV1, Handle_Adaptor3d_HSurface theS2, Standard_Integer const theNbSU2, Standard_Integer const theNbSV2) -> IntPolyh_Intersection
        __init__(IntPolyh_Intersection self, Handle_Adaptor3d_HSurface theS1, NCollection_Array1_Standard_Real theUPars1, NCollection_Array1_Standard_Real theVPars1, Handle_Adaptor3d_HSurface theS2, NCollection_Array1_Standard_Real theUPars2, NCollection_Array1_Standard_Real theVPars2) -> IntPolyh_Intersection

        Constructor for intersection of two surfaces with the precomputed sampling.
        Performs intersection.

        :type theS1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUPars1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVPars1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theS2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theUPars2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVPars2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _IntPolyh.new_IntPolyh_Intersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(IntPolyh_Intersection self) -> Standard_Boolean

        Returns state of the operation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntPolyh.IntPolyh_Intersection_IsDone(self, *args)


    def NbSectionLines(self, *args):
        """
        NbSectionLines(IntPolyh_Intersection self) -> Standard_Integer

        Returns the number of section lines

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Intersection_NbSectionLines(self, *args)


    def NbPointsInLine(self, *args):
        """
        NbPointsInLine(IntPolyh_Intersection self, Standard_Integer const IndexLine) -> Standard_Integer

        Returns the number of points in the given line

        :type IndexLine: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Intersection_NbPointsInLine(self, *args)


    def NbTangentZones(self, *args):
        """
        NbTangentZones(IntPolyh_Intersection self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Intersection_NbTangentZones(self, *args)


    def NbPointsInTangentZone(self, *args):
        """
        NbPointsInTangentZone(IntPolyh_Intersection self, Standard_Integer const arg2) -> Standard_Integer

        Returns number of points in tangent zone

        :type : int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntPolyh.IntPolyh_Intersection_NbPointsInTangentZone(self, *args)


    def GetLinePoint(self, *args):
        """
        GetLinePoint(IntPolyh_Intersection self, Standard_Integer const IndexLine, Standard_Integer const IndexPoint)

        Gets the parameters of the point in section line

        :type IndexLine: int
        :type IndexPoint: int
        :type x: float
        :type y: float
        :type z: float
        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float
        :type incidence: float

        """
        return _IntPolyh.IntPolyh_Intersection_GetLinePoint(self, *args)


    def GetTangentZonePoint(self, *args):
        """
        GetTangentZonePoint(IntPolyh_Intersection self, Standard_Integer const IndexLine, Standard_Integer const IndexPoint)

        Gets the parameters of the point in tangent zone

        :type IndexLine: int
        :type IndexPoint: int
        :type x: float
        :type y: float
        :type z: float
        :type u1: float
        :type v1: float
        :type u2: float
        :type v2: float

        """
        return _IntPolyh.IntPolyh_Intersection_GetTangentZonePoint(self, *args)

    __swig_destroy__ = _IntPolyh.delete_IntPolyh_Intersection
IntPolyh_Intersection_swigregister = _IntPolyh.IntPolyh_Intersection_swigregister
IntPolyh_Intersection_swigregister(IntPolyh_Intersection)


try:
	IntPolyh_ArrayOfEdges = IntPolyh_Array_IntPolyh_Edge
except NameError:
	pass # does not exist, probably ignored


try:
	IntPolyh_ArrayOfPointNormal = IntPolyh_Array_IntPolyh_PointNormal
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TDF')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TDF')
    _TDF = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TDF', [dirname(__file__)])
        except ImportError:
            import _TDF
            return _TDF
        try:
            _mod = imp.load_module('_TDF', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TDF = swig_import_helper()
    del swig_import_helper
else:
    import _TDF
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TDF.delete_SwigPyIterator

    def value(self):
        return _TDF.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TDF.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TDF.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TDF.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TDF.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TDF.SwigPyIterator_copy(self)

    def next(self):
        return _TDF.SwigPyIterator_next(self)

    def __next__(self):
        return _TDF.SwigPyIterator___next__(self)

    def previous(self):
        return _TDF.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TDF.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TDF.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TDF.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TDF.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TDF.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TDF.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TDF.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TDF.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TDF.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TDF.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TDF.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TDF.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TDF.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TDF.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TDF.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TDF.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TDF.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TDF.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TDF.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TDF.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TDF.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TDF.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TDF.ptr_to_number(item)
ptr_to_number = _TDF.ptr_to_number

def HashCode(*args):
    return _TDF.HashCode(*args)
HashCode = _TDF.HashCode

def ptr_equal(a, b):
    return _TDF.ptr_equal(a, b)
ptr_equal = _TDF.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
TDF_LabelNodeImportMsk = _TDF.TDF_LabelNodeImportMsk
TDF_LabelNodeAttModMsk = _TDF.TDF_LabelNodeAttModMsk
TDF_LabelNodeMayModMsk = _TDF.TDF_LabelNodeMayModMsk
TDF_LabelNodeFlagsMsk = _TDF.TDF_LabelNodeFlagsMsk
class TDF_AttributeDelta(Standard.Standard_Transient):
    """
    This class discribes the services we need to
    implement Delta and Undo/Redo services.

    AttributeDeltas are applied in an unpredictable
    order. But by the redefinition of the method
    IsNowApplicable, a condition can be verified
    before application. If the AttributeDelta is not
    yet applicable, it is put at the end of the
    AttributeDelta list, to be treated later. If a
    dead lock if found on the list, the
    AttributeDeltas are forced to be applied in an
    unpredictable order.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_AttributeDelta
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_AttributeDelta(self) 
            return h


    def Apply(self, *args):
        """
        Apply(TDF_AttributeDelta self)

        Applies the delta to the attribute.


        """
        return _TDF.TDF_AttributeDelta_Apply(self, *args)


    def Label(self, *args):
        """
        Label(TDF_AttributeDelta self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_AttributeDelta_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(TDF_AttributeDelta self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_AttributeDelta_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(TDF_AttributeDelta self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.TDF_AttributeDelta_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_AttributeDelta self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_AttributeDelta_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(TDF_AttributeDelta self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_AttributeDelta___lshift__(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_AttributeDelta_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_AttributeDelta_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_AttributeDelta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_AttributeDelta
TDF_AttributeDelta_swigregister = _TDF.TDF_AttributeDelta_swigregister
TDF_AttributeDelta_swigregister(TDF_AttributeDelta)

def TDF_AttributeDelta_get_type_name(*args):
    """
    TDF_AttributeDelta_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_AttributeDelta_get_type_name(*args)

def TDF_AttributeDelta_get_type_descriptor(*args):
    """
    TDF_AttributeDelta_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_AttributeDelta_get_type_descriptor(*args)

class TDF_Attribute(Standard.Standard_Transient):
    """
    A class each application has to implement. It is
    used to contain the application data.
    This abstract class, alongwith Label,
    is one of the cornerstones of Model Editor.
    The groundwork is to define the root of
    information. This information is to be
    attached to a Label, and could be of any of
    the following types:
    -   a feature
    -   a constraint
    -   a comment

    Contents:
    ---------

    Each software component who'd like to attach its
    own information to a label has to inherit from
    this class and has to add its own information as
    fields of this new class.

    Identification:
    ---------------

    An attribute can be identified by its ID. Every
    attributes used with the same meaning (for
    exemple: Integer, String, Topology...) have the
    same worldwide unique ID.

    Addition:
    ---------

    An attribute can be added to a label only if there
    is no attribute yet with the same ID. Call-back
    methods are offered, called automatically before
    and after the addition action.

    Removal:
    --------

    An attribute can be removed from a label only if
    there is an attribute yet with the same
    ID. Call-back methods are offered, called
    automatically before and after the removal
    action. A removed attribute cannot be found
    again. After a removal, only an addition of an
    attribute with the sane ID is possible (no
    backup...).

    Modification & Transaction:
    ---------------------------

    An attribute can be backuped before a
    modification. Only one backup attribute by
    transaction is possible. The modification can be
    forgotten (abort transaction) or validated (commit
    transaction).

    BackupCopy and restore are methods used by the backup or
    abort transaction actions. BackupCopy is called by
    Backup to generate an attribute with the same
    contents as the current one. Restore is called
    when aborting a transaction to transfer the
    backuped contents into the current
    attribute. These methods must be implemented by
    end use inheriting classes.

    A standard implementation of BackupCopy is provided, but
    it is not necessary a good one for any use.

    Copy use methods:
    -----------------

    Paste and NewEmpty methods are used by the copy
    algorithms. The goal of "Paste" is to transfer an
    attribute new contents into another attribute. The
    goal of "NewEmpty" is to create an attribute
    whithout contents, to be further filled with the
    new contents of another one. These 2 methods must
    be implemented by end use inheriting classes.

    AttributeDelta:
    ---------------

    An AttributeDelta is the difference between to
    attribute values states.  These methods must be
    implemented by end use inheriting classes, to
    profit from the delta services.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_Attribute
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_Attribute(self) 
            return h


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.TDF_Attribute_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(TDF_Attribute self, Standard_GUID arg2)
        SetID(TDF_Attribute self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDF.TDF_Attribute_SetID(self, *args)


    def Label(self, *args):
        """
        Label(TDF_Attribute self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Attribute_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(TDF_Attribute self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Attribute_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(TDF_Attribute self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Attribute_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(TDF_Attribute self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(TDF_Attribute self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(TDF_Attribute self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_Attribute_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(TDF_Attribute self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(TDF_Attribute self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDF.TDF_Attribute_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(TDF_Attribute self)

        Something to do after adding an Attribute to a label.


        """
        return _TDF.TDF_Attribute_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(TDF_Attribute self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDF.TDF_Attribute_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(TDF_Attribute self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDF.TDF_Attribute_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(TDF_Attribute self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDF.TDF_Attribute_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(TDF_Attribute self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(TDF_Attribute self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TDF_Attribute self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(TDF_Attribute self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDF.TDF_Attribute_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(TDF_Attribute self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDF.TDF_Attribute_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Attribute_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(TDF_Attribute self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_Attribute_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(TDF_Attribute self, Handle_TDF_Attribute anAttribute)

        Restores the backuped contents from <anAttribute>
        into this one. It is used when aborting a
        transaction.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_Attribute_Restore(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(TDF_Attribute self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDF.TDF_Attribute_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(TDF_Attribute self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDF.TDF_Attribute_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(TDF_Attribute self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDF.TDF_Attribute_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(TDF_Attribute self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDF.TDF_Attribute_DeltaOnRemoval(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDF_Attribute self) -> Handle_TDF_Attribute

        Returns an new empty attribute from the good end
        type. It is used by the copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_Attribute_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDF_Attribute self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocationTable)

        This method is different from the "Copy" one,
        because it is used when copying an attribute from
        a source structure into a target structure. This
        method may paste the contents of <me> into
        <intoAttribute>.

        The given pasted attribute can be full or empty of
        its contents. But don't make a NEW! Just set the
        contents!

        It is possible to use <aRelocationTable> to
        get/set the relocation value of a source
        attribute.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDF.TDF_Attribute_Paste(self, *args)


    def References(self, *args):
        """
        References(TDF_Attribute self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDF.TDF_Attribute_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_Attribute self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Attribute_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(TDF_Attribute self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Attribute___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(TDF_Attribute self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDF.TDF_Attribute_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(TDF_Attribute self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDF.TDF_Attribute_Forget(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_Attribute_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_Attribute_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_Attribute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_Attribute
TDF_Attribute_swigregister = _TDF.TDF_Attribute_swigregister
TDF_Attribute_swigregister(TDF_Attribute)

def TDF_Attribute_get_type_name(*args):
    """
    TDF_Attribute_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_Attribute_get_type_name(*args)

def TDF_Attribute_get_type_descriptor(*args):
    """
    TDF_Attribute_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_Attribute_get_type_descriptor(*args)

class TDF_HAttributeArray1(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_HAttributeArray1
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_HAttributeArray1(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_HAttributeArray1 self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TDF_HAttributeArray1
        __init__(TDF_HAttributeArray1 self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_TDF_Attribute theValue) -> TDF_HAttributeArray1
        __init__(TDF_HAttributeArray1 self, NCollection_Array1_Handle_TDF_Attribute theOther) -> TDF_HAttributeArray1

        :type theOther: OCC.wrapper.TDF.TDF_AttributeArray1

        """
        this = _TDF.new_TDF_HAttributeArray1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_AttributeArray1

        """
        res = _TDF.TDF_HAttributeArray1_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TDF_HAttributeArray1 self) -> NCollection_Array1_Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.TDF_AttributeArray1

        """
        return _TDF.TDF_HAttributeArray1_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_HAttributeArray1_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_HAttributeArray1_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_HAttributeArray1_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_HAttributeArray1
TDF_HAttributeArray1_swigregister = _TDF.TDF_HAttributeArray1_swigregister
TDF_HAttributeArray1_swigregister(TDF_HAttributeArray1)

def TDF_HAttributeArray1_get_type_name(*args):
    """
    TDF_HAttributeArray1_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_HAttributeArray1_get_type_name(*args)

def TDF_HAttributeArray1_get_type_descriptor(*args):
    """
    TDF_HAttributeArray1_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_HAttributeArray1_get_type_descriptor(*args)

class TDF_DeltaOnForget(TDF_AttributeDelta):
    """
    This class provides default services for an
    AttributeDelta on an Forget action.

    Applying this AttributeDelta means RESUMING its
    attribute.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DeltaOnForget
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DeltaOnForget(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_DeltaOnForget self, Handle_TDF_Attribute anAtt) -> TDF_DeltaOnForget

        Creates a TDF_DeltaOnForget.

        :type anAtt: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        this = _TDF.new_TDF_DeltaOnForget(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDF_DeltaOnForget self)

        Applies the delta to the attribute.


        """
        return _TDF.TDF_DeltaOnForget_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DeltaOnForget_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DeltaOnForget_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DeltaOnForget_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DeltaOnForget
TDF_DeltaOnForget_swigregister = _TDF.TDF_DeltaOnForget_swigregister
TDF_DeltaOnForget_swigregister(TDF_DeltaOnForget)

def TDF_DeltaOnForget_get_type_name(*args):
    """
    TDF_DeltaOnForget_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DeltaOnForget_get_type_name(*args)

def TDF_DeltaOnForget_get_type_descriptor(*args):
    """
    TDF_DeltaOnForget_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DeltaOnForget_get_type_descriptor(*args)

class TDF_Delta(Standard.Standard_Transient):
    """
    A set of AttributeDelta for a given transaction
    number and reference time number.
    A delta set is available at <aSourceTime>. If
    applied, it restores the TDF_Data in the state it
    was at <aTargetTime>.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_Delta
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_Delta(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_Delta self) -> TDF_Delta

        Creates a delta.


        """
        this = _TDF.new_TDF_Delta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TDF_Delta self) -> Standard_Boolean

        Returns true if there is nothing to undo.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Delta_IsEmpty(self, *args)


    def IsApplicable(self, *args):
        """
        IsApplicable(TDF_Delta self, Standard_Integer const aCurrentTime) -> Standard_Boolean

        Returns true if the Undo action of <me> is
        applicable at <aCurrentTime>.

        :type aCurrentTime: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Delta_IsApplicable(self, *args)


    def BeginTime(self, *args):
        """
        BeginTime(TDF_Delta self) -> Standard_Integer

        Returns the field <myBeginTime>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Delta_BeginTime(self, *args)


    def EndTime(self, *args):
        """
        EndTime(TDF_Delta self) -> Standard_Integer

        Returns the field <myEndTime>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Delta_EndTime(self, *args)


    def Labels(self, *args):
        """
        Labels(TDF_Delta self, NCollection_List_TDF_Label aLabelList)

        Adds in <aLabelList> the labels of the attribute deltas.
        Caution: <aLabelList> is not cleared before use.

        :type aLabelList: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TDF.TDF_Delta_Labels(self, *args)


    def AttributeDeltas(self, *args):
        """
        Returns the field <myAttDeltaList>.

        :rtype: OCC.wrapper.TDF.TDF_AttributeDeltaList

        """
        res = _TDF.TDF_Delta_AttributeDeltas(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(TDF_Delta self) -> TCollection_ExtendedString

        Returns a name associated with this delta.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDF.TDF_Delta_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(TDF_Delta self, TCollection_ExtendedString theName)

        Associates a name <theName> with this delta

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDF.TDF_Delta_SetName(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_Delta self, Standard_OStream & OS)

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Delta_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_Delta_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_Delta_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_Delta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_Delta
TDF_Delta_swigregister = _TDF.TDF_Delta_swigregister
TDF_Delta_swigregister(TDF_Delta)

def TDF_Delta_get_type_name(*args):
    """
    TDF_Delta_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_Delta_get_type_name(*args)

def TDF_Delta_get_type_descriptor(*args):
    """
    TDF_Delta_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_Delta_get_type_descriptor(*args)

class TDF_RelocationTable(Standard.Standard_Transient):
    """
    This is a relocation dictionnary between source
    and target labels, attributes or any
    transient(useful for copy or paste actions).
    Note that one target value may be the
    relocation value of more than one source object.

    Common behaviour: it returns true and the found
    relocation value as target object; false
    otherwise.

    Look at SelfRelocate method for more explanation
    about self relocation behavior of this class.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_RelocationTable
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_RelocationTable(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_RelocationTable self, Standard_Boolean const selfRelocate) -> TDF_RelocationTable

        Creates an relocation table. <selfRelocate> says
        if a value without explicit relocation is its own
        relocation.

        :type selfRelocate: bool

        """
        this = _TDF.new_TDF_RelocationTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SelfRelocate(self, *args):
        """
        SelfRelocate(TDF_RelocationTable self, Standard_Boolean const selfRelocate)
        SelfRelocate(TDF_RelocationTable self) -> Standard_Boolean

        Returns <mySelfRelocate>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_RelocationTable_SelfRelocate(self, *args)


    def AfterRelocate(self, *args):
        """
        AfterRelocate(TDF_RelocationTable self, Standard_Boolean const afterRelocate)
        AfterRelocate(TDF_RelocationTable self) -> Standard_Boolean

        Returns <myAfterRelocate>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_RelocationTable_AfterRelocate(self, *args)


    def SetRelocation(self, *args):
        """
        SetRelocation(TDF_RelocationTable self, TDF_Label aSourceLabel, TDF_Label aTargetLabel)
        SetRelocation(TDF_RelocationTable self, Handle_TDF_Attribute aSourceAttribute, Handle_TDF_Attribute aTargetAttribute)

        Sets the relocation value of <aSourceAttribute> to
        <aTargetAttribute>.

        :type aSourceAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aTargetAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_RelocationTable_SetRelocation(self, *args)


    def HasRelocation(self, *args):
        """
        HasRelocation(TDF_RelocationTable self, TDF_Label aSourceLabel, TDF_Label aTargetLabel) -> Standard_Boolean
        HasRelocation(TDF_RelocationTable self, Handle_TDF_Attribute aSourceAttribute, Handle_TDF_Attribute aTargetAttribute) -> Standard_Boolean

        Finds the relocation value of <aSourceAttribute>
        and returns it into <aTargetAttribute>.

        (See above SelfRelocate method for more
        explanation about the method behavior)

        :type aSourceAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aTargetAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_RelocationTable_HasRelocation(self, *args)


    def SetTransientRelocation(self, *args):
        """
        SetTransientRelocation(TDF_RelocationTable self, Handle_Standard_Transient aSourceTransient, Handle_Standard_Transient aTargetTransient)

        Sets the relocation value of <aSourceTransient> to
        <aTargetTransient>.

        :type aSourceTransient: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aTargetTransient: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _TDF.TDF_RelocationTable_SetTransientRelocation(self, *args)


    def HasTransientRelocation(self, *args):
        """
        HasTransientRelocation(TDF_RelocationTable self, Handle_Standard_Transient aSourceTransient, Handle_Standard_Transient aTargetTransient) -> Standard_Boolean

        Finds the relocation value of <aSourceTransient>
        and returns it into <aTargetTransient>.

        (See above SelfRelocate method for more
        explanation about the method behavior)

        :type aSourceTransient: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aTargetTransient: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_RelocationTable_HasTransientRelocation(self, *args)


    def Clear(self, *args):
        """
        Clear(TDF_RelocationTable self)

        Clears the relocation dictionnary, but lets the
        self relocation flag to its current value.


        """
        return _TDF.TDF_RelocationTable_Clear(self, *args)


    def TargetLabelMap(self, *args):
        """
        TargetLabelMap(TDF_RelocationTable self, NCollection_Map_TDF_Label_TDF_LabelMapHasher aLabelMap)

        Fills <aLabelMap> with target relocation
        labels. <aLabelMap> is not cleared before use.

        :type aLabelMap: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TDF.TDF_RelocationTable_TargetLabelMap(self, *args)


    def TargetAttributeMap(self, *args):
        """
        TargetAttributeMap(TDF_RelocationTable self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher anAttributeMap)

        Fills <anAttributeMap> with target relocation
        attributes. <anAttributeMap> is not cleared before
        use.

        :type anAttributeMap: OCC.wrapper.TDF.TDF_AttributeMap

        """
        return _TDF.TDF_RelocationTable_TargetAttributeMap(self, *args)


    def LabelTable(self, *args):
        """
        LabelTable(TDF_RelocationTable self) -> NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher

        Returns <myLabelTable> to be used or updated.

        :rtype: OCC.wrapper.TDF.TDF_LabelDataMap

        """
        return _TDF.TDF_RelocationTable_LabelTable(self, *args)


    def AttributeTable(self, *args):
        """
        AttributeTable(TDF_RelocationTable self) -> NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Returns <myAttributeTable> to be used or updated.

        :rtype: OCC.wrapper.TDF.TDF_AttributeDataMap

        """
        return _TDF.TDF_RelocationTable_AttributeTable(self, *args)


    def TransientTable(self, *args):
        """
        TransientTable(TDF_RelocationTable self) -> NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Returns <myTransientTable> to be used or updated.

        :rtype: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TDF.TDF_RelocationTable_TransientTable(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_RelocationTable self, Standard_Boolean const dumpLabels, Standard_Boolean const dumpAttributes, Standard_Boolean const dumpTransients, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the relocation table.

        :type dumpLabels: bool
        :type dumpAttributes: bool
        :type dumpTransients: bool
        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_RelocationTable_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_RelocationTable_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_RelocationTable_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_RelocationTable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_RelocationTable
TDF_RelocationTable_swigregister = _TDF.TDF_RelocationTable_swigregister
TDF_RelocationTable_swigregister(TDF_RelocationTable)

def TDF_RelocationTable_get_type_name(*args):
    """
    TDF_RelocationTable_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_RelocationTable_get_type_name(*args)

def TDF_RelocationTable_get_type_descriptor(*args):
    """
    TDF_RelocationTable_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_RelocationTable_get_type_descriptor(*args)

class TDF_LabelMapHasher(object):
    """A label hasher for label maps."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(TDF_Label aLab, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  Key <K>  in the range 0..Upper.

        :type aLab: OCC.wrapper.TDF.TDF_Label
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_LabelMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(TDF_Label aLab1, TDF_Label aLab2) -> Standard_Boolean

        Returns True  when the two  keys are the same. Two
        same  keys  must   have  the  same  hashcode,  the
        contrary is not necessary.

        :type aLab1: OCC.wrapper.TDF.TDF_Label
        :type aLab2: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_LabelMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """A label hasher for label maps."""
        this = _TDF.new_TDF_LabelMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_TDF_LabelMapHasher
TDF_LabelMapHasher_swigregister = _TDF.TDF_LabelMapHasher_swigregister
TDF_LabelMapHasher_swigregister(TDF_LabelMapHasher)

def TDF_LabelMapHasher_HashCode(*args):
    """
    TDF_LabelMapHasher_HashCode(TDF_Label aLab, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  Key <K>  in the range 0..Upper.

    :type aLab: OCC.wrapper.TDF.TDF_Label
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TDF.TDF_LabelMapHasher_HashCode(*args)

def TDF_LabelMapHasher_IsEqual(*args):
    """
    TDF_LabelMapHasher_IsEqual(TDF_Label aLab1, TDF_Label aLab2) -> Standard_Boolean

    Returns True  when the two  keys are the same. Two
    same  keys  must   have  the  same  hashcode,  the
    contrary is not necessary.

    :type aLab1: OCC.wrapper.TDF.TDF_Label
    :type aLab2: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDF.TDF_LabelMapHasher_IsEqual(*args)

class TDF_Label(object):
    """
    This class provides basic operations  to define
    a label in a data structure.
    A label is a feature in the feature hierarchy. A
    label is always connected to a Data from TDF.
    To a label is attached attributes containing the
    software components information.

    Label information:

    It is possible to know the tag, the father, the
    depth in the tree of the label, if the label is
    root, null or equal to another label.

    Comfort methods:
    Some methods useful on a label.

    Attributes:

    It is possible to get an attribute in accordance
    to an ID, or the yougest previous version of a
    current attribute.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_Label self) -> TDF_Label

        Constructs an empty label object.


        """
        this = _TDF.new_TDF_Label(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Nullify(self, *args):
        """
        Nullify(TDF_Label self)

        Nullifies the label.


        """
        return _TDF.TDF_Label_Nullify(self, *args)


    def Data(self, *args):
        """
        Data(TDF_Label self) -> Handle_TDF_Data

        Returns the Data owning <me>.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Data

        """
        return _TDF.TDF_Label_Data(self, *args)


    def Tag(self, *args):
        """
        Tag(TDF_Label self) -> Standard_Integer

        Returns the tag of the label.
        This is the integer assigned randomly to a label
        in a data framework. This integer is used to
        identify this label in an entry.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Label_Tag(self, *args)


    def Father(self, *args):
        """
        Father(TDF_Label self) -> TDF_Label

        Returns the label father. This label may be null
        if the label is root.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Label_Father(self, *args)


    def IsNull(self, *args):
        """
        IsNull(TDF_Label self) -> Standard_Boolean

        Returns True if the <aLabel> is null, i.e. it has
        not been included in the data framework.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_IsNull(self, *args)


    def Imported(self, *args):
        """
        Imported(TDF_Label self, Standard_Boolean const aStatus)

        Sets or unsets <me> and all its descendants as
        imported label, according to <aStatus>.

        :type aStatus: bool

        """
        return _TDF.TDF_Label_Imported(self, *args)


    def IsImported(self, *args):
        """
        IsImported(TDF_Label self) -> Standard_Boolean

        Returns True if the <aLabel> is imported.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_IsImported(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(TDF_Label self, TDF_Label aLabel) -> Standard_Boolean

        Returns True if the <aLabel> is equal to me (same
        LabelNode*).

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(TDF_Label self, TDF_Label aLabel) -> Standard_Boolean

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label___eq__(self, *args)


    def IsDifferent(self, *args):
        """
        IsDifferent(TDF_Label self, TDF_Label aLabel) -> Standard_Boolean

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_IsDifferent(self, *args)


    def __ne__(self, *args):
        """
        __ne__(TDF_Label self, TDF_Label aLabel) -> Standard_Boolean

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label___ne__(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(TDF_Label self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_IsRoot(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(TDF_Label self, Standard_GUID anID) -> Standard_Boolean

        Returns true if <me> owns an attribute with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_IsAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(TDF_Label self, Handle_TDF_Attribute anAttribute, Standard_Boolean const append)

        Adds an Attribute  to the current label. Raises if
        there is already one.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type append: bool

        """
        return _TDF.TDF_Label_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(TDF_Label self, Handle_TDF_Attribute anAttribute)
        ForgetAttribute(TDF_Label self, Standard_GUID aguid) -> Standard_Boolean

        Forgets the  Attribute of  GUID <aguid> from   the
        current label   . If the   attribute doesn't exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(TDF_Label self, Standard_Boolean const clearChildren)

        Forgets all the attributes. Does it on also on the
        sub-labels if <clearChildren> is set to true. Of
        course, this method is compatible with Transaction
        & Delta mecanisms.

        :type clearChildren: bool

        """
        return _TDF.TDF_Label_ForgetAllAttributes(self, *args)


    def ResumeAttribute(self, *args):
        """
        ResumeAttribute(TDF_Label self, Handle_TDF_Attribute anAttribute)

        Undo Forget action, setting its forgotten status
        false and its valid status true. Raises if the
        attribute is not in the structure.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_Label_ResumeAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(TDF_Label self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean
        FindAttribute(TDF_Label self, Standard_GUID anID, Standard_Integer const aTransaction, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an attribute of the current label, according
        to <anID> and <aTransaction>. This attribute
        has/had to be a valid one for the given
        transaction index . So, this attribute is not
        necessary a valid one.

        The method returns True if found, False otherwise.

        A removed attribute cannot be found nor a backuped
        attribute of a removed one.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type aTransaction: int
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_FindAttribute(self, *args)


    def MayBeModified(self, *args):
        """
        MayBeModified(TDF_Label self) -> Standard_Boolean

        Returns true if <me> or a DESCENDANT of <me> owns
        attributes not yet available in transaction 0. It
        means at least one of their attributes is new,
        modified or deleted.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_MayBeModified(self, *args)


    def AttributesModified(self, *args):
        """
        AttributesModified(TDF_Label self) -> Standard_Boolean

        Returns true if <me> owns attributes not yet
        available in transaction 0. It means at least one
        attribute is new, modified or deleted.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_AttributesModified(self, *args)


    def HasAttribute(self, *args):
        """
        HasAttribute(TDF_Label self) -> Standard_Boolean

        Returns true if this label has at least one attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_HasAttribute(self, *args)


    def NbAttributes(self, *args):
        """
        NbAttributes(TDF_Label self) -> Standard_Integer

        Returns the number of attributes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Label_NbAttributes(self, *args)


    def Depth(self, *args):
        """
        Depth(TDF_Label self) -> Standard_Integer

        Returns the depth of the label in the data framework.
        This corresponds to the number of fathers which
        this label has, and is used in determining
        whether a label is root, null or equivalent to another label.
        Exceptions:
        Standard_NullObject if this label is null. This is
        because a null object can have no depth.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Label_Depth(self, *args)


    def IsDescendant(self, *args):
        """
        IsDescendant(TDF_Label self, TDF_Label aLabel) -> Standard_Boolean

        Returns True if <me> is a descendant of
        <aLabel>. Attention: every label is its own
        descendant.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_IsDescendant(self, *args)


    def Root(self, *args):
        """
        Root(TDF_Label self) -> TDF_Label

        Returns the root label Root of the data structure.
        This has a depth of 0.
        Exceptions:
        Standard_NullObject if this label is null. This is
        because a null object can have no depth.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Label_Root(self, *args)


    def HasChild(self, *args):
        """
        HasChild(TDF_Label self) -> Standard_Boolean

        Returns true if this label has at least one child.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_HasChild(self, *args)


    def NbChildren(self, *args):
        """
        NbChildren(TDF_Label self) -> Standard_Integer

        Returns the number of children.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Label_NbChildren(self, *args)


    def FindChild(self, *args):
        """
        FindChild(TDF_Label self, Standard_Integer const aTag, Standard_Boolean const create) -> TDF_Label

        Finds a child label having <aTag> as tag. Creates
        The tag aTag identifies the label which will be the parent.
        If create is true and no child label is found, a new one is created.
        Example:
        //creating a label with tag 10 at Root
        TDF_Label lab1 = aDF->Root().FindChild(10);
        //creating labels 7 and 2 on label 10
        TDF_Label lab2 = lab1.FindChild(7);
        TDF_Label lab3 = lab1.FindChild(2);

        :type aTag: int
        :type create: bool
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Label_FindChild(self, *args)


    def NewChild(self, *args):
        """
        NewChild(TDF_Label self) -> TDF_Label

        Create  a new child   label of me  using autoamtic
        delivery tags provided by TagSource.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Label_NewChild(self, *args)


    def Transaction(self, *args):
        """
        Transaction(TDF_Label self) -> Standard_Integer

        Returns the current transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Label_Transaction(self, *args)


    def HasLowerNode(self, *args):
        """
        HasLowerNode(TDF_Label self, TDF_Label otherLabel) -> Standard_Boolean

        Returns true if node address of <me> is lower than
        <otherLabel> one. Used to quickly sort labels (not
        on entry criterion).

        -C++: inline

        :type otherLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_HasLowerNode(self, *args)


    def HasGreaterNode(self, *args):
        """
        HasGreaterNode(TDF_Label self, TDF_Label otherLabel) -> Standard_Boolean

        Returns true if node address of <me> is greater
        than <otherLabel> one. Used to quickly sort labels
        (not on entry criterion).

        -C++: inline

        :type otherLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Label_HasGreaterNode(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_Label self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Label_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(TDF_Label self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Label___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(TDF_Label self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the label on <aStream> and its attributes
        rank in <aMap> if their IDs are kept by <IDFilter>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDF.TDF_Label_ExtendedDump(self, *args)


    def EntryDump(self, *args):
        """
        EntryDump(TDF_Label self, Standard_OStream & anOS)

        Dumps the label entry.

        :type anOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Label_EntryDump(self, *args)

    __swig_destroy__ = _TDF.delete_TDF_Label
TDF_Label_swigregister = _TDF.TDF_Label_swigregister
TDF_Label_swigregister(TDF_Label)

class TDF_DeltaOnAddition(TDF_AttributeDelta):
    """
    This class provides default services for an
    AttributeDelta on an ADDITION action.

    Applying this AttributeDelta means REMOVING its
    attribute.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DeltaOnAddition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DeltaOnAddition(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_DeltaOnAddition self, Handle_TDF_Attribute anAtt) -> TDF_DeltaOnAddition

        Creates a TDF_DeltaOnAddition.

        :type anAtt: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        this = _TDF.new_TDF_DeltaOnAddition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDF_DeltaOnAddition self)

        Applies the delta to the attribute.


        """
        return _TDF.TDF_DeltaOnAddition_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DeltaOnAddition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DeltaOnAddition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DeltaOnAddition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DeltaOnAddition
TDF_DeltaOnAddition_swigregister = _TDF.TDF_DeltaOnAddition_swigregister
TDF_DeltaOnAddition_swigregister(TDF_DeltaOnAddition)

def TDF_DeltaOnAddition_get_type_name(*args):
    """
    TDF_DeltaOnAddition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DeltaOnAddition_get_type_name(*args)

def TDF_DeltaOnAddition_get_type_descriptor(*args):
    """
    TDF_DeltaOnAddition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DeltaOnAddition_get_type_descriptor(*args)

class TDF_DeltaOnRemoval(TDF_AttributeDelta):
    """
    This class provides default services for an
    AttributeDelta on a REMOVAL action.

    Applying this AttributeDelta means ADDING its
    attribute.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DeltaOnRemoval
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DeltaOnRemoval(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DeltaOnRemoval_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DeltaOnRemoval_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DeltaOnRemoval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DeltaOnRemoval
TDF_DeltaOnRemoval_swigregister = _TDF.TDF_DeltaOnRemoval_swigregister
TDF_DeltaOnRemoval_swigregister(TDF_DeltaOnRemoval)

def TDF_DeltaOnRemoval_get_type_name(*args):
    """
    TDF_DeltaOnRemoval_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DeltaOnRemoval_get_type_name(*args)

def TDF_DeltaOnRemoval_get_type_descriptor(*args):
    """
    TDF_DeltaOnRemoval_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DeltaOnRemoval_get_type_descriptor(*args)

class TDF_DeltaOnModification(TDF_AttributeDelta):
    """
    This class provides default services for an
    AttributeDelta on a MODIFICATION action.

    Applying this AttributeDelta means GOING BACK to
    the attribute previously registered state.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DeltaOnModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DeltaOnModification(self) 
            return h


    def Apply(self, *args):
        """
        Apply(TDF_DeltaOnModification self)

        Applies the delta to the attribute.


        """
        return _TDF.TDF_DeltaOnModification_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DeltaOnModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DeltaOnModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DeltaOnModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DeltaOnModification
TDF_DeltaOnModification_swigregister = _TDF.TDF_DeltaOnModification_swigregister
TDF_DeltaOnModification_swigregister(TDF_DeltaOnModification)

def TDF_DeltaOnModification_get_type_name(*args):
    """
    TDF_DeltaOnModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DeltaOnModification_get_type_name(*args)

def TDF_DeltaOnModification_get_type_descriptor(*args):
    """
    TDF_DeltaOnModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DeltaOnModification_get_type_descriptor(*args)

class TDF_Reference(TDF_Attribute):
    """
    This  attribute is  used to  store in the  framework a
    reference to an other label.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_Reference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_Reference(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.TDF_Reference_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(self, *args):
        """
        Set(TDF_Reference self, TDF_Label I, TDF_Label Origin) -> Handle_TDF_Reference
        Set(TDF_Reference self, TDF_Label Origin)

        :type Origin: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Reference_Set(self, *args)


    def Get(self, *args):
        """
        Get(TDF_Reference self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Reference_Get(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.TDF_Reference_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDF_Reference self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_Reference_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDF_Reference self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_Reference_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDF_Reference self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDF.TDF_Reference_Paste(self, *args)


    def References(self, *args):
        """
        References(TDF_Reference self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDF.TDF_Reference_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_Reference self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Reference_Dump(self, *args)


    def __init__(self, *args):
        """
        __init__(TDF_Reference self) -> TDF_Reference

        This  attribute is  used to  store in the  framework a
        reference to an other label.
        """
        this = _TDF.new_TDF_Reference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_Reference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_Reference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_Reference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_Reference
TDF_Reference_swigregister = _TDF.TDF_Reference_swigregister
TDF_Reference_swigregister(TDF_Reference)

def TDF_Reference_GetID(*args):
    """
    TDF_Reference_GetID() -> Standard_GUID

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDF.TDF_Reference_GetID(*args)

def TDF_Reference_get_type_name(*args):
    """
    TDF_Reference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_Reference_get_type_name(*args)

def TDF_Reference_get_type_descriptor(*args):
    """
    TDF_Reference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_Reference_get_type_descriptor(*args)

class TDF_DeltaOnResume(TDF_AttributeDelta):
    """
    This class provides default services for an
    AttributeDelta on an Resume action.

    Applying this AttributeDelta means FORGETTING its
    attribute.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DeltaOnResume
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DeltaOnResume(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_DeltaOnResume self, Handle_TDF_Attribute anAtt) -> TDF_DeltaOnResume

        Creates a TDF_DeltaOnResume.

        :type anAtt: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        this = _TDF.new_TDF_DeltaOnResume(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDF_DeltaOnResume self)

        Applies the delta to the attribute.


        """
        return _TDF.TDF_DeltaOnResume_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DeltaOnResume_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DeltaOnResume_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DeltaOnResume_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DeltaOnResume
TDF_DeltaOnResume_swigregister = _TDF.TDF_DeltaOnResume_swigregister
TDF_DeltaOnResume_swigregister(TDF_DeltaOnResume)

def TDF_DeltaOnResume_get_type_name(*args):
    """
    TDF_DeltaOnResume_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DeltaOnResume_get_type_name(*args)

def TDF_DeltaOnResume_get_type_descriptor(*args):
    """
    TDF_DeltaOnResume_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DeltaOnResume_get_type_descriptor(*args)

class TDF_CopyTool(object):
    """
    This class provides services to build, copy or
    paste a set of information.

    Copy methods:
    -------------

    * Copy(aSourceDataSet, aTargetLabel,
    aRelocationTable) copies a source DataSet under
    its target place (see below: IMPORTANT NOTICE 1).

    * Copy(aSourceDataSet, anTargetLabel,
    aRelocationTable, aFilter) does the same job as
    the previous method. But <aFilter> gives a list of
    IDs for which a target attribute prevails over a
    source one. In this special case, the source
    attribute will be copied only if there will be no
    target attribute.

    IMPORTANT NOTICE : Label pre-binding
    ------------------

    For it is possible to copy root labels in another
    place in the same Data or in a different one with
    other tags, it is necessary to inform the Copy
    algorithm about the target place. To do so:

    * first get or create new target root labels;

    * then bind them with the source root labels using
    the relocation table method:
    SetRelocation(aSourceLabel, aTargetLabel);

    * finally call Copy(...) with the relocation table
    previously set. In this way, this method will take
    these relocations in account.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Copy(*args):
        """
        Copy(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_RelocationTable aRelocationTable)
        Copy(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aPrivilegeFilter)
        Copy(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aPrivilegeFilter, TDF_IDFilter aRefFilter, Standard_Boolean const setSelfContained)

        Copy    <aSourceDataSet>   using and    updating
        <aRelocationTable>. Use <aPrivilegeFilter> to give
        a  list of IDs   for which  the target  attribute
        prevails    over    the    source     one.   If
        <setSelfContained>   is   set  to   true,  every
        TDF_Reference will  be replaced  by the referenced
        structure according to <aRefFilter>.

        NB: <aRefFilter> is used only if
        <setSelfContained> is true.
        Internal root label copy recursive method.

        :type aSourceDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :type aPrivilegeFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aRefFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type setSelfContained: bool

        """
        return _TDF.TDF_CopyTool_Copy(*args)

    Copy = staticmethod(Copy)

    def __init__(self):
        """
        This class provides services to build, copy or
        paste a set of information.

        Copy methods:
        -------------

        * Copy(aSourceDataSet, aTargetLabel,
        aRelocationTable) copies a source DataSet under
        its target place (see below: IMPORTANT NOTICE 1).

        * Copy(aSourceDataSet, anTargetLabel,
        aRelocationTable, aFilter) does the same job as
        the previous method. But <aFilter> gives a list of
        IDs for which a target attribute prevails over a
        source one. In this special case, the source
        attribute will be copied only if there will be no
        target attribute.

        IMPORTANT NOTICE : Label pre-binding
        ------------------

        For it is possible to copy root labels in another
        place in the same Data or in a different one with
        other tags, it is necessary to inform the Copy
        algorithm about the target place. To do so:

        * first get or create new target root labels;

        * then bind them with the source root labels using
        the relocation table method:
        SetRelocation(aSourceLabel, aTargetLabel);

        * finally call Copy(...) with the relocation table
        previously set. In this way, this method will take
        these relocations in account.
        """
        this = _TDF.new_TDF_CopyTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_TDF_CopyTool
TDF_CopyTool_swigregister = _TDF.TDF_CopyTool_swigregister
TDF_CopyTool_swigregister(TDF_CopyTool)

def TDF_CopyTool_Copy(*args):
    """
    Copy(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_RelocationTable aRelocationTable)
    Copy(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aPrivilegeFilter)
    TDF_CopyTool_Copy(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aPrivilegeFilter, TDF_IDFilter aRefFilter, Standard_Boolean const setSelfContained)

    Copy    <aSourceDataSet>   using and    updating
    <aRelocationTable>. Use <aPrivilegeFilter> to give
    a  list of IDs   for which  the target  attribute
    prevails    over    the    source     one.   If
    <setSelfContained>   is   set  to   true,  every
    TDF_Reference will  be replaced  by the referenced
    structure according to <aRefFilter>.

    NB: <aRefFilter> is used only if
    <setSelfContained> is true.
    Internal root label copy recursive method.

    :type aSourceDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
    :type aPrivilegeFilter: OCC.wrapper.TDF.TDF_IDFilter
    :type aRefFilter: OCC.wrapper.TDF.TDF_IDFilter
    :type setSelfContained: bool

    """
    return _TDF.TDF_CopyTool_Copy(*args)

class NCollection_Sequence_Handle_TDF_Attribute(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TDF_Attribute self) -> NCollection_Sequence< opencascade::handle< TDF_Attribute > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TDF_Attribute self) -> NCollection_Sequence< opencascade::handle< TDF_Attribute > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TDF_Attribute self) -> NCollection_Sequence< opencascade::handle< TDF_Attribute > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TDF_Attribute self) -> NCollection_Sequence< opencascade::handle< TDF_Attribute > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TDF.new_NCollection_Sequence_Handle_TDF_Attribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TDF_Attribute self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TDF_Attribute self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TDF_Attribute self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TDF_Attribute self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TDF_Attribute self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TDF_Attribute self)

        Reverse sequence


        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TDF_Attribute self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TDF_Attribute self, NCollection_Sequence_Handle_TDF_Attribute theOther) -> NCollection_Sequence_Handle_TDF_Attribute

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TDF_Attribute self, NCollection_Sequence_Handle_TDF_Attribute theOther) -> NCollection_Sequence_Handle_TDF_Attribute

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TDF_Attribute self, NCollection_Sequence< opencascade::handle< TDF_Attribute > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TDF_Attribute self, Handle_TDF_Attribute theItem)
        Append(NCollection_Sequence_Handle_TDF_Attribute self, NCollection_Sequence_Handle_TDF_Attribute theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TDF_Attribute self, Handle_TDF_Attribute theItem)
        Prepend(NCollection_Sequence_Handle_TDF_Attribute self, NCollection_Sequence_Handle_TDF_Attribute theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex, Handle_TDF_Attribute theItem)
        InsertBefore(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDF_Attribute theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TDF_Attribute self, NCollection_Sequence< opencascade::handle< TDF_Attribute > >::Iterator & thePosition, Handle_TDF_Attribute theItem)
        InsertAfter(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDF_Attribute theSeq)
        InsertAfter(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex, Handle_TDF_Attribute theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TDF_Attribute theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_Handle_TDF_Attribute_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TDF_Attribute self) -> Handle_TDF_Attribute

        First item access

        :rtype: TheItemType &

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_Handle_TDF_Attribute_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TDF_Attribute self) -> Handle_TDF_Attribute

        Last item access

        :rtype: TheItemType &

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_Handle_TDF_Attribute_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex) -> Handle_TDF_Attribute

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_Handle_TDF_Attribute___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TDF_Attribute self, Standard_Integer const theIndex, Handle_TDF_Attribute theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_SetValue(self, *args)


    def __iter__(self):
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_Sequence_Handle_TDF_Attribute
NCollection_Sequence_Handle_TDF_Attribute_swigregister = _TDF.NCollection_Sequence_Handle_TDF_Attribute_swigregister
NCollection_Sequence_Handle_TDF_Attribute_swigregister(NCollection_Sequence_Handle_TDF_Attribute)

def NCollection_Sequence_Handle_TDF_Attribute_delNode(*args):
    """
    NCollection_Sequence_Handle_TDF_Attribute_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TDF.NCollection_Sequence_Handle_TDF_Attribute_delNode(*args)

class NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper_swigregister = _TDF.NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper_swigregister
NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper_swigregister(NCollection_Sequence_Handle_TDF_Attribute_IteratorHelper)


try:
	TDF_AttributeSequence = NCollection_Sequence_Handle_TDF_Attribute
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_TDF_AttributeDelta(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_TDF_AttributeDelta self) -> NCollection_List< opencascade::handle< TDF_AttributeDelta > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_TDF_AttributeDelta self) -> NCollection_List< opencascade::handle< TDF_AttributeDelta > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_TDF_AttributeDelta self) -> NCollection_List< opencascade::handle< TDF_AttributeDelta > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_TDF_AttributeDelta self) -> NCollection_List< opencascade::handle< TDF_AttributeDelta > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TDF.new_NCollection_List_Handle_TDF_AttributeDelta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_TDF_AttributeDelta self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_TDF_AttributeDelta self, NCollection_List_Handle_TDF_AttributeDelta theOther) -> NCollection_List_Handle_TDF_AttributeDelta

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_TDF_AttributeDelta self, NCollection_List_Handle_TDF_AttributeDelta theOther) -> NCollection_List_Handle_TDF_AttributeDelta

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_TDF_AttributeDelta self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Handle_TDF_AttributeDelta_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Handle_TDF_AttributeDelta_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_TDF_AttributeDelta self, Handle_TDF_AttributeDelta theItem) -> Handle_TDF_AttributeDelta
        Append(NCollection_List_Handle_TDF_AttributeDelta self, Handle_TDF_AttributeDelta theItem, NCollection_List< opencascade::handle< TDF_AttributeDelta > >::Iterator & theIter)
        Append(NCollection_List_Handle_TDF_AttributeDelta self, NCollection_List_Handle_TDF_AttributeDelta theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_TDF_AttributeDelta self, Handle_TDF_AttributeDelta theItem) -> Handle_TDF_AttributeDelta
        Prepend(NCollection_List_Handle_TDF_AttributeDelta self, NCollection_List_Handle_TDF_AttributeDelta theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_TDF_AttributeDelta self)

        RemoveFirst item


        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_TDF_AttributeDelta self, NCollection_List< opencascade::handle< TDF_AttributeDelta > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_TDF_AttributeDelta self, Handle_TDF_AttributeDelta theItem, NCollection_List< opencascade::handle< TDF_AttributeDelta > >::Iterator & theIter) -> Handle_TDF_AttributeDelta
        InsertBefore(NCollection_List_Handle_TDF_AttributeDelta self, NCollection_List_Handle_TDF_AttributeDelta theOther, NCollection_List< opencascade::handle< TDF_AttributeDelta > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_TDF_AttributeDelta self, Handle_TDF_AttributeDelta theItem, NCollection_List< opencascade::handle< TDF_AttributeDelta > >::Iterator & theIter) -> Handle_TDF_AttributeDelta
        InsertAfter(NCollection_List_Handle_TDF_AttributeDelta self, NCollection_List_Handle_TDF_AttributeDelta theOther, NCollection_List< opencascade::handle< TDF_AttributeDelta > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_TDF_AttributeDelta self)

        Reverse the list


        """
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_Reverse(self, *args)


    def __iter__(self):
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_List_Handle_TDF_AttributeDelta
NCollection_List_Handle_TDF_AttributeDelta_swigregister = _TDF.NCollection_List_Handle_TDF_AttributeDelta_swigregister
NCollection_List_Handle_TDF_AttributeDelta_swigregister(NCollection_List_Handle_TDF_AttributeDelta)

class NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper___next__(self)
NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper_swigregister = _TDF.NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper_swigregister
NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper_swigregister(NCollection_List_Handle_TDF_AttributeDelta_IteratorHelper)


try:
	TDF_AttributeDeltaList = NCollection_List_Handle_TDF_AttributeDelta
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TDF_Attribute >,opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TDF_Attribute >,opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TDF_Attribute >,opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TDF_Attribute >,opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDF.new_NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey, Handle_TDF_Attribute theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey, Handle_TDF_Attribute theItem) -> Handle_TDF_Attribute

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey) -> Handle_TDF_Attribute

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey) -> Handle_TDF_Attribute

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey) -> Handle_TDF_Attribute

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher
NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister = _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TDF.NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper)


try:
	TDF_AttributeDataMap = NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Standard_GUID(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Standard_GUID self) -> NCollection_List< Standard_GUID >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Standard_GUID_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Standard_GUID self) -> NCollection_List< Standard_GUID >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Standard_GUID_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Standard_GUID self) -> NCollection_List< Standard_GUID >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Standard_GUID_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Standard_GUID self) -> NCollection_List< Standard_GUID >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Standard_GUID_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TDF.new_NCollection_List_Standard_GUID(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Standard_GUID self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_List_Standard_GUID_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Standard_GUID self, NCollection_List_Standard_GUID theOther) -> NCollection_List_Standard_GUID

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Standard_GUID_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Standard_GUID self, NCollection_List_Standard_GUID theOther) -> NCollection_List_Standard_GUID

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Standard_GUID_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Standard_GUID self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_List_Standard_GUID_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Standard_GUID_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Standard_GUID_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Standard_GUID self, Standard_GUID theItem) -> Standard_GUID
        Append(NCollection_List_Standard_GUID self, Standard_GUID theItem, NCollection_List< Standard_GUID >::Iterator & theIter)
        Append(NCollection_List_Standard_GUID self, NCollection_List_Standard_GUID theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Standard_GUID_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Standard_GUID self, Standard_GUID theItem) -> Standard_GUID
        Prepend(NCollection_List_Standard_GUID self, NCollection_List_Standard_GUID theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Standard_GUID_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Standard_GUID self)

        RemoveFirst item


        """
        return _TDF.NCollection_List_Standard_GUID_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Standard_GUID self, NCollection_List< Standard_GUID >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Standard_GUID_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Standard_GUID self, Standard_GUID theItem, NCollection_List< Standard_GUID >::Iterator & theIter) -> Standard_GUID
        InsertBefore(NCollection_List_Standard_GUID self, NCollection_List_Standard_GUID theOther, NCollection_List< Standard_GUID >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Standard_GUID_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Standard_GUID self, Standard_GUID theItem, NCollection_List< Standard_GUID >::Iterator & theIter) -> Standard_GUID
        InsertAfter(NCollection_List_Standard_GUID self, NCollection_List_Standard_GUID theOther, NCollection_List< Standard_GUID >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Standard_GUID_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Standard_GUID self)

        Reverse the list


        """
        return _TDF.NCollection_List_Standard_GUID_Reverse(self, *args)


    def __iter__(self):
        return _TDF.NCollection_List_Standard_GUID___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_List_Standard_GUID
NCollection_List_Standard_GUID_swigregister = _TDF.NCollection_List_Standard_GUID_swigregister
NCollection_List_Standard_GUID_swigregister(NCollection_List_Standard_GUID)

class NCollection_List_Standard_GUID_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_List_Standard_GUID_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_List_Standard_GUID_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_List_Standard_GUID_IteratorHelper___next__(self)
NCollection_List_Standard_GUID_IteratorHelper_swigregister = _TDF.NCollection_List_Standard_GUID_IteratorHelper_swigregister
NCollection_List_Standard_GUID_IteratorHelper_swigregister(NCollection_List_Standard_GUID_IteratorHelper)


try:
	TDF_IDList = NCollection_List_Standard_GUID
except NameError:
	pass # does not exist, probably ignored

class Handle_TDF_RelocationTable(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_RelocationTable self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_RelocationTable_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_RelocationTable self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_RelocationTable_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_RelocationTable self, TDF_RelocationTable thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_RelocationTable_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_RelocationTable self, Handle_TDF_RelocationTable theHandle) -> Handle_TDF_RelocationTable
        assign(Handle_TDF_RelocationTable self, TDF_RelocationTable thePtr) -> Handle_TDF_RelocationTable
        assign(Handle_TDF_RelocationTable self, Handle_TDF_RelocationTable theHandle) -> Handle_TDF_RelocationTable

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_RelocationTable_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_RelocationTable self) -> TDF_RelocationTable

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_RelocationTable_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_RelocationTable self) -> TDF_RelocationTable

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_RelocationTable___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_RelocationTable self) -> TDF_RelocationTable

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_RelocationTable___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_RelocationTable___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_RelocationTable___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_RelocationTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_RelocationTable_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_RelocationTable

    def SelfRelocate(self, *args):
        """
        SelfRelocate(Handle_TDF_RelocationTable self, Standard_Boolean const selfRelocate)
        SelfRelocate(Handle_TDF_RelocationTable self) -> Standard_Boolean

        Returns <mySelfRelocate>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_RelocationTable_SelfRelocate(self, *args)


    def AfterRelocate(self, *args):
        """
        AfterRelocate(Handle_TDF_RelocationTable self, Standard_Boolean const afterRelocate)
        AfterRelocate(Handle_TDF_RelocationTable self) -> Standard_Boolean

        Returns <myAfterRelocate>.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_RelocationTable_AfterRelocate(self, *args)


    def SetRelocation(self, *args):
        """
        SetRelocation(Handle_TDF_RelocationTable self, TDF_Label aSourceLabel, TDF_Label aTargetLabel)
        SetRelocation(Handle_TDF_RelocationTable self, Handle_TDF_Attribute aSourceAttribute, Handle_TDF_Attribute aTargetAttribute)

        Sets the relocation value of <aSourceAttribute> to
        <aTargetAttribute>.

        :type aSourceAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aTargetAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_RelocationTable_SetRelocation(self, *args)


    def HasRelocation(self, *args):
        """
        HasRelocation(Handle_TDF_RelocationTable self, TDF_Label aSourceLabel, TDF_Label aTargetLabel) -> Standard_Boolean
        HasRelocation(Handle_TDF_RelocationTable self, Handle_TDF_Attribute aSourceAttribute, Handle_TDF_Attribute aTargetAttribute) -> Standard_Boolean

        Finds the relocation value of <aSourceAttribute>
        and returns it into <aTargetAttribute>.

        (See above SelfRelocate method for more
        explanation about the method behavior)

        :type aSourceAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aTargetAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_RelocationTable_HasRelocation(self, *args)


    def SetTransientRelocation(self, *args):
        """
        SetTransientRelocation(Handle_TDF_RelocationTable self, Handle_Standard_Transient aSourceTransient, Handle_Standard_Transient aTargetTransient)

        Sets the relocation value of <aSourceTransient> to
        <aTargetTransient>.

        :type aSourceTransient: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aTargetTransient: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _TDF.Handle_TDF_RelocationTable_SetTransientRelocation(self, *args)


    def HasTransientRelocation(self, *args):
        """
        HasTransientRelocation(Handle_TDF_RelocationTable self, Handle_Standard_Transient aSourceTransient, Handle_Standard_Transient aTargetTransient) -> Standard_Boolean

        Finds the relocation value of <aSourceTransient>
        and returns it into <aTargetTransient>.

        (See above SelfRelocate method for more
        explanation about the method behavior)

        :type aSourceTransient: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aTargetTransient: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_RelocationTable_HasTransientRelocation(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_TDF_RelocationTable self)

        Clears the relocation dictionnary, but lets the
        self relocation flag to its current value.


        """
        return _TDF.Handle_TDF_RelocationTable_Clear(self, *args)


    def TargetLabelMap(self, *args):
        """
        TargetLabelMap(Handle_TDF_RelocationTable self, NCollection_Map_TDF_Label_TDF_LabelMapHasher aLabelMap)

        Fills <aLabelMap> with target relocation
        labels. <aLabelMap> is not cleared before use.

        :type aLabelMap: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TDF.Handle_TDF_RelocationTable_TargetLabelMap(self, *args)


    def TargetAttributeMap(self, *args):
        """
        TargetAttributeMap(Handle_TDF_RelocationTable self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher anAttributeMap)

        Fills <anAttributeMap> with target relocation
        attributes. <anAttributeMap> is not cleared before
        use.

        :type anAttributeMap: OCC.wrapper.TDF.TDF_AttributeMap

        """
        return _TDF.Handle_TDF_RelocationTable_TargetAttributeMap(self, *args)


    def LabelTable(self, *args):
        """
        LabelTable(Handle_TDF_RelocationTable self) -> NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher

        Returns <myLabelTable> to be used or updated.

        :rtype: OCC.wrapper.TDF.TDF_LabelDataMap

        """
        return _TDF.Handle_TDF_RelocationTable_LabelTable(self, *args)


    def AttributeTable(self, *args):
        """
        AttributeTable(Handle_TDF_RelocationTable self) -> NCollection_DataMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Returns <myAttributeTable> to be used or updated.

        :rtype: OCC.wrapper.TDF.TDF_AttributeDataMap

        """
        return _TDF.Handle_TDF_RelocationTable_AttributeTable(self, *args)


    def TransientTable(self, *args):
        """
        TransientTable(Handle_TDF_RelocationTable self) -> NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Returns <myTransientTable> to be used or updated.

        :rtype: OCC.wrapper.TColStd.TColStd_IndexedDataMapOfTransientTransient

        """
        return _TDF.Handle_TDF_RelocationTable_TransientTable(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_RelocationTable self, Standard_Boolean const dumpLabels, Standard_Boolean const dumpAttributes, Standard_Boolean const dumpTransients, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the relocation table.

        :type dumpLabels: bool
        :type dumpAttributes: bool
        :type dumpTransients: bool
        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_RelocationTable_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_RelocationTable self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_RelocationTable_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_RelocationTable_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_RelocationTable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDF_RelocationTable self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_RelocationTable_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_RelocationTable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_RelocationTable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_RelocationTable_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_RelocationTable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_RelocationTable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_RelocationTable_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_RelocationTable self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_RelocationTable_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_RelocationTable self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_RelocationTable_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_RelocationTable self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_RelocationTable_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_RelocationTable self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_RelocationTable_DecrementRefCounter(self, *args)

Handle_TDF_RelocationTable_swigregister = _TDF.Handle_TDF_RelocationTable_swigregister
Handle_TDF_RelocationTable_swigregister(Handle_TDF_RelocationTable)

def Handle_TDF_RelocationTable_DownCast(thing):
    return _TDF.Handle_TDF_RelocationTable_DownCast(thing)
Handle_TDF_RelocationTable_DownCast = _TDF.Handle_TDF_RelocationTable_DownCast

class NCollection_List_TDF_Label(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_TDF_Label self) -> NCollection_List< TDF_Label >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_TDF_Label_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_TDF_Label self) -> NCollection_List< TDF_Label >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_TDF_Label_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_TDF_Label self) -> NCollection_List< TDF_Label >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_TDF_Label_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_TDF_Label self) -> NCollection_List< TDF_Label >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_TDF_Label_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TDF.new_NCollection_List_TDF_Label(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_TDF_Label self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_List_TDF_Label_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_TDF_Label self, NCollection_List_TDF_Label theOther) -> NCollection_List_TDF_Label

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_TDF_Label_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_TDF_Label self, NCollection_List_TDF_Label theOther) -> NCollection_List_TDF_Label

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_TDF_Label_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_TDF_Label self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_List_TDF_Label_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_TDF_Label_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_TDF_Label_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_TDF_Label self, TDF_Label theItem) -> TDF_Label
        Append(NCollection_List_TDF_Label self, TDF_Label theItem, NCollection_List< TDF_Label >::Iterator & theIter)
        Append(NCollection_List_TDF_Label self, NCollection_List_TDF_Label theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_TDF_Label_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_TDF_Label self, TDF_Label theItem) -> TDF_Label
        Prepend(NCollection_List_TDF_Label self, NCollection_List_TDF_Label theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_TDF_Label_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_TDF_Label self)

        RemoveFirst item


        """
        return _TDF.NCollection_List_TDF_Label_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_TDF_Label self, NCollection_List< TDF_Label >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TDF.NCollection_List_TDF_Label_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_TDF_Label self, TDF_Label theItem, NCollection_List< TDF_Label >::Iterator & theIter) -> TDF_Label
        InsertBefore(NCollection_List_TDF_Label self, NCollection_List_TDF_Label theOther, NCollection_List< TDF_Label >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_TDF_Label_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_TDF_Label self, TDF_Label theItem, NCollection_List< TDF_Label >::Iterator & theIter) -> TDF_Label
        InsertAfter(NCollection_List_TDF_Label self, NCollection_List_TDF_Label theOther, NCollection_List< TDF_Label >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_TDF_Label_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_TDF_Label self)

        Reverse the list


        """
        return _TDF.NCollection_List_TDF_Label_Reverse(self, *args)


    def __iter__(self):
        return _TDF.NCollection_List_TDF_Label___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_List_TDF_Label
NCollection_List_TDF_Label_swigregister = _TDF.NCollection_List_TDF_Label_swigregister
NCollection_List_TDF_Label_swigregister(NCollection_List_TDF_Label)

class NCollection_List_TDF_Label_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_List_TDF_Label_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_List_TDF_Label_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_List_TDF_Label_IteratorHelper___next__(self)
NCollection_List_TDF_Label_IteratorHelper_swigregister = _TDF.NCollection_List_TDF_Label_IteratorHelper_swigregister
NCollection_List_TDF_Label_IteratorHelper_swigregister(NCollection_List_TDF_Label_IteratorHelper)


try:
	TDF_LabelList = NCollection_List_TDF_Label
except NameError:
	pass # does not exist, probably ignored

class Handle_TDF_DeltaOnModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DeltaOnModification self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DeltaOnModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DeltaOnModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DeltaOnModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DeltaOnModification self, TDF_DeltaOnModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DeltaOnModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DeltaOnModification self, Handle_TDF_DeltaOnModification theHandle) -> Handle_TDF_DeltaOnModification
        assign(Handle_TDF_DeltaOnModification self, TDF_DeltaOnModification thePtr) -> Handle_TDF_DeltaOnModification
        assign(Handle_TDF_DeltaOnModification self, Handle_TDF_DeltaOnModification theHandle) -> Handle_TDF_DeltaOnModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DeltaOnModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DeltaOnModification self) -> TDF_DeltaOnModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DeltaOnModification self) -> TDF_DeltaOnModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DeltaOnModification self) -> TDF_DeltaOnModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DeltaOnModification___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DeltaOnModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DeltaOnModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DeltaOnModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DeltaOnModification_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DeltaOnModification

    def Apply(self, *args):
        """
        Apply(Handle_TDF_DeltaOnModification self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_DeltaOnModification_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DeltaOnModification self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DeltaOnModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDF_DeltaOnModification self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DeltaOnModification_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_DeltaOnModification self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DeltaOnModification_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_DeltaOnModification self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_DeltaOnModification_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DeltaOnModification self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnModification_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DeltaOnModification self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnModification___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_DeltaOnModification self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DeltaOnModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DeltaOnModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DeltaOnModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DeltaOnModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DeltaOnModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DeltaOnModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DeltaOnModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DeltaOnModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DeltaOnModification self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DeltaOnModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DeltaOnModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnModification_DecrementRefCounter(self, *args)

Handle_TDF_DeltaOnModification_swigregister = _TDF.Handle_TDF_DeltaOnModification_swigregister
Handle_TDF_DeltaOnModification_swigregister(Handle_TDF_DeltaOnModification)

def Handle_TDF_DeltaOnModification_DownCast(thing):
    return _TDF.Handle_TDF_DeltaOnModification_DownCast(thing)
Handle_TDF_DeltaOnModification_DownCast = _TDF.Handle_TDF_DeltaOnModification_DownCast

class TDF_ChildIterator(object):
    """
    Iterates on the children of a label, at the first
    level only. It is possible to ask the iterator to
    explore all the sub label levels of the given one,
    with the option "allLevels".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_ChildIterator self) -> TDF_ChildIterator
        __init__(TDF_ChildIterator self, TDF_Label aLabel, Standard_Boolean const allLevels) -> TDF_ChildIterator

        Constructs the iterator object defined by
        the label aLabel.  Iterates on the children of the given label. If
        <allLevels> option is set to true, it explores not
        only the first, but all the sub label levels.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type allLevels: bool

        """
        this = _TDF.new_TDF_ChildIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TDF_ChildIterator self, TDF_Label aLabel, Standard_Boolean const allLevels)

        Initializes the iteration on the children of the
        given label.
        If <allLevels> option is set to true,
        it explores not only the first, but all the sub
        label levels.
        If allLevels is false, only the first level of
        child labels is explored.
        In the example below, the label is iterated
        using Initialize, More and Next and its
        child labels dumped using TDF_Tool::Entry.
        Example
        void DumpChildren(const
        TDF_Label& aLabel)
        {
        TDF_ChildIterator it;
        TCollection_AsciiString es;
        for
        (it.Initialize(aLabel,Standard_True);
        it.More(); it.Next()){
        TDF_Tool::Entry(it.Value(),es);
        cout << as.ToCString() << endl;
        }
        }

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type allLevels: bool

        """
        return _TDF.TDF_ChildIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(TDF_ChildIterator self) -> Standard_Boolean

        Returns true if a current label is found in the
        iteration process.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_ChildIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TDF_ChildIterator self)

        Move the  current  iteration  to the next Item.


        """
        return _TDF.TDF_ChildIterator_Next(self, *args)


    def NextBrother(self, *args):
        """
        NextBrother(TDF_ChildIterator self)

        Moves this iteration to the next brother
        label. A brother label is one with the same
        father as an initial label.
        Use this function when the non-empty
        constructor or Initialize has allLevels set to
        true. The result is that the iteration does not
        explore the children of the current label.
        This method is interesting only with
        "allLevels" behavior, because it avoids to explore
        the current label children.


        """
        return _TDF.TDF_ChildIterator_NextBrother(self, *args)


    def Value(self, *args):
        """
        Value(TDF_ChildIterator self) -> TDF_Label

        Returns the current label; or, if there is
        none, a null label.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_ChildIterator_Value(self, *args)

    __swig_destroy__ = _TDF.delete_TDF_ChildIterator
TDF_ChildIterator_swigregister = _TDF.TDF_ChildIterator_swigregister
TDF_ChildIterator_swigregister(TDF_ChildIterator)

class TDF_Data(Standard.Standard_Transient):
    """
    This class is used to manipulate a complete
    independant, self sufficient data structure and
    its services:

    Access to the root label;

    Opens, aborts, commits a transaction;

    Generation and use of Delta, depending on the time.
    This class uses a special allocator
    (see LabelNodeAllocator() method)
    for more efficient allocation of
    objects in memory.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_Data
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_Data(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_Data self) -> TDF_Data

        A new and empty Data structure.


        """
        this = _TDF.new_TDF_Data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Root(self, *args):
        """
        Root(TDF_Data self) -> TDF_Label

        Returns the root label of the Data structure.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Data_Root(self, *args)


    def Transaction(self, *args):
        """
        Transaction(TDF_Data self) -> Standard_Integer

        Returns the current transaction number.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Data_Transaction(self, *args)


    def Time(self, *args):
        """
        Time(TDF_Data self) -> Standard_Integer

        Returns the current tick. It is incremented each Commit.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Data_Time(self, *args)


    def IsApplicable(self, *args):
        """
        IsApplicable(TDF_Data self, Handle_TDF_Delta aDelta) -> Standard_Boolean

        Returns true if <aDelta> is applicable HERE and NOW.

        :type aDelta: OCC.wrapper.TDF.Handle_TDF_Delta
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Data_IsApplicable(self, *args)


    def Undo(self, *args):
        """
        Undo(TDF_Data self, Handle_TDF_Delta aDelta, Standard_Boolean const withDelta) -> Handle_TDF_Delta

        Apply <aDelta> to undo a set of attribute
        modifications.

        Optionnal <withDelta> set to True indiquates a
        Delta Set must be generated. (See above)

        :type aDelta: OCC.wrapper.TDF.Handle_TDF_Delta
        :type withDelta: bool
        :rtype: OCC.wrapper.TDF.Handle_TDF_Delta

        """
        return _TDF.TDF_Data_Undo(self, *args)


    def Destroy(self, *args):
        """Destroy(TDF_Data self)"""
        return _TDF.TDF_Data_Destroy(self, *args)


    def NotUndoMode(self, *args):
        """
        NotUndoMode(TDF_Data self) -> Standard_Boolean

        Returns the undo mode status.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Data_NotUndoMode(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_Data self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the Data on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Data_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(TDF_Data self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_Data___lshift__(self, *args)


    def AllowModification(self, *args):
        """
        AllowModification(TDF_Data self, Standard_Boolean const isAllowed)

        Sets modification mode.

        :type isAllowed: bool

        """
        return _TDF.TDF_Data_AllowModification(self, *args)


    def IsModificationAllowed(self, *args):
        """
        IsModificationAllowed(TDF_Data self) -> Standard_Boolean

        returns modification mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Data_IsModificationAllowed(self, *args)


    def LabelNodeAllocator(self, *args):
        """
        Returns TDF_HAllocator, which is an
        incremental allocator used by
        TDF_LabelNode.
        This allocator is used to
        manage TDF_LabelNode objects,
        but it can also be used for
        allocating memory to
        application-specific data (be
        careful because this
        allocator does not release
        the memory).
        The benefits of this
        allocation scheme are
        noticeable when dealing with
        large OCAF documents, due to:
        1.    Very quick allocation of
        objects (memory heap is not
        used, the algorithm that
        replaces it is very simple).
        2.    Very quick destruction of
        objects (memory is released not
        by destructors of TDF_LabelNode,
        but rather by the destructor of
        TDF_Data).
        3.  TDF_LabelNode objects do not
        fragmentize the memory; they are
        kept compactly in a number of
        arrays of 16K each.
        4.    Swapping is reduced on large
        data, because each document now
        occupies a smaller number of
        memory pages.

        :rtype: OCC.wrapper.TDF.TDF_HAllocator

        """
        res = _TDF.TDF_Data_LabelNodeAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_Data_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_Data_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_Data_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_Data
TDF_Data_swigregister = _TDF.TDF_Data_swigregister
TDF_Data_swigregister(TDF_Data)

def TDF_Data_get_type_name(*args):
    """
    TDF_Data_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_Data_get_type_name(*args)

def TDF_Data_get_type_descriptor(*args):
    """
    TDF_Data_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_Data_get_type_descriptor(*args)

class TDF_IDFilter(object):
    """This class offers filtering services around an ID list."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_IDFilter self, Standard_Boolean const ignoreMode) -> TDF_IDFilter

        Creates an ID/attribute filter based on an ID
        list. The default mode is "ignore all but...".

        This filter has 2 working mode: keep and ignore.

        Ignore/Exclusive mode: all IDs are ignored except
        these set to be kept, using Keep(). Of course, it
        is possible set an kept ID to be ignored using
        Ignore().

        Keep/Inclusive mode: all IDs are kept except these
        set to be ignored, using Ignore(). Of course, it
        is possible set an ignored ID to be kept using
        Keep().

        :type ignoreMode: bool

        """
        this = _TDF.new_TDF_IDFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IgnoreAll(self, *args):
        """
        IgnoreAll(TDF_IDFilter self, Standard_Boolean const ignore)
        IgnoreAll(TDF_IDFilter self) -> Standard_Boolean

        Returns true is the mode is set to "ignore all
        but...".

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_IDFilter_IgnoreAll(self, *args)


    def Keep(self, *args):
        """
        Keep(TDF_IDFilter self, Standard_GUID anID)
        Keep(TDF_IDFilter self, NCollection_List_Standard_GUID anIDList)

        Attributes with ID owned by <anIDList> are to be kept and
        the filter will answer true to the question
        IsKept(<anID>) with ID from <anIDList>.

        :type anIDList: OCC.wrapper.TDF.TDF_IDList

        """
        return _TDF.TDF_IDFilter_Keep(self, *args)


    def Ignore(self, *args):
        """
        Ignore(TDF_IDFilter self, Standard_GUID anID)
        Ignore(TDF_IDFilter self, NCollection_List_Standard_GUID anIDList)

        Attributes with ID owned by <anIDList> are to be
        ignored and the filter will answer false to the
        question IsKept(<anID>) with ID from <anIDList>.

        :type anIDList: OCC.wrapper.TDF.TDF_IDList

        """
        return _TDF.TDF_IDFilter_Ignore(self, *args)


    def IsKept(self, *args):
        """
        IsKept(TDF_IDFilter self, Standard_GUID anID) -> Standard_Boolean
        IsKept(TDF_IDFilter self, Handle_TDF_Attribute anAtt) -> Standard_Boolean

        Returns true if the attribute is to be kept.

        :type anAtt: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_IDFilter_IsKept(self, *args)


    def IsIgnored(self, *args):
        """
        IsIgnored(TDF_IDFilter self, Standard_GUID anID) -> Standard_Boolean
        IsIgnored(TDF_IDFilter self, Handle_TDF_Attribute anAtt) -> Standard_Boolean

        Returns true if the attribute is to be ignored.

        :type anAtt: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_IDFilter_IsIgnored(self, *args)


    def IDList(self, *args):
        """
        IDList(TDF_IDFilter self, NCollection_List_Standard_GUID anIDList)

        Copies the list of ID to be kept or ignored in
        <anIDList>. <anIDList> is cleared before use.

        :type anIDList: OCC.wrapper.TDF.TDF_IDList

        """
        return _TDF.TDF_IDFilter_IDList(self, *args)


    def Copy(self, *args):
        """
        Copy(TDF_IDFilter self, TDF_IDFilter fromFilter)

        Copies into <me> the contents of
        <fromFilter>. <me> is cleared before copy.

        :type fromFilter: OCC.wrapper.TDF.TDF_IDFilter

        """
        return _TDF.TDF_IDFilter_Copy(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_IDFilter self, Standard_OStream & anOS)

        Writes the contents of <me> to <OS>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_IDFilter_Dump(self, *args)

    __swig_destroy__ = _TDF.delete_TDF_IDFilter
TDF_IDFilter_swigregister = _TDF.TDF_IDFilter_swigregister
TDF_IDFilter_swigregister(TDF_IDFilter)

class Handle_TDF_HAttributeArray1(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_HAttributeArray1 self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_HAttributeArray1_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_HAttributeArray1 self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_HAttributeArray1_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_HAttributeArray1 self, TDF_HAttributeArray1 thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_HAttributeArray1_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_HAttributeArray1 self, Handle_TDF_HAttributeArray1 theHandle) -> Handle_TDF_HAttributeArray1
        assign(Handle_TDF_HAttributeArray1 self, TDF_HAttributeArray1 thePtr) -> Handle_TDF_HAttributeArray1
        assign(Handle_TDF_HAttributeArray1 self, Handle_TDF_HAttributeArray1 theHandle) -> Handle_TDF_HAttributeArray1

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_HAttributeArray1_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_HAttributeArray1 self) -> TDF_HAttributeArray1

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_HAttributeArray1_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_HAttributeArray1 self) -> TDF_HAttributeArray1

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_HAttributeArray1___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_HAttributeArray1 self) -> TDF_HAttributeArray1

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_HAttributeArray1___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_HAttributeArray1___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_HAttributeArray1___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_HAttributeArray1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_HAttributeArray1_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_HAttributeArray1

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_AttributeArray1

        """
        res = _TDF.Handle_TDF_HAttributeArray1_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TDF_HAttributeArray1 self) -> NCollection_Array1_Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.TDF_AttributeArray1

        """
        return _TDF.Handle_TDF_HAttributeArray1_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_HAttributeArray1 self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_HAttributeArray1_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_HAttributeArray1_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_HAttributeArray1_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDF_HAttributeArray1 self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_HAttributeArray1_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_HAttributeArray1 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_HAttributeArray1 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_HAttributeArray1_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_HAttributeArray1 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_HAttributeArray1 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_HAttributeArray1_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_HAttributeArray1 self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_HAttributeArray1_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_HAttributeArray1 self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_HAttributeArray1_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_HAttributeArray1 self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_HAttributeArray1_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_HAttributeArray1 self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_HAttributeArray1_DecrementRefCounter(self, *args)

Handle_TDF_HAttributeArray1_swigregister = _TDF.Handle_TDF_HAttributeArray1_swigregister
Handle_TDF_HAttributeArray1_swigregister(Handle_TDF_HAttributeArray1)

def Handle_TDF_HAttributeArray1_DownCast(thing):
    return _TDF.Handle_TDF_HAttributeArray1_DownCast(thing)
Handle_TDF_HAttributeArray1_DownCast = _TDF.Handle_TDF_HAttributeArray1_DownCast

class Handle_TDF_Attribute(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_Attribute self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_Attribute_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_Attribute self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_Attribute_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_Attribute self, TDF_Attribute thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_Attribute_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_Attribute self, Handle_TDF_Attribute theHandle) -> Handle_TDF_Attribute
        assign(Handle_TDF_Attribute self, TDF_Attribute thePtr) -> Handle_TDF_Attribute
        assign(Handle_TDF_Attribute self, Handle_TDF_Attribute theHandle) -> Handle_TDF_Attribute

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_Attribute_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_Attribute self) -> TDF_Attribute

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_Attribute_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_Attribute self) -> TDF_Attribute

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_Attribute___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_Attribute self) -> TDF_Attribute

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_Attribute___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_Attribute___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_Attribute___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_Attribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_Attribute_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_Attribute

    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.Handle_TDF_Attribute_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDF_Attribute self, Standard_GUID arg2)
        SetID(Handle_TDF_Attribute self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDF.Handle_TDF_Attribute_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDF_Attribute self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_Attribute_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDF_Attribute self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Attribute_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDF_Attribute self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Attribute_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDF_Attribute self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDF_Attribute self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDF_Attribute self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Attribute_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDF_Attribute self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDF_Attribute self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDF.Handle_TDF_Attribute_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDF_Attribute self)

        Something to do after adding an Attribute to a label.


        """
        return _TDF.Handle_TDF_Attribute_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDF_Attribute self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDF.Handle_TDF_Attribute_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDF_Attribute self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDF.Handle_TDF_Attribute_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDF_Attribute self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDF.Handle_TDF_Attribute_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDF_Attribute self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDF_Attribute self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDF_Attribute self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDF_Attribute self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDF.Handle_TDF_Attribute_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDF_Attribute self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDF.Handle_TDF_Attribute_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDF_Attribute self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDF_Attribute self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Attribute_BackupCopy(self, *args)


    def Restore(self, *args):
        """
        Restore(Handle_TDF_Attribute self, Handle_TDF_Attribute anAttribute)

        Restores the backuped contents from <anAttribute>
        into this one. It is used when aborting a
        transaction.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Attribute_Restore(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDF_Attribute self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDF.Handle_TDF_Attribute_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDF_Attribute self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDF.Handle_TDF_Attribute_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDF_Attribute self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDF.Handle_TDF_Attribute_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDF_Attribute self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDF.Handle_TDF_Attribute_DeltaOnRemoval(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDF_Attribute self) -> Handle_TDF_Attribute

        Returns an new empty attribute from the good end
        type. It is used by the copy algorithm.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Attribute_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDF_Attribute self, Handle_TDF_Attribute intoAttribute, Handle_TDF_RelocationTable aRelocationTable)

        This method is different from the "Copy" one,
        because it is used when copying an attribute from
        a source structure into a target structure. This
        method may paste the contents of <me> into
        <intoAttribute>.

        The given pasted attribute can be full or empty of
        its contents. But don't make a NEW! Just set the
        contents!

        It is possible to use <aRelocationTable> to
        get/set the relocation value of a source
        attribute.

        :type intoAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDF.Handle_TDF_Attribute_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TDF_Attribute self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDF.Handle_TDF_Attribute_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_Attribute self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_Attribute_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_Attribute self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_Attribute___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDF_Attribute self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDF.Handle_TDF_Attribute_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDF_Attribute self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDF.Handle_TDF_Attribute_Forget(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_Attribute self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_Attribute_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Attribute_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Attribute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDF_Attribute self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_Attribute_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_Attribute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_Attribute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_Attribute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_Attribute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Attribute_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_Attribute self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_Attribute_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_Attribute self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Attribute_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_Attribute self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_Attribute_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_Attribute self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Attribute_DecrementRefCounter(self, *args)

Handle_TDF_Attribute_swigregister = _TDF.Handle_TDF_Attribute_swigregister
Handle_TDF_Attribute_swigregister(Handle_TDF_Attribute)

def Handle_TDF_Attribute_DownCast(thing):
    return _TDF.Handle_TDF_Attribute_DownCast(thing)
Handle_TDF_Attribute_DownCast = _TDF.Handle_TDF_Attribute_DownCast

class TDF_ClosureTool(object):
    """
    This class provides services to build the closure
    of an information set.
    This class gives services around the transitive
    enclosure of a set of information, starting from a
    list of label.
    You can set closure options by using IDFilter
    (to select or exclude specific attribute IDs) and
    CopyOption objects and by giving to Closure
    method.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Closure(*args):
        """
        Closure(Handle_TDF_DataSet aDataSet)
        Closure(Handle_TDF_DataSet aDataSet, TDF_IDFilter aFilter, TDF_ClosureMode aMode)
        Closure(TDF_Label aLabel, NCollection_Map_TDF_Label_TDF_LabelMapHasher aLabMap, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher anAttMap, TDF_IDFilter aFilter, TDF_ClosureMode aMode)

        Builds the transitive closure of <aLabel>.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aLabMap: OCC.wrapper.TDF.TDF_LabelMap
        :type anAttMap: OCC.wrapper.TDF.TDF_AttributeMap
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMode: OCC.wrapper.TDF.TDF_ClosureMode

        """
        return _TDF.TDF_ClosureTool_Closure(*args)

    Closure = staticmethod(Closure)

    def __init__(self):
        """
        This class provides services to build the closure
        of an information set.
        This class gives services around the transitive
        enclosure of a set of information, starting from a
        list of label.
        You can set closure options by using IDFilter
        (to select or exclude specific attribute IDs) and
        CopyOption objects and by giving to Closure
        method.
        """
        this = _TDF.new_TDF_ClosureTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_TDF_ClosureTool
TDF_ClosureTool_swigregister = _TDF.TDF_ClosureTool_swigregister
TDF_ClosureTool_swigregister(TDF_ClosureTool)

def TDF_ClosureTool_Closure(*args):
    """
    Closure(Handle_TDF_DataSet aDataSet)
    Closure(Handle_TDF_DataSet aDataSet, TDF_IDFilter aFilter, TDF_ClosureMode aMode)
    TDF_ClosureTool_Closure(TDF_Label aLabel, NCollection_Map_TDF_Label_TDF_LabelMapHasher aLabMap, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher anAttMap, TDF_IDFilter aFilter, TDF_ClosureMode aMode)

    Builds the transitive closure of <aLabel>.

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type aLabMap: OCC.wrapper.TDF.TDF_LabelMap
    :type anAttMap: OCC.wrapper.TDF.TDF_AttributeMap
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
    :type aMode: OCC.wrapper.TDF.TDF_ClosureMode

    """
    return _TDF.TDF_ClosureTool_Closure(*args)

class NCollection_Sequence_TDF_Label(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TDF_Label self) -> NCollection_Sequence< TDF_Label >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TDF.NCollection_Sequence_TDF_Label_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TDF_Label self) -> NCollection_Sequence< TDF_Label >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TDF.NCollection_Sequence_TDF_Label_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TDF_Label self) -> NCollection_Sequence< TDF_Label >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Sequence_TDF_Label_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TDF_Label self) -> NCollection_Sequence< TDF_Label >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Sequence_TDF_Label_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TDF.new_NCollection_Sequence_TDF_Label(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TDF_Label self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_TDF_Label_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TDF_Label self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_TDF_Label_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TDF_Label self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_TDF_Label_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TDF_Label self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Sequence_TDF_Label_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TDF_Label self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Sequence_TDF_Label_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TDF_Label self)

        Reverse sequence


        """
        return _TDF.NCollection_Sequence_TDF_Label_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TDF_Label self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TDF.NCollection_Sequence_TDF_Label_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_Sequence_TDF_Label_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TDF_Label self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_Sequence_TDF_Label_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TDF_Label self, NCollection_Sequence_TDF_Label theOther) -> NCollection_Sequence_TDF_Label

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_TDF_Label_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TDF_Label self, NCollection_Sequence_TDF_Label theOther) -> NCollection_Sequence_TDF_Label

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_TDF_Label_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TDF_Label self, NCollection_Sequence< TDF_Label >::Iterator & thePosition)
        Remove(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TDF_Label self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TDF.NCollection_Sequence_TDF_Label_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TDF_Label self, TDF_Label theItem)
        Append(NCollection_Sequence_TDF_Label self, NCollection_Sequence_TDF_Label theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_TDF_Label_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TDF_Label self, TDF_Label theItem)
        Prepend(NCollection_Sequence_TDF_Label self, NCollection_Sequence_TDF_Label theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_TDF_Label_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex, TDF_Label theItem)
        InsertBefore(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex, NCollection_Sequence_TDF_Label theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_TDF_Label_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TDF_Label self, NCollection_Sequence< TDF_Label >::Iterator & thePosition, TDF_Label theItem)
        InsertAfter(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex, NCollection_Sequence_TDF_Label theSeq)
        InsertAfter(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex, TDF_Label theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDF.NCollection_Sequence_TDF_Label_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex, NCollection_Sequence_TDF_Label theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TDF.NCollection_Sequence_TDF_Label_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_TDF_Label_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TDF_Label self) -> TDF_Label

        First item access

        :rtype: TheItemType &

        """
        return _TDF.NCollection_Sequence_TDF_Label_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_TDF_Label_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TDF_Label self) -> TDF_Label

        Last item access

        :rtype: TheItemType &

        """
        return _TDF.NCollection_Sequence_TDF_Label_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_TDF_Label_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex) -> TDF_Label

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TDF.NCollection_Sequence_TDF_Label_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Sequence_TDF_Label___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TDF_Label self, Standard_Integer const theIndex, TDF_Label theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDF.NCollection_Sequence_TDF_Label_SetValue(self, *args)


    def __iter__(self):
        return _TDF.NCollection_Sequence_TDF_Label___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_Sequence_TDF_Label
NCollection_Sequence_TDF_Label_swigregister = _TDF.NCollection_Sequence_TDF_Label_swigregister
NCollection_Sequence_TDF_Label_swigregister(NCollection_Sequence_TDF_Label)

def NCollection_Sequence_TDF_Label_delNode(*args):
    """
    NCollection_Sequence_TDF_Label_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TDF.NCollection_Sequence_TDF_Label_delNode(*args)

class NCollection_Sequence_TDF_Label_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_Sequence_TDF_Label_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_Sequence_TDF_Label_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_Sequence_TDF_Label_IteratorHelper___next__(self)
NCollection_Sequence_TDF_Label_IteratorHelper_swigregister = _TDF.NCollection_Sequence_TDF_Label_IteratorHelper_swigregister
NCollection_Sequence_TDF_Label_IteratorHelper_swigregister(NCollection_Sequence_TDF_Label_IteratorHelper)


try:
	TDF_LabelSequence = NCollection_Sequence_TDF_Label
except NameError:
	pass # does not exist, probably ignored

class Handle_TDF_Reference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_Reference self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_Reference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_Reference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_Reference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_Reference self, TDF_Reference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_Reference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_Reference self, Handle_TDF_Reference theHandle) -> Handle_TDF_Reference
        assign(Handle_TDF_Reference self, TDF_Reference thePtr) -> Handle_TDF_Reference
        assign(Handle_TDF_Reference self, Handle_TDF_Reference theHandle) -> Handle_TDF_Reference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_Reference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_Reference self) -> TDF_Reference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_Reference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_Reference self) -> TDF_Reference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_Reference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_Reference self) -> TDF_Reference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_Reference___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_Reference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_Reference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_Reference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_Reference_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_Reference

    def GetID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.Handle_TDF_Reference_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDF_Reference self, TDF_Label I, TDF_Label Origin) -> Handle_TDF_Reference
        Set(Handle_TDF_Reference self, TDF_Label Origin)

        :type Origin: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_Reference_Set(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TDF_Reference self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_Reference_Get(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.Handle_TDF_Reference_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDF_Reference self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Reference_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDF_Reference self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Reference_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDF_Reference self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDF.Handle_TDF_Reference_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TDF_Reference self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDF.Handle_TDF_Reference_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_Reference self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_Reference_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_Reference self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_Reference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Reference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Reference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDF_Reference self, Standard_GUID arg2)
        SetID(Handle_TDF_Reference self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDF.Handle_TDF_Reference_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDF_Reference self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_Reference_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDF_Reference self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Reference_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDF_Reference self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Reference_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDF_Reference self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDF_Reference self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDF_Reference self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDF_Reference self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDF_Reference self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDF_Reference self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Reference_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDF_Reference self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDF_Reference self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDF.Handle_TDF_Reference_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDF_Reference self)

        Something to do after adding an Attribute to a label.


        """
        return _TDF.Handle_TDF_Reference_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDF_Reference self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDF.Handle_TDF_Reference_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDF_Reference self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDF.Handle_TDF_Reference_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDF_Reference self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDF.Handle_TDF_Reference_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDF_Reference self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDF_Reference self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDF_Reference self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDF_Reference self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDF.Handle_TDF_Reference_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDF_Reference self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDF.Handle_TDF_Reference_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDF_Reference self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDF_Reference self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_Reference_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDF_Reference self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDF.Handle_TDF_Reference_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDF_Reference self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDF.Handle_TDF_Reference_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDF_Reference self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDF.Handle_TDF_Reference_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDF_Reference self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDF.Handle_TDF_Reference_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_Reference self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_Reference___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDF_Reference self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDF.Handle_TDF_Reference_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDF_Reference self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDF.Handle_TDF_Reference_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_Reference self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_Reference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_Reference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_Reference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_Reference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_Reference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Reference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_Reference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_Reference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_Reference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Reference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_Reference self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_Reference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_Reference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Reference_DecrementRefCounter(self, *args)

Handle_TDF_Reference_swigregister = _TDF.Handle_TDF_Reference_swigregister
Handle_TDF_Reference_swigregister(Handle_TDF_Reference)

def Handle_TDF_Reference_DownCast(thing):
    return _TDF.Handle_TDF_Reference_DownCast(thing)
Handle_TDF_Reference_DownCast = _TDF.Handle_TDF_Reference_DownCast

class Handle_TDF_DeltaOnForget(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DeltaOnForget self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DeltaOnForget_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DeltaOnForget self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DeltaOnForget_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DeltaOnForget self, TDF_DeltaOnForget thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DeltaOnForget_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DeltaOnForget self, Handle_TDF_DeltaOnForget theHandle) -> Handle_TDF_DeltaOnForget
        assign(Handle_TDF_DeltaOnForget self, TDF_DeltaOnForget thePtr) -> Handle_TDF_DeltaOnForget
        assign(Handle_TDF_DeltaOnForget self, Handle_TDF_DeltaOnForget theHandle) -> Handle_TDF_DeltaOnForget

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DeltaOnForget_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DeltaOnForget self) -> TDF_DeltaOnForget

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnForget_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DeltaOnForget self) -> TDF_DeltaOnForget

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnForget___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DeltaOnForget self) -> TDF_DeltaOnForget

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DeltaOnForget___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DeltaOnForget___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DeltaOnForget___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DeltaOnForget(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DeltaOnForget_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DeltaOnForget

    def Apply(self, *args):
        """
        Apply(Handle_TDF_DeltaOnForget self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_DeltaOnForget_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DeltaOnForget self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DeltaOnForget_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnForget_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnForget_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDF_DeltaOnForget self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DeltaOnForget_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_DeltaOnForget self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DeltaOnForget_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_DeltaOnForget self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_DeltaOnForget_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DeltaOnForget self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnForget_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DeltaOnForget self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnForget___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_DeltaOnForget self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DeltaOnForget_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DeltaOnForget self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DeltaOnForget self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnForget_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DeltaOnForget self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DeltaOnForget self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnForget_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DeltaOnForget self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DeltaOnForget_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DeltaOnForget self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnForget_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DeltaOnForget self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DeltaOnForget_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DeltaOnForget self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnForget_DecrementRefCounter(self, *args)

Handle_TDF_DeltaOnForget_swigregister = _TDF.Handle_TDF_DeltaOnForget_swigregister
Handle_TDF_DeltaOnForget_swigregister(Handle_TDF_DeltaOnForget)

def Handle_TDF_DeltaOnForget_DownCast(thing):
    return _TDF.Handle_TDF_DeltaOnForget_DownCast(thing)
Handle_TDF_DeltaOnForget_DownCast = _TDF.Handle_TDF_DeltaOnForget_DownCast

class Handle_TDF_Delta(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_Delta self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_Delta_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_Delta self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_Delta_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_Delta self, TDF_Delta thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_Delta_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_Delta self, Handle_TDF_Delta theHandle) -> Handle_TDF_Delta
        assign(Handle_TDF_Delta self, TDF_Delta thePtr) -> Handle_TDF_Delta
        assign(Handle_TDF_Delta self, Handle_TDF_Delta theHandle) -> Handle_TDF_Delta

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_Delta_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_Delta self) -> TDF_Delta

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_Delta_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_Delta self) -> TDF_Delta

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_Delta___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_Delta self) -> TDF_Delta

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_Delta___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_Delta___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_Delta___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_Delta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_Delta_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_Delta

    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDF_Delta self) -> Standard_Boolean

        Returns true if there is nothing to undo.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Delta_IsEmpty(self, *args)


    def IsApplicable(self, *args):
        """
        IsApplicable(Handle_TDF_Delta self, Standard_Integer const aCurrentTime) -> Standard_Boolean

        Returns true if the Undo action of <me> is
        applicable at <aCurrentTime>.

        :type aCurrentTime: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Delta_IsApplicable(self, *args)


    def BeginTime(self, *args):
        """
        BeginTime(Handle_TDF_Delta self) -> Standard_Integer

        Returns the field <myBeginTime>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Delta_BeginTime(self, *args)


    def EndTime(self, *args):
        """
        EndTime(Handle_TDF_Delta self) -> Standard_Integer

        Returns the field <myEndTime>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Delta_EndTime(self, *args)


    def Labels(self, *args):
        """
        Labels(Handle_TDF_Delta self, NCollection_List_TDF_Label aLabelList)

        Adds in <aLabelList> the labels of the attribute deltas.
        Caution: <aLabelList> is not cleared before use.

        :type aLabelList: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TDF.Handle_TDF_Delta_Labels(self, *args)


    def AttributeDeltas(self, *args):
        """
        Returns the field <myAttDeltaList>.

        :rtype: OCC.wrapper.TDF.TDF_AttributeDeltaList

        """
        res = _TDF.Handle_TDF_Delta_AttributeDeltas(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_TDF_Delta self) -> TCollection_ExtendedString

        Returns a name associated with this delta.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDF.Handle_TDF_Delta_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_TDF_Delta self, TCollection_ExtendedString theName)

        Associates a name <theName> with this delta

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDF.Handle_TDF_Delta_SetName(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_Delta self, Standard_OStream & OS)

        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_Delta_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_Delta self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_Delta_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Delta_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Delta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDF_Delta self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_Delta_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_Delta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_Delta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Delta_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_Delta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_Delta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Delta_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_Delta self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_Delta_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_Delta self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Delta_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_Delta self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_Delta_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_Delta self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Delta_DecrementRefCounter(self, *args)

Handle_TDF_Delta_swigregister = _TDF.Handle_TDF_Delta_swigregister
Handle_TDF_Delta_swigregister(Handle_TDF_Delta)

def Handle_TDF_Delta_DownCast(thing):
    return _TDF.Handle_TDF_Delta_DownCast(thing)
Handle_TDF_Delta_DownCast = _TDF.Handle_TDF_Delta_DownCast

class NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self) -> NCollection_IndexedMap< TDF_Label,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self) -> NCollection_IndexedMap< TDF_Label,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TDF.new_NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher theOther) -> NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher theOther) -> NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, Standard_Integer const theIndex, TDF_Label theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self)

        RemoveLast


        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_Size(self, *args)


    def __iter__(self):
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher
NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_swigregister = _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_swigregister
NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_swigregister(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher)

class NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister = _TDF.NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher_IteratorHelper)


try:
	TDF_LabelIndexedMap = NCollection_IndexedMap_TDF_Label_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TDF_HAllocator = NCollection.Handle_NCollection_BaseAllocator
except AttributeError:
	pass # does not exist, probably ignored

class TDF_Transaction(object):
    """
    This class offers services to open, commit or
    abort a transaction in a more secure way than
    using Data from TDF. If you forget to close a
    transaction, it will be automaticaly aborted at
    the destruction of this object, at the closure of
    its scope.

    In case of catching errors, the effect will be the
    same: aborting transactions until the good current
    one.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_Transaction self, TCollection_AsciiString aName) -> TDF_Transaction
        __init__(TDF_Transaction self, Handle_TDF_Data aDF, TCollection_AsciiString aName) -> TDF_Transaction

        Creates a transaction context on <aDF>, ready to
        be opened.

        :type aDF: OCC.wrapper.TDF.Handle_TDF_Data
        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _TDF.new_TDF_Transaction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TDF_Transaction self, Handle_TDF_Data aDF)

        Aborts all the transactions on <myDF> and sets
        <aDF> to build a transaction context on <aDF>,
        ready to be opened.

        :type aDF: OCC.wrapper.TDF.Handle_TDF_Data

        """
        return _TDF.TDF_Transaction_Initialize(self, *args)


    def Open(self, *args):
        """
        Open(TDF_Transaction self) -> Standard_Integer

        If not yet done, opens a new transaction on
        <myDF>. Returns the index of the just opened
        transaction.

        It raises DomainError if the transaction is
        already open, and NullObject if there is no
        current Data framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Transaction_Open(self, *args)


    def Commit(self, *args):
        """
        Commit(TDF_Transaction self, Standard_Boolean const withDelta) -> Handle_TDF_Delta

        Commits the transactions until AND including the
        current opened one.

        :type withDelta: bool
        :rtype: OCC.wrapper.TDF.Handle_TDF_Delta

        """
        return _TDF.TDF_Transaction_Commit(self, *args)


    def Abort(self, *args):
        """
        Abort(TDF_Transaction self)

        Aborts the transactions until AND including the
        current opened one.


        """
        return _TDF.TDF_Transaction_Abort(self, *args)


    def Data(self, *args):
        """
        Data(TDF_Transaction self) -> Handle_TDF_Data

        Returns the Data from TDF.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Data

        """
        return _TDF.TDF_Transaction_Data(self, *args)


    def Transaction(self, *args):
        """
        Transaction(TDF_Transaction self) -> Standard_Integer

        Returns the number of the transaction opened by <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Transaction_Transaction(self, *args)


    def Name(self, *args):
        """
        Returns the transaction name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDF.TDF_Transaction_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsOpen(self, *args):
        """
        IsOpen(TDF_Transaction self) -> Standard_Boolean

        Returns true if the transaction is open.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Transaction_IsOpen(self, *args)

    __swig_destroy__ = _TDF.delete_TDF_Transaction
TDF_Transaction_swigregister = _TDF.TDF_Transaction_swigregister
TDF_Transaction_swigregister(TDF_Transaction)

class TDF_AttributeIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_AttributeIterator self) -> TDF_AttributeIterator
        __init__(TDF_AttributeIterator self, TDF_Label aLabel, Standard_Boolean const withoutForgotten) -> TDF_AttributeIterator
        __init__(TDF_AttributeIterator self, TDF_LabelNode aLabelNode, Standard_Boolean const withoutForgotten) -> TDF_AttributeIterator

        :type aLabelNode: OCC.wrapper.TDF.TDF_LabelNodePtr
        :type withoutForgotten: bool

        """
        this = _TDF.new_TDF_AttributeIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TDF_AttributeIterator self, TDF_Label aLabel, Standard_Boolean const withoutForgotten)

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type withoutForgotten: bool

        """
        return _TDF.TDF_AttributeIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(TDF_AttributeIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_AttributeIterator_More(self, *args)


    def Next(self, *args):
        """Next(TDF_AttributeIterator self)"""
        return _TDF.TDF_AttributeIterator_Next(self, *args)


    def Value(self, *args):
        """
        Value(TDF_AttributeIterator self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_AttributeIterator_Value(self, *args)

    __swig_destroy__ = _TDF.delete_TDF_AttributeIterator
TDF_AttributeIterator_swigregister = _TDF.TDF_AttributeIterator_swigregister
TDF_AttributeIterator_swigregister(TDF_AttributeIterator)

class Handle_TDF_DeltaOnAddition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DeltaOnAddition self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DeltaOnAddition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DeltaOnAddition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DeltaOnAddition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DeltaOnAddition self, TDF_DeltaOnAddition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DeltaOnAddition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DeltaOnAddition self, Handle_TDF_DeltaOnAddition theHandle) -> Handle_TDF_DeltaOnAddition
        assign(Handle_TDF_DeltaOnAddition self, TDF_DeltaOnAddition thePtr) -> Handle_TDF_DeltaOnAddition
        assign(Handle_TDF_DeltaOnAddition self, Handle_TDF_DeltaOnAddition theHandle) -> Handle_TDF_DeltaOnAddition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DeltaOnAddition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DeltaOnAddition self) -> TDF_DeltaOnAddition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnAddition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DeltaOnAddition self) -> TDF_DeltaOnAddition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnAddition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DeltaOnAddition self) -> TDF_DeltaOnAddition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DeltaOnAddition___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DeltaOnAddition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DeltaOnAddition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DeltaOnAddition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DeltaOnAddition_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DeltaOnAddition

    def Apply(self, *args):
        """
        Apply(Handle_TDF_DeltaOnAddition self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_DeltaOnAddition_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DeltaOnAddition self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DeltaOnAddition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnAddition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnAddition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDF_DeltaOnAddition self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DeltaOnAddition_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_DeltaOnAddition self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DeltaOnAddition_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_DeltaOnAddition self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_DeltaOnAddition_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DeltaOnAddition self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnAddition_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DeltaOnAddition self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnAddition___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_DeltaOnAddition self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DeltaOnAddition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DeltaOnAddition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DeltaOnAddition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnAddition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DeltaOnAddition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DeltaOnAddition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnAddition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DeltaOnAddition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DeltaOnAddition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DeltaOnAddition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnAddition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DeltaOnAddition self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DeltaOnAddition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DeltaOnAddition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnAddition_DecrementRefCounter(self, *args)

Handle_TDF_DeltaOnAddition_swigregister = _TDF.Handle_TDF_DeltaOnAddition_swigregister
Handle_TDF_DeltaOnAddition_swigregister(Handle_TDF_DeltaOnAddition)

def Handle_TDF_DeltaOnAddition_DownCast(thing):
    return _TDF.Handle_TDF_DeltaOnAddition_DownCast(thing)
Handle_TDF_DeltaOnAddition_DownCast = _TDF.Handle_TDF_DeltaOnAddition_DownCast

class NCollection_Map_Standard_GUID_Standard_GUID(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Standard_GUID_Standard_GUID self) -> NCollection_Map< Standard_GUID,Standard_GUID >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Standard_GUID_Standard_GUID self) -> NCollection_Map< Standard_GUID,Standard_GUID >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TDF.new_NCollection_Map_Standard_GUID_Standard_GUID(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> NCollection_Map_Standard_GUID_Standard_GUID

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> NCollection_Map_Standard_GUID_Standard_GUID

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Standard_GUID_Standard_GUID self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Standard_GUID_Standard_GUID self, Standard_GUID K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Standard_GUID_Standard_GUID self, Standard_GUID K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Standard_GUID_Standard_GUID self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Standard_GUID_Standard_GUID self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Standard_GUID_Standard_GUID self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Standard_GUID_Standard_GUID self, Standard_GUID K) -> Standard_Boolean
        Contains(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theLeft, NCollection_Map_Standard_GUID_Standard_GUID theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theLeft, NCollection_Map_Standard_GUID_Standard_GUID theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theLeft, NCollection_Map_Standard_GUID_Standard_GUID theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theLeft, NCollection_Map_Standard_GUID_Standard_GUID theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Standard_GUID_Standard_GUID self, NCollection_Map_Standard_GUID_Standard_GUID theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_Differ(self, *args)


    def __iter__(self):
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_Map_Standard_GUID_Standard_GUID
NCollection_Map_Standard_GUID_Standard_GUID_swigregister = _TDF.NCollection_Map_Standard_GUID_Standard_GUID_swigregister
NCollection_Map_Standard_GUID_Standard_GUID_swigregister(NCollection_Map_Standard_GUID_Standard_GUID)

class NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper___next__(self)
NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper_swigregister = _TDF.NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper_swigregister
NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper_swigregister(NCollection_Map_Standard_GUID_Standard_GUID_IteratorHelper)


try:
	TDF_IDMap = NCollection_Map_Standard_GUID_Standard_GUID
except NameError:
	pass # does not exist, probably ignored

class TDF_DefaultDeltaOnRemoval(TDF_DeltaOnRemoval):
    """
    This class provides a default implementation of a
    TDF_DeltaOnRemoval.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DefaultDeltaOnRemoval
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DefaultDeltaOnRemoval(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_DefaultDeltaOnRemoval self, Handle_TDF_Attribute anAttribute) -> TDF_DefaultDeltaOnRemoval

        Creates a TDF_DefaultDeltaOnRemoval.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        this = _TDF.new_TDF_DefaultDeltaOnRemoval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDF_DefaultDeltaOnRemoval self)

        Applies the delta to the attribute.


        """
        return _TDF.TDF_DefaultDeltaOnRemoval_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DefaultDeltaOnRemoval_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DefaultDeltaOnRemoval_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DefaultDeltaOnRemoval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DefaultDeltaOnRemoval
TDF_DefaultDeltaOnRemoval_swigregister = _TDF.TDF_DefaultDeltaOnRemoval_swigregister
TDF_DefaultDeltaOnRemoval_swigregister(TDF_DefaultDeltaOnRemoval)

def TDF_DefaultDeltaOnRemoval_get_type_name(*args):
    """
    TDF_DefaultDeltaOnRemoval_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DefaultDeltaOnRemoval_get_type_name(*args)

def TDF_DefaultDeltaOnRemoval_get_type_descriptor(*args):
    """
    TDF_DefaultDeltaOnRemoval_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DefaultDeltaOnRemoval_get_type_descriptor(*args)

class Handle_TDF_DefaultDeltaOnRemoval(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DefaultDeltaOnRemoval self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DefaultDeltaOnRemoval self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DefaultDeltaOnRemoval self, TDF_DefaultDeltaOnRemoval thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DefaultDeltaOnRemoval self, Handle_TDF_DefaultDeltaOnRemoval theHandle) -> Handle_TDF_DefaultDeltaOnRemoval
        assign(Handle_TDF_DefaultDeltaOnRemoval self, TDF_DefaultDeltaOnRemoval thePtr) -> Handle_TDF_DefaultDeltaOnRemoval
        assign(Handle_TDF_DefaultDeltaOnRemoval self, Handle_TDF_DefaultDeltaOnRemoval theHandle) -> Handle_TDF_DefaultDeltaOnRemoval

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DefaultDeltaOnRemoval self) -> TDF_DefaultDeltaOnRemoval

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DefaultDeltaOnRemoval self) -> TDF_DefaultDeltaOnRemoval

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DefaultDeltaOnRemoval self) -> TDF_DefaultDeltaOnRemoval

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DefaultDeltaOnRemoval___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DefaultDeltaOnRemoval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DefaultDeltaOnRemoval_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DefaultDeltaOnRemoval

    def Apply(self, *args):
        """
        Apply(Handle_TDF_DefaultDeltaOnRemoval self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DefaultDeltaOnRemoval self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DefaultDeltaOnRemoval_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DefaultDeltaOnRemoval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDF_DefaultDeltaOnRemoval self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_DefaultDeltaOnRemoval self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_DefaultDeltaOnRemoval self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DefaultDeltaOnRemoval self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DefaultDeltaOnRemoval self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_DefaultDeltaOnRemoval self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DefaultDeltaOnRemoval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DefaultDeltaOnRemoval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DefaultDeltaOnRemoval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DefaultDeltaOnRemoval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DefaultDeltaOnRemoval self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DefaultDeltaOnRemoval self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DefaultDeltaOnRemoval self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DefaultDeltaOnRemoval self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DefaultDeltaOnRemoval_DecrementRefCounter(self, *args)

Handle_TDF_DefaultDeltaOnRemoval_swigregister = _TDF.Handle_TDF_DefaultDeltaOnRemoval_swigregister
Handle_TDF_DefaultDeltaOnRemoval_swigregister(Handle_TDF_DefaultDeltaOnRemoval)

def Handle_TDF_DefaultDeltaOnRemoval_DownCast(thing):
    return _TDF.Handle_TDF_DefaultDeltaOnRemoval_DownCast(thing)
Handle_TDF_DefaultDeltaOnRemoval_DownCast = _TDF.Handle_TDF_DefaultDeltaOnRemoval_DownCast

class Handle_TDF_Data(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_Data self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_Data_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_Data self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_Data_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_Data self, TDF_Data thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_Data_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_Data self, Handle_TDF_Data theHandle) -> Handle_TDF_Data
        assign(Handle_TDF_Data self, TDF_Data thePtr) -> Handle_TDF_Data
        assign(Handle_TDF_Data self, Handle_TDF_Data theHandle) -> Handle_TDF_Data

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_Data_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_Data self) -> TDF_Data

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_Data_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_Data self) -> TDF_Data

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_Data___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_Data self) -> TDF_Data

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_Data___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_Data___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_Data___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_Data(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_Data_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_Data

    def Root(self, *args):
        """
        Root(Handle_TDF_Data self) -> TDF_Label

        Returns the root label of the Data structure.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_Data_Root(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDF_Data self) -> Standard_Integer

        Returns the current transaction number.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Data_Transaction(self, *args)


    def Time(self, *args):
        """
        Time(Handle_TDF_Data self) -> Standard_Integer

        Returns the current tick. It is incremented each Commit.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Data_Time(self, *args)


    def IsApplicable(self, *args):
        """
        IsApplicable(Handle_TDF_Data self, Handle_TDF_Delta aDelta) -> Standard_Boolean

        Returns true if <aDelta> is applicable HERE and NOW.

        :type aDelta: OCC.wrapper.TDF.Handle_TDF_Delta
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Data_IsApplicable(self, *args)


    def Undo(self, *args):
        """
        Undo(Handle_TDF_Data self, Handle_TDF_Delta aDelta, Standard_Boolean const withDelta) -> Handle_TDF_Delta

        Apply <aDelta> to undo a set of attribute
        modifications.

        Optionnal <withDelta> set to True indiquates a
        Delta Set must be generated. (See above)

        :type aDelta: OCC.wrapper.TDF.Handle_TDF_Delta
        :type withDelta: bool
        :rtype: OCC.wrapper.TDF.Handle_TDF_Delta

        """
        return _TDF.Handle_TDF_Data_Undo(self, *args)


    def Destroy(self, *args):
        """Destroy(Handle_TDF_Data self)"""
        return _TDF.Handle_TDF_Data_Destroy(self, *args)


    def NotUndoMode(self, *args):
        """
        NotUndoMode(Handle_TDF_Data self) -> Standard_Boolean

        Returns the undo mode status.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Data_NotUndoMode(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_Data self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the Data on <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_Data_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_Data self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_Data___lshift__(self, *args)


    def AllowModification(self, *args):
        """
        AllowModification(Handle_TDF_Data self, Standard_Boolean const isAllowed)

        Sets modification mode.

        :type isAllowed: bool

        """
        return _TDF.Handle_TDF_Data_AllowModification(self, *args)


    def IsModificationAllowed(self, *args):
        """
        IsModificationAllowed(Handle_TDF_Data self) -> Standard_Boolean

        returns modification mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Data_IsModificationAllowed(self, *args)


    def LabelNodeAllocator(self, *args):
        """
        Returns TDF_HAllocator, which is an
        incremental allocator used by
        TDF_LabelNode.
        This allocator is used to
        manage TDF_LabelNode objects,
        but it can also be used for
        allocating memory to
        application-specific data (be
        careful because this
        allocator does not release
        the memory).
        The benefits of this
        allocation scheme are
        noticeable when dealing with
        large OCAF documents, due to:
        1.    Very quick allocation of
        objects (memory heap is not
        used, the algorithm that
        replaces it is very simple).
        2.    Very quick destruction of
        objects (memory is released not
        by destructors of TDF_LabelNode,
        but rather by the destructor of
        TDF_Data).
        3.  TDF_LabelNode objects do not
        fragmentize the memory; they are
        kept compactly in a number of
        arrays of 16K each.
        4.    Swapping is reduced on large
        data, because each document now
        occupies a smaller number of
        memory pages.

        :rtype: OCC.wrapper.TDF.TDF_HAllocator

        """
        res = _TDF.Handle_TDF_Data_LabelNodeAllocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_Data self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_Data_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Data_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_Data_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDF_Data self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_Data_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_Data self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_Data self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Data_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_Data self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_Data self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_Data_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_Data self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_Data_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_Data self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Data_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_Data self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_Data_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_Data self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_Data_DecrementRefCounter(self, *args)

Handle_TDF_Data_swigregister = _TDF.Handle_TDF_Data_swigregister
Handle_TDF_Data_swigregister(Handle_TDF_Data)

def Handle_TDF_Data_DownCast(thing):
    return _TDF.Handle_TDF_Data_DownCast(thing)
Handle_TDF_Data_DownCast = _TDF.Handle_TDF_Data_DownCast

class TDF_DefaultDeltaOnModification(TDF_DeltaOnModification):
    """
    This class provides a default implementation of a
    TDF_DeltaOnModification.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DefaultDeltaOnModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DefaultDeltaOnModification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_DefaultDeltaOnModification self, Handle_TDF_Attribute anAttribute) -> TDF_DefaultDeltaOnModification

        Creates a TDF_DefaultDeltaOnModification.
        <anAttribute> must be the backup copy.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        this = _TDF.new_TDF_DefaultDeltaOnModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDF_DefaultDeltaOnModification self)

        Applies the delta to the attribute.


        """
        return _TDF.TDF_DefaultDeltaOnModification_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DefaultDeltaOnModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DefaultDeltaOnModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DefaultDeltaOnModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DefaultDeltaOnModification
TDF_DefaultDeltaOnModification_swigregister = _TDF.TDF_DefaultDeltaOnModification_swigregister
TDF_DefaultDeltaOnModification_swigregister(TDF_DefaultDeltaOnModification)

def TDF_DefaultDeltaOnModification_get_type_name(*args):
    """
    TDF_DefaultDeltaOnModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DefaultDeltaOnModification_get_type_name(*args)

def TDF_DefaultDeltaOnModification_get_type_descriptor(*args):
    """
    TDF_DefaultDeltaOnModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DefaultDeltaOnModification_get_type_descriptor(*args)

class NCollection_List_Handle_TDF_Delta(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_TDF_Delta self) -> NCollection_List< opencascade::handle< TDF_Delta > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_TDF_Delta self) -> NCollection_List< opencascade::handle< TDF_Delta > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_TDF_Delta self) -> NCollection_List< opencascade::handle< TDF_Delta > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_TDF_Delta self) -> NCollection_List< opencascade::handle< TDF_Delta > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TDF.new_NCollection_List_Handle_TDF_Delta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_TDF_Delta self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_TDF_Delta self, NCollection_List_Handle_TDF_Delta theOther) -> NCollection_List_Handle_TDF_Delta

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_TDF_Delta self, NCollection_List_Handle_TDF_Delta theOther) -> NCollection_List_Handle_TDF_Delta

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_TDF_Delta self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Handle_TDF_Delta_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Handle_TDF_Delta_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_TDF_Delta self, Handle_TDF_Delta theItem) -> Handle_TDF_Delta
        Append(NCollection_List_Handle_TDF_Delta self, Handle_TDF_Delta theItem, NCollection_List< opencascade::handle< TDF_Delta > >::Iterator & theIter)
        Append(NCollection_List_Handle_TDF_Delta self, NCollection_List_Handle_TDF_Delta theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_TDF_Delta self, Handle_TDF_Delta theItem) -> Handle_TDF_Delta
        Prepend(NCollection_List_Handle_TDF_Delta self, NCollection_List_Handle_TDF_Delta theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_TDF_Delta self)

        RemoveFirst item


        """
        return _TDF.NCollection_List_Handle_TDF_Delta_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_TDF_Delta self, NCollection_List< opencascade::handle< TDF_Delta > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_TDF_Delta self, Handle_TDF_Delta theItem, NCollection_List< opencascade::handle< TDF_Delta > >::Iterator & theIter) -> Handle_TDF_Delta
        InsertBefore(NCollection_List_Handle_TDF_Delta self, NCollection_List_Handle_TDF_Delta theOther, NCollection_List< opencascade::handle< TDF_Delta > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_TDF_Delta self, Handle_TDF_Delta theItem, NCollection_List< opencascade::handle< TDF_Delta > >::Iterator & theIter) -> Handle_TDF_Delta
        InsertAfter(NCollection_List_Handle_TDF_Delta self, NCollection_List_Handle_TDF_Delta theOther, NCollection_List< opencascade::handle< TDF_Delta > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Delta_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_TDF_Delta self)

        Reverse the list


        """
        return _TDF.NCollection_List_Handle_TDF_Delta_Reverse(self, *args)


    def __iter__(self):
        return _TDF.NCollection_List_Handle_TDF_Delta___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_List_Handle_TDF_Delta
NCollection_List_Handle_TDF_Delta_swigregister = _TDF.NCollection_List_Handle_TDF_Delta_swigregister
NCollection_List_Handle_TDF_Delta_swigregister(NCollection_List_Handle_TDF_Delta)

class NCollection_List_Handle_TDF_Delta_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_List_Handle_TDF_Delta_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_List_Handle_TDF_Delta_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_List_Handle_TDF_Delta_IteratorHelper___next__(self)
NCollection_List_Handle_TDF_Delta_IteratorHelper_swigregister = _TDF.NCollection_List_Handle_TDF_Delta_IteratorHelper_swigregister
NCollection_List_Handle_TDF_Delta_IteratorHelper_swigregister(NCollection_List_Handle_TDF_Delta_IteratorHelper)


try:
	TDF_DeltaList = NCollection_List_Handle_TDF_Delta
except NameError:
	pass # does not exist, probably ignored

class TDF_CopyLabel(object):
    """This class gives copy of  source  label  hierarchy"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_CopyLabel self) -> TDF_CopyLabel
        __init__(TDF_CopyLabel self, TDF_Label aSource, TDF_Label aTarget) -> TDF_CopyLabel

        CopyTool

        :type aSource: OCC.wrapper.TDF.TDF_Label
        :type aTarget: OCC.wrapper.TDF.TDF_Label

        """
        this = _TDF.new_TDF_CopyLabel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(TDF_CopyLabel self, TDF_Label aSource, TDF_Label aTarget)

        Loads  src  and  tgt  labels

        :type aSource: OCC.wrapper.TDF.TDF_Label
        :type aTarget: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_CopyLabel_Load(self, *args)


    def UseFilter(self, *args):
        """
        UseFilter(TDF_CopyLabel self, TDF_IDFilter aFilter)

        Sets  filter

        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter

        """
        return _TDF.TDF_CopyLabel_UseFilter(self, *args)


    def ExternalReferences(*args):
        """
        ExternalReferences(TDF_Label Lab, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher aExternals, TDF_IDFilter aFilter) -> Standard_Boolean
        ExternalReferences(TDF_Label aRefLab, TDF_Label Lab, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher aExternals, TDF_IDFilter aFilter, Handle_TDF_DataSet aDataSet)

        Check  external  references and  if  exist  fills  the  aExternals  Map

        :type aRefLab: OCC.wrapper.TDF.TDF_Label
        :type Lab: OCC.wrapper.TDF.TDF_Label
        :type aExternals: OCC.wrapper.TDF.TDF_AttributeMap
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDF.TDF_CopyLabel_ExternalReferences(*args)

    ExternalReferences = staticmethod(ExternalReferences)

    def Perform(self, *args):
        """
        Perform(TDF_CopyLabel self)

        performs  algorithm  of  selfcontained  copy


        """
        return _TDF.TDF_CopyLabel_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(TDF_CopyLabel self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_CopyLabel_IsDone(self, *args)


    def RelocationTable(self, *args):
        """
        returns  relocation  table

        :rtype: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        res = _TDF.TDF_CopyLabel_RelocationTable(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_CopyLabel
TDF_CopyLabel_swigregister = _TDF.TDF_CopyLabel_swigregister
TDF_CopyLabel_swigregister(TDF_CopyLabel)

def TDF_CopyLabel_ExternalReferences(*args):
    """
    ExternalReferences(TDF_Label Lab, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher aExternals, TDF_IDFilter aFilter) -> Standard_Boolean
    TDF_CopyLabel_ExternalReferences(TDF_Label aRefLab, TDF_Label Lab, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher aExternals, TDF_IDFilter aFilter, Handle_TDF_DataSet aDataSet)

    Check  external  references and  if  exist  fills  the  aExternals  Map

    :type aRefLab: OCC.wrapper.TDF.TDF_Label
    :type Lab: OCC.wrapper.TDF.TDF_Label
    :type aExternals: OCC.wrapper.TDF.TDF_AttributeMap
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
    :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

    """
    return _TDF.TDF_CopyLabel_ExternalReferences(*args)

class TDF_TagSource(TDF_Attribute):
    """
    This attribute manage   a tag provider   to create
    child labels of a given one.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_TagSource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_TagSource(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.TDF_TagSource_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDF_TagSource self) -> TDF_TagSource

        This attribute manage   a tag provider   to create
        child labels of a given one.
        """
        this = _TDF.new_TDF_TagSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewTag(self, *args):
        """
        NewTag(TDF_TagSource self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_TagSource_NewTag(self, *args)


    def NewChild(self, *args):
        """
        NewChild(TDF_TagSource self, TDF_Label L) -> TDF_Label
        NewChild(TDF_TagSource self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_TagSource_NewChild(self, *args)


    def Get(self, *args):
        """
        Get(TDF_TagSource self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_TagSource_Get(self, *args)


    def Set(self, *args):
        """
        Set(TDF_TagSource self, TDF_Label label) -> Handle_TDF_TagSource
        Set(TDF_TagSource self, Standard_Integer const T)

        TDF_Attribute methods
        =====================

        :type T: int

        """
        return _TDF.TDF_TagSource_Set(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.TDF_TagSource_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDF_TagSource self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_TagSource_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDF_TagSource self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_TagSource_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDF_TagSource self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDF.TDF_TagSource_Paste(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_TagSource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_TagSource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_TagSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_TagSource
TDF_TagSource_swigregister = _TDF.TDF_TagSource_swigregister
TDF_TagSource_swigregister(TDF_TagSource)

def TDF_TagSource_GetID(*args):
    """
    TDF_TagSource_GetID() -> Standard_GUID

    class methods
    =============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDF.TDF_TagSource_GetID(*args)

def TDF_TagSource_get_type_name(*args):
    """
    TDF_TagSource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_TagSource_get_type_name(*args)

def TDF_TagSource_get_type_descriptor(*args):
    """
    TDF_TagSource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_TagSource_get_type_descriptor(*args)

class NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,Standard_Integer,TDF_LabelMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,Standard_Integer,TDF_LabelMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,Standard_Integer,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,Standard_Integer,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDF.new_NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, TDF_Label theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, TDF_Label theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, TDF_Label theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, TDF_Label theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, TDF_Label theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_Size(self, *args)


    def __iter__(self):
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher
NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_swigregister = _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_swigregister
NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_swigregister(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher)

class NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper_swigregister = _TDF.NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher_IteratorHelper)


try:
	TDF_LabelIntegerMap = NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored

class TDF_DataSet(Standard.Standard_Transient):
    """
    This class is a set of TDF informations like
    labels and attributes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDF_DataSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDF_DataSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDF_DataSet self) -> TDF_DataSet

        Creates an  empty   DataSet  object.


        """
        this = _TDF.new_TDF_DataSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(TDF_DataSet self)

        Clears all information.


        """
        return _TDF.TDF_DataSet_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TDF_DataSet self) -> Standard_Boolean

        Returns true if there is at least one label or one
        attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_DataSet_IsEmpty(self, *args)


    def AddLabel(self, *args):
        """
        AddLabel(TDF_DataSet self, TDF_Label aLabel)

        Adds <aLabel> in  the  current  data  set.

        :type aLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_DataSet_AddLabel(self, *args)


    def ContainsLabel(self, *args):
        """
        ContainsLabel(TDF_DataSet self, TDF_Label aLabel) -> Standard_Boolean

        Returns true if the label  <alabel>   is in the data set.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_DataSet_ContainsLabel(self, *args)


    def Labels(self, *args):
        """
        Labels(TDF_DataSet self) -> NCollection_Map_TDF_Label_TDF_LabelMapHasher

        Returns the map of labels in this data set.
        This map can be used directly, or updated.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TDF.TDF_DataSet_Labels(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(TDF_DataSet self, Handle_TDF_Attribute anAttribute)

        Adds <anAttribute> into the current data  set.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_DataSet_AddAttribute(self, *args)


    def ContainsAttribute(self, *args):
        """
        ContainsAttribute(TDF_DataSet self, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Returns true if <anAttribute> is in the data set.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_DataSet_ContainsAttribute(self, *args)


    def Attributes(self, *args):
        """
        Attributes(TDF_DataSet self) -> NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Returns the map of attributes in the  current  data   set.
        This map can be used directly, or updated.

        :rtype: OCC.wrapper.TDF.TDF_AttributeMap

        """
        return _TDF.TDF_DataSet_Attributes(self, *args)


    def AddRoot(self, *args):
        """
        AddRoot(TDF_DataSet self, TDF_Label aLabel)

        Adds a root label to <myRootLabels>.

        :type aLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_DataSet_AddRoot(self, *args)


    def Roots(self, *args):
        """
        Roots(TDF_DataSet self) -> NCollection_List_TDF_Label

        Returns <myRootLabels> to be used or updated.

        :rtype: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TDF.TDF_DataSet_Roots(self, *args)


    def Dump(self, *args):
        """
        Dump(TDF_DataSet self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_DataSet_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(TDF_DataSet self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.TDF_DataSet___lshift__(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDF.TDF_DataSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDF.TDF_DataSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.TDF_DataSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDF.delete_TDF_DataSet
TDF_DataSet_swigregister = _TDF.TDF_DataSet_swigregister
TDF_DataSet_swigregister(TDF_DataSet)

def TDF_DataSet_get_type_name(*args):
    """
    TDF_DataSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDF.TDF_DataSet_get_type_name(*args)

def TDF_DataSet_get_type_descriptor(*args):
    """
    TDF_DataSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDF.TDF_DataSet_get_type_descriptor(*args)

class NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_Label,TDF_LabelMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_Label,TDF_LabelMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_Label,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_Label,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDF.new_NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey, TDF_Label theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey, TDF_Label theItem) -> TDF_Label

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey) -> TDF_Label

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey) -> TDF_Label

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, TDF_Label theKey) -> TDF_Label

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_Size(self, *args)


    def __iter__(self):
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher
NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_swigregister = _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_swigregister
NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_swigregister(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher)

class NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister = _TDF.NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_IteratorHelper)


try:
	TDF_LabelDataMap = NCollection_DataMap_TDF_Label_TDF_Label_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_TDF_Attribute(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_TDF_Attribute self) -> NCollection_List< opencascade::handle< TDF_Attribute > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_TDF_Attribute self) -> NCollection_List< opencascade::handle< TDF_Attribute > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_TDF_Attribute self) -> NCollection_List< opencascade::handle< TDF_Attribute > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_TDF_Attribute self) -> NCollection_List< opencascade::handle< TDF_Attribute > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TDF.new_NCollection_List_Handle_TDF_Attribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_TDF_Attribute self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_TDF_Attribute self, NCollection_List_Handle_TDF_Attribute theOther) -> NCollection_List_Handle_TDF_Attribute

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_TDF_Attribute self, NCollection_List_Handle_TDF_Attribute theOther) -> NCollection_List_Handle_TDF_Attribute

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_TDF_Attribute self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Handle_TDF_Attribute_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_List_Handle_TDF_Attribute_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_TDF_Attribute self, Handle_TDF_Attribute theItem) -> Handle_TDF_Attribute
        Append(NCollection_List_Handle_TDF_Attribute self, Handle_TDF_Attribute theItem, NCollection_List< opencascade::handle< TDF_Attribute > >::Iterator & theIter)
        Append(NCollection_List_Handle_TDF_Attribute self, NCollection_List_Handle_TDF_Attribute theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_TDF_Attribute self, Handle_TDF_Attribute theItem) -> Handle_TDF_Attribute
        Prepend(NCollection_List_Handle_TDF_Attribute self, NCollection_List_Handle_TDF_Attribute theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_TDF_Attribute self)

        RemoveFirst item


        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_TDF_Attribute self, NCollection_List< opencascade::handle< TDF_Attribute > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_TDF_Attribute self, Handle_TDF_Attribute theItem, NCollection_List< opencascade::handle< TDF_Attribute > >::Iterator & theIter) -> Handle_TDF_Attribute
        InsertBefore(NCollection_List_Handle_TDF_Attribute self, NCollection_List_Handle_TDF_Attribute theOther, NCollection_List< opencascade::handle< TDF_Attribute > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_TDF_Attribute self, Handle_TDF_Attribute theItem, NCollection_List< opencascade::handle< TDF_Attribute > >::Iterator & theIter) -> Handle_TDF_Attribute
        InsertAfter(NCollection_List_Handle_TDF_Attribute self, NCollection_List_Handle_TDF_Attribute theOther, NCollection_List< opencascade::handle< TDF_Attribute > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_TDF_Attribute self)

        Reverse the list


        """
        return _TDF.NCollection_List_Handle_TDF_Attribute_Reverse(self, *args)


    def __iter__(self):
        return _TDF.NCollection_List_Handle_TDF_Attribute___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_List_Handle_TDF_Attribute
NCollection_List_Handle_TDF_Attribute_swigregister = _TDF.NCollection_List_Handle_TDF_Attribute_swigregister
NCollection_List_Handle_TDF_Attribute_swigregister(NCollection_List_Handle_TDF_Attribute)

class NCollection_List_Handle_TDF_Attribute_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_List_Handle_TDF_Attribute_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_List_Handle_TDF_Attribute_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_List_Handle_TDF_Attribute_IteratorHelper___next__(self)
NCollection_List_Handle_TDF_Attribute_IteratorHelper_swigregister = _TDF.NCollection_List_Handle_TDF_Attribute_IteratorHelper_swigregister
NCollection_List_Handle_TDF_Attribute_IteratorHelper_swigregister(NCollection_List_Handle_TDF_Attribute_IteratorHelper)


try:
	TDF_AttributeList = NCollection_List_Handle_TDF_Attribute
except NameError:
	pass # does not exist, probably ignored

class Handle_TDF_TagSource(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_TagSource self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_TagSource_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_TagSource self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_TagSource_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_TagSource self, TDF_TagSource thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_TagSource_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_TagSource self, Handle_TDF_TagSource theHandle) -> Handle_TDF_TagSource
        assign(Handle_TDF_TagSource self, TDF_TagSource thePtr) -> Handle_TDF_TagSource
        assign(Handle_TDF_TagSource self, Handle_TDF_TagSource theHandle) -> Handle_TDF_TagSource

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_TagSource_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_TagSource self) -> TDF_TagSource

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_TagSource_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_TagSource self) -> TDF_TagSource

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_TagSource___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_TagSource self) -> TDF_TagSource

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_TagSource___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_TagSource___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_TagSource___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_TagSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_TagSource_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_TagSource

    def GetID(self, *args):
        """
        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.Handle_TDF_TagSource_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDF_TagSource self, TDF_Label label) -> Handle_TDF_TagSource
        Set(Handle_TDF_TagSource self, Standard_Integer const T)

        TDF_Attribute methods
        =====================

        :type T: int

        """
        return _TDF.Handle_TDF_TagSource_Set(self, *args)


    def NewChild(self, *args):
        """
        NewChild(Handle_TDF_TagSource self, TDF_Label L) -> TDF_Label
        NewChild(Handle_TDF_TagSource self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_TagSource_NewChild(self, *args)


    def NewTag(self, *args):
        """
        NewTag(Handle_TDF_TagSource self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_TagSource_NewTag(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TDF_TagSource self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_TagSource_Get(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDF.Handle_TDF_TagSource_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDF_TagSource self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_TagSource_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDF_TagSource self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_TagSource_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDF_TagSource self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDF.Handle_TDF_TagSource_Paste(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_TagSource self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_TagSource_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_TagSource_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_TagSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDF_TagSource self, Standard_GUID arg2)
        SetID(Handle_TDF_TagSource self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDF.Handle_TDF_TagSource_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDF_TagSource self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_TagSource_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDF_TagSource self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_TagSource_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDF_TagSource self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_TagSource_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDF_TagSource self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDF_TagSource self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDF_TagSource self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDF_TagSource self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDF_TagSource self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDF_TagSource self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_TagSource_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDF_TagSource self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDF_TagSource self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDF.Handle_TDF_TagSource_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDF_TagSource self)

        Something to do after adding an Attribute to a label.


        """
        return _TDF.Handle_TDF_TagSource_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDF_TagSource self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDF.Handle_TDF_TagSource_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDF_TagSource self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDF.Handle_TDF_TagSource_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDF_TagSource self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDF.Handle_TDF_TagSource_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDF_TagSource self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDF_TagSource self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDF_TagSource self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDF_TagSource self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDF.Handle_TDF_TagSource_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDF_TagSource self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDF.Handle_TDF_TagSource_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDF_TagSource self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDF_TagSource self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_TagSource_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDF_TagSource self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDF.Handle_TDF_TagSource_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDF_TagSource self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDF.Handle_TDF_TagSource_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDF_TagSource self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDF.Handle_TDF_TagSource_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDF_TagSource self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDF.Handle_TDF_TagSource_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDF_TagSource self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDF.Handle_TDF_TagSource_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_TagSource self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_TagSource_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_TagSource self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_TagSource___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDF_TagSource self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDF.Handle_TDF_TagSource_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDF_TagSource self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDF.Handle_TDF_TagSource_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_TagSource self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_TagSource_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_TagSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_TagSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_TagSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_TagSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_TagSource_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_TagSource self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_TagSource_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_TagSource self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_TagSource_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_TagSource self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_TagSource_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_TagSource self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_TagSource_DecrementRefCounter(self, *args)

Handle_TDF_TagSource_swigregister = _TDF.Handle_TDF_TagSource_swigregister
Handle_TDF_TagSource_swigregister(Handle_TDF_TagSource)

def Handle_TDF_TagSource_DownCast(thing):
    return _TDF.Handle_TDF_TagSource_DownCast(thing)
Handle_TDF_TagSource_DownCast = _TDF.Handle_TDF_TagSource_DownCast

class Handle_TDF_DeltaOnResume(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DeltaOnResume self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DeltaOnResume_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DeltaOnResume self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DeltaOnResume_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DeltaOnResume self, TDF_DeltaOnResume thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DeltaOnResume_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DeltaOnResume self, Handle_TDF_DeltaOnResume theHandle) -> Handle_TDF_DeltaOnResume
        assign(Handle_TDF_DeltaOnResume self, TDF_DeltaOnResume thePtr) -> Handle_TDF_DeltaOnResume
        assign(Handle_TDF_DeltaOnResume self, Handle_TDF_DeltaOnResume theHandle) -> Handle_TDF_DeltaOnResume

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DeltaOnResume_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DeltaOnResume self) -> TDF_DeltaOnResume

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnResume_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DeltaOnResume self) -> TDF_DeltaOnResume

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnResume___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DeltaOnResume self) -> TDF_DeltaOnResume

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DeltaOnResume___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DeltaOnResume___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DeltaOnResume___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DeltaOnResume(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DeltaOnResume_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DeltaOnResume

    def Apply(self, *args):
        """
        Apply(Handle_TDF_DeltaOnResume self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_DeltaOnResume_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DeltaOnResume self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DeltaOnResume_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnResume_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnResume_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDF_DeltaOnResume self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DeltaOnResume_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_DeltaOnResume self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DeltaOnResume_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_DeltaOnResume self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_DeltaOnResume_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DeltaOnResume self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnResume_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DeltaOnResume self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnResume___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_DeltaOnResume self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DeltaOnResume_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DeltaOnResume self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DeltaOnResume self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnResume_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DeltaOnResume self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DeltaOnResume self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnResume_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DeltaOnResume self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DeltaOnResume_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DeltaOnResume self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnResume_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DeltaOnResume self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DeltaOnResume_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DeltaOnResume self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnResume_DecrementRefCounter(self, *args)

Handle_TDF_DeltaOnResume_swigregister = _TDF.Handle_TDF_DeltaOnResume_swigregister
Handle_TDF_DeltaOnResume_swigregister(Handle_TDF_DeltaOnResume)

def Handle_TDF_DeltaOnResume_DownCast(thing):
    return _TDF.Handle_TDF_DeltaOnResume_DownCast(thing)
Handle_TDF_DeltaOnResume_DownCast = _TDF.Handle_TDF_DeltaOnResume_DownCast

class NCollection_Array1_Handle_TDF_Attribute(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_TDF_Attribute self) -> NCollection_Array1< opencascade::handle< TDF_Attribute > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_TDF_Attribute self) -> NCollection_Array1< opencascade::handle< TDF_Attribute > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_TDF_Attribute self) -> NCollection_Array1< opencascade::handle< TDF_Attribute > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_TDF_Attribute self) -> NCollection_Array1< opencascade::handle< TDF_Attribute > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TDF.new_NCollection_Array1_Handle_TDF_Attribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_TDF_Attribute self, Handle_TDF_Attribute theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_TDF_Attribute self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_TDF_Attribute self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_TDF_Attribute self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_TDF_Attribute self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_TDF_Attribute self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_TDF_Attribute self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_TDF_Attribute self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_TDF_Attribute self, NCollection_Array1_Handle_TDF_Attribute theOther) -> NCollection_Array1_Handle_TDF_Attribute

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_TDF_Attribute self, NCollection_Array1_Handle_TDF_Attribute theOther) -> NCollection_Array1_Handle_TDF_Attribute

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_TDF_Attribute self, NCollection_Array1_Handle_TDF_Attribute theOther) -> NCollection_Array1_Handle_TDF_Attribute
        assign(NCollection_Array1_Handle_TDF_Attribute self, NCollection_Array1_Handle_TDF_Attribute theOther) -> NCollection_Array1_Handle_TDF_Attribute

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Array1_Handle_TDF_Attribute_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_TDF_Attribute self) -> Handle_TDF_Attribute

        @return first element

        :rtype: TheItemType &

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Array1_Handle_TDF_Attribute_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_TDF_Attribute self) -> Handle_TDF_Attribute

        @return last element

        :rtype: TheItemType &

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Array1_Handle_TDF_Attribute_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_TDF_Attribute self, Standard_Integer const theIndex) -> Handle_TDF_Attribute

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Array1_Handle_TDF_Attribute___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDF.NCollection_Array1_Handle_TDF_Attribute_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_TDF_Attribute self, Standard_Integer const theIndex, Handle_TDF_Attribute theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_TDF_Attribute self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TDF.NCollection_Array1_Handle_TDF_Attribute_Resize(self, *args)

    __swig_destroy__ = _TDF.delete_NCollection_Array1_Handle_TDF_Attribute
NCollection_Array1_Handle_TDF_Attribute_swigregister = _TDF.NCollection_Array1_Handle_TDF_Attribute_swigregister
NCollection_Array1_Handle_TDF_Attribute_swigregister(NCollection_Array1_Handle_TDF_Attribute)


try:
	TDF_AttributeArray1 = NCollection_Array1_Handle_TDF_Attribute
except NameError:
	pass # does not exist, probably ignored

class TDF_ClosureMode(object):
    """This class provides options closure management."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_ClosureMode self, Standard_Boolean const aMode) -> TDF_ClosureMode

        Creates an objet with all modes set to <aMode>.

        :type aMode: bool

        """
        this = _TDF.new_TDF_ClosureMode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Descendants(self, *args):
        """
        Descendants(TDF_ClosureMode self, Standard_Boolean const aStatus)
        Descendants(TDF_ClosureMode self) -> Standard_Boolean

        Returns true if the mode "Descendants" is set.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_ClosureMode_Descendants(self, *args)


    def References(self, *args):
        """
        References(TDF_ClosureMode self, Standard_Boolean const aStatus)
        References(TDF_ClosureMode self) -> Standard_Boolean

        Returns true if the mode "References" is set.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_ClosureMode_References(self, *args)

    __swig_destroy__ = _TDF.delete_TDF_ClosureMode
TDF_ClosureMode_swigregister = _TDF.TDF_ClosureMode_swigregister
TDF_ClosureMode_swigregister(TDF_ClosureMode)

class NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
    and retrieve them in linear time.

    See Map from NCollection for a discussion about the number
    of buckets
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
        and retrieve them in linear time.

        See Map from NCollection for a discussion about the number
        of buckets
        """
        this = _TDF.new_NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher theOther) -> NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher theOther) -> NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, TDF_Label theKey1, TDF_Label theKey2)

        Bind

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_Bind(self, *args)


    def AreBound(self, *args):
        """
        AreBound(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, TDF_Label theKey1, TDF_Label theKey2) -> Standard_Boolean

        * AreBound

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_AreBound(self, *args)


    def IsBound1(self, *args):
        """
        IsBound1(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, TDF_Label theKey1) -> Standard_Boolean

        IsBound1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_IsBound1(self, *args)


    def IsBound2(self, *args):
        """
        IsBound2(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, TDF_Label theKey2) -> Standard_Boolean

        IsBound2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_IsBound2(self, *args)


    def UnBind1(self, *args):
        """
        UnBind1(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, TDF_Label theKey1) -> Standard_Boolean

        UnBind1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_UnBind1(self, *args)


    def UnBind2(self, *args):
        """
        UnBind2(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, TDF_Label theKey2) -> Standard_Boolean

        UnBind2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_UnBind2(self, *args)


    def Find1(self, *args):
        """
        Find1

        :type theKey1: const TheKey1Type &
        :rtype: const TheKey2Type &

        """
        res = _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_Find1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Find2(self, *args):
        """
        Find2

        :type theKey2: const TheKey2Type &
        :rtype: const TheKey1Type &

        """
        res = _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_Find2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_Size(self, *args)

    __swig_destroy__ = _TDF.delete_NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher
NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_swigregister = _TDF.NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_swigregister
NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher_swigregister(NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher)


try:
	TDF_LabelDoubleMap = NCollection_DoubleMap_TDF_Label_TDF_Label_TDF_LabelMapHasher_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored

class TDF_ComparisonTool(object):
    """
    This class provides services to compare sets of
    information. The use of this tool can works after
    a copy, acted by a CopyTool.

    * Compare(...) compares two DataSet and returns
    the result.

    * SourceUnbound(...) builds the difference between
    a relocation dictionnary and a source set of
    information.

    * TargetUnbound(...) does the same between a
    relocation dictionnary and a target set of
    information.

    * Cut(aDataSet, anLabel) removes a set of
    attributes.

    * IsSelfContained(...) returns true if all the
    labels of the attributes of the given DataSet are
    descendant of the given label.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Compare(*args):
        """
        Compare(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_DataSet aTargetDataSet, TDF_IDFilter aFilter, Handle_TDF_RelocationTable aRelocationTable)

        Compares <aSourceDataSet> with <aTargetDataSet>,
        updating <aRelocationTable> with labels and
        attributes found in both sets.

        :type aSourceDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :type aTargetDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDF.TDF_ComparisonTool_Compare(*args)

    Compare = staticmethod(Compare)

    def SourceUnbound(*args):
        """
        SourceUnbound(Handle_TDF_DataSet aRefDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aFilter, Handle_TDF_DataSet aDiffDataSet, Standard_Integer const anOption=2) -> Standard_Boolean

        Finds from <aRefDataSet> all the keys not bound
        into <aRelocationTable> and put them into
        <aDiffDataSet>. Returns True if the difference
        contains at least one key. (A key is a source
        object).

        <anOption> may take the following values:
        1 : labels treatment only;
        2 : attributes treatment only (default value);
        3 : both labels & attributes treatment.

        :type aRefDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aDiffDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :type anOption: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_ComparisonTool_SourceUnbound(*args)

    SourceUnbound = staticmethod(SourceUnbound)

    def TargetUnbound(*args):
        """
        TargetUnbound(Handle_TDF_DataSet aRefDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aFilter, Handle_TDF_DataSet aDiffDataSet, Standard_Integer const anOption=2) -> Standard_Boolean

        Substracts from <aRefDataSet> all the items bound
        into <aRelocationTable>. The result is put into
        <aDiffDataSet>. Returns True if the difference
        contains at least one item. (An item is a target
        object).

        <anOption> may take the following values:
        1 : labels treatment only;
        2 : attributes treatment  only(default value);
        3 : both labels & attributes treatment.

        :type aRefDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aDiffDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :type anOption: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_ComparisonTool_TargetUnbound(*args)

    TargetUnbound = staticmethod(TargetUnbound)

    def Cut(*args):
        """
        Cut(Handle_TDF_DataSet aDataSet)

        Removes attributes from <aDataSet>.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDF.TDF_ComparisonTool_Cut(*args)

    Cut = staticmethod(Cut)

    def IsSelfContained(*args):
        """
        IsSelfContained(TDF_Label aLabel, Handle_TDF_DataSet aDataSet) -> Standard_Boolean

        Returns true if all the labels of <aDataSet> are
        descendant of <aLabel>.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_ComparisonTool_IsSelfContained(*args)

    IsSelfContained = staticmethod(IsSelfContained)

    def __init__(self):
        """
        This class provides services to compare sets of
        information. The use of this tool can works after
        a copy, acted by a CopyTool.

        * Compare(...) compares two DataSet and returns
        the result.

        * SourceUnbound(...) builds the difference between
        a relocation dictionnary and a source set of
        information.

        * TargetUnbound(...) does the same between a
        relocation dictionnary and a target set of
        information.

        * Cut(aDataSet, anLabel) removes a set of
        attributes.

        * IsSelfContained(...) returns true if all the
        labels of the attributes of the given DataSet are
        descendant of the given label.
        """
        this = _TDF.new_TDF_ComparisonTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_TDF_ComparisonTool
TDF_ComparisonTool_swigregister = _TDF.TDF_ComparisonTool_swigregister
TDF_ComparisonTool_swigregister(TDF_ComparisonTool)

def TDF_ComparisonTool_Compare(*args):
    """
    TDF_ComparisonTool_Compare(Handle_TDF_DataSet aSourceDataSet, Handle_TDF_DataSet aTargetDataSet, TDF_IDFilter aFilter, Handle_TDF_RelocationTable aRelocationTable)

    Compares <aSourceDataSet> with <aTargetDataSet>,
    updating <aRelocationTable> with labels and
    attributes found in both sets.

    :type aSourceDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :type aTargetDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
    :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable

    """
    return _TDF.TDF_ComparisonTool_Compare(*args)

def TDF_ComparisonTool_SourceUnbound(*args):
    """
    TDF_ComparisonTool_SourceUnbound(Handle_TDF_DataSet aRefDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aFilter, Handle_TDF_DataSet aDiffDataSet, Standard_Integer const anOption=2) -> Standard_Boolean

    Finds from <aRefDataSet> all the keys not bound
    into <aRelocationTable> and put them into
    <aDiffDataSet>. Returns True if the difference
    contains at least one key. (A key is a source
    object).

    <anOption> may take the following values:
    1 : labels treatment only;
    2 : attributes treatment only (default value);
    3 : both labels & attributes treatment.

    :type aRefDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
    :type aDiffDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :type anOption: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDF.TDF_ComparisonTool_SourceUnbound(*args)

def TDF_ComparisonTool_TargetUnbound(*args):
    """
    TDF_ComparisonTool_TargetUnbound(Handle_TDF_DataSet aRefDataSet, Handle_TDF_RelocationTable aRelocationTable, TDF_IDFilter aFilter, Handle_TDF_DataSet aDiffDataSet, Standard_Integer const anOption=2) -> Standard_Boolean

    Substracts from <aRefDataSet> all the items bound
    into <aRelocationTable>. The result is put into
    <aDiffDataSet>. Returns True if the difference
    contains at least one item. (An item is a target
    object).

    <anOption> may take the following values:
    1 : labels treatment only;
    2 : attributes treatment  only(default value);
    3 : both labels & attributes treatment.

    :type aRefDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :type aRelocationTable: OCC.wrapper.TDF.Handle_TDF_RelocationTable
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
    :type aDiffDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :type anOption: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDF.TDF_ComparisonTool_TargetUnbound(*args)

def TDF_ComparisonTool_Cut(*args):
    """
    TDF_ComparisonTool_Cut(Handle_TDF_DataSet aDataSet)

    Removes attributes from <aDataSet>.

    :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

    """
    return _TDF.TDF_ComparisonTool_Cut(*args)

def TDF_ComparisonTool_IsSelfContained(*args):
    """
    TDF_ComparisonTool_IsSelfContained(TDF_Label aLabel, Handle_TDF_DataSet aDataSet) -> Standard_Boolean

    Returns true if all the labels of <aDataSet> are
    descendant of <aLabel>.

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDF.TDF_ComparisonTool_IsSelfContained(*args)


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
    and retrieve them in linear time.

    See Map from NCollection for a discussion about the number
    of buckets
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
        and retrieve them in linear time.

        See Map from NCollection for a discussion about the number
        of buckets
        """
        this = _TDF.new_NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher theOther) -> NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher theOther) -> NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1, Handle_TDF_Attribute theKey2)

        Bind

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_Bind(self, *args)


    def AreBound(self, *args):
        """
        AreBound(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1, Handle_TDF_Attribute theKey2) -> Standard_Boolean

        * AreBound

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_AreBound(self, *args)


    def IsBound1(self, *args):
        """
        IsBound1(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1) -> Standard_Boolean

        IsBound1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_IsBound1(self, *args)


    def IsBound2(self, *args):
        """
        IsBound2(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey2) -> Standard_Boolean

        IsBound2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_IsBound2(self, *args)


    def UnBind1(self, *args):
        """
        UnBind1(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1) -> Standard_Boolean

        UnBind1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_UnBind1(self, *args)


    def UnBind2(self, *args):
        """
        UnBind2(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey2) -> Standard_Boolean

        UnBind2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_UnBind2(self, *args)


    def Find1(self, *args):
        """
        Find1

        :type theKey1: const TheKey1Type &
        :rtype: const TheKey2Type &

        """
        res = _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_Find1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Find2(self, *args):
        """
        Find2

        :type theKey2: const TheKey2Type &
        :rtype: const TheKey1Type &

        """
        res = _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_Find2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_Size(self, *args)

    __swig_destroy__ = _TDF.delete_NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher
NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_swigregister = _TDF.NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_swigregister
NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher_swigregister(NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher)


try:
	TDF_AttributeDoubleMap = NCollection_DoubleMap_Handle_TDF_Attribute_Handle_TDF_Attribute_TColStd_MapTransientHasher_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class TDF_ChildIDIterator(object):
    """
    Iterates on the children of a label, to find
    attributes having ID as Attribute ID.

    Level option works as TDF_ChildIterator.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDF_ChildIDIterator self) -> TDF_ChildIDIterator
        __init__(TDF_ChildIDIterator self, TDF_Label aLabel, Standard_GUID anID, Standard_Boolean const allLevels) -> TDF_ChildIDIterator

        Iterates on the children of the given label. If
        <allLevels> option is set to true, it explores not
        only the first, but all the sub label levels.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type allLevels: bool

        """
        this = _TDF.new_TDF_ChildIDIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TDF_ChildIDIterator self, TDF_Label aLabel, Standard_GUID anID, Standard_Boolean const allLevels)

        Initializes the iteration on the children of the
        given label. If <allLevels> option is set to true,
        it explores not only the first, but all the sub
        label levels.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type allLevels: bool

        """
        return _TDF.TDF_ChildIDIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(TDF_ChildIDIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the
        iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_ChildIDIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TDF_ChildIDIterator self)

        Move to the next Item


        """
        return _TDF.TDF_ChildIDIterator_Next(self, *args)


    def NextBrother(self, *args):
        """
        NextBrother(TDF_ChildIDIterator self)

        Move to the next Brother. If there is none, go up
        etc. This method is interesting only with
        "allLevels" behavior, because it avoids to explore
        the current label children.


        """
        return _TDF.TDF_ChildIDIterator_NextBrother(self, *args)


    def Value(self, *args):
        """
        Value(TDF_ChildIDIterator self) -> Handle_TDF_Attribute

        Returns the current item; a null handle if there is none.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.TDF_ChildIDIterator_Value(self, *args)

    __swig_destroy__ = _TDF.delete_TDF_ChildIDIterator
TDF_ChildIDIterator_swigregister = _TDF.TDF_ChildIDIterator_swigregister
TDF_ChildIDIterator_swigregister(TDF_ChildIDIterator)

class Handle_TDF_AttributeDelta(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_AttributeDelta self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_AttributeDelta_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_AttributeDelta self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_AttributeDelta_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_AttributeDelta self, TDF_AttributeDelta thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_AttributeDelta_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_AttributeDelta self, Handle_TDF_AttributeDelta theHandle) -> Handle_TDF_AttributeDelta
        assign(Handle_TDF_AttributeDelta self, TDF_AttributeDelta thePtr) -> Handle_TDF_AttributeDelta
        assign(Handle_TDF_AttributeDelta self, Handle_TDF_AttributeDelta theHandle) -> Handle_TDF_AttributeDelta

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_AttributeDelta_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_AttributeDelta self) -> TDF_AttributeDelta

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_AttributeDelta_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_AttributeDelta self) -> TDF_AttributeDelta

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_AttributeDelta___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_AttributeDelta self) -> TDF_AttributeDelta

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_AttributeDelta___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_AttributeDelta___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_AttributeDelta___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_AttributeDelta(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_AttributeDelta_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_AttributeDelta

    def Apply(self, *args):
        """
        Apply(Handle_TDF_AttributeDelta self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_AttributeDelta_Apply(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDF_AttributeDelta self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_AttributeDelta_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_AttributeDelta self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_AttributeDelta_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_AttributeDelta self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_AttributeDelta_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_AttributeDelta self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_AttributeDelta_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_AttributeDelta self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_AttributeDelta___lshift__(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_AttributeDelta self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_AttributeDelta_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_AttributeDelta_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_AttributeDelta_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDF_AttributeDelta self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_AttributeDelta_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_AttributeDelta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_AttributeDelta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_AttributeDelta_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_AttributeDelta self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_AttributeDelta self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_AttributeDelta_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_AttributeDelta self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_AttributeDelta_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_AttributeDelta self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_AttributeDelta_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_AttributeDelta self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_AttributeDelta_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_AttributeDelta self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_AttributeDelta_DecrementRefCounter(self, *args)

Handle_TDF_AttributeDelta_swigregister = _TDF.Handle_TDF_AttributeDelta_swigregister
Handle_TDF_AttributeDelta_swigregister(Handle_TDF_AttributeDelta)

def Handle_TDF_AttributeDelta_DownCast(thing):
    return _TDF.Handle_TDF_AttributeDelta_DownCast(thing)
Handle_TDF_AttributeDelta_DownCast = _TDF.Handle_TDF_AttributeDelta_DownCast

class TDF_Tool(object):
    """This class provides general services for a data framework."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NbLabels(*args):
        """
        NbLabels(TDF_Label aLabel) -> Standard_Integer

        Returns the number of labels of the tree,
        including <aLabel>. aLabel is also included in this figure.
        This information is useful in setting the size of an array.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Tool_NbLabels(*args)

    NbLabels = staticmethod(NbLabels)

    def NbAttributes(*args):
        """
        NbAttributes(TDF_Label aLabel) -> Standard_Integer
        NbAttributes(TDF_Label aLabel, TDF_IDFilter aFilter) -> Standard_Integer

        Returns the number of attributes of the tree,
        selected by a<Filter>, including those of
        <aLabel>.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_Tool_NbAttributes(*args)

    NbAttributes = staticmethod(NbAttributes)

    def IsSelfContained(*args):
        """
        IsSelfContained(TDF_Label aLabel) -> Standard_Boolean
        IsSelfContained(TDF_Label aLabel, TDF_IDFilter aFilter) -> Standard_Boolean

        Returns true if <aLabel> and its descendants
        reference only attributes or labels attached to
        themselves and kept by <aFilter>.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_Tool_IsSelfContained(*args)

    IsSelfContained = staticmethod(IsSelfContained)

    def OutReferers(*args):
        """
        OutReferers(TDF_Label theLabel, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theAtts)
        OutReferers(TDF_Label aLabel, TDF_IDFilter aFilterForReferers, TDF_IDFilter aFilterForReferences, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher atts)

        Returns in <atts> the attributes having out
        references and kept by <aFilterForReferers>.
        It considers only the references kept by <aFilterForReferences>.
        Caution: <atts> is not cleared before use!

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aFilterForReferers: OCC.wrapper.TDF.TDF_IDFilter
        :type aFilterForReferences: OCC.wrapper.TDF.TDF_IDFilter
        :type atts: OCC.wrapper.TDF.TDF_AttributeMap

        """
        return _TDF.TDF_Tool_OutReferers(*args)

    OutReferers = staticmethod(OutReferers)

    def OutReferences(*args):
        """
        OutReferences(TDF_Label aLabel, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher atts)
        OutReferences(TDF_Label aLabel, TDF_IDFilter aFilterForReferers, TDF_IDFilter aFilterForReferences, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher atts)

        Returns in <atts> the referenced attributes and kept by <aFilterForReferences>.
        It considers only the referers kept by <aFilterForReferers>.
        Caution: <atts> is not cleared before use!

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aFilterForReferers: OCC.wrapper.TDF.TDF_IDFilter
        :type aFilterForReferences: OCC.wrapper.TDF.TDF_IDFilter
        :type atts: OCC.wrapper.TDF.TDF_AttributeMap

        """
        return _TDF.TDF_Tool_OutReferences(*args)

    OutReferences = staticmethod(OutReferences)

    def RelocateLabel(*args):
        """
        RelocateLabel(TDF_Label aSourceLabel, TDF_Label fromRoot, TDF_Label toRoot, TDF_Label aTargetLabel, Standard_Boolean const create)

        Returns the label having the same sub-entry as
        <aLabel> but located as descendant as <toRoot>
        instead of <fromRoot>.

        Exemple :

        aLabel = 0:3:24:7:2:7
        fromRoot = 0:3:24
        toRoot = 0:5
        returned label = 0:5:7:2:7

        :type aSourceLabel: OCC.wrapper.TDF.TDF_Label
        :type fromRoot: OCC.wrapper.TDF.TDF_Label
        :type toRoot: OCC.wrapper.TDF.TDF_Label
        :type aTargetLabel: OCC.wrapper.TDF.TDF_Label
        :type create: bool

        """
        return _TDF.TDF_Tool_RelocateLabel(*args)

    RelocateLabel = staticmethod(RelocateLabel)

    def Entry(*args):
        """
        Entry(TDF_Label aLabel, TCollection_AsciiString anEntry)

        Returns the entry for the label aLabel in the form
        of the ASCII character string anEntry containing
        the tag list for aLabel.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type anEntry: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TDF.TDF_Tool_Entry(*args)

    Entry = staticmethod(Entry)

    def TagList(*args):
        """
        TagList(TDF_Label aLabel, NCollection_List_Standard_Integer aTagList)
        TagList(TCollection_AsciiString anEntry, NCollection_List_Standard_Integer aTagList)

        Returns the entry expressed by <anEntry> as list
        of integers in <aTagList>.

        :type anEntry: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aTagList: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _TDF.TDF_Tool_TagList(*args)

    TagList = staticmethod(TagList)

    def Label(*args):
        """
        Label(Handle_TDF_Data aDF, TCollection_AsciiString anEntry, TDF_Label aLabel, Standard_Boolean const create)
        Label(Handle_TDF_Data aDF, Standard_CString const anEntry, TDF_Label aLabel, Standard_Boolean const create)
        Label(Handle_TDF_Data aDF, NCollection_List_Standard_Integer aTagList, TDF_Label aLabel, Standard_Boolean const create)

        Returns the label expressed by <anEntry>; creates
        the label if it does not exist and if <create> is
        true.

        :type aDF: OCC.wrapper.TDF.Handle_TDF_Data
        :type aTagList: OCC.wrapper.TColStd.TColStd_ListOfInteger
        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type create: bool

        """
        return _TDF.TDF_Tool_Label(*args)

    Label = staticmethod(Label)

    def CountLabels(*args):
        """
        CountLabels(NCollection_List_TDF_Label aLabelList, NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher aLabelMap)

        Adds the labels of <aLabelList> to <aLabelMap> if
        they are unbound, or increases their reference
        counters. At the end of the process, <aLabelList>
        contains only the ADDED labels.

        :type aLabelList: OCC.wrapper.TDF.TDF_LabelList
        :type aLabelMap: OCC.wrapper.TDF.TDF_LabelIntegerMap

        """
        return _TDF.TDF_Tool_CountLabels(*args)

    CountLabels = staticmethod(CountLabels)

    def DeductLabels(*args):
        """
        DeductLabels(NCollection_List_TDF_Label aLabelList, NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher aLabelMap)

        Decreases the reference counters of the labels of
        <aLabelList> to <aLabelMap>, and removes labels
        with null counter. At the end of the process,
        <aLabelList> contains only the SUPPRESSED labels.

        :type aLabelList: OCC.wrapper.TDF.TDF_LabelList
        :type aLabelMap: OCC.wrapper.TDF.TDF_LabelIntegerMap

        """
        return _TDF.TDF_Tool_DeductLabels(*args)

    DeductLabels = staticmethod(DeductLabels)

    def DeepDump(*args):
        """
        DeepDump(Standard_OStream & anOS, Handle_TDF_Data aDF)
        DeepDump(Standard_OStream & anOS, TDF_Label aLabel)

        Dumps <aLabel>, its chilren and their attributes.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.TDF_Tool_DeepDump(*args)

    DeepDump = staticmethod(DeepDump)

    def ExtendedDeepDump(*args):
        """
        ExtendedDeepDump(Standard_OStream & anOS, Handle_TDF_Data aDF, TDF_IDFilter aFilter)
        ExtendedDeepDump(Standard_OStream & anOS, TDF_Label aLabel, TDF_IDFilter aFilter)

        Dumps <aLabel>, its chilren and their attributes,
        if their IDs are kept by <aFilter>. Dumps also the
        attributes content.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter

        """
        return _TDF.TDF_Tool_ExtendedDeepDump(*args)

    ExtendedDeepDump = staticmethod(ExtendedDeepDump)

    def __init__(self):
        """This class provides general services for a data framework."""
        this = _TDF.new_TDF_Tool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_TDF_Tool
TDF_Tool_swigregister = _TDF.TDF_Tool_swigregister
TDF_Tool_swigregister(TDF_Tool)

def TDF_Tool_NbLabels(*args):
    """
    TDF_Tool_NbLabels(TDF_Label aLabel) -> Standard_Integer

    Returns the number of labels of the tree,
    including <aLabel>. aLabel is also included in this figure.
    This information is useful in setting the size of an array.

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TDF.TDF_Tool_NbLabels(*args)

def TDF_Tool_NbAttributes(*args):
    """
    NbAttributes(TDF_Label aLabel) -> Standard_Integer
    TDF_Tool_NbAttributes(TDF_Label aLabel, TDF_IDFilter aFilter) -> Standard_Integer

    Returns the number of attributes of the tree,
    selected by a<Filter>, including those of
    <aLabel>.

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TDF.TDF_Tool_NbAttributes(*args)

def TDF_Tool_IsSelfContained(*args):
    """
    IsSelfContained(TDF_Label aLabel) -> Standard_Boolean
    TDF_Tool_IsSelfContained(TDF_Label aLabel, TDF_IDFilter aFilter) -> Standard_Boolean

    Returns true if <aLabel> and its descendants
    reference only attributes or labels attached to
    themselves and kept by <aFilter>.

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDF.TDF_Tool_IsSelfContained(*args)

def TDF_Tool_OutReferers(*args):
    """
    OutReferers(TDF_Label theLabel, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theAtts)
    TDF_Tool_OutReferers(TDF_Label aLabel, TDF_IDFilter aFilterForReferers, TDF_IDFilter aFilterForReferences, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher atts)

    Returns in <atts> the attributes having out
    references and kept by <aFilterForReferers>.
    It considers only the references kept by <aFilterForReferences>.
    Caution: <atts> is not cleared before use!

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type aFilterForReferers: OCC.wrapper.TDF.TDF_IDFilter
    :type aFilterForReferences: OCC.wrapper.TDF.TDF_IDFilter
    :type atts: OCC.wrapper.TDF.TDF_AttributeMap

    """
    return _TDF.TDF_Tool_OutReferers(*args)

def TDF_Tool_OutReferences(*args):
    """
    OutReferences(TDF_Label aLabel, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher atts)
    TDF_Tool_OutReferences(TDF_Label aLabel, TDF_IDFilter aFilterForReferers, TDF_IDFilter aFilterForReferences, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher atts)

    Returns in <atts> the referenced attributes and kept by <aFilterForReferences>.
    It considers only the referers kept by <aFilterForReferers>.
    Caution: <atts> is not cleared before use!

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type aFilterForReferers: OCC.wrapper.TDF.TDF_IDFilter
    :type aFilterForReferences: OCC.wrapper.TDF.TDF_IDFilter
    :type atts: OCC.wrapper.TDF.TDF_AttributeMap

    """
    return _TDF.TDF_Tool_OutReferences(*args)

def TDF_Tool_RelocateLabel(*args):
    """
    TDF_Tool_RelocateLabel(TDF_Label aSourceLabel, TDF_Label fromRoot, TDF_Label toRoot, TDF_Label aTargetLabel, Standard_Boolean const create)

    Returns the label having the same sub-entry as
    <aLabel> but located as descendant as <toRoot>
    instead of <fromRoot>.

    Exemple :

    aLabel = 0:3:24:7:2:7
    fromRoot = 0:3:24
    toRoot = 0:5
    returned label = 0:5:7:2:7

    :type aSourceLabel: OCC.wrapper.TDF.TDF_Label
    :type fromRoot: OCC.wrapper.TDF.TDF_Label
    :type toRoot: OCC.wrapper.TDF.TDF_Label
    :type aTargetLabel: OCC.wrapper.TDF.TDF_Label
    :type create: bool

    """
    return _TDF.TDF_Tool_RelocateLabel(*args)

def TDF_Tool_Entry(*args):
    """
    TDF_Tool_Entry(TDF_Label aLabel, TCollection_AsciiString anEntry)

    Returns the entry for the label aLabel in the form
    of the ASCII character string anEntry containing
    the tag list for aLabel.

    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type anEntry: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _TDF.TDF_Tool_Entry(*args)

def TDF_Tool_TagList(*args):
    """
    TagList(TDF_Label aLabel, NCollection_List_Standard_Integer aTagList)
    TDF_Tool_TagList(TCollection_AsciiString anEntry, NCollection_List_Standard_Integer aTagList)

    Returns the entry expressed by <anEntry> as list
    of integers in <aTagList>.

    :type anEntry: OCC.wrapper.TCollection.TCollection_AsciiString
    :type aTagList: OCC.wrapper.TColStd.TColStd_ListOfInteger

    """
    return _TDF.TDF_Tool_TagList(*args)

def TDF_Tool_Label(*args):
    """
    Label(Handle_TDF_Data aDF, TCollection_AsciiString anEntry, TDF_Label aLabel, Standard_Boolean const create)
    Label(Handle_TDF_Data aDF, Standard_CString const anEntry, TDF_Label aLabel, Standard_Boolean const create)
    TDF_Tool_Label(Handle_TDF_Data aDF, NCollection_List_Standard_Integer aTagList, TDF_Label aLabel, Standard_Boolean const create)

    Returns the label expressed by <anEntry>; creates
    the label if it does not exist and if <create> is
    true.

    :type aDF: OCC.wrapper.TDF.Handle_TDF_Data
    :type aTagList: OCC.wrapper.TColStd.TColStd_ListOfInteger
    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type create: bool

    """
    return _TDF.TDF_Tool_Label(*args)

def TDF_Tool_CountLabels(*args):
    """
    TDF_Tool_CountLabels(NCollection_List_TDF_Label aLabelList, NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher aLabelMap)

    Adds the labels of <aLabelList> to <aLabelMap> if
    they are unbound, or increases their reference
    counters. At the end of the process, <aLabelList>
    contains only the ADDED labels.

    :type aLabelList: OCC.wrapper.TDF.TDF_LabelList
    :type aLabelMap: OCC.wrapper.TDF.TDF_LabelIntegerMap

    """
    return _TDF.TDF_Tool_CountLabels(*args)

def TDF_Tool_DeductLabels(*args):
    """
    TDF_Tool_DeductLabels(NCollection_List_TDF_Label aLabelList, NCollection_DataMap_TDF_Label_Standard_Integer_TDF_LabelMapHasher aLabelMap)

    Decreases the reference counters of the labels of
    <aLabelList> to <aLabelMap>, and removes labels
    with null counter. At the end of the process,
    <aLabelList> contains only the SUPPRESSED labels.

    :type aLabelList: OCC.wrapper.TDF.TDF_LabelList
    :type aLabelMap: OCC.wrapper.TDF.TDF_LabelIntegerMap

    """
    return _TDF.TDF_Tool_DeductLabels(*args)

def TDF_Tool_DeepDump(*args):
    """
    DeepDump(Standard_OStream & anOS, Handle_TDF_Data aDF)
    TDF_Tool_DeepDump(Standard_OStream & anOS, TDF_Label aLabel)

    Dumps <aLabel>, its chilren and their attributes.

    :type anOS: OCC.wrapper.Standard.Standard_OStream
    :type aLabel: OCC.wrapper.TDF.TDF_Label

    """
    return _TDF.TDF_Tool_DeepDump(*args)

def TDF_Tool_ExtendedDeepDump(*args):
    """
    ExtendedDeepDump(Standard_OStream & anOS, Handle_TDF_Data aDF, TDF_IDFilter aFilter)
    TDF_Tool_ExtendedDeepDump(Standard_OStream & anOS, TDF_Label aLabel, TDF_IDFilter aFilter)

    Dumps <aLabel>, its chilren and their attributes,
    if their IDs are kept by <aFilter>. Dumps also the
    attributes content.

    :type anOS: OCC.wrapper.Standard.Standard_OStream
    :type aLabel: OCC.wrapper.TDF.TDF_Label
    :type aFilter: OCC.wrapper.TDF.TDF_IDFilter

    """
    return _TDF.TDF_Tool_ExtendedDeepDump(*args)

class NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TDF.new_NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_TDF_Attribute theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher
NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister = _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister
NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher)

class NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TDF.NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper)


try:
	TDF_AttributeIndexedMap = NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TDF_DeltaOnRemoval(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DeltaOnRemoval self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DeltaOnRemoval_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DeltaOnRemoval self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DeltaOnRemoval self, TDF_DeltaOnRemoval thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DeltaOnRemoval self, Handle_TDF_DeltaOnRemoval theHandle) -> Handle_TDF_DeltaOnRemoval
        assign(Handle_TDF_DeltaOnRemoval self, TDF_DeltaOnRemoval thePtr) -> Handle_TDF_DeltaOnRemoval
        assign(Handle_TDF_DeltaOnRemoval self, Handle_TDF_DeltaOnRemoval theHandle) -> Handle_TDF_DeltaOnRemoval

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DeltaOnRemoval self) -> TDF_DeltaOnRemoval

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DeltaOnRemoval self) -> TDF_DeltaOnRemoval

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DeltaOnRemoval___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DeltaOnRemoval self) -> TDF_DeltaOnRemoval

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DeltaOnRemoval___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DeltaOnRemoval___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DeltaOnRemoval___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DeltaOnRemoval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DeltaOnRemoval_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DeltaOnRemoval

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DeltaOnRemoval self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnRemoval_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DeltaOnRemoval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Apply(self, *args):
        """
        Apply(Handle_TDF_DeltaOnRemoval self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_DeltaOnRemoval_Apply(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDF_DeltaOnRemoval self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_DeltaOnRemoval self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_DeltaOnRemoval self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DeltaOnRemoval self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DeltaOnRemoval self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DeltaOnRemoval___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_DeltaOnRemoval self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DeltaOnRemoval_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DeltaOnRemoval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DeltaOnRemoval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DeltaOnRemoval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DeltaOnRemoval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DeltaOnRemoval self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DeltaOnRemoval self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DeltaOnRemoval self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DeltaOnRemoval_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DeltaOnRemoval self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DeltaOnRemoval_DecrementRefCounter(self, *args)

Handle_TDF_DeltaOnRemoval_swigregister = _TDF.Handle_TDF_DeltaOnRemoval_swigregister
Handle_TDF_DeltaOnRemoval_swigregister(Handle_TDF_DeltaOnRemoval)

def Handle_TDF_DeltaOnRemoval_DownCast(thing):
    return _TDF.Handle_TDF_DeltaOnRemoval_DownCast(thing)
Handle_TDF_DeltaOnRemoval_DownCast = _TDF.Handle_TDF_DeltaOnRemoval_DownCast

class NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
    and retrieve them in linear time.

    See Map from NCollection for a discussion about the number
    of buckets
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
        and retrieve them in linear time.

        See Map from NCollection for a discussion about the number
        of buckets
        """
        this = _TDF.new_NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString theOther) -> NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString theOther) -> NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, Standard_GUID theKey1, TCollection_ExtendedString theKey2)

        Bind

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_Bind(self, *args)


    def AreBound(self, *args):
        """
        AreBound(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, Standard_GUID theKey1, TCollection_ExtendedString theKey2) -> Standard_Boolean

        * AreBound

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_AreBound(self, *args)


    def IsBound1(self, *args):
        """
        IsBound1(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, Standard_GUID theKey1) -> Standard_Boolean

        IsBound1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_IsBound1(self, *args)


    def IsBound2(self, *args):
        """
        IsBound2(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, TCollection_ExtendedString theKey2) -> Standard_Boolean

        IsBound2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_IsBound2(self, *args)


    def UnBind1(self, *args):
        """
        UnBind1(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, Standard_GUID theKey1) -> Standard_Boolean

        UnBind1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_UnBind1(self, *args)


    def UnBind2(self, *args):
        """
        UnBind2(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, TCollection_ExtendedString theKey2) -> Standard_Boolean

        UnBind2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_UnBind2(self, *args)


    def Find1(self, *args):
        """
        Find1

        :type theKey1: const TheKey1Type &
        :rtype: const TheKey2Type &

        """
        res = _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_Find1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Find2(self, *args):
        """
        Find2

        :type theKey2: const TheKey2Type &
        :rtype: const TheKey1Type &

        """
        res = _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_Find2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_Size(self, *args)

    __swig_destroy__ = _TDF.delete_NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString
NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_swigregister = _TDF.NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_swigregister
NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString_swigregister(NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString)


try:
	TDF_GUIDProgIDMap = NCollection_DoubleMap_Standard_GUID_TCollection_ExtendedString_Standard_GUID_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class Handle_TDF_DataSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DataSet self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DataSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DataSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DataSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DataSet self, TDF_DataSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DataSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DataSet self, Handle_TDF_DataSet theHandle) -> Handle_TDF_DataSet
        assign(Handle_TDF_DataSet self, TDF_DataSet thePtr) -> Handle_TDF_DataSet
        assign(Handle_TDF_DataSet self, Handle_TDF_DataSet theHandle) -> Handle_TDF_DataSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DataSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DataSet self) -> TDF_DataSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DataSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DataSet self) -> TDF_DataSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DataSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DataSet self) -> TDF_DataSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DataSet___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DataSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DataSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DataSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DataSet_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DataSet

    def Clear(self, *args):
        """
        Clear(Handle_TDF_DataSet self)

        Clears all information.


        """
        return _TDF.Handle_TDF_DataSet_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDF_DataSet self) -> Standard_Boolean

        Returns true if there is at least one label or one
        attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DataSet_IsEmpty(self, *args)


    def AddLabel(self, *args):
        """
        AddLabel(Handle_TDF_DataSet self, TDF_Label aLabel)

        Adds <aLabel> in  the  current  data  set.

        :type aLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DataSet_AddLabel(self, *args)


    def ContainsLabel(self, *args):
        """
        ContainsLabel(Handle_TDF_DataSet self, TDF_Label aLabel) -> Standard_Boolean

        Returns true if the label  <alabel>   is in the data set.

        :type aLabel: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DataSet_ContainsLabel(self, *args)


    def Labels(self, *args):
        """
        Labels(Handle_TDF_DataSet self) -> NCollection_Map_TDF_Label_TDF_LabelMapHasher

        Returns the map of labels in this data set.
        This map can be used directly, or updated.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TDF.Handle_TDF_DataSet_Labels(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDF_DataSet self, Handle_TDF_Attribute anAttribute)

        Adds <anAttribute> into the current data  set.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DataSet_AddAttribute(self, *args)


    def ContainsAttribute(self, *args):
        """
        ContainsAttribute(Handle_TDF_DataSet self, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Returns true if <anAttribute> is in the data set.

        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DataSet_ContainsAttribute(self, *args)


    def Attributes(self, *args):
        """
        Attributes(Handle_TDF_DataSet self) -> NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Returns the map of attributes in the  current  data   set.
        This map can be used directly, or updated.

        :rtype: OCC.wrapper.TDF.TDF_AttributeMap

        """
        return _TDF.Handle_TDF_DataSet_Attributes(self, *args)


    def AddRoot(self, *args):
        """
        AddRoot(Handle_TDF_DataSet self, TDF_Label aLabel)

        Adds a root label to <myRootLabels>.

        :type aLabel: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DataSet_AddRoot(self, *args)


    def Roots(self, *args):
        """
        Roots(Handle_TDF_DataSet self) -> NCollection_List_TDF_Label

        Returns <myRootLabels> to be used or updated.

        :rtype: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TDF.Handle_TDF_DataSet_Roots(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DataSet self, Standard_OStream & anOS) -> Standard_OStream &

        Dumps the minimum information about <me> on
        <aStream>.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DataSet_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DataSet self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DataSet___lshift__(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DataSet self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DataSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DataSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DataSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDF_DataSet self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DataSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DataSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DataSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DataSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DataSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DataSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DataSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DataSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DataSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DataSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DataSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DataSet self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DataSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DataSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DataSet_DecrementRefCounter(self, *args)

Handle_TDF_DataSet_swigregister = _TDF.Handle_TDF_DataSet_swigregister
Handle_TDF_DataSet_swigregister(Handle_TDF_DataSet)

def Handle_TDF_DataSet_DownCast(thing):
    return _TDF.Handle_TDF_DataSet_DownCast(thing)
Handle_TDF_DataSet_DownCast = _TDF.Handle_TDF_DataSet_DownCast

class TDF_LabelNode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Father(self, *args):
        """
        Father(TDF_LabelNode self) -> TDF_LabelNode

        :rtype: OCC.wrapper.TDF.TDF_LabelNode

        """
        return _TDF.TDF_LabelNode_Father(self, *args)


    def Brother(self, *args):
        """
        Brother(TDF_LabelNode self) -> TDF_LabelNode

        :rtype: OCC.wrapper.TDF.TDF_LabelNode

        """
        return _TDF.TDF_LabelNode_Brother(self, *args)


    def FirstChild(self, *args):
        """
        FirstChild(TDF_LabelNode self) -> TDF_LabelNode

        :rtype: OCC.wrapper.TDF.TDF_LabelNode

        """
        return _TDF.TDF_LabelNode_FirstChild(self, *args)


    def FirstAttribute(self, *args):
        """
        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        res = _TDF.TDF_LabelNode_FirstAttribute(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tag(self, *args):
        """
        Tag(TDF_LabelNode self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_LabelNode_Tag(self, *args)


    def Depth(self, *args):
        """
        Depth(TDF_LabelNode self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.TDF_LabelNode_Depth(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(TDF_LabelNode self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_LabelNode_IsRoot(self, *args)


    def Data(self, *args):
        """
        Data(TDF_LabelNode self) -> TDF_Data

        :rtype: OCC.wrapper.TDF.TDF_Data

        """
        return _TDF.TDF_LabelNode_Data(self, *args)


    def AttributesModified(self, *args):
        """
        AttributesModified(TDF_LabelNode self, Standard_Boolean const aStatus)
        AttributesModified(TDF_LabelNode self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_LabelNode_AttributesModified(self, *args)


    def MayBeModified(self, *args):
        """
        MayBeModified(TDF_LabelNode self, Standard_Boolean const aStatus)
        MayBeModified(TDF_LabelNode self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF_LabelNode_MayBeModified(self, *args)

TDF_LabelNode_swigregister = _TDF.TDF_LabelNode_swigregister
TDF_LabelNode_swigregister(TDF_LabelNode)

class Handle_TDF_DefaultDeltaOnModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDF_DefaultDeltaOnModification self)

        Nullify the handle


        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDF_DefaultDeltaOnModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDF_DefaultDeltaOnModification self, TDF_DefaultDeltaOnModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDF_DefaultDeltaOnModification self, Handle_TDF_DefaultDeltaOnModification theHandle) -> Handle_TDF_DefaultDeltaOnModification
        assign(Handle_TDF_DefaultDeltaOnModification self, TDF_DefaultDeltaOnModification thePtr) -> Handle_TDF_DefaultDeltaOnModification
        assign(Handle_TDF_DefaultDeltaOnModification self, Handle_TDF_DefaultDeltaOnModification theHandle) -> Handle_TDF_DefaultDeltaOnModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDF_DefaultDeltaOnModification self) -> TDF_DefaultDeltaOnModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDF_DefaultDeltaOnModification self) -> TDF_DefaultDeltaOnModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDF_DefaultDeltaOnModification self) -> TDF_DefaultDeltaOnModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification___ref__(self, *args)


    def __hash__(self):
        return _TDF.Handle_TDF_DefaultDeltaOnModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDF.Handle_TDF_DefaultDeltaOnModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDF.new_Handle_TDF_DefaultDeltaOnModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDF.Handle_TDF_DefaultDeltaOnModification_DownCast)
    __swig_destroy__ = _TDF.delete_Handle_TDF_DefaultDeltaOnModification

    def Apply(self, *args):
        """
        Apply(Handle_TDF_DefaultDeltaOnModification self)

        Applies the delta to the attribute.


        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDF_DefaultDeltaOnModification self) -> char const *

        :rtype: const char *

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DefaultDeltaOnModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDF.Handle_TDF_DefaultDeltaOnModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDF_DefaultDeltaOnModification self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDF_DefaultDeltaOnModification self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDF_DefaultDeltaOnModification self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDF_DefaultDeltaOnModification self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDF_DefaultDeltaOnModification self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDF_DefaultDeltaOnModification self)

        Memory deallocator for transient classes


        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDF_DefaultDeltaOnModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDF_DefaultDeltaOnModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDF_DefaultDeltaOnModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDF_DefaultDeltaOnModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDF_DefaultDeltaOnModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDF_DefaultDeltaOnModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDF_DefaultDeltaOnModification self)

        Increments the reference counter of this object


        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDF_DefaultDeltaOnModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.Handle_TDF_DefaultDeltaOnModification_DecrementRefCounter(self, *args)

Handle_TDF_DefaultDeltaOnModification_swigregister = _TDF.Handle_TDF_DefaultDeltaOnModification_swigregister
Handle_TDF_DefaultDeltaOnModification_swigregister(Handle_TDF_DefaultDeltaOnModification)

def Handle_TDF_DefaultDeltaOnModification_DownCast(thing):
    return _TDF.Handle_TDF_DefaultDeltaOnModification_DownCast(thing)
Handle_TDF_DefaultDeltaOnModification_DownCast = _TDF.Handle_TDF_DefaultDeltaOnModification_DownCast

class TDF_(object):
    """
    This package provides data framework for binding
    features and data structures.

    The feature structure is a tree used to bind
    semantic informations about each feature together.

    The only one concrete   attribute defined in  this
    package is the TagSource attribute.This attribute
    is used for  random creation of child labels under
    a given label. Tags are randomly delivered.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def LowestID(*args):
        """
        LowestID() -> Standard_GUID

        Returns ID "00000000-0000-0000-0000-000000000000",
        sometimes used as null ID.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.TDF__LowestID(*args)

    LowestID = staticmethod(LowestID)

    def UppestID(*args):
        """
        UppestID() -> Standard_GUID

        Returns ID "ffffffff-ffff-ffff-ffff-ffffffffffff".

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDF.TDF__UppestID(*args)

    UppestID = staticmethod(UppestID)

    def AddLinkGUIDToProgID(*args):
        """
        AddLinkGUIDToProgID(Standard_GUID ID, TCollection_ExtendedString ProgID)

        Sets link between GUID and ProgID in hidden DataMap

        :type ID: OCC.wrapper.Standard.Standard_GUID
        :type ProgID: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDF.TDF__AddLinkGUIDToProgID(*args)

    AddLinkGUIDToProgID = staticmethod(AddLinkGUIDToProgID)

    def GUIDFromProgID(*args):
        """
        GUIDFromProgID(TCollection_ExtendedString ProgID, Standard_GUID ID) -> Standard_Boolean

        Returns True if there is GUID for given <ProgID> then GUID is returned in <ID>

        :type ProgID: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type ID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF__GUIDFromProgID(*args)

    GUIDFromProgID = staticmethod(GUIDFromProgID)

    def ProgIDFromGUID(*args):
        """
        ProgIDFromGUID(Standard_GUID ID, TCollection_ExtendedString ProgID) -> Standard_Boolean

        Returns True if there is ProgID for given <ID> then ProgID is returned in <ProgID>

        :type ID: OCC.wrapper.Standard.Standard_GUID
        :type ProgID: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.TDF__ProgIDFromGUID(*args)

    ProgIDFromGUID = staticmethod(ProgIDFromGUID)

    def __init__(self):
        """
        This package provides data framework for binding
        features and data structures.

        The feature structure is a tree used to bind
        semantic informations about each feature together.

        The only one concrete   attribute defined in  this
        package is the TagSource attribute.This attribute
        is used for  random creation of child labels under
        a given label. Tags are randomly delivered.
        """
        this = _TDF.new_TDF_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_TDF_
TDF__swigregister = _TDF.TDF__swigregister
TDF__swigregister(TDF_)

def TDF__LowestID(*args):
    """
    TDF__LowestID() -> Standard_GUID

    Returns ID "00000000-0000-0000-0000-000000000000",
    sometimes used as null ID.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDF.TDF__LowestID(*args)

def TDF__UppestID(*args):
    """
    TDF__UppestID() -> Standard_GUID

    Returns ID "ffffffff-ffff-ffff-ffff-ffffffffffff".

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDF.TDF__UppestID(*args)

def TDF__AddLinkGUIDToProgID(*args):
    """
    TDF__AddLinkGUIDToProgID(Standard_GUID ID, TCollection_ExtendedString ProgID)

    Sets link between GUID and ProgID in hidden DataMap

    :type ID: OCC.wrapper.Standard.Standard_GUID
    :type ProgID: OCC.wrapper.TCollection.TCollection_ExtendedString

    """
    return _TDF.TDF__AddLinkGUIDToProgID(*args)

def TDF__GUIDFromProgID(*args):
    """
    TDF__GUIDFromProgID(TCollection_ExtendedString ProgID, Standard_GUID ID) -> Standard_Boolean

    Returns True if there is GUID for given <ProgID> then GUID is returned in <ID>

    :type ProgID: OCC.wrapper.TCollection.TCollection_ExtendedString
    :type ID: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDF.TDF__GUIDFromProgID(*args)

def TDF__ProgIDFromGUID(*args):
    """
    TDF__ProgIDFromGUID(Standard_GUID ID, TCollection_ExtendedString ProgID) -> Standard_Boolean

    Returns True if there is ProgID for given <ID> then ProgID is returned in <ProgID>

    :type ID: OCC.wrapper.Standard.Standard_GUID
    :type ProgID: OCC.wrapper.TCollection.TCollection_ExtendedString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDF.TDF__ProgIDFromGUID(*args)

class NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< TDF_Attribute >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TDF.new_NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, Handle_TDF_Attribute K) -> Standard_Boolean
        Contains(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher self, NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_Differ(self, *args)


    def __iter__(self):
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher
NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister = _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister
NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_swigregister(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher)

class NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TDF.NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher_IteratorHelper)


try:
	TDF_AttributeMap = NCollection_Map_Handle_TDF_Attribute_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_TDF_Label_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_TDF_Label_TDF_LabelMapHasher self) -> NCollection_Map< TDF_Label,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_TDF_Label_TDF_LabelMapHasher self) -> NCollection_Map< TDF_Label,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TDF.new_NCollection_Map_TDF_Label_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> NCollection_Map_TDF_Label_TDF_LabelMapHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> NCollection_Map_TDF_Label_TDF_LabelMapHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, TDF_Label K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, TDF_Label K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_TDF_Label_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, TDF_Label K) -> Standard_Boolean
        Contains(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theLeft, NCollection_Map_TDF_Label_TDF_LabelMapHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theLeft, NCollection_Map_TDF_Label_TDF_LabelMapHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theLeft, NCollection_Map_TDF_Label_TDF_LabelMapHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theLeft, NCollection_Map_TDF_Label_TDF_LabelMapHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_TDF_Label_TDF_LabelMapHasher self, NCollection_Map_TDF_Label_TDF_LabelMapHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_Differ(self, *args)


    def __iter__(self):
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _TDF.delete_NCollection_Map_TDF_Label_TDF_LabelMapHasher
NCollection_Map_TDF_Label_TDF_LabelMapHasher_swigregister = _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_swigregister
NCollection_Map_TDF_Label_TDF_LabelMapHasher_swigregister(NCollection_Map_TDF_Label_TDF_LabelMapHasher)

class NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDF.new_NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDF.delete_NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister = _TDF.NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_Map_TDF_Label_TDF_LabelMapHasher_IteratorHelper)


try:
	TDF_LabelMap = NCollection_Map_TDF_Label_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepMAT2d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepMAT2d')
    _BRepMAT2d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepMAT2d', [dirname(__file__)])
        except ImportError:
            import _BRepMAT2d
            return _BRepMAT2d
        try:
            _mod = imp.load_module('_BRepMAT2d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepMAT2d = swig_import_helper()
    del swig_import_helper
else:
    import _BRepMAT2d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepMAT2d.delete_SwigPyIterator

    def value(self):
        return _BRepMAT2d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepMAT2d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepMAT2d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepMAT2d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepMAT2d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepMAT2d.SwigPyIterator_copy(self)

    def next(self):
        return _BRepMAT2d.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepMAT2d.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepMAT2d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepMAT2d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepMAT2d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepMAT2d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepMAT2d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepMAT2d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepMAT2d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepMAT2d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepMAT2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepMAT2d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepMAT2d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepMAT2d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepMAT2d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepMAT2d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepMAT2d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepMAT2d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepMAT2d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepMAT2d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepMAT2d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepMAT2d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepMAT2d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepMAT2d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepMAT2d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepMAT2d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepMAT2d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepMAT2d.ptr_to_number(item)
ptr_to_number = _BRepMAT2d.ptr_to_number

def HashCode(*args):
    return _BRepMAT2d.HashCode(*args)
HashCode = _BRepMAT2d.HashCode

def ptr_equal(a, b):
    return _BRepMAT2d.ptr_equal(a, b)
ptr_equal = _BRepMAT2d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom2d
else:
    import TColGeom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MAT
else:
    import MAT
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bisector
else:
    import Bisector
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccInt
else:
    import GccInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
class NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_BasicElt >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_BasicElt >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_BasicElt >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< MAT_BasicElt >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepMAT2d.new_NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_BasicElt theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_BasicElt theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_BasicElt theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_BasicElt theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_BasicElt theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_BasicElt theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_MAT_BasicElt theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _BRepMAT2d.delete_NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher
NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_swigregister = _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepMAT2d.new_NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepMAT2d.delete_NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister = _BRepMAT2d.NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper)


try:
	BRepMAT2d_DataMapOfBasicEltShape = NCollection_DataMap_Handle_MAT_BasicElt_TopoDS_Shape_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class BRepMAT2d_BisectingLocus(object):
    """
    BisectingLocus generates and contains the Bisecting_Locus
    of a set of lines from Geom2d, defined by <ExploSet>.

    If the set of lines contains closed lines:
    ------------------------------------------
    These lines cut the plane  in areas.
    One map can  be  computed for each area.

    Bisecting locus computes a map in an area.
    The area is defined by a side (MAT_Left,MAT_Right)
    on one of the closed lines.

    If the set of lines contains only open lines:
    --------------------------------------------
    the map recovers all the plane.

    Warning: Assume the orientation of the   closed  lines  are
    compatible.

    Assume the explo contains only lines located in the
    area where the bisecting locus will be computed.

    Assume a line don't cross itself or an other line.

    Remark:
    the  curves  coming   from   the  explorer can   be
    decomposed in different parts. It  the  case for the
    curves other than circles or lines.

    The map of bisecting  locus is described by a graph.
    - The  BasicsElements  correspond  to elements on
    the figure described by the Explorer from BRepMAT2d.
    - The Arcs correspond to the bisectors.
    - The Nodes are the extremities of the arcs.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMAT2d_BisectingLocus self) -> BRepMAT2d_BisectingLocus

        BisectingLocus generates and contains the Bisecting_Locus
        of a set of lines from Geom2d, defined by <ExploSet>.

        If the set of lines contains closed lines:
        ------------------------------------------
        These lines cut the plane  in areas.
        One map can  be  computed for each area.

        Bisecting locus computes a map in an area.
        The area is defined by a side (MAT_Left,MAT_Right)
        on one of the closed lines.

        If the set of lines contains only open lines:
        --------------------------------------------
        the map recovers all the plane.

        Warning: Assume the orientation of the   closed  lines  are
        compatible.

        Assume the explo contains only lines located in the
        area where the bisecting locus will be computed.

        Assume a line don't cross itself or an other line.

        Remark:
        the  curves  coming   from   the  explorer can   be
        decomposed in different parts. It  the  case for the
        curves other than circles or lines.

        The map of bisecting  locus is described by a graph.
        - The  BasicsElements  correspond  to elements on
        the figure described by the Explorer from BRepMAT2d.
        - The Arcs correspond to the bisectors.
        - The Nodes are the extremities of the arcs.
        """
        this = _BRepMAT2d.new_BRepMAT2d_BisectingLocus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Compute(self, *args):
        """
        Compute(BRepMAT2d_BisectingLocus self, BRepMAT2d_Explorer anExplo, Standard_Integer const LineIndex=1, MAT_Side const aSide=MAT_Left, GeomAbs_JoinType const aJoinType=GeomAbs_Arc, Standard_Boolean const IsOpenResult)

        Computation of the Bisector_Locus in a set of Lines
        defined in <anExplo>.
        The bisecting locus are computed on the side <aSide>
        from the line <LineIndex> in <anExplo>.

        :type anExplo: OCC.wrapper.BRepMAT2d.BRepMAT2d_Explorer
        :type LineIndex: int
        :type aSide: OCC.wrapper.MAT.MAT_Side
        :type aJoinType: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type IsOpenResult: bool

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_Compute(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepMAT2d_BisectingLocus self) -> Standard_Boolean

        Returns True if Compute has succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_IsDone(self, *args)


    def Graph(self, *args):
        """
        Graph(BRepMAT2d_BisectingLocus self) -> Handle_MAT_Graph

        Returns <theGraph> of <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Graph

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_Graph(self, *args)


    def NumberOfContours(self, *args):
        """
        NumberOfContours(BRepMAT2d_BisectingLocus self) -> Standard_Integer

        Returns the number of contours.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_NumberOfContours(self, *args)


    def NumberOfElts(self, *args):
        """
        NumberOfElts(BRepMAT2d_BisectingLocus self, Standard_Integer const IndLine) -> Standard_Integer

        Returns the number of BasicElts on the line
        <IndLine>.

        :type IndLine: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_NumberOfElts(self, *args)


    def NumberOfSections(self, *args):
        """
        NumberOfSections(BRepMAT2d_BisectingLocus self, Standard_Integer const IndLine, Standard_Integer const Index) -> Standard_Integer

        Returns the number of sections of a curve.
        this curve is the Indexth curve in the IndLineth contour
        given by anExplo.

        :type IndLine: int
        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_NumberOfSections(self, *args)


    def BasicElt(self, *args):
        """
        BasicElt(BRepMAT2d_BisectingLocus self, Standard_Integer const IndLine, Standard_Integer const Index) -> Handle_MAT_BasicElt

        Returns the BasicElts located at the position
        <Index> on the contour designed by <IndLine>.
        Remark: the BasicElts on a contour are sorted.

        :type IndLine: int
        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_BasicElt(self, *args)


    def GeomElt(self, *args):
        """
        GeomElt(BRepMAT2d_BisectingLocus self, Handle_MAT_BasicElt aBasicElt) -> Handle_Geom2d_Geometry
        GeomElt(BRepMAT2d_BisectingLocus self, Handle_MAT_Node aNode) -> gp_Pnt2d

        Returns the geometry of  type <gp> linked to
        the <Node>.

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_GeomElt(self, *args)


    def GeomBis(self, *args):
        """
        GeomBis(BRepMAT2d_BisectingLocus self, Handle_MAT_Arc anArc) -> Bisector_Bisec

        Returns the  geometry of type <Bissec>
        linked   to the arc <ARC>.
        <Reverse> is False when the FirstNode of <anArc>
        correspond to the first point of geometry.

        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc
        :type Reverse: bool
        :rtype: OCC.wrapper.Bisector.Bisector_Bisec

        """
        return _BRepMAT2d.BRepMAT2d_BisectingLocus_GeomBis(self, *args)

    __swig_destroy__ = _BRepMAT2d.delete_BRepMAT2d_BisectingLocus
BRepMAT2d_BisectingLocus_swigregister = _BRepMAT2d.BRepMAT2d_BisectingLocus_swigregister
BRepMAT2d_BisectingLocus_swigregister(BRepMAT2d_BisectingLocus)


try:
	MAT_SequenceOfBasicElt = MAT.NCollection_Sequence_Handle_MAT_BasicElt
except AttributeError:
	pass # does not exist, probably ignored


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class BRepMAT2d_Explorer(object):
    """
    Construct an explorer from wires, face, set of curves
    from Geom2d to compute the bisecting Locus.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMAT2d_Explorer self) -> BRepMAT2d_Explorer
        __init__(BRepMAT2d_Explorer self, TopoDS_Face aFace) -> BRepMAT2d_Explorer

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _BRepMAT2d.new_BRepMAT2d_Explorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BRepMAT2d_Explorer self)

        Clear the contents of <me>.


        """
        return _BRepMAT2d.BRepMAT2d_Explorer_Clear(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepMAT2d_Explorer self, TopoDS_Face aFace)

        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_Perform(self, *args)


    def NumberOfContours(self, *args):
        """
        NumberOfContours(BRepMAT2d_Explorer self) -> Standard_Integer

        Returns the Number of contours.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_NumberOfContours(self, *args)


    def NumberOfCurves(self, *args):
        """
        NumberOfCurves(BRepMAT2d_Explorer self, Standard_Integer const IndexContour) -> Standard_Integer

        Returns the Number of Curves in the Contour  number
        <IndexContour>.

        :type IndexContour: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_NumberOfCurves(self, *args)


    def Init(self, *args):
        """
        Init(BRepMAT2d_Explorer self, Standard_Integer const IndexContour)

        Initialisation of  an Iterator on  the curves of
        the Contour number <IndexContour>.

        :type IndexContour: int

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_Init(self, *args)


    def More(self, *args):
        """
        More(BRepMAT2d_Explorer self) -> Standard_Boolean

        Return False if there is no more curves on the Contour
        initialised by the method Init.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_More(self, *args)


    def Next(self, *args):
        """
        Next(BRepMAT2d_Explorer self)

        Move to the next curve of the current Contour.


        """
        return _BRepMAT2d.BRepMAT2d_Explorer_Next(self, *args)


    def Value(self, *args):
        """
        Value(BRepMAT2d_Explorer self) -> Handle_Geom2d_Curve

        Returns the current curve on the current Contour.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_Value(self, *args)


    def Shape(self, *args):
        """
        Shape(BRepMAT2d_Explorer self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_Shape(self, *args)


    def Contour(self, *args):
        """
        :type IndexContour: int
        :rtype: OCC.wrapper.TColGeom2d.TColGeom2d_SequenceOfCurve

        """
        res = _BRepMAT2d.BRepMAT2d_Explorer_Contour(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsModified(self, *args):
        """
        IsModified(BRepMAT2d_Explorer self, TopoDS_Shape aShape) -> Standard_Boolean

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_IsModified(self, *args)


    def ModifiedShape(self, *args):
        """
        ModifiedShape(BRepMAT2d_Explorer self, TopoDS_Shape aShape) -> TopoDS_Shape

        If the shape is not modified, returns the shape itself.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMAT2d.BRepMAT2d_Explorer_ModifiedShape(self, *args)


    def GetIsClosed(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfBoolean

        """
        res = _BRepMAT2d.BRepMAT2d_Explorer_GetIsClosed(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepMAT2d.delete_BRepMAT2d_Explorer
BRepMAT2d_Explorer_swigregister = _BRepMAT2d.BRepMAT2d_Explorer_swigregister
BRepMAT2d_Explorer_swigregister(BRepMAT2d_Explorer)

class BRepMAT2d_LinkTopoBilo(object):
    """
    Constucts links between the Wire or the Face of the explorer and
    the BasicElts contained in the bisecting locus.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepMAT2d_LinkTopoBilo self) -> BRepMAT2d_LinkTopoBilo
        __init__(BRepMAT2d_LinkTopoBilo self, BRepMAT2d_Explorer Explo, BRepMAT2d_BisectingLocus BiLo) -> BRepMAT2d_LinkTopoBilo

        Constructs the links Between S and BiLo.

        raises if <S> is not a face.

        :type Explo: OCC.wrapper.BRepMAT2d.BRepMAT2d_Explorer
        :type BiLo: OCC.wrapper.BRepMAT2d.BRepMAT2d_BisectingLocus

        """
        this = _BRepMAT2d.new_BRepMAT2d_LinkTopoBilo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepMAT2d_LinkTopoBilo self, BRepMAT2d_Explorer Explo, BRepMAT2d_BisectingLocus BiLo)

        Constructs the links Between S and BiLo.

        raises if <S> is not a face or a wire.

        :type Explo: OCC.wrapper.BRepMAT2d.BRepMAT2d_Explorer
        :type BiLo: OCC.wrapper.BRepMAT2d.BRepMAT2d_BisectingLocus

        """
        return _BRepMAT2d.BRepMAT2d_LinkTopoBilo_Perform(self, *args)


    def Init(self, *args):
        """
        Init(BRepMAT2d_LinkTopoBilo self, TopoDS_Shape S)

        Initialise the Iterator on <S>
        <S> is an edge or a vertex of the initial
        wire or face.
        raises if <S> is not an edge or a vertex.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMAT2d.BRepMAT2d_LinkTopoBilo_Init(self, *args)


    def More(self, *args):
        """
        More(BRepMAT2d_LinkTopoBilo self) -> Standard_Boolean

        Returns True if there  is a current  BasicElt.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.BRepMAT2d_LinkTopoBilo_More(self, *args)


    def Next(self, *args):
        """
        Next(BRepMAT2d_LinkTopoBilo self)

        Proceed to the next BasicElt.


        """
        return _BRepMAT2d.BRepMAT2d_LinkTopoBilo_Next(self, *args)


    def Value(self, *args):
        """
        Value(BRepMAT2d_LinkTopoBilo self) -> Handle_MAT_BasicElt

        Returns the current BasicElt.

        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _BRepMAT2d.BRepMAT2d_LinkTopoBilo_Value(self, *args)


    def GeneratingShape(self, *args):
        """
        GeneratingShape(BRepMAT2d_LinkTopoBilo self, Handle_MAT_BasicElt aBE) -> TopoDS_Shape

        Returns the Shape linked to <aBE>.

        :type aBE: OCC.wrapper.MAT.Handle_MAT_BasicElt
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepMAT2d.BRepMAT2d_LinkTopoBilo_GeneratingShape(self, *args)

    __swig_destroy__ = _BRepMAT2d.delete_BRepMAT2d_LinkTopoBilo
BRepMAT2d_LinkTopoBilo_swigregister = _BRepMAT2d.BRepMAT2d_LinkTopoBilo_swigregister
BRepMAT2d_LinkTopoBilo_swigregister(BRepMAT2d_LinkTopoBilo)

class NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,MAT_SequenceOfBasicElt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,MAT_SequenceOfBasicElt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,MAT_SequenceOfBasicElt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,MAT_SequenceOfBasicElt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepMAT2d.new_NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_Handle_MAT_BasicElt theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Sequence_Handle_MAT_BasicElt theItem) -> NCollection_Sequence_Handle_MAT_BasicElt

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_Handle_MAT_BasicElt

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_Handle_MAT_BasicElt

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Sequence_Handle_MAT_BasicElt

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepMAT2d.delete_NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_swigregister = _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepMAT2d.new_NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepMAT2d.delete_NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepMAT2d.NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepMAT2d_DataMapOfShapeSequenceOfBasicElt = NCollection_DataMap_TopoDS_Shape_MAT_SequenceOfBasicElt_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored



